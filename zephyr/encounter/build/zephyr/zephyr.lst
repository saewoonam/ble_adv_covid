
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:

	return fd_entry->obj;
}

int z_reserve_fd(void)
{
   0:	2000a320 	.word	0x2000a320
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   4:	00005d19 	.word	0x00005d19
   8:	00015f61 	.word	0x00015f61
		if (fdtable[fd].obj == NULL) {
   c:	00005d49 	.word	0x00005d49
  10:	00005d49 	.word	0x00005d49
  14:	00005d49 	.word	0x00005d49
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  18:	00005d49 	.word	0x00005d49
	...
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
  2c:	00005ab9 	.word	0x00005ab9
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  30:	00005d49 	.word	0x00005d49
		fdtable[fd].obj = FD_OBJ_RESERVED;
  34:	00000000 	.word	0x00000000
  38:	00005a71 	.word	0x00005a71
  3c:	00015e99 	.word	0x00015e99

00000040 <_irq_vector_table>:
  40:	00005cd9 000169c3 00005cd9 00005cd9     .\...i...\...\..
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
}
  50:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  60:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  70:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  80:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  90:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  a0:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  b0:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  c0:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  d0:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  e0:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..
  f0:	00005cd9 00005cd9 00005cd9 00005cd9     .\...\...\...\..

Disassembly of section text:

00000100 <fe25519_add>:
// clobbers all other registers
// cycles: 45
	.type fe25519_add, %function
fe25519_add:
	.global fe25519_add
	ldr r0,[r8,#28]
     100:	f8d8 001c 	ldr.w	r0, [r8, #28]
	ldr r4,[r9,#28]
     104:	f8d9 401c 	ldr.w	r4, [r9, #28]
	adds r0,r0,r4
     108:	1900      	adds	r0, r0, r4
	mov r11,#0
     10a:	f04f 0b00 	mov.w	fp, #0
	adc r11,r11,r11
     10e:	eb4b 0b0b 	adc.w	fp, fp, fp
	lsl r11,r11,#1
     112:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
	add r11,r11,r0, lsr #31
     116:	eb0b 7bd0 	add.w	fp, fp, r0, lsr #31
	movs r7,#19
     11a:	2713      	movs	r7, #19
	mul r11,r11,r7
     11c:	fb0b fb07 	mul.w	fp, fp, r7
	bic r7,r0,#0x80000000
     120:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
	
	ldm r8!,{r0-r3}
     124:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
	ldm r9!,{r4-r6,r10}
     128:	e8b9 0470 	ldmia.w	r9!, {r4, r5, r6, sl}
	mov r12,#1
     12c:	f04f 0c01 	mov.w	ip, #1
	umaal r0,r11,r12,r4
     130:	fbec 0b64 	umaal	r0, fp, ip, r4
	umaal r1,r11,r12,r5
     134:	fbec 1b65 	umaal	r1, fp, ip, r5
	umaal r2,r11,r12,r6
     138:	fbec 2b66 	umaal	r2, fp, ip, r6
	umaal r3,r11,r12,r10
     13c:	fbec 3b6a 	umaal	r3, fp, ip, sl
	ldm r9,{r4-r6}
     140:	e899 0070 	ldmia.w	r9, {r4, r5, r6}
	ldm r8,{r8-r10}
     144:	e898 0700 	ldmia.w	r8, {r8, r9, sl}
	umaal r4,r11,r12,r8
     148:	fbec 4b68 	umaal	r4, fp, ip, r8
	umaal r5,r11,r12,r9
     14c:	fbec 5b69 	umaal	r5, fp, ip, r9
	umaal r6,r11,r12,r10
     150:	fbec 6b6a 	umaal	r6, fp, ip, sl
	add r7,r7,r11
     154:	445f      	add	r7, fp
	bx lr
     156:	4770      	bx	lr

00000158 <fe25519_sub>:
// cycles: 46
	.type fe25519_sub, %function
fe25519_sub:
	.global fe25519_sub
	
	ldm r8,{r0-r7}
     158:	e898 00ff 	ldmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	ldm r9!,{r8,r10-r12}
     15c:	e8b9 1d00 	ldmia.w	r9!, {r8, sl, fp, ip}
	subs r0,r8
     160:	ebb0 0008 	subs.w	r0, r0, r8
	sbcs r1,r10
     164:	eb71 010a 	sbcs.w	r1, r1, sl
	sbcs r2,r11
     168:	eb72 020b 	sbcs.w	r2, r2, fp
	sbcs r3,r12
     16c:	eb73 030c 	sbcs.w	r3, r3, ip
	ldm r9,{r8-r11}
     170:	e899 0f00 	ldmia.w	r9, {r8, r9, sl, fp}
	sbcs r4,r8
     174:	eb74 0408 	sbcs.w	r4, r4, r8
	sbcs r5,r9
     178:	eb75 0509 	sbcs.w	r5, r5, r9
	sbcs r6,r10
     17c:	eb76 060a 	sbcs.w	r6, r6, sl
	sbcs r7,r11
     180:	eb77 070b 	sbcs.w	r7, r7, fp
	
	// if subtraction goes below 0, set r8 to -1 and r9 to -38, else set both to 0
	sbc r8,r8
     184:	eb68 0808 	sbc.w	r8, r8, r8
	and r9,r8,#-38
     188:	f028 0925 	bic.w	r9, r8, #37	; 0x25
	
	adds r0,r9
     18c:	eb10 0009 	adds.w	r0, r0, r9
	adcs r1,r8
     190:	eb51 0108 	adcs.w	r1, r1, r8
	adcs r2,r8
     194:	eb52 0208 	adcs.w	r2, r2, r8
	adcs r3,r8
     198:	eb53 0308 	adcs.w	r3, r3, r8
	adcs r4,r8
     19c:	eb54 0408 	adcs.w	r4, r4, r8
	adcs r5,r8
     1a0:	eb55 0508 	adcs.w	r5, r5, r8
	adcs r6,r8
     1a4:	eb56 0608 	adcs.w	r6, r6, r8
	adcs r7,r8
     1a8:	eb57 0708 	adcs.w	r7, r7, r8
	// (r8,r9) will be correctly set to (-1,-38) only when r8 was -1 and we don't have a carry,
	// note that the carry will always be 0 in case (r8,r9) was (0,0) since then there was no real addition
	// also note that it is extremely unlikely we will need an extra addition:
	//   that can only happen if input1 was slightly >= 0 and input2 was > 2^256-38 (really input2-input1 > 2^256-38)
	//   in that case we currently have 2^256-38 < (r0...r7) < 2^256, so adding -38 will only affect r0
	adcs r8,#0
     1ac:	f158 0800 	adcs.w	r8, r8, #0
	and r9,r8,#-38
     1b0:	f028 0925 	bic.w	r9, r8, #37	; 0x25
	
	adds r0,r9
     1b4:	eb10 0009 	adds.w	r0, r0, r9
	
	bx lr
     1b8:	4770      	bx	lr

000001ba <fe25519_mul>:
// clobbers all other registers
// cycles: 173
	.type fe25519_mul, %function
fe25519_mul:
	.global fe25519_mul
	push {r2,lr}
     1ba:	b504      	push	{r2, lr}
	//frame push {lr}
	//frame address sp,8
	
	sub sp,#28
     1bc:	b087      	sub	sp, #28
	//frame address sp,36
	ldm r2,{r2,r3,r4,r5}
     1be:	ca3c      	ldmia	r2, {r2, r3, r4, r5}
	
	ldm r1!,{r0,r10,lr}
     1c0:	e8b1 4401 	ldmia.w	r1!, {r0, sl, lr}
	umull r6,r11,r2,r0
     1c4:	fba2 6b00 	umull	r6, fp, r2, r0
	
	umull r7,r12,r3,r0
     1c8:	fba3 7c00 	umull	r7, ip, r3, r0
	umaal r7,r11,r2,r10
     1cc:	fbe2 7b6a 	umaal	r7, fp, r2, sl
	
	push {r6,r7}
     1d0:	b4c0      	push	{r6, r7}
	//frame address sp,44
	
	umull r8,r6,r4,r0
     1d2:	fba4 8600 	umull	r8, r6, r4, r0
	umaal r8,r11,r3,r10
     1d6:	fbe3 8b6a 	umaal	r8, fp, r3, sl
	
	umull r9,r7,r5,r0
     1da:	fba5 9700 	umull	r9, r7, r5, r0
	umaal r9,r11,r4,r10
     1de:	fbe4 9b6a 	umaal	r9, fp, r4, sl
	
	umaal r11,r7,r5,r10
     1e2:	fbe5 b76a 	umaal	fp, r7, r5, sl
	
	umaal r8,r12,r2,lr
     1e6:	fbe2 8c6e 	umaal	r8, ip, r2, lr
	umaal r9,r12,r3,lr
     1ea:	fbe3 9c6e 	umaal	r9, ip, r3, lr
	umaal r11,r12,r4,lr
     1ee:	fbe4 bc6e 	umaal	fp, ip, r4, lr
	umaal r12,r7,r5,lr
     1f2:	fbe5 c76e 	umaal	ip, r7, r5, lr
	
	ldm r1!,{r0,r10,lr}
     1f6:	e8b1 4401 	ldmia.w	r1!, {r0, sl, lr}
	
	umaal r9,r6,r2,r0
     1fa:	fbe2 9660 	umaal	r9, r6, r2, r0
	umaal r11,r6,r3,r0
     1fe:	fbe3 b660 	umaal	fp, r6, r3, r0
	umaal r12,r6,r4,r0
     202:	fbe4 c660 	umaal	ip, r6, r4, r0
	umaal r6,r7,r5,r0
     206:	fbe5 6760 	umaal	r6, r7, r5, r0
	
	strd r8,r9,[sp,#8]
     20a:	e9cd 8902 	strd	r8, r9, [sp, #8]
	
	mov r9,#0
     20e:	f04f 0900 	mov.w	r9, #0
	umaal r11,r9,r2,r10
     212:	fbe2 b96a 	umaal	fp, r9, r2, sl
	umaal r12,r9,r3,r10
     216:	fbe3 c96a 	umaal	ip, r9, r3, sl
	umaal r6,r9,r4,r10
     21a:	fbe4 696a 	umaal	r6, r9, r4, sl
	umaal r7,r9,r5,r10
     21e:	fbe5 796a 	umaal	r7, r9, r5, sl
	
	mov r10,#0
     222:	f04f 0a00 	mov.w	sl, #0
	umaal r12,r10,r2,lr
     226:	fbe2 ca6e 	umaal	ip, sl, r2, lr
	umaal r6,r10,r3,lr
     22a:	fbe3 6a6e 	umaal	r6, sl, r3, lr
	umaal r7,r10,r4,lr
     22e:	fbe4 7a6e 	umaal	r7, sl, r4, lr
	umaal r9,r10,r5,lr
     232:	fbe5 9a6e 	umaal	r9, sl, r5, lr
	
	ldr r8,[r1],#4
     236:	f851 8b04 	ldr.w	r8, [r1], #4
	mov lr,#0
     23a:	f04f 0e00 	mov.w	lr, #0
	umaal lr,r6,r2,r8
     23e:	fbe2 e668 	umaal	lr, r6, r2, r8
	umaal r7,r6,r3,r8
     242:	fbe3 7668 	umaal	r7, r6, r3, r8
	umaal r9,r6,r4,r8
     246:	fbe4 9668 	umaal	r9, r6, r4, r8
	umaal r10,r6,r5,r8
     24a:	fbe5 a668 	umaal	sl, r6, r5, r8
	
	//_ _ _ _ _ 6 10 9| 7 | lr 12 11 _ _ _ _
	
	ldr r8,[r1],#-28
     24e:	f851 891c 	ldr.w	r8, [r1], #-28
	mov r0,#0
     252:	f04f 0000 	mov.w	r0, #0
	umaal r7,r0,r2,r8
     256:	fbe2 7068 	umaal	r7, r0, r2, r8
	umaal r9,r0,r3,r8
     25a:	fbe3 9068 	umaal	r9, r0, r3, r8
	umaal r10,r0,r4,r8
     25e:	fbe4 a068 	umaal	sl, r0, r4, r8
	umaal r6,r0,r5,r8
     262:	fbe5 6068 	umaal	r6, r0, r5, r8
	
	push {r0}
     266:	b401      	push	{r0}
	//frame address sp,48
	
	//_ _ _ _ s 6 10 9| 7 | lr 12 11 _ _ _ _
	
	ldr r2,[sp,#40]
     268:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	adds r2,r2,#16
     26a:	3210      	adds	r2, #16
	ldm r2,{r2,r3,r4,r5}
     26c:	ca3c      	ldmia	r2, {r2, r3, r4, r5}
	
	ldr r8,[r1],#4
     26e:	f851 8b04 	ldr.w	r8, [r1], #4
	mov r0,#0
     272:	f04f 0000 	mov.w	r0, #0
	umaal r11,r0,r2,r8
     276:	fbe2 b068 	umaal	fp, r0, r2, r8
	str r11,[sp,#16+4]
     27a:	f8cd b014 	str.w	fp, [sp, #20]
	umaal r12,r0,r3,r8
     27e:	fbe3 c068 	umaal	ip, r0, r3, r8
	umaal lr,r0,r4,r8
     282:	fbe4 e068 	umaal	lr, r0, r4, r8
	umaal r0,r7,r5,r8 // 7=carry for 9
     286:	fbe5 0768 	umaal	r0, r7, r5, r8
	
	//_ _ _ _ s 6 10 9+7| 0 | lr 12 _ _ _ _ _
	
	ldr r8,[r1],#4
     28a:	f851 8b04 	ldr.w	r8, [r1], #4
	mov r11,#0
     28e:	f04f 0b00 	mov.w	fp, #0
	umaal r12,r11,r2,r8
     292:	fbe2 cb68 	umaal	ip, fp, r2, r8
	str r12,[sp,#20+4]
     296:	f8cd c018 	str.w	ip, [sp, #24]
	umaal lr,r11,r3,r8
     29a:	fbe3 eb68 	umaal	lr, fp, r3, r8
	umaal r0,r11,r4,r8
     29e:	fbe4 0b68 	umaal	r0, fp, r4, r8
	umaal r11,r7,r5,r8 // 7=carry for 10
     2a2:	fbe5 b768 	umaal	fp, r7, r5, r8
	
	//_ _ _ _ s 6 10+7 9+11| 0 | lr _ _ _ _ _ _
	
	ldr r8,[r1],#4
     2a6:	f851 8b04 	ldr.w	r8, [r1], #4
	mov r12,#0
     2aa:	f04f 0c00 	mov.w	ip, #0
	umaal lr,r12,r2,r8
     2ae:	fbe2 ec68 	umaal	lr, ip, r2, r8
	str lr,[sp,#24+4]
     2b2:	f8cd e01c 	str.w	lr, [sp, #28]
	umaal r0,r12,r3,r8
     2b6:	fbe3 0c68 	umaal	r0, ip, r3, r8
	umaal r11,r12,r4,r8
     2ba:	fbe4 bc68 	umaal	fp, ip, r4, r8
	umaal r10,r12,r5,r8 // 12=carry for 6
     2be:	fbe5 ac68 	umaal	sl, ip, r5, r8
	
	//_ _ _ _ s 6+12 10+7 9+11| 0 | _ _ _ _ _ _ _
	
	ldr r8,[r1],#4
     2c2:	f851 8b04 	ldr.w	r8, [r1], #4
	mov lr,#0
     2c6:	f04f 0e00 	mov.w	lr, #0
	umaal r0,lr,r2,r8
     2ca:	fbe2 0e68 	umaal	r0, lr, r2, r8
	str r0,[sp,#28+4]
     2ce:	9008      	str	r0, [sp, #32]
	umaal r11,lr,r3,r8
     2d0:	fbe3 be68 	umaal	fp, lr, r3, r8
	umaal r10,lr,r4,r8
     2d4:	fbe4 ae68 	umaal	sl, lr, r4, r8
	umaal r6,lr,r5,r8 // lr=carry for saved
     2d8:	fbe5 6e68 	umaal	r6, lr, r5, r8
	
	//_ _ _ _ s+lr 6+12 10+7 9+11| _ | _ _ _ _ _ _ _
	
	ldm r1!,{r0,r8}
     2dc:	e8b1 0101 	ldmia.w	r1!, {r0, r8}
	umaal r11,r9,r2,r0
     2e0:	fbe2 b960 	umaal	fp, r9, r2, r0
	str r11,[sp,#32+4]
     2e4:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
	umaal r9,r10,r3,r0
     2e8:	fbe3 9a60 	umaal	r9, sl, r3, r0
	umaal r10,r6,r4,r0
     2ec:	fbe4 a660 	umaal	sl, r6, r4, r0
	pop {r11}
     2f0:	f85d bb04 	ldr.w	fp, [sp], #4
	//frame address sp,44
	umaal r11,r6,r5,r0 // 6=carry for next
     2f4:	fbe5 b660 	umaal	fp, r6, r5, r0
	
	//_ _ _ 6 11+lr 10+12 9+7 _ | _ | _ _ _ _ _ _ _
	
	umaal r9,r7,r2,r8
     2f8:	fbe2 9768 	umaal	r9, r7, r2, r8
	umaal r10,r7,r3,r8
     2fc:	fbe3 a768 	umaal	sl, r7, r3, r8
	umaal r11,r7,r4,r8
     300:	fbe4 b768 	umaal	fp, r7, r4, r8
	umaal r6,r7,r5,r8
     304:	fbe5 6768 	umaal	r6, r7, r5, r8
	
	ldm r1!,{r0,r8}
     308:	e8b1 0101 	ldmia.w	r1!, {r0, r8}
	umaal r10,r12,r2,r0
     30c:	fbe2 ac60 	umaal	sl, ip, r2, r0
	umaal r11,r12,r3,r0
     310:	fbe3 bc60 	umaal	fp, ip, r3, r0
	umaal r6,r12,r4,r0
     314:	fbe4 6c60 	umaal	r6, ip, r4, r0
	umaal r7,r12,r5,r0
     318:	fbe5 7c60 	umaal	r7, ip, r5, r0
	
	umaal r11,lr,r2,r8
     31c:	fbe2 be68 	umaal	fp, lr, r2, r8
	umaal r6,lr,r3,r8
     320:	fbe3 6e68 	umaal	r6, lr, r3, r8
	umaal lr,r7,r4,r8
     324:	fbe4 e768 	umaal	lr, r7, r4, r8
	umaal r7,r12,r5,r8
     328:	fbe5 7c68 	umaal	r7, ip, r5, r8
	
	// 12 7 lr 6 11 10 9 stack*9
	
	//now reduce
	
	ldrd r4,r5,[sp,#28]
     32c:	e9dd 4507 	ldrd	r4, r5, [sp, #28]
	movs r3,#38
     330:	2326      	movs	r3, #38	; 0x26
	mov r8,#0
     332:	f04f 0800 	mov.w	r8, #0
	umaal r4,r8,r3,r12
     336:	fbe3 486c 	umaal	r4, r8, r3, ip
	lsl r8,r8,#1
     33a:	ea4f 0848 	mov.w	r8, r8, lsl #1
	orr r8,r8,r4, lsr #31
     33e:	ea48 78d4 	orr.w	r8, r8, r4, lsr #31
	and r12,r4,#0x7fffffff
     342:	f024 4c00 	bic.w	ip, r4, #2147483648	; 0x80000000
	movs r4,#19
     346:	2413      	movs	r4, #19
	mul r8,r8,r4
     348:	fb08 f804 	mul.w	r8, r8, r4
	
	pop {r0-r2}
     34c:	bc07      	pop	{r0, r1, r2}
	//frame address sp,32
	umaal r0,r8,r3,r5
     34e:	fbe3 0865 	umaal	r0, r8, r3, r5
	umaal r1,r8,r3,r9
     352:	fbe3 1869 	umaal	r1, r8, r3, r9
	umaal r2,r8,r3,r10
     356:	fbe3 286a 	umaal	r2, r8, r3, sl
	mov r9,#38
     35a:	f04f 0926 	mov.w	r9, #38	; 0x26
	pop {r3,r4}
     35e:	bc18      	pop	{r3, r4}
	//frame address sp,24
	umaal r3,r8,r9,r11
     360:	fbe9 386b 	umaal	r3, r8, r9, fp
	umaal r4,r8,r9,r6
     364:	fbe9 4866 	umaal	r4, r8, r9, r6
	pop {r5,r6}
     368:	bc60      	pop	{r5, r6}
	//frame address sp,16
	umaal r5,r8,r9,lr
     36a:	fbe9 586e 	umaal	r5, r8, r9, lr
	umaal r6,r8,r9,r7
     36e:	fbe9 6867 	umaal	r6, r8, r9, r7
	add r7,r8,r12
     372:	eb08 070c 	add.w	r7, r8, ip
	
	add sp,#12
     376:	b003      	add	sp, #12
	//frame address sp,4
	pop {pc}
     378:	bd00      	pop	{pc}

0000037a <fe25519_sqr>:
// clobbers all other registers
// cycles: 115
	.type fe25519_sqr, %function
fe25519_sqr:
	.global fe25519_sqr
	push {lr}
     37a:	b500      	push	{lr}
	//frame push {lr}
	sub sp,#20
     37c:	b085      	sub	sp, #20
	//frame address sp,24
	
	//mul 01, 00
	umull r9,r10,r0,r0
     37e:	fba0 9a00 	umull	r9, sl, r0, r0
	umull r11,r12,r0,r1
     382:	fba0 bc01 	umull	fp, ip, r0, r1
	adds r11,r11,r11
     386:	eb1b 0b0b 	adds.w	fp, fp, fp
	mov lr,#0
     38a:	f04f 0e00 	mov.w	lr, #0
	umaal r10,r11,lr,lr
     38e:	fbee ab6e 	umaal	sl, fp, lr, lr
	
	//r9 r10 done
	//r12 carry for 3rd before col
	//r11+C carry for 3rd final col
	
	push {r9,r10}
     392:	e92d 0600 	stmdb	sp!, {r9, sl}
	//frame address sp,32
	
	//mul 02, 11
	mov r8,#0
     396:	f04f 0800 	mov.w	r8, #0
	umaal r8,r12,r0,r2
     39a:	fbe0 8c62 	umaal	r8, ip, r0, r2
	adcs r8,r8,r8
     39e:	eb58 0808 	adcs.w	r8, r8, r8
	umaal r8,r11,r1,r1
     3a2:	fbe1 8b61 	umaal	r8, fp, r1, r1
	//r8 done (3rd col)
	//r12 carry for 4th before col
	//r11+C carry for 4th final col
	
	//mul 03, 12
	umull r9,r10,r0,r3
     3a6:	fba0 9a03 	umull	r9, sl, r0, r3
	umaal r9,r12,r1,r2
     3aa:	fbe1 9c62 	umaal	r9, ip, r1, r2
	adcs r9,r9,r9
     3ae:	eb59 0909 	adcs.w	r9, r9, r9
	umaal r9,r11,lr,lr
     3b2:	fbee 9b6e 	umaal	r9, fp, lr, lr
	
	//r9 done (4th col)
	//r10+r12 carry for 5th before col
	//r11+C carry for 5th final col
	
	strd r8,r9,[sp,#8]
     3b6:	e9cd 8902 	strd	r8, r9, [sp, #8]
	
	//mul 04, 13, 22
	mov r9,#0
     3ba:	f04f 0900 	mov.w	r9, #0
	umaal r9,r10,r0,r4
     3be:	fbe0 9a64 	umaal	r9, sl, r0, r4
	umaal r9,r12,r1,r3
     3c2:	fbe1 9c63 	umaal	r9, ip, r1, r3
	adcs r9,r9,r9
     3c6:	eb59 0909 	adcs.w	r9, r9, r9
	umaal r9,r11,r2,r2
     3ca:	fbe2 9b62 	umaal	r9, fp, r2, r2
	
	//r9 done (5th col)
	//r10+r12 carry for 6th before col
	//r11+C carry for 6th final col
	
	str r9,[sp,#16]
     3ce:	f8cd 9010 	str.w	r9, [sp, #16]
	
	//mul 05, 14, 23
	umull r9,r8,r0,r5
     3d2:	fba0 9805 	umull	r9, r8, r0, r5
	umaal r9,r10,r1,r4
     3d6:	fbe1 9a64 	umaal	r9, sl, r1, r4
	umaal r9,r12,r2,r3
     3da:	fbe2 9c63 	umaal	r9, ip, r2, r3
	adcs r9,r9,r9
     3de:	eb59 0909 	adcs.w	r9, r9, r9
	umaal r9,r11,lr,lr
     3e2:	fbee 9b6e 	umaal	r9, fp, lr, lr
	
	//r9 done (6th col)
	//r10+r12+r8 carry for 7th before col
	//r11+C carry for 7th final col
	
	str r9,[sp,#20]
     3e6:	f8cd 9014 	str.w	r9, [sp, #20]
	
	//mul 06, 15, 24, 33
	mov r9,#0
     3ea:	f04f 0900 	mov.w	r9, #0
	umaal r9,r8,r1,r5
     3ee:	fbe1 9865 	umaal	r9, r8, r1, r5
	umaal r9,r12,r2,r4
     3f2:	fbe2 9c64 	umaal	r9, ip, r2, r4
	umaal r9,r10,r0,r6
     3f6:	fbe0 9a66 	umaal	r9, sl, r0, r6
	adcs r9,r9,r9
     3fa:	eb59 0909 	adcs.w	r9, r9, r9
	umaal r9,r11,r3,r3
     3fe:	fbe3 9b63 	umaal	r9, fp, r3, r3
	
	//r9 done (7th col)
	//r8+r10+r12 carry for 8th before col
	//r11+C carry for 8th final col
	
	str r9,[sp,#24]
     402:	f8cd 9018 	str.w	r9, [sp, #24]
	
	//mul 07, 16, 25, 34
	umull r0,r9,r0,r7
     406:	fba0 0907 	umull	r0, r9, r0, r7
	umaal r0,r10,r1,r6
     40a:	fbe1 0a66 	umaal	r0, sl, r1, r6
	umaal r0,r12,r2,r5
     40e:	fbe2 0c65 	umaal	r0, ip, r2, r5
	umaal r0,r8,r3,r4
     412:	fbe3 0864 	umaal	r0, r8, r3, r4
	adcs r0,r0,r0
     416:	4140      	adcs	r0, r0
	umaal r0,r11,lr,lr
     418:	fbee 0b6e 	umaal	r0, fp, lr, lr
	//r0 done (8th col)
	//r9+r8+r10+r12 carry for 9th before col
	//r11+C carry for 9th final col
	
	//mul 17, 26, 35, 44
	umaal r9,r8,r1,r7 //r1 is now dead
     41c:	fbe1 9867 	umaal	r9, r8, r1, r7
	umaal r9,r10,r2,r6
     420:	fbe2 9a66 	umaal	r9, sl, r2, r6
	umaal r12,r9,r3,r5
     424:	fbe3 c965 	umaal	ip, r9, r3, r5
	adcs r12,r12,r12
     428:	eb5c 0c0c 	adcs.w	ip, ip, ip
	umaal r11,r12,r4,r4
     42c:	fbe4 bc64 	umaal	fp, ip, r4, r4
	//r11 done (9th col)
	//r8+r10+r9 carry for 10th before col
	//r12+C carry for 10th final col
	
	//mul 27, 36, 45
	umaal r9,r8,r2,r7 //r2 is now dead
     430:	fbe2 9867 	umaal	r9, r8, r2, r7
	umaal r10,r9,r3,r6
     434:	fbe3 a966 	umaal	sl, r9, r3, r6
	movs r2,#0
     438:	2200      	movs	r2, #0
	umaal r10,r2,r4,r5
     43a:	fbe4 a265 	umaal	sl, r2, r4, r5
	adcs r10,r10,r10
     43e:	eb5a 0a0a 	adcs.w	sl, sl, sl
	umaal r12,r10,lr,lr
     442:	fbee ca6e 	umaal	ip, sl, lr, lr
	//r12 done (10th col)
	//r8+r9+r2 carry for 11th before col
	//r10+C carry for 11th final col
	
	//mul 37, 46, 55
	umaal r2,r8,r3,r7 //r3 is now dead
     446:	fbe3 2867 	umaal	r2, r8, r3, r7
	umaal r9,r2,r4,r6
     44a:	fbe4 9266 	umaal	r9, r2, r4, r6
	adcs r9,r9,r9
     44e:	eb59 0909 	adcs.w	r9, r9, r9
	umaal r10,r9,r5,r5
     452:	fbe5 a965 	umaal	sl, r9, r5, r5
	//r10 done (11th col)
	//r8+r2 carry for 12th before col
	//r9+C carry for 12th final col
	
	//mul 47, 56
	movs r3,#0
     456:	2300      	movs	r3, #0
	umaal r3,r8,r4,r7 //r4 is now dead
     458:	fbe4 3867 	umaal	r3, r8, r4, r7
	umaal r3,r2,r5,r6
     45c:	fbe5 3266 	umaal	r3, r2, r5, r6
	adcs r3,r3,r3
     460:	415b      	adcs	r3, r3
	umaal r9,r3,lr,lr
     462:	fbee 936e 	umaal	r9, r3, lr, lr
	//r9 done (12th col)
	//r8+r2 carry for 13th before col
	//r3+C carry for 13th final col
	
	//mul 57, 66
	umaal r8,r2,r5,r7 //r5 is now dead
     466:	fbe5 8267 	umaal	r8, r2, r5, r7
	adcs r8,r8,r8
     46a:	eb58 0808 	adcs.w	r8, r8, r8
	umaal r3,r8,r6,r6
     46e:	fbe6 3866 	umaal	r3, r8, r6, r6
	//r3 done (13th col)
	//r2 carry for 14th before col
	//r8+C carry for 14th final col
	
	//mul 67
	umull r4,r5,lr,lr // set 0
     472:	fbae 450e 	umull	r4, r5, lr, lr
	umaal r4,r2,r6,r7
     476:	fbe6 4267 	umaal	r4, r2, r6, r7
	adcs r4,r4,r4
     47a:	4164      	adcs	r4, r4
	umaal r4,r8,lr,lr
     47c:	fbee 486e 	umaal	r4, r8, lr, lr
	//r4 done (14th col)
	//r2 carry for 15th before col
	//r8+C carry for 15th final col
	
	//mul 77
	adcs r2,r2,r2
     480:	4152      	adcs	r2, r2
	umaal r8,r2,r7,r7
     482:	fbe7 8267 	umaal	r8, r2, r7, r7
	adcs r2,r2,lr
     486:	eb52 020e 	adcs.w	r2, r2, lr
	
	//msb -> lsb: r2 r8 r4 r3 r9 r10 r12 r11 r0 sp+24 sp+20 sp+16 sp+12 sp+8 sp+4 sp
	//lr: 0
	//now do reduction
	
	mov r6,#38
     48a:	f04f 0626 	mov.w	r6, #38	; 0x26
	umaal r0,lr,r6,r2
     48e:	fbe6 0e62 	umaal	r0, lr, r6, r2
	lsl lr,lr,#1
     492:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
	orr lr,lr,r0, lsr #31
     496:	ea4e 7ed0 	orr.w	lr, lr, r0, lsr #31
	and r7,r0,#0x7fffffff
     49a:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
	movs r5,#19
     49e:	2513      	movs	r5, #19
	mul lr,lr,r5
     4a0:	fb0e fe05 	mul.w	lr, lr, r5
	
	pop {r0,r1}
     4a4:	bc03      	pop	{r0, r1}
	//frame address sp,24
	umaal r0,lr,r6,r11
     4a6:	fbe6 0e6b 	umaal	r0, lr, r6, fp
	umaal r1,lr,r6,r12
     4aa:	fbe6 1e6c 	umaal	r1, lr, r6, ip
	
	mov r11,r3
     4ae:	469b      	mov	fp, r3
	mov r12,r4
     4b0:	46a4      	mov	ip, r4
	
	pop {r2,r3,r4,r5}
     4b2:	bc3c      	pop	{r2, r3, r4, r5}
	//frame address sp,8
	umaal r2,lr,r6,r10
     4b4:	fbe6 2e6a 	umaal	r2, lr, r6, sl
	umaal r3,lr,r6,r9
     4b8:	fbe6 3e69 	umaal	r3, lr, r6, r9
	
	umaal r4,lr,r6,r11
     4bc:	fbe6 4e6b 	umaal	r4, lr, r6, fp
	umaal r5,lr,r6,r12
     4c0:	fbe6 5e6c 	umaal	r5, lr, r6, ip
	
	pop {r6}
     4c4:	bc40      	pop	{r6}
	//frame address sp,4
	mov r12,#38
     4c6:	f04f 0c26 	mov.w	ip, #38	; 0x26
	umaal r6,lr,r12,r8
     4ca:	fbec 6e68 	umaal	r6, lr, ip, r8
	add r7,r7,lr
     4ce:	4477      	add	r7, lr
	
	pop {pc}
     4d0:	bd00      	pop	{pc}

000004d2 <fe25519_sqr_many>:
// clobbers all other registers
// cycles: 19 + 123*n
	.type fe25519_sqr_many, %function
fe25519_sqr_many:
	.global fe25519_sqr_many
	push {r8,lr}
     4d2:	e92d 4100 	stmdb	sp!, {r8, lr}
	//frame push {r8,lr}
0:
	bl fe25519_sqr
     4d6:	f7ff ff50 	bl	37a <fe25519_sqr>
	
	ldr r8,[sp,#0]
     4da:	f8dd 8000 	ldr.w	r8, [sp]
	subs r8,r8,#1
     4de:	f1b8 0801 	subs.w	r8, r8, #1
	str r8,[sp,#0]
     4e2:	f8cd 8000 	str.w	r8, [sp]
	bne 0b
     4e6:	d1f6      	bne.n	4d6 <fe25519_sqr_many+0x4>
	
	add sp,sp,#4
     4e8:	b001      	add	sp, #4
	//frame address sp,4
	add r8,sp,#4
     4ea:	f10d 0804 	add.w	r8, sp, #4
	stm r8,{r0-r7}
     4ee:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	pop {pc}
     4f2:	bd00      	pop	{pc}

000004f4 <loadm>:
// in: *r1
// out: r0-r7
// cycles: 22
	.type loadm, %function
loadm:
	ldr r0,[r1,#0]
     4f4:	6808      	ldr	r0, [r1, #0]
	ldr r2,[r1,#8]
     4f6:	688a      	ldr	r2, [r1, #8]
	ldr r3,[r1,#12]
     4f8:	68cb      	ldr	r3, [r1, #12]
	ldr r4,[r1,#16]
     4fa:	690c      	ldr	r4, [r1, #16]
	ldr r5,[r1,#20]
     4fc:	694d      	ldr	r5, [r1, #20]
	ldr r6,[r1,#24]
     4fe:	698e      	ldr	r6, [r1, #24]
	ldr r7,[r1,#28]
     500:	69cf      	ldr	r7, [r1, #28]
	ldr r1,[r1,#4]
     502:	6849      	ldr	r1, [r1, #4]
	bx lr
     504:	4770      	bx	lr

00000506 <curve25519_scalarmult>:
	.global curve25519_scalarmult
	
	// stack layout: xp zp xq zq x0  bitpos lastbit scalar result_ptr r4-r11,lr
	//               0  32 64 96 128 160    164     168    200        204

	push {r0,r4-r11,lr}
     506:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//frame push {r4-r11,lr}
	//frame address sp,40
	
	mov r10,r2
     50a:	4692      	mov	sl, r2
	bl loadm
     50c:	f7ff fff2 	bl	4f4 <loadm>
	
	and r0,r0,#0xfffffff8
     510:	f020 0007 	bic.w	r0, r0, #7
	//and r7,r7,#0x7fffffff not needed since we don't inspect the msb anyway
	orr r7,r7,#0x40000000
     514:	f047 4780 	orr.w	r7, r7, #1073741824	; 0x40000000
	push {r0-r7}
     518:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,72
	movs r8,#0
     51a:	f05f 0800 	movs.w	r8, #0
	push {r2,r8}
     51e:	e92d 0104 	stmdb	sp!, {r2, r8}
	//frame address sp,80
	
	//ldm r1,{r0-r7}
	mov r1,r10
     522:	4651      	mov	r1, sl
	bl loadm
     524:	f7ff ffe6 	bl	4f4 <loadm>
	
	and r7,r7,#0x7fffffff
     528:	f027 4700 	bic.w	r7, r7, #2147483648	; 0x80000000
	push {r0-r7}
     52c:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,112
	
	movs r9,#1
     52e:	f05f 0901 	movs.w	r9, #1
	umull r10,r11,r8,r8
     532:	fba8 ab08 	umull	sl, fp, r8, r8
	mov r12,#0
     536:	f04f 0c00 	mov.w	ip, #0
	push {r8,r10,r11,r12}
     53a:	e92d 1d00 	stmdb	sp!, {r8, sl, fp, ip}
	//frame address sp,128
	push {r9,r10,r11,r12}
     53e:	e92d 1e00 	stmdb	sp!, {r9, sl, fp, ip}
	//frame address sp,144
	
	push {r0-r7}
     542:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,176
	
	umull r6,r7,r8,r8
     544:	fba8 6708 	umull	r6, r7, r8, r8
	push {r6,r7,r8,r10,r11,r12}
     548:	e92d 1dc0 	stmdb	sp!, {r6, r7, r8, sl, fp, ip}
	//frame address sp,200
	push {r6,r7,r8,r10,r11,r12}
     54c:	e92d 1dc0 	stmdb	sp!, {r6, r7, r8, sl, fp, ip}
	//frame address sp,224
	push {r9,r10,r11,r12}
     550:	e92d 1e00 	stmdb	sp!, {r9, sl, fp, ip}
	//frame address sp,240
	
	movs r0,#254
     554:	20fe      	movs	r0, #254	; 0xfe
	movs r3,#0
     556:	2300      	movs	r3, #0
	// 129 cycles so far
0:
	// load scalar bit into r1
	lsrs r1,r0,#5
     558:	0941      	lsrs	r1, r0, #5
	adds r2,sp,#168
     55a:	f11d 02a8 	adds.w	r2, sp, #168	; 0xa8
	ldr r1,[r2,r1,lsl #2]
     55e:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
	and r4,r0,#0x1f
     562:	f000 041f 	and.w	r4, r0, #31
	lsrs r1,r1,r4
     566:	40e1      	lsrs	r1, r4
	and r1,r1,#1
     568:	f001 0101 	and.w	r1, r1, #1
	
	strd r0,r1,[sp,#160]
     56c:	e9cd 0128 	strd	r0, r1, [sp, #160]	; 0xa0
	
	eors r1,r1,r3
     570:	4059      	eors	r1, r3
	rsbs lr,r1,#0
     572:	f1d1 0e00 	rsbs	lr, r1, #0
	
	mov r0,sp
     576:	4668      	mov	r0, sp
	add r1,sp,#64
     578:	a910      	add	r1, sp, #64	; 0x40
	
	mov r11,#4
     57a:	f04f 0b04 	mov.w	fp, #4
	// 15 cycles
1:
	ldm r0,{r2-r5}
     57e:	e890 003c 	ldmia.w	r0, {r2, r3, r4, r5}
	ldm r1,{r6-r9}
     582:	e891 03c0 	ldmia.w	r1, {r6, r7, r8, r9}
	
	eors r2,r2,r6
     586:	4072      	eors	r2, r6
	and r10,r2,lr
     588:	ea02 0a0e 	and.w	sl, r2, lr
	eors r6,r6,r10
     58c:	ea96 060a 	eors.w	r6, r6, sl
	eors r2,r2,r6
     590:	4072      	eors	r2, r6
	
	eors r3,r3,r7
     592:	407b      	eors	r3, r7
	and r10,r3,lr
     594:	ea03 0a0e 	and.w	sl, r3, lr
	eors r7,r7,r10
     598:	ea97 070a 	eors.w	r7, r7, sl
	eors r3,r3,r7
     59c:	407b      	eors	r3, r7
	
	eors r4,r4,r8
     59e:	ea94 0408 	eors.w	r4, r4, r8
	and r10,r4,lr
     5a2:	ea04 0a0e 	and.w	sl, r4, lr
	eors r8,r8,r10
     5a6:	ea98 080a 	eors.w	r8, r8, sl
	eors r4,r4,r8
     5aa:	ea94 0408 	eors.w	r4, r4, r8
	
	eors r5,r5,r9
     5ae:	ea95 0509 	eors.w	r5, r5, r9
	and r10,r5,lr
     5b2:	ea05 0a0e 	and.w	sl, r5, lr
	eors r9,r9,r10
     5b6:	ea99 090a 	eors.w	r9, r9, sl
	eors r5,r5,r9
     5ba:	ea95 0509 	eors.w	r5, r5, r9
	
	stm r0!,{r2-r5}
     5be:	c03c      	stmia	r0!, {r2, r3, r4, r5}
	stm r1!,{r6-r9}
     5c0:	e8a1 03c0 	stmia.w	r1!, {r6, r7, r8, r9}
	
	subs r11,#1
     5c4:	f1bb 0b01 	subs.w	fp, fp, #1
	bne 1b
     5c8:	d1d9      	bne.n	57e <curve25519_scalarmult+0x78>
	// 40*4 - 2 = 158 cycles
	
	mov r8,sp
     5ca:	46e8      	mov	r8, sp
	add r9,sp,#32
     5cc:	f10d 0920 	add.w	r9, sp, #32
	bl fe25519_add
     5d0:	f7ff fd96 	bl	100 <fe25519_add>
	push {r0-r7}
     5d4:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,272
	
	bl fe25519_sqr
     5d6:	f7ff fed0 	bl	37a <fe25519_sqr>
	push {r0-r7}
     5da:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,304
	
	add r8,sp,#64
     5dc:	f10d 0840 	add.w	r8, sp, #64	; 0x40
	add r9,sp,#96
     5e0:	f10d 0960 	add.w	r9, sp, #96	; 0x60
	bl fe25519_sub
     5e4:	f7ff fdb8 	bl	158 <fe25519_sub>
	push {r0-r7}
     5e8:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,336
	
	bl fe25519_sqr
     5ea:	f7ff fec6 	bl	37a <fe25519_sqr>
	push {r0-r7}
     5ee:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,368
	
	mov r1,sp
     5f0:	4669      	mov	r1, sp
	add r2,sp,#64
     5f2:	aa10      	add	r2, sp, #64	; 0x40
	bl fe25519_mul
     5f4:	f7ff fde1 	bl	1ba <fe25519_mul>
	add r8,sp,#128
     5f8:	f10d 0880 	add.w	r8, sp, #128	; 0x80
	stm r8,{r0-r7}
     5fc:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	add r8,sp,#64
     600:	f10d 0840 	add.w	r8, sp, #64	; 0x40
	mov r9,sp
     604:	46e9      	mov	r9, sp
	bl fe25519_sub
     606:	f7ff fda7 	bl	158 <fe25519_sub>
	add r8,sp,#64
     60a:	f10d 0840 	add.w	r8, sp, #64	; 0x40
	stm r8,{r0-r7}
     60e:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	// 64 + 1*45 + 2*46 + 1*173 + 2*115 = 604 cycles
	
	//multiplies (r0-r7) with 121666, adds *sp and puts the result on the top of the stack (replacing old content)
	ldr lr,=121666
     612:	f8df e24c 	ldr.w	lr, [pc, #588]	; 860 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x60>
	//mov lr,#56130
	//add lr,lr,#65536
	ldr r12,[sp,#28]
     616:	f8dd c01c 	ldr.w	ip, [sp, #28]
	mov r11,#0
     61a:	f04f 0b00 	mov.w	fp, #0
	umaal r12,r11,lr,r7
     61e:	fbee cb67 	umaal	ip, fp, lr, r7
	lsl r11,r11,#1
     622:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
	add r11,r11,r12, lsr #31
     626:	eb0b 7bdc 	add.w	fp, fp, ip, lsr #31
	movs r7,#19
     62a:	2713      	movs	r7, #19
	mul r11,r11,r7
     62c:	fb0b fb07 	mul.w	fp, fp, r7
	bic r7,r12,#0x80000000
     630:	f02c 4700 	bic.w	r7, ip, #2147483648	; 0x80000000
	ldm sp!,{r8,r9,r10,r12}
     634:	e8bd 1700 	ldmia.w	sp!, {r8, r9, sl, ip}
	//frame address sp,352
	umaal r8,r11,lr,r0
     638:	fbee 8b60 	umaal	r8, fp, lr, r0
	umaal r9,r11,lr,r1
     63c:	fbee 9b61 	umaal	r9, fp, lr, r1
	umaal r10,r11,lr,r2
     640:	fbee ab62 	umaal	sl, fp, lr, r2
	umaal r12,r11,lr,r3
     644:	fbee cb63 	umaal	ip, fp, lr, r3
	ldm sp!,{r0,r1,r2}
     648:	bc07      	pop	{r0, r1, r2}
	//frame address sp,340
	umaal r0,r11,lr,r4
     64a:	fbee 0b64 	umaal	r0, fp, lr, r4
	umaal r1,r11,lr,r5
     64e:	fbee 1b65 	umaal	r1, fp, lr, r5
	umaal r2,r11,lr,r6
     652:	fbee 2b66 	umaal	r2, fp, lr, r6
	add r7,r7,r11
     656:	445f      	add	r7, fp
	add sp,sp,#4
     658:	b001      	add	sp, #4
	//frame address sp,338
	push {r0,r1,r2,r7}
     65a:	b487      	push	{r0, r1, r2, r7}
	//frame address sp,352
	push {r8,r9,r10,r12}
     65c:	e92d 1700 	stmdb	sp!, {r8, r9, sl, ip}
	//frame address sp,368
	// 39 cycles
	
	mov r1,sp
     660:	4669      	mov	r1, sp
	add r2,sp,#64
     662:	aa10      	add	r2, sp, #64	; 0x40
	bl fe25519_mul
     664:	f7ff fda9 	bl	1ba <fe25519_mul>
	add r8,sp,#160
     668:	f10d 08a0 	add.w	r8, sp, #160	; 0xa0
	stm r8,{r0-r7}
     66c:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	add r8,sp,#192
     670:	f10d 08c0 	add.w	r8, sp, #192	; 0xc0
	add r9,sp,#224
     674:	f10d 09e0 	add.w	r9, sp, #224	; 0xe0
	bl fe25519_add
     678:	f7ff fd42 	bl	100 <fe25519_add>
	stm sp,{r0-r7}
     67c:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	mov r1,sp
     680:	4669      	mov	r1, sp
	add r2,sp,#32
     682:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     684:	f7ff fd99 	bl	1ba <fe25519_mul>
	add r8,sp,#32
     688:	f10d 0820 	add.w	r8, sp, #32
	stm r8,{r0-r7}
     68c:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	add r8,sp,#192
     690:	f10d 08c0 	add.w	r8, sp, #192	; 0xc0
	add r9,sp,#224
     694:	f10d 09e0 	add.w	r9, sp, #224	; 0xe0
	bl fe25519_sub
     698:	f7ff fd5e 	bl	158 <fe25519_sub>
	stm sp,{r0-r7}
     69c:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	mov r1,sp
     6a0:	4669      	mov	r1, sp
	add r2,sp,#96
     6a2:	aa18      	add	r2, sp, #96	; 0x60
	bl fe25519_mul
     6a4:	f7ff fd89 	bl	1ba <fe25519_mul>
	stm sp,{r0-r7}
     6a8:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	mov r8,sp
     6ac:	46e8      	mov	r8, sp
	add r9,sp,#32
     6ae:	f10d 0920 	add.w	r9, sp, #32
	bl fe25519_add
     6b2:	f7ff fd25 	bl	100 <fe25519_add>
	
	bl fe25519_sqr
     6b6:	f7ff fe60 	bl	37a <fe25519_sqr>
	
	add r8,sp,#192
     6ba:	f10d 08c0 	add.w	r8, sp, #192	; 0xc0
	stm r8,{r0-r7}
     6be:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	mov r8,sp
     6c2:	46e8      	mov	r8, sp
	add r9,sp,#32
     6c4:	f10d 0920 	add.w	r9, sp, #32
	bl fe25519_sub
     6c8:	f7ff fd46 	bl	158 <fe25519_sub>
	
	bl fe25519_sqr
     6cc:	f7ff fe55 	bl	37a <fe25519_sqr>
	stm sp,{r0-r7}
     6d0:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	mov r1,sp
     6d4:	4669      	mov	r1, sp
	add r2,sp,#256
     6d6:	aa40      	add	r2, sp, #256	; 0x100
	bl fe25519_mul
     6d8:	f7ff fd6f 	bl	1ba <fe25519_mul>
	add r8,sp,#224
     6dc:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
	stm r8,{r0-r7}
     6e0:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	add sp,sp,#128
     6e4:	b020      	add	sp, #128	; 0x80
	//frame address sp,240
	
	ldrd r2,r3,[sp,#160]
     6e6:	e9dd 2328 	ldrd	r2, r3, [sp, #160]	; 0xa0
	subs r0,r2,#1
     6ea:	1e50      	subs	r0, r2, #1
	// 97 + 2*45 + 2*46 + 4*173 + 2*115 = 1201 cycles
	bpl 0b
     6ec:	f57f af34 	bpl.w	558 <curve25519_scalarmult+0x52>
	//subs r11,#1
	//bne 1b
	//----------

	// now we must invert zp
	add r0,sp,#32
     6f0:	a808      	add	r0, sp, #32
	ldm r0,{r0-r7}
     6f2:	c8ff      	ldmia	r0, {r0, r1, r2, r3, r4, r5, r6, r7}
	bl fe25519_sqr
     6f4:	f7ff fe41 	bl	37a <fe25519_sqr>
	push {r0-r7}
     6f8:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,272
	
	bl fe25519_sqr
     6fa:	f7ff fe3e 	bl	37a <fe25519_sqr>
	bl fe25519_sqr
     6fe:	f7ff fe3c 	bl	37a <fe25519_sqr>
	push {r0-r7}
     702:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,304
	
	add r1,sp,#96
     704:	a918      	add	r1, sp, #96	; 0x60
	mov r2,sp
     706:	466a      	mov	r2, sp
	bl fe25519_mul
     708:	f7ff fd57 	bl	1ba <fe25519_mul>
	stm sp,{r0-r7}
     70c:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	mov r1,sp
     710:	4669      	mov	r1, sp
	add r2,sp,#32
     712:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     714:	f7ff fd51 	bl	1ba <fe25519_mul>
	add r8,sp,#32
     718:	f10d 0820 	add.w	r8, sp, #32
	stm r8,{r0-r7}
     71c:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	// current stack: z^(2^9) z^(2^11) x z
	
	bl fe25519_sqr
     720:	f7ff fe2b 	bl	37a <fe25519_sqr>
	push {r0-r7}
     724:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
	//frame address sp,336
	
	mov r1,sp
     726:	4669      	mov	r1, sp
	add r2,sp,#32
     728:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     72a:	f7ff fd46 	bl	1ba <fe25519_mul>
	add r8,sp,#32
     72e:	f10d 0820 	add.w	r8, sp, #32
	stm r8,{r0-r7}
     732:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	// current stack: _ z^(2^5 - 2^0) z^(2^11) x z
	
	mov r8,#5
     736:	f04f 0805 	mov.w	r8, #5
	// 1052 cycles
	bl fe25519_sqr_many // 634 cycles
     73a:	f7ff feca 	bl	4d2 <fe25519_sqr_many>
	
	mov r1,sp
     73e:	4669      	mov	r1, sp
	add r2,sp,#32
     740:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     742:	f7ff fd3a 	bl	1ba <fe25519_mul>
	add r8,sp,#32
     746:	f10d 0820 	add.w	r8, sp, #32
	stm r8,{r0-r7}
     74a:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	// current stack: _ z^(2^10 - 2^0) z^(2^11) x z <scratch> ...
	
	movs r8,#10
     74e:	f05f 080a 	movs.w	r8, #10
	bl fe25519_sqr_many // 1249 cycles
     752:	f7ff febe 	bl	4d2 <fe25519_sqr_many>
	//z^(2^20 - 2^10)
	
	mov r1,sp
     756:	4669      	mov	r1, sp
	add r2,sp,#32
     758:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     75a:	f7ff fd2e 	bl	1ba <fe25519_mul>
	stm sp,{r0-r7}
     75e:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	//z^(2^20 - 2^0)
	
	// current stack: z^(2^20 - 2^0) z^(2^10 - 2^0) z^(2^11) x z <scratch> ...
	
	movs r8,#20
     762:	f05f 0814 	movs.w	r8, #20
	sub sp,sp,#32
     766:	b088      	sub	sp, #32
	//frame address sp,368
	bl fe25519_sqr_many // 2479 cycles
     768:	f7ff feb3 	bl	4d2 <fe25519_sqr_many>
	//z^(2^40 - 2^20)
	
	mov r1,sp
     76c:	4669      	mov	r1, sp
	add r2,sp,#32
     76e:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     770:	f7ff fd23 	bl	1ba <fe25519_mul>
	add sp,sp,#32
     774:	b008      	add	sp, #32
	//frame address sp,336
	//z^(2^40 - 2^0)
	
	movs r8,#10
     776:	f05f 080a 	movs.w	r8, #10
	bl fe25519_sqr_many // 1249 cycles
     77a:	f7ff feaa 	bl	4d2 <fe25519_sqr_many>
	//z^(2^50 - 2^10)
	
	mov r1,sp
     77e:	4669      	mov	r1, sp
	add r2,sp,#32
     780:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     782:	f7ff fd1a 	bl	1ba <fe25519_mul>
	add r8,sp,#32
     786:	f10d 0820 	add.w	r8, sp, #32
	stm r8,{r0-r7}
     78a:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	// current stack: _ z^(2^50 - 2^0) z^(2^11) x z <scratch> ...
	
	movs r8,#50
     78e:	f05f 0832 	movs.w	r8, #50	; 0x32
	bl fe25519_sqr_many // 6169 cycles
     792:	f7ff fe9e 	bl	4d2 <fe25519_sqr_many>
	//z^(2^100 - 2^50)
	
	mov r1,sp
     796:	4669      	mov	r1, sp
	add r2,sp,#32
     798:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     79a:	f7ff fd0e 	bl	1ba <fe25519_mul>
	stm sp,{r0-r7}
     79e:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	
	// 13751 cycles so far for inversion
	
	// current stack: z^(2^100 - 2^0) z^(2^50 - 2^0) z^(2^11) x z <scratch> ...
	
	movs r8,#100
     7a2:	f05f 0864 	movs.w	r8, #100	; 0x64
	sub sp,sp,#32
     7a6:	b088      	sub	sp, #32
	//frame address sp,368
	bl fe25519_sqr_many // 12319 cycles
     7a8:	f7ff fe93 	bl	4d2 <fe25519_sqr_many>
	//z^(2^200 - 2^100)
	
	mov r1,sp
     7ac:	4669      	mov	r1, sp
	add r2,sp,#32
     7ae:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     7b0:	f7ff fd03 	bl	1ba <fe25519_mul>
	add sp,sp,#32
     7b4:	b008      	add	sp, #32
	//frame address sp,336
	//z^(2^200 - 2^0)
	
	// current stack: _ z^(2^50 - 2^0) z^(2^11) x z <scratch> ...
	
	movs r8,#50
     7b6:	f05f 0832 	movs.w	r8, #50	; 0x32
	bl fe25519_sqr_many // 6169 cycles
     7ba:	f7ff fe8a 	bl	4d2 <fe25519_sqr_many>
	//z^(2^250 - 2^50)
	
	mov r1,sp
     7be:	4669      	mov	r1, sp
	add r2,sp,#32
     7c0:	aa08      	add	r2, sp, #32
	bl fe25519_mul
     7c2:	f7ff fcfa 	bl	1ba <fe25519_mul>
	//z^(2^250 - 2^0)
	
	movs r8,#5
     7c6:	f05f 0805 	movs.w	r8, #5
	bl fe25519_sqr_many // 634 cycles
     7ca:	f7ff fe82 	bl	4d2 <fe25519_sqr_many>
	//z^(2^255 - 2^5)
	
	mov r1,sp
     7ce:	4669      	mov	r1, sp
	add r2,sp,#64
     7d0:	aa10      	add	r2, sp, #64	; 0x40
	bl fe25519_mul
     7d2:	f7ff fcf2 	bl	1ba <fe25519_mul>
	stm sp,{r0-r7}
     7d6:	e88d 00ff 	stmia.w	sp, {r0, r1, r2, r3, r4, r5, r6, r7}
	// 19661 for second half of inversion
	
	// done inverting!
	// total inversion cost: 33412 cycles
	
	mov r1,sp
     7da:	4669      	mov	r1, sp
	add r2,sp,#96
     7dc:	aa18      	add	r2, sp, #96	; 0x60
	bl fe25519_mul
     7de:	f7ff fcec 	bl	1ba <fe25519_mul>
	
	// now final reduce
	lsr r8,r7,#31
     7e2:	ea4f 78d7 	mov.w	r8, r7, lsr #31
	mov r9,#19
     7e6:	f04f 0913 	mov.w	r9, #19
	mul r8,r8,r9
     7ea:	fb08 f809 	mul.w	r8, r8, r9
	mov r10,#0
     7ee:	f04f 0a00 	mov.w	sl, #0
	
	// handle the case when 2^255 - 19 <= x < 2^255
	add r8,r8,#19
     7f2:	f108 0813 	add.w	r8, r8, #19
	
	adds r8,r0,r8
     7f6:	eb10 0808 	adds.w	r8, r0, r8
	adcs r8,r1,r10
     7fa:	eb51 080a 	adcs.w	r8, r1, sl
	adcs r8,r2,r10
     7fe:	eb52 080a 	adcs.w	r8, r2, sl
	adcs r8,r3,r10
     802:	eb53 080a 	adcs.w	r8, r3, sl
	adcs r8,r4,r10
     806:	eb54 080a 	adcs.w	r8, r4, sl
	adcs r8,r5,r10
     80a:	eb55 080a 	adcs.w	r8, r5, sl
	adcs r8,r6,r10
     80e:	eb56 080a 	adcs.w	r8, r6, sl
	adcs r8,r7,r10
     812:	eb57 080a 	adcs.w	r8, r7, sl
	adcs r11,r10,r10
     816:	eb5a 0b0a 	adcs.w	fp, sl, sl
	
	lsr r8,r8,#31
     81a:	ea4f 78d8 	mov.w	r8, r8, lsr #31
	orr r8,r8,r11, lsl #1
     81e:	ea48 084b 	orr.w	r8, r8, fp, lsl #1
	mul r8,r8,r9
     822:	fb08 f809 	mul.w	r8, r8, r9
	
	ldr r9,[sp,#296]
     826:	f8dd 9128 	ldr.w	r9, [sp, #296]	; 0x128
	
	adds r0,r0,r8
     82a:	eb10 0008 	adds.w	r0, r0, r8
	str r0,[r9,#0]
     82e:	f8c9 0000 	str.w	r0, [r9]
	movs r0,#0
     832:	2000      	movs	r0, #0
	adcs r1,r1,r0
     834:	4141      	adcs	r1, r0
	str r1,[r9,#4]
     836:	f8c9 1004 	str.w	r1, [r9, #4]
	mov r1,r9
     83a:	4649      	mov	r1, r9
	adcs r2,r2,r0
     83c:	4142      	adcs	r2, r0
	adcs r3,r3,r0
     83e:	4143      	adcs	r3, r0
	adcs r4,r4,r0
     840:	4144      	adcs	r4, r0
	adcs r5,r5,r0
     842:	4145      	adcs	r5, r0
	adcs r6,r6,r0
     844:	4146      	adcs	r6, r0
	adcs r7,r7,r0
     846:	4147      	adcs	r7, r0
	and r7,r7,#0x7fffffff
     848:	f027 4700 	bic.w	r7, r7, #2147483648	; 0x80000000
	
	str r2,[r1,#8]
     84c:	608a      	str	r2, [r1, #8]
	str r3,[r1,#12]
     84e:	60cb      	str	r3, [r1, #12]
	str r4,[r1,#16]
     850:	610c      	str	r4, [r1, #16]
	str r5,[r1,#20]
     852:	614d      	str	r5, [r1, #20]
	str r6,[r1,#24]
     854:	618e      	str	r6, [r1, #24]
	str r7,[r1,#28]
     856:	61cf      	str	r7, [r1, #28]
	
	add sp,sp,#300
     858:	b04b      	add	sp, #300	; 0x12c
	//frame address sp,36
	
	pop {r4-r11,pc}
     85a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     85e:	0000      	.short	0x0000
	ldr lr,=121666
     860:	0001db42 	.word	0x0001db42

00000864 <__aeabi_ldivmod>:
     864:	b97b      	cbnz	r3, 886 <__aeabi_ldivmod+0x22>
     866:	b972      	cbnz	r2, 886 <__aeabi_ldivmod+0x22>
     868:	2900      	cmp	r1, #0
     86a:	bfbe      	ittt	lt
     86c:	2000      	movlt	r0, #0
     86e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
     872:	e006      	blt.n	882 <__aeabi_ldivmod+0x1e>
     874:	bf08      	it	eq
     876:	2800      	cmpeq	r0, #0
     878:	bf1c      	itt	ne
     87a:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
     87e:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     882:	f000 b9cb 	b.w	c1c <__aeabi_idiv0>
     886:	f1ad 0c08 	sub.w	ip, sp, #8
     88a:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     88e:	2900      	cmp	r1, #0
     890:	db09      	blt.n	8a6 <__aeabi_ldivmod+0x42>
     892:	2b00      	cmp	r3, #0
     894:	db1a      	blt.n	8cc <__aeabi_ldivmod+0x68>
     896:	f000 f861 	bl	95c <__udivmoddi4>
     89a:	f8dd e004 	ldr.w	lr, [sp, #4]
     89e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     8a2:	b004      	add	sp, #16
     8a4:	4770      	bx	lr
     8a6:	4240      	negs	r0, r0
     8a8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     8ac:	2b00      	cmp	r3, #0
     8ae:	db1b      	blt.n	8e8 <__aeabi_ldivmod+0x84>
     8b0:	f000 f854 	bl	95c <__udivmoddi4>
     8b4:	f8dd e004 	ldr.w	lr, [sp, #4]
     8b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     8bc:	b004      	add	sp, #16
     8be:	4240      	negs	r0, r0
     8c0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     8c4:	4252      	negs	r2, r2
     8c6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     8ca:	4770      	bx	lr
     8cc:	4252      	negs	r2, r2
     8ce:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     8d2:	f000 f843 	bl	95c <__udivmoddi4>
     8d6:	f8dd e004 	ldr.w	lr, [sp, #4]
     8da:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     8de:	b004      	add	sp, #16
     8e0:	4240      	negs	r0, r0
     8e2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     8e6:	4770      	bx	lr
     8e8:	4252      	negs	r2, r2
     8ea:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     8ee:	f000 f835 	bl	95c <__udivmoddi4>
     8f2:	f8dd e004 	ldr.w	lr, [sp, #4]
     8f6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     8fa:	b004      	add	sp, #16
     8fc:	4252      	negs	r2, r2
     8fe:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     902:	4770      	bx	lr

00000904 <__aeabi_uldivmod>:
     904:	b953      	cbnz	r3, 91c <__aeabi_uldivmod+0x18>
     906:	b94a      	cbnz	r2, 91c <__aeabi_uldivmod+0x18>
     908:	2900      	cmp	r1, #0
     90a:	bf08      	it	eq
     90c:	2800      	cmpeq	r0, #0
     90e:	bf1c      	itt	ne
     910:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     914:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     918:	f000 b980 	b.w	c1c <__aeabi_idiv0>
     91c:	f1ad 0c08 	sub.w	ip, sp, #8
     920:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     924:	f000 f81a 	bl	95c <__udivmoddi4>
     928:	f8dd e004 	ldr.w	lr, [sp, #4]
     92c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     930:	b004      	add	sp, #16
     932:	4770      	bx	lr

00000934 <__popcountsi2>:
     934:	0843      	lsrs	r3, r0, #1
     936:	f003 3355 	and.w	r3, r3, #1431655765	; 0x55555555
     93a:	1ac0      	subs	r0, r0, r3
     93c:	0883      	lsrs	r3, r0, #2
     93e:	f003 3333 	and.w	r3, r3, #858993459	; 0x33333333
     942:	f000 3033 	and.w	r0, r0, #858993459	; 0x33333333
     946:	4418      	add	r0, r3
     948:	eb00 1010 	add.w	r0, r0, r0, lsr #4
     94c:	f000 300f 	and.w	r0, r0, #252645135	; 0xf0f0f0f
     950:	eb00 2000 	add.w	r0, r0, r0, lsl #8
     954:	eb00 4000 	add.w	r0, r0, r0, lsl #16
     958:	0e00      	lsrs	r0, r0, #24
     95a:	4770      	bx	lr

0000095c <__udivmoddi4>:
     95c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     960:	9e08      	ldr	r6, [sp, #32]
     962:	460d      	mov	r5, r1
     964:	4604      	mov	r4, r0
     966:	468e      	mov	lr, r1
     968:	2b00      	cmp	r3, #0
     96a:	f040 8082 	bne.w	a72 <__udivmoddi4+0x116>
     96e:	428a      	cmp	r2, r1
     970:	4617      	mov	r7, r2
     972:	d946      	bls.n	a02 <__udivmoddi4+0xa6>
     974:	fab2 f282 	clz	r2, r2
     978:	b14a      	cbz	r2, 98e <__udivmoddi4+0x32>
     97a:	f1c2 0120 	rsb	r1, r2, #32
     97e:	fa05 f302 	lsl.w	r3, r5, r2
     982:	fa20 f101 	lsr.w	r1, r0, r1
     986:	4097      	lsls	r7, r2
     988:	ea41 0e03 	orr.w	lr, r1, r3
     98c:	4094      	lsls	r4, r2
     98e:	ea4f 4817 	mov.w	r8, r7, lsr #16
     992:	0c23      	lsrs	r3, r4, #16
     994:	fbbe fcf8 	udiv	ip, lr, r8
     998:	b2b9      	uxth	r1, r7
     99a:	fb08 ee1c 	mls	lr, r8, ip, lr
     99e:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
     9a2:	fb0c f001 	mul.w	r0, ip, r1
     9a6:	4298      	cmp	r0, r3
     9a8:	d90a      	bls.n	9c0 <__udivmoddi4+0x64>
     9aa:	18fb      	adds	r3, r7, r3
     9ac:	f10c 35ff 	add.w	r5, ip, #4294967295	; 0xffffffff
     9b0:	f080 8116 	bcs.w	be0 <__udivmoddi4+0x284>
     9b4:	4298      	cmp	r0, r3
     9b6:	f240 8113 	bls.w	be0 <__udivmoddi4+0x284>
     9ba:	f1ac 0c02 	sub.w	ip, ip, #2
     9be:	443b      	add	r3, r7
     9c0:	1a1b      	subs	r3, r3, r0
     9c2:	b2a4      	uxth	r4, r4
     9c4:	fbb3 f0f8 	udiv	r0, r3, r8
     9c8:	fb08 3310 	mls	r3, r8, r0, r3
     9cc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     9d0:	fb00 f101 	mul.w	r1, r0, r1
     9d4:	42a1      	cmp	r1, r4
     9d6:	d909      	bls.n	9ec <__udivmoddi4+0x90>
     9d8:	193c      	adds	r4, r7, r4
     9da:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
     9de:	f080 8101 	bcs.w	be4 <__udivmoddi4+0x288>
     9e2:	42a1      	cmp	r1, r4
     9e4:	f240 80fe 	bls.w	be4 <__udivmoddi4+0x288>
     9e8:	3802      	subs	r0, #2
     9ea:	443c      	add	r4, r7
     9ec:	1a64      	subs	r4, r4, r1
     9ee:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     9f2:	2100      	movs	r1, #0
     9f4:	b11e      	cbz	r6, 9fe <__udivmoddi4+0xa2>
     9f6:	40d4      	lsrs	r4, r2
     9f8:	2300      	movs	r3, #0
     9fa:	e9c6 4300 	strd	r4, r3, [r6]
     9fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     a02:	b902      	cbnz	r2, a06 <__udivmoddi4+0xaa>
     a04:	deff      	udf	#255	; 0xff
     a06:	fab2 f282 	clz	r2, r2
     a0a:	2a00      	cmp	r2, #0
     a0c:	d14f      	bne.n	aae <__udivmoddi4+0x152>
     a0e:	1bcb      	subs	r3, r1, r7
     a10:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     a14:	fa1f f887 	uxth.w	r8, r7
     a18:	2101      	movs	r1, #1
     a1a:	fbb3 fcfe 	udiv	ip, r3, lr
     a1e:	0c25      	lsrs	r5, r4, #16
     a20:	fb0e 331c 	mls	r3, lr, ip, r3
     a24:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     a28:	fb08 f30c 	mul.w	r3, r8, ip
     a2c:	42ab      	cmp	r3, r5
     a2e:	d907      	bls.n	a40 <__udivmoddi4+0xe4>
     a30:	197d      	adds	r5, r7, r5
     a32:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     a36:	d202      	bcs.n	a3e <__udivmoddi4+0xe2>
     a38:	42ab      	cmp	r3, r5
     a3a:	f200 80e7 	bhi.w	c0c <__udivmoddi4+0x2b0>
     a3e:	4684      	mov	ip, r0
     a40:	1aed      	subs	r5, r5, r3
     a42:	b2a3      	uxth	r3, r4
     a44:	fbb5 f0fe 	udiv	r0, r5, lr
     a48:	fb0e 5510 	mls	r5, lr, r0, r5
     a4c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
     a50:	fb08 f800 	mul.w	r8, r8, r0
     a54:	45a0      	cmp	r8, r4
     a56:	d907      	bls.n	a68 <__udivmoddi4+0x10c>
     a58:	193c      	adds	r4, r7, r4
     a5a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
     a5e:	d202      	bcs.n	a66 <__udivmoddi4+0x10a>
     a60:	45a0      	cmp	r8, r4
     a62:	f200 80d7 	bhi.w	c14 <__udivmoddi4+0x2b8>
     a66:	4618      	mov	r0, r3
     a68:	eba4 0408 	sub.w	r4, r4, r8
     a6c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     a70:	e7c0      	b.n	9f4 <__udivmoddi4+0x98>
     a72:	428b      	cmp	r3, r1
     a74:	d908      	bls.n	a88 <__udivmoddi4+0x12c>
     a76:	2e00      	cmp	r6, #0
     a78:	f000 80af 	beq.w	bda <__udivmoddi4+0x27e>
     a7c:	2100      	movs	r1, #0
     a7e:	e9c6 0500 	strd	r0, r5, [r6]
     a82:	4608      	mov	r0, r1
     a84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     a88:	fab3 f183 	clz	r1, r3
     a8c:	2900      	cmp	r1, #0
     a8e:	d14b      	bne.n	b28 <__udivmoddi4+0x1cc>
     a90:	42ab      	cmp	r3, r5
     a92:	d302      	bcc.n	a9a <__udivmoddi4+0x13e>
     a94:	4282      	cmp	r2, r0
     a96:	f200 80b7 	bhi.w	c08 <__udivmoddi4+0x2ac>
     a9a:	1a84      	subs	r4, r0, r2
     a9c:	eb65 0303 	sbc.w	r3, r5, r3
     aa0:	2001      	movs	r0, #1
     aa2:	469e      	mov	lr, r3
     aa4:	2e00      	cmp	r6, #0
     aa6:	d0aa      	beq.n	9fe <__udivmoddi4+0xa2>
     aa8:	e9c6 4e00 	strd	r4, lr, [r6]
     aac:	e7a7      	b.n	9fe <__udivmoddi4+0xa2>
     aae:	f1c2 0c20 	rsb	ip, r2, #32
     ab2:	fa01 f302 	lsl.w	r3, r1, r2
     ab6:	4097      	lsls	r7, r2
     ab8:	fa20 f00c 	lsr.w	r0, r0, ip
     abc:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     ac0:	fa21 fc0c 	lsr.w	ip, r1, ip
     ac4:	4318      	orrs	r0, r3
     ac6:	fbbc f1fe 	udiv	r1, ip, lr
     aca:	0c05      	lsrs	r5, r0, #16
     acc:	fb0e cc11 	mls	ip, lr, r1, ip
     ad0:	fa1f f887 	uxth.w	r8, r7
     ad4:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
     ad8:	fb01 f308 	mul.w	r3, r1, r8
     adc:	42ab      	cmp	r3, r5
     ade:	fa04 f402 	lsl.w	r4, r4, r2
     ae2:	d909      	bls.n	af8 <__udivmoddi4+0x19c>
     ae4:	197d      	adds	r5, r7, r5
     ae6:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
     aea:	f080 808b 	bcs.w	c04 <__udivmoddi4+0x2a8>
     aee:	42ab      	cmp	r3, r5
     af0:	f240 8088 	bls.w	c04 <__udivmoddi4+0x2a8>
     af4:	3902      	subs	r1, #2
     af6:	443d      	add	r5, r7
     af8:	1aeb      	subs	r3, r5, r3
     afa:	b285      	uxth	r5, r0
     afc:	fbb3 f0fe 	udiv	r0, r3, lr
     b00:	fb0e 3310 	mls	r3, lr, r0, r3
     b04:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     b08:	fb00 f308 	mul.w	r3, r0, r8
     b0c:	42ab      	cmp	r3, r5
     b0e:	d907      	bls.n	b20 <__udivmoddi4+0x1c4>
     b10:	197d      	adds	r5, r7, r5
     b12:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
     b16:	d271      	bcs.n	bfc <__udivmoddi4+0x2a0>
     b18:	42ab      	cmp	r3, r5
     b1a:	d96f      	bls.n	bfc <__udivmoddi4+0x2a0>
     b1c:	3802      	subs	r0, #2
     b1e:	443d      	add	r5, r7
     b20:	1aeb      	subs	r3, r5, r3
     b22:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
     b26:	e778      	b.n	a1a <__udivmoddi4+0xbe>
     b28:	f1c1 0c20 	rsb	ip, r1, #32
     b2c:	408b      	lsls	r3, r1
     b2e:	fa22 f70c 	lsr.w	r7, r2, ip
     b32:	431f      	orrs	r7, r3
     b34:	fa20 f40c 	lsr.w	r4, r0, ip
     b38:	fa05 f301 	lsl.w	r3, r5, r1
     b3c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     b40:	fa25 f50c 	lsr.w	r5, r5, ip
     b44:	431c      	orrs	r4, r3
     b46:	0c23      	lsrs	r3, r4, #16
     b48:	fbb5 f9fe 	udiv	r9, r5, lr
     b4c:	fa1f f887 	uxth.w	r8, r7
     b50:	fb0e 5519 	mls	r5, lr, r9, r5
     b54:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
     b58:	fb09 fa08 	mul.w	sl, r9, r8
     b5c:	45aa      	cmp	sl, r5
     b5e:	fa02 f201 	lsl.w	r2, r2, r1
     b62:	fa00 f301 	lsl.w	r3, r0, r1
     b66:	d908      	bls.n	b7a <__udivmoddi4+0x21e>
     b68:	197d      	adds	r5, r7, r5
     b6a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     b6e:	d247      	bcs.n	c00 <__udivmoddi4+0x2a4>
     b70:	45aa      	cmp	sl, r5
     b72:	d945      	bls.n	c00 <__udivmoddi4+0x2a4>
     b74:	f1a9 0902 	sub.w	r9, r9, #2
     b78:	443d      	add	r5, r7
     b7a:	eba5 050a 	sub.w	r5, r5, sl
     b7e:	b2a4      	uxth	r4, r4
     b80:	fbb5 f0fe 	udiv	r0, r5, lr
     b84:	fb0e 5510 	mls	r5, lr, r0, r5
     b88:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
     b8c:	fb00 f808 	mul.w	r8, r0, r8
     b90:	45a0      	cmp	r8, r4
     b92:	d907      	bls.n	ba4 <__udivmoddi4+0x248>
     b94:	193c      	adds	r4, r7, r4
     b96:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
     b9a:	d22d      	bcs.n	bf8 <__udivmoddi4+0x29c>
     b9c:	45a0      	cmp	r8, r4
     b9e:	d92b      	bls.n	bf8 <__udivmoddi4+0x29c>
     ba0:	3802      	subs	r0, #2
     ba2:	443c      	add	r4, r7
     ba4:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
     ba8:	eba4 0408 	sub.w	r4, r4, r8
     bac:	fba0 8902 	umull	r8, r9, r0, r2
     bb0:	454c      	cmp	r4, r9
     bb2:	46c6      	mov	lr, r8
     bb4:	464d      	mov	r5, r9
     bb6:	d319      	bcc.n	bec <__udivmoddi4+0x290>
     bb8:	d016      	beq.n	be8 <__udivmoddi4+0x28c>
     bba:	b15e      	cbz	r6, bd4 <__udivmoddi4+0x278>
     bbc:	ebb3 020e 	subs.w	r2, r3, lr
     bc0:	eb64 0405 	sbc.w	r4, r4, r5
     bc4:	fa04 fc0c 	lsl.w	ip, r4, ip
     bc8:	40ca      	lsrs	r2, r1
     bca:	ea4c 0202 	orr.w	r2, ip, r2
     bce:	40cc      	lsrs	r4, r1
     bd0:	e9c6 2400 	strd	r2, r4, [r6]
     bd4:	2100      	movs	r1, #0
     bd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     bda:	4631      	mov	r1, r6
     bdc:	4630      	mov	r0, r6
     bde:	e70e      	b.n	9fe <__udivmoddi4+0xa2>
     be0:	46ac      	mov	ip, r5
     be2:	e6ed      	b.n	9c0 <__udivmoddi4+0x64>
     be4:	4618      	mov	r0, r3
     be6:	e701      	b.n	9ec <__udivmoddi4+0x90>
     be8:	4543      	cmp	r3, r8
     bea:	d2e6      	bcs.n	bba <__udivmoddi4+0x25e>
     bec:	ebb8 0e02 	subs.w	lr, r8, r2
     bf0:	eb69 0507 	sbc.w	r5, r9, r7
     bf4:	3801      	subs	r0, #1
     bf6:	e7e0      	b.n	bba <__udivmoddi4+0x25e>
     bf8:	4628      	mov	r0, r5
     bfa:	e7d3      	b.n	ba4 <__udivmoddi4+0x248>
     bfc:	4660      	mov	r0, ip
     bfe:	e78f      	b.n	b20 <__udivmoddi4+0x1c4>
     c00:	4681      	mov	r9, r0
     c02:	e7ba      	b.n	b7a <__udivmoddi4+0x21e>
     c04:	4661      	mov	r1, ip
     c06:	e777      	b.n	af8 <__udivmoddi4+0x19c>
     c08:	4608      	mov	r0, r1
     c0a:	e74b      	b.n	aa4 <__udivmoddi4+0x148>
     c0c:	f1ac 0c02 	sub.w	ip, ip, #2
     c10:	443d      	add	r5, r7
     c12:	e715      	b.n	a40 <__udivmoddi4+0xe4>
     c14:	3802      	subs	r0, #2
     c16:	443c      	add	r4, r7
     c18:	e726      	b.n	a68 <__udivmoddi4+0x10c>
     c1a:	bf00      	nop

00000c1c <__aeabi_idiv0>:
     c1c:	4770      	bx	lr
     c1e:	bf00      	nop

00000c20 <ll_adv_enable>:
{
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
u8_t ll_adv_enable(u8_t enable)
{
     c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     c24:	b08d      	sub	sp, #52	; 0x34
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     c26:	2302      	movs	r3, #2
     c28:	930b      	str	r3, [sp, #44]	; 0x2c
	u32_t ticks_slot_offset;
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	u32_t ret;

	if (!enable) {
     c2a:	b930      	cbnz	r0, c3a <ll_adv_enable+0x1a>
		return disable(handle);
     c2c:	f009 ffc6 	bl	abbc <disable.constprop.0>
     c30:	4605      	mov	r5, r0
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
     c32:	4628      	mov	r0, r5
     c34:	b00d      	add	sp, #52	; 0x34
     c36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
     c3a:	4e63      	ldr	r6, [pc, #396]	; (dc8 <ll_adv_enable+0x1a8>)
     c3c:	f896 50c8 	ldrb.w	r5, [r6, #200]	; 0xc8
     c40:	f015 0501 	ands.w	r5, r5, #1
     c44:	4634      	mov	r4, r6
     c46:	d001      	beq.n	c4c <ll_adv_enable+0x2c>
		return BT_HCI_ERR_CMD_DISALLOWED;
     c48:	250c      	movs	r5, #12
     c4a:	e7f2      	b.n	c32 <ll_adv_enable+0x12>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     c4c:	f896 7026 	ldrb.w	r7, [r6, #38]	; 0x26
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     c50:	f896 8076 	ldrb.w	r8, [r6, #118]	; 0x76
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     c54:	2327      	movs	r3, #39	; 0x27
     c56:	fb07 3703 	mla	r7, r7, r3, r3
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
     c5a:	4629      	mov	r1, r5
     c5c:	5df0      	ldrb	r0, [r6, r7]
     c5e:	f3c0 1080 	ubfx	r0, r0, #6, #1
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     c62:	fb03 6808 	mla	r8, r3, r8, r6
     c66:	f008 fc6b 	bl	9540 <ll_addr_get>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     c6a:	eb06 0907 	add.w	r9, r6, r7
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
     c6e:	f109 0b02 	add.w	fp, r9, #2
     c72:	4601      	mov	r1, r0
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
     c74:	4682      	mov	sl, r0
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
     c76:	2206      	movs	r2, #6
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     c78:	f108 0877 	add.w	r8, r8, #119	; 0x77
     c7c:	4658      	mov	r0, fp
     c7e:	f015 f9dc 	bl	1603a <memcpy>
			memcpy(&pdu_scan->scan_rsp.addr[0], tx_addr,
     c82:	2206      	movs	r2, #6
     c84:	4651      	mov	r1, sl
     c86:	f108 0002 	add.w	r0, r8, #2
     c8a:	f015 f9d6 	bl	1603a <memcpy>
		if (pdu_adv->tx_addr &&
     c8e:	5df3      	ldrb	r3, [r6, r7]
     c90:	065b      	lsls	r3, r3, #25
     c92:	d46f      	bmi.n	d74 <ll_adv_enable+0x154>
	u8_t ch_map = lll->chan_map;
     c94:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     c98:	2101      	movs	r1, #1
	u8_t ch_map = lll->chan_map;
     c9a:	f3c3 0302 	ubfx	r3, r3, #0, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     c9e:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
	u8_t ch_map = lll->chan_map;
     ca2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     ca6:	f015 fb9f 	bl	163e8 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
     caa:	2800      	cmp	r0, #0
     cac:	d0cc      	beq.n	c48 <ll_adv_enable+0x28>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     cae:	5df6      	ldrb	r6, [r6, r7]
		const u8_t adv_data_len = pdu_adv->len;
     cb0:	f899 2001 	ldrb.w	r2, [r9, #1]
		const u8_t rsp_data_len = pdu_scan->len;
     cb4:	f898 3001 	ldrb.w	r3, [r8, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     cb8:	f006 060f 	and.w	r6, r6, #15
     cbc:	2e02      	cmp	r6, #2
     cbe:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
     cc2:	d15f      	bne.n	d84 <ll_adv_enable+0x164>
			adv_size += adv_data_len;
     cc4:	3210      	adds	r2, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
     cc6:	00d2      	lsls	r2, r2, #3
     cc8:	4350      	muls	r0, r2
     cca:	f500 70aa 	add.w	r0, r0, #340	; 0x154
     cce:	2364      	movs	r3, #100	; 0x64
     cd0:	fb03 0001 	mla	r0, r3, r1, r0
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
     cd4:	f894 3020 	ldrb.w	r3, [r4, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     cd8:	493c      	ldr	r1, [pc, #240]	; (dcc <ll_adv_enable+0x1ac>)
	hdr->parent = parent;
     cda:	61e4      	str	r4, [r4, #28]
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
     cdc:	2600      	movs	r6, #0
	hdr->is_stop = 0U;
     cde:	f366 0300 	bfi	r3, r6, #0, #1
     ce2:	f884 3020 	strb.w	r3, [r4, #32]
	adv->evt.ticks_xtal_to_start =
     ce6:	2331      	movs	r3, #49	; 0x31
     ce8:	6023      	str	r3, [r4, #0]
     cea:	e9c4 6605 	strd	r6, r6, [r4, #20]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     cee:	a334      	add	r3, pc, #208	; (adr r3, dc0 <ll_adv_enable+0x1a0>)
     cf0:	e9d3 2300 	ldrd	r2, r3, [r3]
	adv->evt.ticks_active_to_start = 0;
     cf4:	6066      	str	r6, [r4, #4]
	adv->evt.ticks_preempt_to_start =
     cf6:	60a6      	str	r6, [r4, #8]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     cf8:	fba0 0101 	umull	r0, r1, r0, r1
     cfc:	f7ff fe02 	bl	904 <__aeabi_uldivmod>
     d00:	60e0      	str	r0, [r4, #12]
	u16_t interval = adv->interval;
     d02:	f8b4 80ca 	ldrh.w	r8, [r4, #202]	; 0xca
	ticks_anchor = ticker_ticks_now_get();
     d06:	f015 fd94 	bl	16832 <ticker_ticks_now_get>
		const u32_t ticks_slot = adv->evt.ticks_slot +
     d0a:	68e3      	ldr	r3, [r4, #12]
		ll_adv_ticker_ext[handle].ticks_slot_window =
     d0c:	4a30      	ldr	r2, [pc, #192]	; (dd0 <ll_adv_enable+0x1b0>)
			ULL_ADV_RANDOM_DELAY + ticks_slot;
     d0e:	f203 1147 	addw	r1, r3, #327	; 0x147
		ll_adv_ticker_ext[handle].ticks_slot_window =
     d12:	6011      	str	r1, [r2, #0]
		ret = ticker_start_ext(
     d14:	9209      	str	r2, [sp, #36]	; 0x24
     d16:	4a2f      	ldr	r2, [pc, #188]	; (dd4 <ll_adv_enable+0x1b4>)
     d18:	e9cd 4206 	strd	r4, r2, [sp, #24]
     d1c:	4a2e      	ldr	r2, [pc, #184]	; (dd8 <ll_adv_enable+0x1b8>)
	ticks_anchor = ticker_ticks_now_get();
     d1e:	4607      	mov	r7, r0
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d20:	482e      	ldr	r0, [pc, #184]	; (ddc <ll_adv_enable+0x1bc>)
		ret = ticker_start_ext(
     d22:	e9cd 3204 	strd	r3, r2, [sp, #16]
     d26:	f64f 73ff 	movw	r3, #65535	; 0xffff
     d2a:	e9cd 6302 	strd	r6, r3, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d2e:	fba8 0100 	umull	r0, r1, r8, r0
     d32:	2391      	movs	r3, #145	; 0x91
		ret = ticker_start_ext(
     d34:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d38:	fb03 1108 	mla	r1, r3, r8, r1
     d3c:	a320      	add	r3, pc, #128	; (adr r3, dc0 <ll_adv_enable+0x1a0>)
     d3e:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start_ext(
     d42:	f8cd 9020 	str.w	r9, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     d46:	f7ff fddd 	bl	904 <__aeabi_uldivmod>
		ret = ticker_start_ext(
     d4a:	2103      	movs	r1, #3
     d4c:	e9cd 6000 	strd	r6, r0, [sp]
     d50:	463b      	mov	r3, r7
     d52:	2202      	movs	r2, #2
     d54:	4630      	mov	r0, r6
     d56:	f008 fb23 	bl	93a0 <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
     d5a:	4649      	mov	r1, r9
     d5c:	f009 fb90 	bl	a480 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     d60:	2800      	cmp	r0, #0
     d62:	f47f af71 	bne.w	c48 <ll_adv_enable+0x28>
	adv->is_enabled = 1;
     d66:	f894 30c8 	ldrb.w	r3, [r4, #200]	; 0xc8
     d6a:	f043 0301 	orr.w	r3, r3, #1
     d6e:	f884 30c8 	strb.w	r3, [r4, #200]	; 0xc8
	return 0;
     d72:	e75e      	b.n	c32 <ll_adv_enable+0x12>
		    !mem_nz(pdu_adv->adv_ind.addr, BDADDR_SIZE)) {
     d74:	2106      	movs	r1, #6
     d76:	4658      	mov	r0, fp
     d78:	f015 fb0a 	bl	16390 <mem_nz>
		if (pdu_adv->tx_addr &&
     d7c:	2800      	cmp	r0, #0
     d7e:	d189      	bne.n	c94 <ll_adv_enable+0x74>
			return BT_HCI_ERR_INVALID_PARAM;
     d80:	2512      	movs	r5, #18
     d82:	e756      	b.n	c32 <ll_adv_enable+0x12>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
     d84:	2e01      	cmp	r6, #1
     d86:	d015      	beq.n	db4 <ll_adv_enable+0x194>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
     d88:	00db      	lsls	r3, r3, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
     d8a:	3380      	adds	r3, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
     d8c:	b966      	cbnz	r6, da8 <ll_adv_enable+0x188>
				adv_size += adv_data_len;
     d8e:	f102 0010 	add.w	r0, r2, #16
				slot_us += scan_req_us + EVENT_IFS_MAX_US +
     d92:	f503 7327 	add.w	r3, r3, #668	; 0x29c
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
     d96:	00c2      	lsls	r2, r0, #3
     d98:	3398      	adds	r3, #152	; 0x98
     d9a:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
     d9e:	f502 709a 	add.w	r0, r2, #308	; 0x134
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
     da2:	fb01 3000 	mla	r0, r1, r0, r3
     da6:	e795      	b.n	cd4 <ll_adv_enable+0xb4>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
     da8:	2e06      	cmp	r6, #6
     daa:	d0f0      	beq.n	d8e <ll_adv_enable+0x16e>
		u32_t adv_size		= ll_hdr_size + ADVA_SIZE;
     dac:	2010      	movs	r0, #16
	u32_t slot_us	= EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
     dae:	f44f 73aa 	mov.w	r3, #340	; 0x154
     db2:	e7f0      	b.n	d96 <ll_adv_enable+0x176>
				adv_size += TARGETA_SIZE;
     db4:	2016      	movs	r0, #22
				slot_us += conn_ind_us;
     db6:	f44f 732d 	mov.w	r3, #692	; 0x2b4
     dba:	e7ec      	b.n	d96 <ll_adv_enable+0x176>
     dbc:	f3af 8000 	nop.w
     dc0:	1afd498d 	.word	0x1afd498d
     dc4:	00000007 	.word	0x00000007
     dc8:	200034e8 	.word	0x200034e8
     dcc:	3b9aca00 	.word	0x3b9aca00
     dd0:	200035b4 	.word	0x200035b4
     dd4:	0000a475 	.word	0x0000a475
     dd8:	0000a899 	.word	0x0000a899
     ddc:	84e72a00 	.word	0x84e72a00

00000de0 <ull_scan_enable>:
	lll->interval = interval;
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
}

u8_t ull_scan_enable(struct ll_scan_set *scan)
{
     de0:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
     de4:	b08c      	sub	sp, #48	; 0x30
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     de6:	2302      	movs	r3, #2
{
     de8:	4604      	mov	r4, r0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     dea:	930b      	str	r3, [sp, #44]	; 0x2c
	u32_t ticks_slot_offset;
	u32_t ticks_interval;
	u32_t ticks_anchor;
	u32_t ret;

	lll->chan = 0;
     dec:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
	lll->init_addr_type = scan->own_addr_type;
     df0:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	ull_hdr_init(&scan->ull);
	lll_hdr_init(lll, scan);

	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     df4:	4e36      	ldr	r6, [pc, #216]	; (ed0 <ull_scan_enable+0xf0>)
	lll->init_addr_type = scan->own_addr_type;
     df6:	f3c0 0040 	ubfx	r0, r0, #1, #1
     dfa:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
     dfe:	f360 1386 	bfi	r3, r0, #6, #1
     e02:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	ll_addr_get(lll->init_addr_type, lll->init_addr);
     e06:	f104 0125 	add.w	r1, r4, #37	; 0x25
     e0a:	f008 fb99 	bl	9540 <ll_addr_get>
     e0e:	f894 3020 	ldrb.w	r3, [r4, #32]
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     e12:	8e67      	ldrh	r7, [r4, #50]	; 0x32
	hdr->parent = parent;
     e14:	61e4      	str	r4, [r4, #28]
     e16:	2500      	movs	r5, #0
	hdr->is_stop = 0U;
     e18:	f365 0300 	bfi	r3, r5, #0, #1
     e1c:	fba7 0106 	umull	r0, r1, r7, r6
     e20:	f884 3020 	strb.w	r3, [r4, #32]
     e24:	2391      	movs	r3, #145	; 0x91
     e26:	fb03 1107 	mla	r1, r3, r7, r1
     e2a:	e9c4 5505 	strd	r5, r5, [r4, #20]
     e2e:	a326      	add	r3, pc, #152	; (adr r3, ec8 <ull_scan_enable+0xe8>)
     e30:	e9d3 2300 	ldrd	r2, r3, [r3]
     e34:	f7ff fd66 	bl	904 <__aeabi_uldivmod>

	/* TODO: active_to_start feature port */
	scan->evt.ticks_active_to_start = 0U;
	scan->evt.ticks_xtal_to_start =
     e38:	2331      	movs	r3, #49	; 0x31
     e3a:	6023      	str	r3, [r4, #0]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	scan->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	if ((lll->ticks_window +
     e3c:	6b63      	ldr	r3, [r4, #52]	; 0x34
	scan->evt.ticks_active_to_start = 0U;
     e3e:	6065      	str	r5, [r4, #4]
	if ((lll->ticks_window +
     e40:	3309      	adds	r3, #9
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) <
	    (ticks_interval -
     e42:	f1a0 0231 	sub.w	r2, r0, #49	; 0x31
	if ((lll->ticks_window +
     e46:	4293      	cmp	r3, r2
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US))) {
		scan->evt.ticks_slot =
     e48:	bf32      	itee	cc
     e4a:	60e3      	strcc	r3, [r4, #12]
			(lll->ticks_window +
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US));
	} else {
		scan->evt.ticks_slot =
     e4c:	60e2      	strcs	r2, [r4, #12]
			(ticks_interval -
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US));
		lll->ticks_window = 0;
     e4e:	6365      	strcs	r5, [r4, #52]	; 0x34
	scan->evt.ticks_preempt_to_start =
     e50:	60a5      	str	r5, [r4, #8]
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     e52:	4607      	mov	r7, r0
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	ticks_anchor = ticker_ticks_now_get();
     e54:	f015 fced 	bl	16832 <ticker_ticks_now_get>
				       HAL_TICKER_US_TO_TICKS(offset_us);
		}
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     e58:	4b1e      	ldr	r3, [pc, #120]	; (ed4 <ull_scan_enable+0xf4>)
			   TICKER_USER_ID_THREAD, TICKER_ID_SCAN_BASE,
			   ticks_anchor, 0, ticks_interval,
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     e5a:	f8b4 b032 	ldrh.w	fp, [r4, #50]	; 0x32
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     e5e:	e9cd 4306 	strd	r4, r3, [sp, #24]
     e62:	4b1d      	ldr	r3, [pc, #116]	; (ed8 <ull_scan_enable+0xf8>)
     e64:	9305      	str	r3, [sp, #20]
     e66:	46b1      	mov	r9, r6
     e68:	68e3      	ldr	r3, [r4, #12]
     e6a:	9304      	str	r3, [sp, #16]
	ticks_anchor = ticker_ticks_now_get();
     e6c:	4680      	mov	r8, r0
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     e6e:	2391      	movs	r3, #145	; 0x91
     e70:	fbab 0109 	umull	r0, r1, fp, r9
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     e74:	2500      	movs	r5, #0
     e76:	ae0b      	add	r6, sp, #44	; 0x2c
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     e78:	fb03 110b 	mla	r1, r3, fp, r1
     e7c:	a312      	add	r3, pc, #72	; (adr r3, ec8 <ull_scan_enable+0xe8>)
     e7e:	e9d3 2300 	ldrd	r2, r3, [r3]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     e82:	9608      	str	r6, [sp, #32]
     e84:	9503      	str	r5, [sp, #12]
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     e86:	f7ff fd3d 	bl	904 <__aeabi_uldivmod>
     e8a:	4610      	mov	r0, r2
     e8c:	4619      	mov	r1, r3
     e8e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     e92:	2300      	movs	r3, #0
     e94:	f7ff fd36 	bl	904 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     e98:	2103      	movs	r1, #3
     e9a:	e9cd 7001 	strd	r7, r0, [sp, #4]
     e9e:	9500      	str	r5, [sp, #0]
     ea0:	4643      	mov	r3, r8
     ea2:	2204      	movs	r2, #4
     ea4:	4628      	mov	r0, r5
     ea6:	f015 fca9 	bl	167fc <ticker_start>
			   TICKER_NULL_LAZY,
			   (scan->evt.ticks_slot + ticks_slot_overhead),
			   ticker_cb, scan,
			   ull_ticker_status_give, (void *)&ret_cb);

	ret = ull_ticker_status_take(ret, &ret_cb);
     eaa:	4631      	mov	r1, r6
     eac:	f009 fae8 	bl	a480 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     eb0:	b940      	cbnz	r0, ec4 <ull_scan_enable+0xe4>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	scan->is_enabled = 1U;
     eb2:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
     eb6:	f043 0301 	orr.w	r3, r3, #1
     eba:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		ull_filter_adv_scan_state_cb(BIT(1));
	}
#endif

	return 0;
}
     ebe:	b00c      	add	sp, #48	; 0x30
     ec0:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
     ec4:	200c      	movs	r0, #12
     ec6:	e7fa      	b.n	ebe <ull_scan_enable+0xde>
     ec8:	1afd498d 	.word	0x1afd498d
     ecc:	00000007 	.word	0x00000007
     ed0:	84e72a00 	.word	0x84e72a00
     ed4:	0000a475 	.word	0x0000a475
     ed8:	0000aca1 	.word	0x0000aca1
     edc:	00000000 	.word	0x00000000

00000ee0 <ll_scan_params_set>:
{
     ee0:	b570      	push	{r4, r5, r6, lr}
     ee2:	4605      	mov	r5, r0
	scan = ull_scan_is_disabled_get(0);
     ee4:	2000      	movs	r0, #0
{
     ee6:	461e      	mov	r6, r3
	scan = ull_scan_is_disabled_get(0);
     ee8:	f009 ff9c 	bl	ae24 <ull_scan_is_disabled_get>
	if (!scan) {
     eec:	4604      	mov	r4, r0
     eee:	b310      	cbz	r0, f36 <ll_scan_params_set+0x56>
	scan->own_addr_type = own_addr_type;
     ef0:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
     ef4:	f366 0342 	bfi	r3, r6, #1, #2
     ef8:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
	lll->filter_policy = filter_policy;
     efc:	f89d 3010 	ldrb.w	r3, [sp, #16]
	lll->interval = interval;
     f00:	8661      	strh	r1, [r4, #50]	; 0x32
	lll->filter_policy = filter_policy;
     f02:	00db      	lsls	r3, r3, #3
     f04:	f003 0318 	and.w	r3, r3, #24
     f08:	ea43 10c5 	orr.w	r0, r3, r5, lsl #7
     f0c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
     f10:	f003 0367 	and.w	r3, r3, #103	; 0x67
     f14:	4318      	orrs	r0, r3
     f16:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
     f1a:	480b      	ldr	r0, [pc, #44]	; (f48 <ll_scan_params_set+0x68>)
     f1c:	2391      	movs	r3, #145	; 0x91
     f1e:	fba2 0100 	umull	r0, r1, r2, r0
     f22:	fb03 1102 	mla	r1, r3, r2, r1
     f26:	a306      	add	r3, pc, #24	; (adr r3, f40 <ll_scan_params_set+0x60>)
     f28:	e9d3 2300 	ldrd	r2, r3, [r3]
     f2c:	f7ff fcea 	bl	904 <__aeabi_uldivmod>
     f30:	6360      	str	r0, [r4, #52]	; 0x34
	return 0;
     f32:	2000      	movs	r0, #0
}
     f34:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
     f36:	200c      	movs	r0, #12
     f38:	e7fc      	b.n	f34 <ll_scan_params_set+0x54>
     f3a:	bf00      	nop
     f3c:	f3af 8000 	nop.w
     f40:	1afd498d 	.word	0x1afd498d
     f44:	00000007 	.word	0x00000007
     f48:	84e72a00 	.word	0x84e72a00
     f4c:	00000000 	.word	0x00000000

00000f50 <erase_op>:
}

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
     f50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     f54:	4604      	mov	r4, r0
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
     f56:	f016 fc3f 	bl	177d8 <nrfx_nvmc_flash_page_size_get>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 0U;

	if (e_ctx->enable_time_limit) {
     f5a:	7b25      	ldrb	r5, [r4, #12]
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
     f5c:	4606      	mov	r6, r0
	if (e_ctx->enable_time_limit) {
     f5e:	b115      	cbz	r5, f66 <erase_op+0x16>
		ticks_begin = ticker_ticks_now_get();
     f60:	f015 fc67 	bl	16832 <ticker_ticks_now_get>
     f64:	4605      	mov	r5, r0
		if (e_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
     f66:	f20f 0968 	addw	r9, pc, #104	; 0x68
     f6a:	e9d9 8900 	ldrd	r8, r9, [r9]
     f6e:	f8df b068 	ldr.w	fp, [pc, #104]	; fd8 <erase_op+0x88>
	u32_t ticks_begin = 0U;
     f72:	f04f 0a00 	mov.w	sl, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
     f76:	6860      	ldr	r0, [r4, #4]
     f78:	f00e fbea 	bl	f750 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
     f7c:	68a3      	ldr	r3, [r4, #8]
     f7e:	1b9b      	subs	r3, r3, r6
     f80:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
     f82:	6863      	ldr	r3, [r4, #4]
     f84:	4433      	add	r3, r6
     f86:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
     f88:	7b23      	ldrb	r3, [r4, #12]
		i++;
     f8a:	f10a 0a01 	add.w	sl, sl, #1
		if (e_ctx->enable_time_limit) {
     f8e:	b94b      	cbnz	r3, fa4 <erase_op+0x54>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
     f90:	68a3      	ldr	r3, [r4, #8]
     f92:	2b00      	cmp	r3, #0
     f94:	d1ef      	bne.n	f76 <erase_op+0x26>

	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
     f96:	68a0      	ldr	r0, [r4, #8]
     f98:	3800      	subs	r0, #0
     f9a:	bf18      	it	ne
     f9c:	2001      	movne	r0, #1
}
     f9e:	4240      	negs	r0, r0
     fa0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker_ticks_diff_get(ticker_ticks_now_get(),
     fa4:	f015 fc45 	bl	16832 <ticker_ticks_now_get>
     fa8:	4629      	mov	r1, r5
     faa:	f015 fc44 	bl	16836 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
     fae:	fbb0 f7fa 	udiv	r7, r0, sl
     fb2:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
     fb4:	6960      	ldr	r0, [r4, #20]
     fb6:	4642      	mov	r2, r8
     fb8:	464b      	mov	r3, r9
     fba:	fba0 010b 	umull	r0, r1, r0, fp
     fbe:	f7ff fca1 	bl	904 <__aeabi_uldivmod>
     fc2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
     fc6:	4287      	cmp	r7, r0
     fc8:	d9e2      	bls.n	f90 <erase_op+0x40>
     fca:	e7e4      	b.n	f96 <erase_op+0x46>
     fcc:	f3af 8000 	nop.w
     fd0:	1afd498d 	.word	0x1afd498d
     fd4:	00000007 	.word	0x00000007
     fd8:	3b9aca00 	.word	0x3b9aca00
     fdc:	00000000 	.word	0x00000000

00000fe0 <work_in_time_slice>:
{
     fe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     fe4:	b08f      	sub	sp, #60	; 0x3c
	struct flash_context *context = p_flash_op_desc->context;
     fe6:	f8d0 9004 	ldr.w	r9, [r0, #4]
			   HAL_TICKER_US_TO_TICKS(context->interval),
     fea:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 10cc <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xcc>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
     fee:	f10d 0137 	add.w	r1, sp, #55	; 0x37
{
     ff2:	4606      	mov	r6, r0
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
     ff4:	f10d 0036 	add.w	r0, sp, #54	; 0x36
     ff8:	f015 fc70 	bl	168dc <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index,
     ffc:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    1000:	f89d a036 	ldrb.w	sl, [sp, #54]	; 0x36
    1004:	930a      	str	r3, [sp, #40]	; 0x28
    1006:	f015 fc14 	bl	16832 <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(context->interval),
    100a:	f8d9 4010 	ldr.w	r4, [r9, #16]
    100e:	fba4 450b 	umull	r4, r5, r4, fp
    1012:	a329      	add	r3, pc, #164	; (adr r3, 10b8 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xb8>)
    1014:	e9d3 2300 	ldrd	r2, r3, [r3]
	err = ticker_start(instance_index,
    1018:	2700      	movs	r7, #0
    101a:	4680      	mov	r8, r0
			   HAL_TICKER_US_TO_TICKS(context->interval),
    101c:	4629      	mov	r1, r5
    101e:	4620      	mov	r0, r4
    1020:	f7ff fc70 	bl	904 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    1024:	e9cd 7707 	strd	r7, r7, [sp, #28]
    1028:	4b25      	ldr	r3, [pc, #148]	; (10c0 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xc0>)
    102a:	9305      	str	r3, [sp, #20]
    102c:	9606      	str	r6, [sp, #24]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    102e:	900b      	str	r0, [sp, #44]	; 0x2c
			   HAL_TICKER_US_TO_TICKS(context->slot),
    1030:	f8d9 0014 	ldr.w	r0, [r9, #20]
    1034:	a320      	add	r3, pc, #128	; (adr r3, 10b8 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xb8>)
    1036:	e9d3 2300 	ldrd	r2, r3, [r3]
    103a:	fba0 010b 	umull	r0, r1, r0, fp
    103e:	f7ff fc61 	bl	904 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(context->interval),
    1042:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1044:	f023 497f 	bic.w	r9, r3, #4278190080	; 0xff000000
    1048:	4b1e      	ldr	r3, [pc, #120]	; (10c4 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xc4>)
	err = ticker_start(instance_index,
    104a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			   HAL_TICKER_REMAINDER(context->interval),
    104e:	fba9 bc03 	umull	fp, ip, r9, r3
    1052:	2307      	movs	r3, #7
    1054:	fb03 cc09 	mla	ip, r3, r9, ip
	err = ticker_start(instance_index,
    1058:	e9cd 7003 	strd	r7, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(context->interval),
    105c:	ebb4 000b 	subs.w	r0, r4, fp
    1060:	eb65 010c 	sbc.w	r1, r5, ip
    1064:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1068:	2300      	movs	r3, #0
    106a:	f7ff fc4b 	bl	904 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    106e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    1070:	9700      	str	r7, [sp, #0]
    1072:	e9cd 9001 	strd	r9, r0, [sp, #4]
    1076:	4643      	mov	r3, r8
    1078:	2103      	movs	r1, #3
    107a:	4650      	mov	r0, sl
    107c:	f015 fbbe 	bl	167fc <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    1080:	f030 0402 	bics.w	r4, r0, #2
    1084:	d115      	bne.n	10b2 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xb2>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sem, *(uintptr_t *)&timeout, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    1086:	4810      	ldr	r0, [pc, #64]	; (10c8 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xc8>)
    1088:	f645 11b3 	movw	r1, #22963	; 0x59b3
    108c:	f013 f954 	bl	14338 <z_impl_k_sem_take>
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
    1090:	b168      	cbz	r0, 10ae <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xae>
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
    1092:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
    1096:	f89d 0036 	ldrb.w	r0, [sp, #54]	; 0x36
    109a:	9400      	str	r4, [sp, #0]
    109c:	4623      	mov	r3, r4
    109e:	2103      	movs	r1, #3
    10a0:	f008 fa14 	bl	94cc <ticker_stop>
		result = -ETIMEDOUT;
    10a4:	f06f 003b 	mvn.w	r0, #59	; 0x3b
}
    10a8:	b00f      	add	sp, #60	; 0x3c
    10aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = p_flash_op_desc->result;
    10ae:	68b0      	ldr	r0, [r6, #8]
    10b0:	e7fa      	b.n	10a8 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xa8>
		result = -ECANCELED;
    10b2:	f06f 0047 	mvn.w	r0, #71	; 0x47
	return result;
    10b6:	e7f7      	b.n	10a8 <CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE+0xa8>
    10b8:	1afd498d 	.word	0x1afd498d
    10bc:	00000007 	.word	0x00000007
    10c0:	0000eb4d 	.word	0x0000eb4d
    10c4:	1afd498d 	.word	0x1afd498d
    10c8:	20003b64 	.word	0x20003b64
    10cc:	3b9aca00 	.word	0x3b9aca00

000010d0 <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
    10d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 1U;

	if (w_ctx->enable_time_limit) {
    10d4:	7b05      	ldrb	r5, [r0, #12]
{
    10d6:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
    10d8:	b115      	cbz	r5, 10e0 <write_op+0x10>
		ticks_begin = ticker_ticks_now_get();
    10da:	f015 fbaa 	bl	16832 <ticker_ticks_now_get>
    10de:	4605      	mov	r5, r0
		if (w_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    10e0:	f20f 0980 	addw	r9, pc, #128	; 0x80
    10e4:	e9d9 8900 	ldrd	r8, r9, [r9]
    10e8:	f8df a080 	ldr.w	sl, [pc, #128]	; 116c <write_op+0x9c>
	u32_t ticks_begin = 0U;
    10ec:	2601      	movs	r6, #1
	while (w_ctx->len >= sizeof(u32_t)) {
    10ee:	68a3      	ldr	r3, [r4, #8]
    10f0:	2b03      	cmp	r3, #3
    10f2:	d807      	bhi.n	1104 <write_op+0x34>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    10f4:	4a1a      	ldr	r2, [pc, #104]	; (1160 <write_op+0x90>)
    10f6:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
    10fa:	07db      	lsls	r3, r3, #31
    10fc:	d5fb      	bpl.n	10f6 <write_op+0x26>
		shift_write_context(w_ctx->len, w_ctx);
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	nvmc_wait_ready();

	return FLASH_OP_DONE;
    10fe:	2000      	movs	r0, #0
}
    1100:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				     UNALIGNED_GET((u32_t *)w_ctx->data_addr));
    1104:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    1106:	6860      	ldr	r0, [r4, #4]
    1108:	6819      	ldr	r1, [r3, #0]
    110a:	f00e fb41 	bl	f790 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
    110e:	6863      	ldr	r3, [r4, #4]
    1110:	3304      	adds	r3, #4
    1112:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    1114:	6823      	ldr	r3, [r4, #0]
    1116:	3304      	adds	r3, #4
    1118:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    111a:	68a3      	ldr	r3, [r4, #8]
    111c:	3b04      	subs	r3, #4
    111e:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
    1120:	7b23      	ldrb	r3, [r4, #12]
		i++;
    1122:	3601      	adds	r6, #1
		if (w_ctx->enable_time_limit) {
    1124:	2b00      	cmp	r3, #0
    1126:	d0e2      	beq.n	10ee <write_op+0x1e>
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    1128:	f015 fb83 	bl	16832 <ticker_ticks_now_get>
    112c:	4629      	mov	r1, r5
    112e:	f015 fb82 	bl	16836 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    1132:	fbb0 f7f6 	udiv	r7, r0, r6
    1136:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    1138:	6960      	ldr	r0, [r4, #20]
    113a:	4642      	mov	r2, r8
    113c:	464b      	mov	r3, r9
    113e:	fba0 010a 	umull	r0, r1, r0, sl
    1142:	f7ff fbdf 	bl	904 <__aeabi_uldivmod>
    1146:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    114a:	4287      	cmp	r7, r0
    114c:	d9cf      	bls.n	10ee <write_op+0x1e>
    114e:	4a04      	ldr	r2, [pc, #16]	; (1160 <write_op+0x90>)
    1150:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
    1154:	07d9      	lsls	r1, r3, #31
    1156:	d5fb      	bpl.n	1150 <write_op+0x80>
				return FLASH_OP_ONGOING;
    1158:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    115c:	e7d0      	b.n	1100 <write_op+0x30>
    115e:	bf00      	nop
    1160:	4001e000 	.word	0x4001e000
    1164:	1afd498d 	.word	0x1afd498d
    1168:	00000007 	.word	0x00000007
    116c:	3b9aca00 	.word	0x3b9aca00

00001170 <bt_init>:
extern uint8_t saewoo_hack[2];

#define BT_LE_ADV_NCONN2 BT_LE_ADV_PARAM(4, BT_GAP_ADV_FAST_INT_MIN_2, \
                                        BT_GAP_ADV_FAST_INT_MAX_2, NULL)
extern bool hide_mac;
void bt_init(void) {
    1170:	b508      	push	{r3, lr}
    int err;
    printk("Starting Scanner/Advertiser Demo\n");
    1172:	480a      	ldr	r0, [pc, #40]	; (119c <bt_init+0x2c>)
    1174:	f013 fcd9 	bl	14b2a <printk>

    /* Initialize the Bluetooth Subsystem */
    err = bt_enable(NULL);
    1178:	2000      	movs	r0, #0
    117a:	f007 f8b3 	bl	82e4 <bt_enable>
    if (err) {
    117e:	4601      	mov	r1, r0
    1180:	b120      	cbz	r0, 118c <bt_init+0x1c>
        // blink(&led2, 1);
        return;
    }
    bt_started = true;
    printk("Bluetooth initialized\n");
}
    1182:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        printk("Bluetooth init failed (err %d)\n", err);
    1186:	4806      	ldr	r0, [pc, #24]	; (11a0 <bt_init+0x30>)
    1188:	f013 bccf 	b.w	14b2a <printk>
    bt_started = true;
    118c:	4b05      	ldr	r3, [pc, #20]	; (11a4 <bt_init+0x34>)
    printk("Bluetooth initialized\n");
    118e:	4806      	ldr	r0, [pc, #24]	; (11a8 <bt_init+0x38>)
    bt_started = true;
    1190:	2201      	movs	r2, #1
    1192:	701a      	strb	r2, [r3, #0]
}
    1194:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    printk("Bluetooth initialized\n");
    1198:	f013 bcc7 	b.w	14b2a <printk>
    119c:	00019b7c 	.word	0x00019b7c
    11a0:	00019b9e 	.word	0x00019b9e
    11a4:	200041ae 	.word	0x200041ae
    11a8:	00019bbe 	.word	0x00019bbe

000011ac <update_public_key>:

bool update_public_key(void) {
    11ac:	b570      	push	{r4, r5, r6, lr}
	return z_impl_k_uptime_ticks();
    11ae:	f017 ff0d 	bl	18fcc <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    11b2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    11b6:	460a      	mov	r2, r1
        // Check if we need to change key
        //
        //  Need to handle rollover... at some point
        u32_t timestamp = k_uptime_get_32();
        if (timestamp >= next_minute) {
    11b8:	4d1d      	ldr	r5, [pc, #116]	; (1230 <update_public_key+0x84>)
    11ba:	fba0 0103 	umull	r0, r1, r0, r3
    11be:	fb03 1102 	mla	r1, r3, r2, r1
    11c2:	0bc2      	lsrs	r2, r0, #15
    11c4:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
    11c8:	6829      	ldr	r1, [r5, #0]
    11ca:	4291      	cmp	r1, r2
    11cc:	d81d      	bhi.n	120a <update_public_key+0x5e>
    11ce:	461c      	mov	r4, r3
            while (k_uptime_get_32() >= next_minute) {
                next_minute += 60000;
    11d0:	f64e 2660 	movw	r6, #60000	; 0xea60
    11d4:	f017 fefa 	bl	18fcc <z_impl_k_uptime_ticks>
    11d8:	460a      	mov	r2, r1
    11da:	fba0 0104 	umull	r0, r1, r0, r4
    11de:	fb04 1102 	mla	r1, r4, r2, r1
            while (k_uptime_get_32() >= next_minute) {
    11e2:	682b      	ldr	r3, [r5, #0]
    11e4:	0bc2      	lsrs	r2, r0, #15
    11e6:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
    11ea:	4293      	cmp	r3, r2
    11ec:	d910      	bls.n	1210 <update_public_key+0x64>
            }
            // update secret key
            sys_csrand_get(private_key, 32);
    11ee:	2120      	movs	r1, #32
    11f0:	4810      	ldr	r0, [pc, #64]	; (1234 <update_public_key+0x88>)
    11f2:	f015 ff92 	bl	1711a <sys_csrand_get>
            X25519_calc_public_key(public_key, private_key);
    11f6:	4a10      	ldr	r2, [pc, #64]	; (1238 <update_public_key+0x8c>)
    11f8:	490e      	ldr	r1, [pc, #56]	; (1234 <update_public_key+0x88>)
    11fa:	4810      	ldr	r0, [pc, #64]	; (123c <update_public_key+0x90>)
    11fc:	f7ff f983 	bl	506 <curve25519_scalarmult>
            if (start_adv) {  // blink once a minute if advertising
    1200:	4b0f      	ldr	r3, [pc, #60]	; (1240 <update_public_key+0x94>)
    1202:	781b      	ldrb	r3, [r3, #0]
    1204:	b93b      	cbnz	r3, 1216 <update_public_key+0x6a>
bool update_public_key(void) {
    1206:	2401      	movs	r4, #1
    1208:	e000      	b.n	120c <update_public_key+0x60>
                    blink(&led3,1);
                }
            }
            return true;
        }
        return false;
    120a:	2400      	movs	r4, #0
}
    120c:	4620      	mov	r0, r4
    120e:	bd70      	pop	{r4, r5, r6, pc}
                next_minute += 60000;
    1210:	4433      	add	r3, r6
    1212:	602b      	str	r3, [r5, #0]
    1214:	e7de      	b.n	11d4 <update_public_key+0x28>
                blink(&led1,1);
    1216:	480b      	ldr	r0, [pc, #44]	; (1244 <update_public_key+0x98>)
    1218:	2101      	movs	r1, #1
    121a:	f013 fb4e 	bl	148ba <blink>
                if (write_flash) {
    121e:	4b0a      	ldr	r3, [pc, #40]	; (1248 <update_public_key+0x9c>)
    1220:	781c      	ldrb	r4, [r3, #0]
    1222:	2c00      	cmp	r4, #0
    1224:	d0ef      	beq.n	1206 <update_public_key+0x5a>
                    blink(&led3,1);
    1226:	4809      	ldr	r0, [pc, #36]	; (124c <update_public_key+0xa0>)
    1228:	2101      	movs	r1, #1
    122a:	f013 fb46 	bl	148ba <blink>
    122e:	e7ed      	b.n	120c <update_public_key+0x60>
    1230:	200010d8 	.word	0x200010d8
    1234:	200079f1 	.word	0x200079f1
    1238:	00019c07 	.word	0x00019c07
    123c:	20007a11 	.word	0x20007a11
    1240:	20007a35 	.word	0x20007a35
    1244:	2000bb28 	.word	0x2000bb28
    1248:	20007a37 	.word	0x20007a37
    124c:	2000bb50 	.word	0x2000bb50

00001250 <bt_adv>:

void bt_adv (void) {
    1250:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1254:	b097      	sub	sp, #92	; 0x5c
     *
     *
     */

    u8_t *tcn;
    struct bt_data encounter_ad[] = {
    1256:	f240 1301 	movw	r3, #257	; 0x101
    125a:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
            BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR),
    125e:	2304      	movs	r3, #4
            // BT_DATA_BYTES(BT_DATA_TX_POWER, 0),
            BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0x6F, 0xFD),
    1260:	4c48      	ldr	r4, [pc, #288]	; (1384 <bt_adv+0x134>)
            BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR),
    1262:	f88d 300c 	strb.w	r3, [sp, #12]
    struct bt_data encounter_ad[] = {
    1266:	ab03      	add	r3, sp, #12
    1268:	9311      	str	r3, [sp, #68]	; 0x44
    126a:	f240 2303 	movw	r3, #515	; 0x203
    126e:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
            BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0x6F, 0xFD),
    1272:	4623      	mov	r3, r4
            BT_DATA_BYTES(BT_DATA_SVC_DATA16,
    1274:	3412      	adds	r4, #18
            BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0x6F, 0xFD),
    1276:	f833 2b02 	ldrh.w	r2, [r3], #2
    127a:	f8ad 2010 	strh.w	r2, [sp, #16]
    struct bt_data encounter_ad[] = {
    127e:	aa04      	add	r2, sp, #16
    1280:	9213      	str	r2, [sp, #76]	; 0x4c
    1282:	f241 6216 	movw	r2, #5654	; 0x1616
    1286:	f8ad 2050 	strh.w	r2, [sp, #80]	; 0x50
            BT_DATA_BYTES(BT_DATA_SVC_DATA16,
    128a:	aa0a      	add	r2, sp, #40	; 0x28
    128c:	4616      	mov	r6, r2
    128e:	6818      	ldr	r0, [r3, #0]
    1290:	6859      	ldr	r1, [r3, #4]
    1292:	4615      	mov	r5, r2
    1294:	c503      	stmia	r5!, {r0, r1}
    1296:	3308      	adds	r3, #8
    1298:	42a3      	cmp	r3, r4
    129a:	462a      	mov	r2, r5
    129c:	d1f7      	bne.n	128e <bt_adv+0x3e>
    129e:	6818      	ldr	r0, [r3, #0]

    tcn = encounter_ad[2].data+2; // 3rd item in array of messages is RPI
    tcn[3] = 0x4;  // set to 4 by google/apple protocol

    do {
        if (!start_adv) {
    12a0:	4f39      	ldr	r7, [pc, #228]	; (1388 <bt_adv+0x138>)
            BT_DATA_BYTES(BT_DATA_SVC_DATA16,
    12a2:	889b      	ldrh	r3, [r3, #4]
    12a4:	80ab      	strh	r3, [r5, #4]

            while (!start_adv) {
                k_sleep(K_MSEC(1000));
                update_public_key();
            }
            if(hide_mac) {
    12a6:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 13a4 <bt_adv+0x154>
            BT_DATA_BYTES(BT_DATA_SVC_DATA16,
    12aa:	6028      	str	r0, [r5, #0]
    tcn[3] = 0x4;  // set to 4 by google/apple protocol
    12ac:	2304      	movs	r3, #4
    struct bt_data encounter_ad[] = {
    12ae:	9615      	str	r6, [sp, #84]	; 0x54
    tcn[3] = 0x4;  // set to 4 by google/apple protocol
    12b0:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    bool adv_part_a = true;
    12b4:	2401      	movs	r4, #1
    12b6:	46b9      	mov	r9, r7
        if (!start_adv) {
    12b8:	783b      	ldrb	r3, [r7, #0]
    12ba:	bb73      	cbnz	r3, 131a <bt_adv+0xca>
            bt_le_adv_stop();
    12bc:	f007 f9b2 	bl	8624 <bt_le_adv_stop>
            while (!start_adv) {
    12c0:	f899 3000 	ldrb.w	r3, [r9]
    12c4:	b1cb      	cbz	r3, 12fa <bt_adv+0xaa>
            if(hide_mac) {
    12c6:	f898 c000 	ldrb.w	ip, [r8]
                err = bt_le_adv_start(BT_LE_ADV_NCONN, encounter_ad,
    12ca:	ad05      	add	r5, sp, #20
            if(hide_mac) {
    12cc:	f1bc 0f00 	cmp.w	ip, #0
    12d0:	d01a      	beq.n	1308 <bt_adv+0xb8>
                err = bt_le_adv_start(BT_LE_ADV_NCONN, encounter_ad,
    12d2:	4e2e      	ldr	r6, [pc, #184]	; (138c <bt_adv+0x13c>)
    12d4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    12d6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    12d8:	6833      	ldr	r3, [r6, #0]
    12da:	602b      	str	r3, [r5, #0]
    12dc:	2300      	movs	r3, #0
    12de:	9300      	str	r3, [sp, #0]
                                        ARRAY_SIZE(encounter_ad), NULL, 0);
            } else {
                err = bt_le_adv_start(BT_LE_ADV_NCONN2, encounter_ad,
    12e0:	a910      	add	r1, sp, #64	; 0x40
    12e2:	2203      	movs	r2, #3
    12e4:	a805      	add	r0, sp, #20
    12e6:	f014 fff0 	bl	162ca <bt_le_adv_start>
    12ea:	4601      	mov	r1, r0
                                    ARRAY_SIZE(encounter_ad), NULL, 0);
            }
            if (err) {
    12ec:	b1a8      	cbz	r0, 131a <bt_adv+0xca>
                printk("Advertising failed to start (err %d)\n", err);
    12ee:	4828      	ldr	r0, [pc, #160]	; (1390 <bt_adv+0x140>)
    12f0:	f013 fc1b 	bl	14b2a <printk>
        }
        k_sleep(K_MSEC(1000));

        printk("Update rpi\n");
    } while (1);
}
    12f4:	b017      	add	sp, #92	; 0x5c
    12f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return z_impl_k_sleep(timeout);
    12fa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    12fe:	f012 ffc7 	bl	14290 <z_impl_k_sleep>
                update_public_key();
    1302:	f7ff ff53 	bl	11ac <update_public_key>
    1306:	e7db      	b.n	12c0 <bt_adv+0x70>
                err = bt_le_adv_start(BT_LE_ADV_NCONN2, encounter_ad,
    1308:	4e22      	ldr	r6, [pc, #136]	; (1394 <bt_adv+0x144>)
    130a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    130c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    130e:	6833      	ldr	r3, [r6, #0]
    1310:	602b      	str	r3, [r5, #0]
    1312:	f8cd c000 	str.w	ip, [sp]
    1316:	4663      	mov	r3, ip
    1318:	e7e2      	b.n	12e0 <bt_adv+0x90>
        bool bool_new_key = update_public_key();
    131a:	f7ff ff47 	bl	11ac <update_public_key>
    131e:	4605      	mov	r5, r0
        if (adv_part_a) {
    1320:	b31c      	cbz	r4, 136a <bt_adv+0x11a>
            tcn[0] = 0;
    1322:	2400      	movs	r4, #0
            memcpy(tcn+4, public_key, 16);
    1324:	491c      	ldr	r1, [pc, #112]	; (1398 <bt_adv+0x148>)
            tcn[0] = 0;
    1326:	f88d 402a 	strb.w	r4, [sp, #42]	; 0x2a
            memcpy(tcn+4, public_key, 16);
    132a:	2210      	movs	r2, #16
            memcpy(tcn+4, public_key+16, 16);
    132c:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
    1330:	f014 fe83 	bl	1603a <memcpy>
        if (bool_new_key && hide_mac) {
    1334:	b1fd      	cbz	r5, 1376 <bt_adv+0x126>
    1336:	f898 3000 	ldrb.w	r3, [r8]
    133a:	b1e3      	cbz	r3, 1376 <bt_adv+0x126>
            err = bt_le_adv_start(BT_LE_ADV_NCONN, encounter_ad,
    133c:	4e13      	ldr	r6, [pc, #76]	; (138c <bt_adv+0x13c>)
            bt_le_adv_stop();
    133e:	f007 f971 	bl	8624 <bt_le_adv_stop>
            err = bt_le_adv_start(BT_LE_ADV_NCONN, encounter_ad,
    1342:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    1344:	ad05      	add	r5, sp, #20
    1346:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1348:	6833      	ldr	r3, [r6, #0]
    134a:	602b      	str	r3, [r5, #0]
    134c:	2300      	movs	r3, #0
    134e:	9300      	str	r3, [sp, #0]
    1350:	2203      	movs	r2, #3
    1352:	a910      	add	r1, sp, #64	; 0x40
    1354:	a805      	add	r0, sp, #20
    1356:	f014 ffb8 	bl	162ca <bt_le_adv_start>
    135a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    135e:	f012 ff97 	bl	14290 <z_impl_k_sleep>
        printk("Update rpi\n");
    1362:	480e      	ldr	r0, [pc, #56]	; (139c <bt_adv+0x14c>)
    1364:	f013 fbe1 	bl	14b2a <printk>
    do {
    1368:	e7a6      	b.n	12b8 <bt_adv+0x68>
            tcn[0] = 1;
    136a:	2401      	movs	r4, #1
            memcpy(tcn+4, public_key+16, 16);
    136c:	490c      	ldr	r1, [pc, #48]	; (13a0 <bt_adv+0x150>)
            tcn[0] = 1;
    136e:	f88d 402a 	strb.w	r4, [sp, #42]	; 0x2a
            memcpy(tcn+4, public_key+16, 16);
    1372:	2210      	movs	r2, #16
    1374:	e7da      	b.n	132c <bt_adv+0xdc>
            err = bt_le_adv_update_data(encounter_ad, ARRAY_SIZE(encounter_ad), NULL, 0);
    1376:	2300      	movs	r3, #0
    1378:	461a      	mov	r2, r3
    137a:	2103      	movs	r1, #3
    137c:	a810      	add	r0, sp, #64	; 0x40
    137e:	f007 f849 	bl	8414 <bt_le_adv_update_data>
    1382:	e7ea      	b.n	135a <bt_adv+0x10a>
    1384:	000196b0 	.word	0x000196b0
    1388:	20007a35 	.word	0x20007a35
    138c:	000196c8 	.word	0x000196c8
    1390:	00019bd5 	.word	0x00019bd5
    1394:	000196dc 	.word	0x000196dc
    1398:	20007a11 	.word	0x20007a11
    139c:	00019bfb 	.word	0x00019bfb
    13a0:	20007a21 	.word	0x20007a21
    13a4:	2000c15c 	.word	0x2000c15c

000013a8 <button_pressed>:

void button_pressed(struct device *dev, struct gpio_callback *cb,
            u32_t pins)
{

    write_flash = !write_flash;
    13a8:	4a02      	ldr	r2, [pc, #8]	; (13b4 <button_pressed+0xc>)
    13aa:	7813      	ldrb	r3, [r2, #0]
    13ac:	f083 0301 	eor.w	r3, r3, #1
    13b0:	7013      	strb	r3, [r2, #0]
    // 
    //  This doesn't work all the time... Better with irq_lock
    // char buffer[64];
    // int len = sprintf(buffer, "write_flash: %d\n", write_flash);
    // uart_print(buffer, len);
}
    13b2:	4770      	bx	lr
    13b4:	20007a37 	.word	0x20007a37

000013b8 <button_init>:

void button_init(void){
    13b8:	b570      	push	{r4, r5, r6, lr}
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    13ba:	4813      	ldr	r0, [pc, #76]	; (1408 <button_init+0x50>)
    int ret;
    static struct gpio_callback button_cb_data;

    button_dev = device_get_binding(DT_ALIAS_SW0_GPIOS_CONTROLLER);
    13bc:	4c13      	ldr	r4, [pc, #76]	; (140c <button_init+0x54>)
    13be:	f012 f955 	bl	1366c <z_impl_device_get_binding>
    13c2:	6020      	str	r0, [r4, #0]
    if (button_dev == NULL) {
    13c4:	b1f8      	cbz	r0, 1406 <button_init+0x4e>
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config->config_info;
	struct gpio_driver_data *data =
    13c6:	6885      	ldr	r5, [r0, #8]
	return api->pin_configure(port, pin, flags);
    13c8:	6843      	ldr	r3, [r0, #4]
    13ca:	f240 1211 	movw	r2, #273	; 0x111
    13ce:	681b      	ldr	r3, [r3, #0]
    13d0:	210b      	movs	r1, #11
    13d2:	4798      	blx	r3
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
    13d4:	b9b8      	cbnz	r0, 1406 <button_init+0x4e>
		return ret;
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
    13d6:	682b      	ldr	r3, [r5, #0]
                 DT_ALIAS_SW0_GPIOS_FLAGS | GPIO_INPUT);
    if (ret != 0) {
        return;
    }

    ret = gpio_pin_interrupt_configure(button_dev, DT_ALIAS_SW0_GPIOS_PIN,
    13d8:	6820      	ldr	r0, [r4, #0]
    13da:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    13de:	602b      	str	r3, [r5, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&port, *(uintptr_t *)&pin, *(uintptr_t *)&flags, K_SYSCALL_GPIO_PIN_INTERRUPT_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
    13e0:	f44f 21b8 	mov.w	r1, #376832	; 0x5c000
    13e4:	f013 fa46 	bl	14874 <z_impl_gpio_pin_interrupt_configure.constprop.0>
                       GPIO_INT_EDGE_TO_ACTIVE);
    if (ret != 0) {
    13e8:	b968      	cbnz	r0, 1406 <button_init+0x4e>
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
    13ea:	4909      	ldr	r1, [pc, #36]	; (1410 <button_init+0x58>)
    13ec:	4b09      	ldr	r3, [pc, #36]	; (1414 <button_init+0x5c>)
        return;
    }

    gpio_init_callback(&button_cb_data, button_pressed,
               BIT(DT_ALIAS_SW0_GPIOS_PIN));
    gpio_add_callback(button_dev, &button_cb_data);
    13ee:	6820      	ldr	r0, [r4, #0]
    13f0:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
    13f2:	f44f 6300 	mov.w	r3, #2048	; 0x800
    13f6:	608b      	str	r3, [r1, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->manage_callback == NULL) {
    13f8:	6843      	ldr	r3, [r0, #4]
    13fa:	69db      	ldr	r3, [r3, #28]
    13fc:	b11b      	cbz	r3, 1406 <button_init+0x4e>

}
    13fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
    1402:	2201      	movs	r2, #1
    1404:	4718      	bx	r3
    1406:	bd70      	pop	{r4, r5, r6, pc}
    1408:	00019c27 	.word	0x00019c27
    140c:	20000088 	.word	0x20000088
    1410:	20000008 	.word	0x20000008
    1414:	000013a9 	.word	0x000013a9

00001418 <ls>:
    printk("%s close: %d\n", fname, rc);

    return 0;
}

void ls(void) {
    1418:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    struct fs_dir_t dir = { 0 };
    int rc;
    char line[64];
    int line_len;

    rc = fs_opendir(&dir, mp->mnt_point);
    141c:	4d2d      	ldr	r5, [pc, #180]	; (14d4 <ls+0xbc>)
        }
        if (ent.name[0] == 0) {
            printk("End of files\n");
            break;
        }
        line_len = sprintf(line, "  %c %u %s\n",
    141e:	4e2e      	ldr	r6, [pc, #184]	; (14d8 <ls+0xc0>)
                (ent.type == FS_DIR_ENTRY_FILE) ? 'F' : 'D',
                ent.size,
                ent.name);
        printk("%s", line);
    1420:	4f2e      	ldr	r7, [pc, #184]	; (14dc <ls+0xc4>)
        unsigned int key = irq_lock();
        int out_len = ring_buf_put(&outringbuf, line, line_len);
    1422:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 14ec <ls+0xd4>
void ls(void) {
    1426:	b0d7      	sub	sp, #348	; 0x15c
    struct fs_dir_t dir = { 0 };
    1428:	2300      	movs	r3, #0
    142a:	e9cd 3302 	strd	r3, r3, [sp, #8]
    rc = fs_opendir(&dir, mp->mnt_point);
    142e:	682b      	ldr	r3, [r5, #0]
    1430:	a802      	add	r0, sp, #8
    1432:	68d9      	ldr	r1, [r3, #12]
    1434:	f00b fc5a 	bl	ccec <fs_opendir>
    printk("%s opendir: %d\n", mp->mnt_point, rc);
    1438:	682b      	ldr	r3, [r5, #0]
    143a:	4602      	mov	r2, r0
    143c:	68d9      	ldr	r1, [r3, #12]
    rc = fs_opendir(&dir, mp->mnt_point);
    143e:	4604      	mov	r4, r0
    printk("%s opendir: %d\n", mp->mnt_point, rc);
    1440:	4827      	ldr	r0, [pc, #156]	; (14e0 <ls+0xc8>)
    1442:	f013 fb72 	bl	14b2a <printk>
    while (rc >= 0) {
    1446:	2c00      	cmp	r4, #0
    1448:	db11      	blt.n	146e <ls+0x56>
        struct fs_dirent ent = { 0 };
    144a:	f44f 7284 	mov.w	r2, #264	; 0x108
    144e:	2100      	movs	r1, #0
    1450:	a814      	add	r0, sp, #80	; 0x50
    1452:	f014 fe1d 	bl	16090 <memset>
        rc = fs_readdir(&dir, &ent);
    1456:	a914      	add	r1, sp, #80	; 0x50
    1458:	a802      	add	r0, sp, #8
    145a:	f00b fcad 	bl	cdb8 <fs_readdir>
        if (rc < 0) {
    145e:	1e04      	subs	r4, r0, #0
    1460:	db05      	blt.n	146e <ls+0x56>
        if (ent.name[0] == 0) {
    1462:	f89d 3051 	ldrb.w	r3, [sp, #81]	; 0x51
    1466:	b943      	cbnz	r3, 147a <ls+0x62>
            printk("End of files\n");
    1468:	481e      	ldr	r0, [pc, #120]	; (14e4 <ls+0xcc>)
    146a:	f013 fb5e 	bl	14b2a <printk>
        irq_unlock(key);
        uart_irq_tx_enable(cdc_dev);
    }

    (void)fs_closedir(&dir);
    146e:	a802      	add	r0, sp, #8
    1470:	f00b fd22 	bl	ceb8 <fs_closedir>
}
    1474:	b057      	add	sp, #348	; 0x15c
    1476:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        line_len = sprintf(line, "  %c %u %s\n",
    147a:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
    147e:	2b00      	cmp	r3, #0
    1480:	f10d 0351 	add.w	r3, sp, #81	; 0x51
    1484:	9300      	str	r3, [sp, #0]
    1486:	bf08      	it	eq
    1488:	2246      	moveq	r2, #70	; 0x46
    148a:	9b55      	ldr	r3, [sp, #340]	; 0x154
    148c:	bf18      	it	ne
    148e:	2244      	movne	r2, #68	; 0x44
    1490:	4631      	mov	r1, r6
    1492:	a804      	add	r0, sp, #16
    1494:	f005 fc7c 	bl	6d90 <sprintf>
        printk("%s", line);
    1498:	a904      	add	r1, sp, #16
        line_len = sprintf(line, "  %c %u %s\n",
    149a:	4605      	mov	r5, r0
        printk("%s", line);
    149c:	4638      	mov	r0, r7
    149e:	f013 fb44 	bl	14b2a <printk>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    14a2:	f04f 0320 	mov.w	r3, #32
    14a6:	f3ef 8911 	mrs	r9, BASEPRI
    14aa:	f383 8811 	msr	BASEPRI, r3
    14ae:	f3bf 8f6f 	isb	sy
        int out_len = ring_buf_put(&outringbuf, line, line_len);
    14b2:	462a      	mov	r2, r5
    14b4:	a904      	add	r1, sp, #16
    14b6:	4640      	mov	r0, r8
    14b8:	f013 fe0c 	bl	150d4 <ring_buf_put>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    14bc:	f389 8811 	msr	BASEPRI, r9
    14c0:	f3bf 8f6f 	isb	sy
        uart_irq_tx_enable(cdc_dev);
    14c4:	4b08      	ldr	r3, [pc, #32]	; (14e8 <ls+0xd0>)
    14c6:	6818      	ldr	r0, [r3, #0]
static inline void z_impl_uart_irq_tx_enable(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_tx_enable) {
    14c8:	6843      	ldr	r3, [r0, #4]
    14ca:	69db      	ldr	r3, [r3, #28]
    14cc:	2b00      	cmp	r3, #0
    14ce:	d0ba      	beq.n	1446 <ls+0x2e>
		api->irq_tx_enable(dev);
    14d0:	4798      	blx	r3
    14d2:	e7b8      	b.n	1446 <ls+0x2e>
    14d4:	2000bb98 	.word	0x2000bb98
    14d8:	00019c4c 	.word	0x00019c4c
    14dc:	0001bd9d 	.word	0x0001bd9d
    14e0:	00019c2e 	.word	0x00019c2e
    14e4:	00019c3e 	.word	0x00019c3e
    14e8:	20000090 	.word	0x20000090
    14ec:	200010e0 	.word	0x200010e0

000014f0 <flash_close>:
        printk("\tfn '%s' siz %u\n", dirent.name, dirent.size);
    }
}


void flash_close(void) {
    14f0:	b510      	push	{r4, lr}
    int rc;
    rc = fs_unmount(mp);
    14f2:	4c06      	ldr	r4, [pc, #24]	; (150c <flash_close+0x1c>)
    14f4:	6820      	ldr	r0, [r4, #0]
    14f6:	f00b fe89 	bl	d20c <fs_unmount>
    printk("%s unmount: %d\n", mp->mnt_point, rc);
    14fa:	6823      	ldr	r3, [r4, #0]
    rc = fs_unmount(mp);
    14fc:	4602      	mov	r2, r0
}
    14fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    printk("%s unmount: %d\n", mp->mnt_point, rc);
    1502:	68d9      	ldr	r1, [r3, #12]
    1504:	4802      	ldr	r0, [pc, #8]	; (1510 <flash_close+0x20>)
    1506:	f013 bb10 	b.w	14b2a <printk>
    150a:	bf00      	nop
    150c:	2000bb98 	.word	0x2000bb98
    1510:	00019c84 	.word	0x00019c84

00001514 <flash_init>:
int flash_init(void) {
    1514:	b570      	push	{r4, r5, r6, lr}
    unsigned int id = (uintptr_t)mp->storage_dev;
    1516:	4c69      	ldr	r4, [pc, #420]	; (16bc <flash_init+0x1a8>)
    1518:	6823      	ldr	r3, [r4, #0]
    151a:	695e      	ldr	r6, [r3, #20]
int flash_init(void) {
    151c:	f5ad 7d0c 	sub.w	sp, sp, #560	; 0x230
    rc = flash_area_open(id, &pfa);
    1520:	a902      	add	r1, sp, #8
    1522:	b2f0      	uxtb	r0, r6
    1524:	f003 f8da 	bl	46dc <flash_area_open>
    if (rc < 0) {
    1528:	1e02      	subs	r2, r0, #0
    152a:	4625      	mov	r5, r4
    152c:	da08      	bge.n	1540 <flash_init+0x2c>
        printk("FAIL: unable to find flash area %u: %d\n",
    152e:	4864      	ldr	r0, [pc, #400]	; (16c0 <flash_init+0x1ac>)
    1530:	4631      	mov	r1, r6
    1532:	f013 fafa 	bl	14b2a <printk>
        return -1;
    1536:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    153a:	f50d 7d0c 	add.w	sp, sp, #560	; 0x230
    153e:	bd70      	pop	{r4, r5, r6, pc}
           id, (unsigned int)pfa->fa_off, pfa->fa_dev_name,
    1540:	9a02      	ldr	r2, [sp, #8]
    printk("\nArea %u at 0x%x on %s for %u bytes\n\n",
    1542:	4860      	ldr	r0, [pc, #384]	; (16c4 <flash_init+0x1b0>)
    1544:	6893      	ldr	r3, [r2, #8]
    1546:	9300      	str	r3, [sp, #0]
    1548:	68d3      	ldr	r3, [r2, #12]
    154a:	6852      	ldr	r2, [r2, #4]
    154c:	4631      	mov	r1, r6
    154e:	f013 faec 	bl	14b2a <printk>
    rc = fs_mount(mp);
    1552:	6820      	ldr	r0, [r4, #0]
    1554:	f00b fdbc 	bl	d0d0 <fs_mount>
    if (rc < 0) {
    1558:	1e03      	subs	r3, r0, #0
               (unsigned int)mp->storage_dev, mp->mnt_point,
    155a:	6821      	ldr	r1, [r4, #0]
    if (rc < 0) {
    155c:	da07      	bge.n	156e <flash_init+0x5a>
        printk("FAIL: mount id %u at %s: %d\n",
    155e:	68ca      	ldr	r2, [r1, #12]
    1560:	4859      	ldr	r0, [pc, #356]	; (16c8 <flash_init+0x1b4>)
    1562:	6949      	ldr	r1, [r1, #20]
    1564:	f013 fae1 	bl	14b2a <printk>
        return -2;
    1568:	f06f 0001 	mvn.w	r0, #1
    156c:	e7e5      	b.n	153a <flash_init+0x26>
    printk("%s mount: %d\n", mp->mnt_point, rc);
    156e:	461a      	mov	r2, r3
    1570:	68c9      	ldr	r1, [r1, #12]
    1572:	4856      	ldr	r0, [pc, #344]	; (16cc <flash_init+0x1b8>)
    1574:	f013 fad9 	bl	14b2a <printk>
    rc = fs_statvfs(mp->mnt_point, &sbuf);
    1578:	6823      	ldr	r3, [r4, #0]
    157a:	a906      	add	r1, sp, #24
    157c:	68d8      	ldr	r0, [r3, #12]
    157e:	f00b fd59 	bl	d034 <fs_statvfs>
    if (rc < 0) {
    1582:	1e01      	subs	r1, r0, #0
    1584:	da07      	bge.n	1596 <flash_init+0x82>
        printk("FAIL: statvfs: %d\n", rc);
    1586:	4852      	ldr	r0, [pc, #328]	; (16d0 <flash_init+0x1bc>)
    1588:	f013 facf 	bl	14b2a <printk>
        flash_close();
    158c:	f7ff ffb0 	bl	14f0 <flash_close>
        return -4;
    1590:	f06f 0003 	mvn.w	r0, #3
    1594:	e7d1      	b.n	153a <flash_init+0x26>
    printk("%s: bsize = %lu ; frsize = %lu ;"
    1596:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1598:	6821      	ldr	r1, [r4, #0]
    159a:	9301      	str	r3, [sp, #4]
    159c:	9b08      	ldr	r3, [sp, #32]
    159e:	9300      	str	r3, [sp, #0]
    15a0:	68c9      	ldr	r1, [r1, #12]
    15a2:	484c      	ldr	r0, [pc, #304]	; (16d4 <flash_init+0x1c0>)
    15a4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    15a8:	f013 fabf 	bl	14b2a <printk>
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    15ac:	6823      	ldr	r3, [r4, #0]
    15ae:	4a4a      	ldr	r2, [pc, #296]	; (16d8 <flash_init+0x1c4>)
    15b0:	68db      	ldr	r3, [r3, #12]
    15b2:	21ff      	movs	r1, #255	; 0xff
    15b4:	a80a      	add	r0, sp, #40	; 0x28
    15b6:	f005 fbd3 	bl	6d60 <snprintf>
    rc = fs_stat(fname, &dirent);
    15ba:	a94a      	add	r1, sp, #296	; 0x128
    15bc:	a80a      	add	r0, sp, #40	; 0x28
    15be:	f00b fceb 	bl	cf98 <fs_stat>
    printk("%s stat: %d\n", fname, rc);
    15c2:	a90a      	add	r1, sp, #40	; 0x28
    rc = fs_stat(fname, &dirent);
    15c4:	4604      	mov	r4, r0
    printk("%s stat: %d\n", fname, rc);
    15c6:	4602      	mov	r2, r0
    15c8:	4844      	ldr	r0, [pc, #272]	; (16dc <flash_init+0x1c8>)
    15ca:	f013 faae 	bl	14b2a <printk>
    if (rc >= 0) {
    15ce:	2c00      	cmp	r4, #0
    15d0:	db05      	blt.n	15de <flash_init+0xca>
        printk("\tfn '%s' siz %u\n", dirent.name, dirent.size);
    15d2:	9a8b      	ldr	r2, [sp, #556]	; 0x22c
    15d4:	4842      	ldr	r0, [pc, #264]	; (16e0 <flash_init+0x1cc>)
    15d6:	f20d 1129 	addw	r1, sp, #297	; 0x129
    15da:	f013 faa6 	bl	14b2a <printk>
    rc = fs_open(&encounter_file, fname);
    15de:	4841      	ldr	r0, [pc, #260]	; (16e4 <flash_init+0x1d0>)
    15e0:	a90a      	add	r1, sp, #40	; 0x28
    15e2:	f00b fa7b 	bl	cadc <fs_open>
    if (rc < 0) {
    15e6:	1e02      	subs	r2, r0, #0
    15e8:	da08      	bge.n	15fc <flash_init+0xe8>
        printk("FAIL: open %s: %d\n", fname, rc);
    15ea:	483f      	ldr	r0, [pc, #252]	; (16e8 <flash_init+0x1d4>)
    15ec:	a90a      	add	r1, sp, #40	; 0x28
    15ee:	f013 fa9c 	bl	14b2a <printk>
        flash_close();
    15f2:	f7ff ff7d 	bl	14f0 <flash_close>
        return -3;
    15f6:	f06f 0002 	mvn.w	r0, #2
    15fa:	e79e      	b.n	153a <flash_init+0x26>
        rc = fs_seek(&encounter_file, 0, FS_SEEK_END);
    15fc:	2202      	movs	r2, #2
    15fe:	2100      	movs	r1, #0
    1600:	4838      	ldr	r0, [pc, #224]	; (16e4 <flash_init+0x1d0>)
    1602:	f00b fb19 	bl	cc38 <fs_seek>
    1606:	4601      	mov	r1, r0
        printk("Jump to end, rc: %d\n", rc);
    1608:	4838      	ldr	r0, [pc, #224]	; (16ec <flash_init+0x1d8>)
    160a:	f013 fa8e 	bl	14b2a <printk>
        printk("address: %x\n",(unsigned int) &encounter_file);
    160e:	4935      	ldr	r1, [pc, #212]	; (16e4 <flash_init+0x1d0>)
    1610:	4837      	ldr	r0, [pc, #220]	; (16f0 <flash_init+0x1dc>)
    1612:	f013 fa8a 	bl	14b2a <printk>
    snprintf(fname, sizeof(fname), "%s/boot_count", mp->mnt_point);
    1616:	682b      	ldr	r3, [r5, #0]
    1618:	4a36      	ldr	r2, [pc, #216]	; (16f4 <flash_init+0x1e0>)
    161a:	68db      	ldr	r3, [r3, #12]
    161c:	21ff      	movs	r1, #255	; 0xff
    161e:	a80a      	add	r0, sp, #40	; 0x28
    1620:	f005 fb9e 	bl	6d60 <snprintf>
    rc = fs_stat(fname, &dirent);
    1624:	a94a      	add	r1, sp, #296	; 0x128
    1626:	a80a      	add	r0, sp, #40	; 0x28
    1628:	f00b fcb6 	bl	cf98 <fs_stat>
    printk("%s stat: %d\n", fname, rc);
    162c:	a90a      	add	r1, sp, #40	; 0x28
    rc = fs_stat(fname, &dirent);
    162e:	4604      	mov	r4, r0
    printk("%s stat: %d\n", fname, rc);
    1630:	4602      	mov	r2, r0
    1632:	482a      	ldr	r0, [pc, #168]	; (16dc <flash_init+0x1c8>)
    1634:	f013 fa79 	bl	14b2a <printk>
    if (rc >= 0) {
    1638:	2c00      	cmp	r4, #0
    163a:	db05      	blt.n	1648 <flash_init+0x134>
        printk("\tfn '%s' siz %u\n", dirent.name, dirent.size);
    163c:	9a8b      	ldr	r2, [sp, #556]	; 0x22c
    163e:	4828      	ldr	r0, [pc, #160]	; (16e0 <flash_init+0x1cc>)
    1640:	f20d 1129 	addw	r1, sp, #297	; 0x129
    1644:	f013 fa71 	bl	14b2a <printk>
    rc = fs_open(&file, fname);
    1648:	a90a      	add	r1, sp, #40	; 0x28
    164a:	a804      	add	r0, sp, #16
    164c:	f00b fa46 	bl	cadc <fs_open>
    if (rc < 0) {
    1650:	1e02      	subs	r2, r0, #0
    1652:	da04      	bge.n	165e <flash_init+0x14a>
        printk("FAIL: open %s: %d\n", fname, rc);
    1654:	4824      	ldr	r0, [pc, #144]	; (16e8 <flash_init+0x1d4>)
    1656:	a90a      	add	r1, sp, #40	; 0x28
    1658:	f013 fa67 	bl	14b2a <printk>
    165c:	e7cb      	b.n	15f6 <flash_init+0xe2>
    u32_t boot_count = 0;
    165e:	2400      	movs	r4, #0
        rc = fs_read(&file, &boot_count, sizeof(boot_count));
    1660:	2204      	movs	r2, #4
    1662:	a903      	add	r1, sp, #12
    1664:	a804      	add	r0, sp, #16
    u32_t boot_count = 0;
    1666:	9403      	str	r4, [sp, #12]
        rc = fs_read(&file, &boot_count, sizeof(boot_count));
    1668:	f00b faaa 	bl	cbc0 <fs_read>
        printk("%s read count %u: %d\n", fname, boot_count, rc);
    166c:	9a03      	ldr	r2, [sp, #12]
        rc = fs_read(&file, &boot_count, sizeof(boot_count));
    166e:	4603      	mov	r3, r0
        printk("%s read count %u: %d\n", fname, boot_count, rc);
    1670:	a90a      	add	r1, sp, #40	; 0x28
    1672:	4821      	ldr	r0, [pc, #132]	; (16f8 <flash_init+0x1e4>)
    1674:	f013 fa59 	bl	14b2a <printk>
        rc = fs_seek(&file, 0, FS_SEEK_SET);
    1678:	4622      	mov	r2, r4
    167a:	4621      	mov	r1, r4
    167c:	a804      	add	r0, sp, #16
    167e:	f00b fadb 	bl	cc38 <fs_seek>
        printk("%s seek start: %d\n", fname, rc);
    1682:	a90a      	add	r1, sp, #40	; 0x28
        rc = fs_seek(&file, 0, FS_SEEK_SET);
    1684:	4602      	mov	r2, r0
        printk("%s seek start: %d\n", fname, rc);
    1686:	481d      	ldr	r0, [pc, #116]	; (16fc <flash_init+0x1e8>)
    1688:	f013 fa4f 	bl	14b2a <printk>
    boot_count += 1;
    168c:	9b03      	ldr	r3, [sp, #12]
    rc = fs_write(&file, &boot_count, sizeof(boot_count));
    168e:	2204      	movs	r2, #4
    boot_count += 1;
    1690:	3301      	adds	r3, #1
    rc = fs_write(&file, &boot_count, sizeof(boot_count));
    1692:	a903      	add	r1, sp, #12
    1694:	a804      	add	r0, sp, #16
    boot_count += 1;
    1696:	9303      	str	r3, [sp, #12]
    rc = fs_write(&file, &boot_count, sizeof(boot_count));
    1698:	f00b fab0 	bl	cbfc <fs_write>
    printk("%s write new boot count %u: %d\n", fname,
    169c:	9a03      	ldr	r2, [sp, #12]
    rc = fs_write(&file, &boot_count, sizeof(boot_count));
    169e:	4603      	mov	r3, r0
    printk("%s write new boot count %u: %d\n", fname,
    16a0:	a90a      	add	r1, sp, #40	; 0x28
    16a2:	4817      	ldr	r0, [pc, #92]	; (1700 <flash_init+0x1ec>)
    16a4:	f013 fa41 	bl	14b2a <printk>
    rc = fs_close(&file);
    16a8:	a804      	add	r0, sp, #16
    16aa:	f00b fa67 	bl	cb7c <fs_close>
    printk("%s close: %d\n", fname, rc);
    16ae:	a90a      	add	r1, sp, #40	; 0x28
    rc = fs_close(&file);
    16b0:	4602      	mov	r2, r0
    printk("%s close: %d\n", fname, rc);
    16b2:	4814      	ldr	r0, [pc, #80]	; (1704 <flash_init+0x1f0>)
    16b4:	f013 fa39 	bl	14b2a <printk>
    return 0;
    16b8:	4620      	mov	r0, r4
    16ba:	e73e      	b.n	153a <flash_init+0x26>
    16bc:	2000bb98 	.word	0x2000bb98
    16c0:	00019c94 	.word	0x00019c94
    16c4:	00019cbc 	.word	0x00019cbc
    16c8:	00019ce2 	.word	0x00019ce2
    16cc:	00019cff 	.word	0x00019cff
    16d0:	00019d0d 	.word	0x00019d0d
    16d4:	00019d20 	.word	0x00019d20
    16d8:	00019c58 	.word	0x00019c58
    16dc:	00019c66 	.word	0x00019c66
    16e0:	00019c73 	.word	0x00019c73
    16e4:	20000094 	.word	0x20000094
    16e8:	00019d5d 	.word	0x00019d5d
    16ec:	00019d70 	.word	0x00019d70
    16f0:	00019d85 	.word	0x00019d85
    16f4:	00019d92 	.word	0x00019d92
    16f8:	00019da0 	.word	0x00019da0
    16fc:	00019db6 	.word	0x00019db6
    1700:	00019dc9 	.word	0x00019dc9
    1704:	00019de9 	.word	0x00019de9

00001708 <led_init>:
#include "led.h"

void led_init(struct led *led) {
    1708:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    170c:	4604      	mov	r4, r0
    int ret;
    led->dev = device_get_binding(led->gpio_dev_name);
    170e:	6800      	ldr	r0, [r0, #0]
    1710:	f011 ffac 	bl	1366c <z_impl_device_get_binding>
    __ASSERT(led->dev != NULL, "Error: didn't find %s device\n",
            led->gpio_dev_name);

    ret = gpio_pin_configure(led->dev, led->gpio_pin, led->gpio_flags);
    1714:	68e6      	ldr	r6, [r4, #12]
    1716:	7a27      	ldrb	r7, [r4, #8]
    led->dev = device_get_binding(led->gpio_dev_name);
    1718:	6120      	str	r0, [r4, #16]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
    171a:	04f3      	lsls	r3, r6, #19
	struct gpio_driver_data *data =
    171c:	e9d0 9801 	ldrd	r9, r8, [r0, #4]
    1720:	4605      	mov	r5, r0
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
    1722:	d506      	bpl.n	1732 <led_init+0x2a>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
    1724:	f416 6f40 	tst.w	r6, #3072	; 0xc00
    1728:	d003      	beq.n	1732 <led_init+0x2a>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    172a:	07f0      	lsls	r0, r6, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH
    172c:	bf48      	it	mi
    172e:	f486 56e0 	eormi.w	r6, r6, #7168	; 0x1c00
	return api->pin_configure(port, pin, flags);
    1732:	686b      	ldr	r3, [r5, #4]
    1734:	4632      	mov	r2, r6
    1736:	681b      	ldr	r3, [r3, #0]
    1738:	4639      	mov	r1, r7
    173a:	4628      	mov	r0, r5
    173c:	4798      	blx	r3
	if (ret != 0) {
    173e:	bb20      	cbnz	r0, 178a <led_init+0x82>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    1740:	f8d8 2000 	ldr.w	r2, [r8]
    1744:	2301      	movs	r3, #1
    1746:	07f1      	lsls	r1, r6, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
    1748:	fa03 f307 	lsl.w	r3, r3, r7
    174c:	bf4c      	ite	mi
    174e:	431a      	orrmi	r2, r3
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    1750:	439a      	bicpl	r2, r3
	if (((flags & (GPIO_INT_DISABLE | GPIO_INT_ENABLE)) != 0U)
    1752:	f416 4fc0 	tst.w	r6, #24576	; 0x6000
    1756:	f8c8 2000 	str.w	r2, [r8]
    175a:	d01c      	beq.n	1796 <led_init+0x8e>
	    && (api->pin_interrupt_configure != NULL)) {
    175c:	f8d9 2018 	ldr.w	r2, [r9, #24]
    1760:	b1ca      	cbz	r2, 1796 <led_init+0x8e>
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
    1762:	0430      	lsls	r0, r6, #16
	const struct gpio_driver_api *api =
    1764:	6869      	ldr	r1, [r5, #4]
		flags &= ~GPIO_INT_DEBOUNCE;
    1766:	f426 2200 	bic.w	r2, r6, #524288	; 0x80000
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
    176a:	d505      	bpl.n	1778 <led_init+0x70>
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
    176c:	68a8      	ldr	r0, [r5, #8]
    176e:	6800      	ldr	r0, [r0, #0]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
    1770:	4203      	tst	r3, r0
		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
    1772:	bf18      	it	ne
    1774:	f482 22c0 	eorne.w	r2, r2, #393216	; 0x60000
	return api->pin_interrupt_configure(port, pin, mode, trig);
    1778:	698e      	ldr	r6, [r1, #24]
    177a:	f402 23c0 	and.w	r3, r2, #393216	; 0x60000
    177e:	4639      	mov	r1, r7
    1780:	f402 32b0 	and.w	r2, r2, #90112	; 0x16000
    1784:	4628      	mov	r0, r5
    1786:	47b0      	blx	r6
    if (ret != 0) {
    1788:	b128      	cbz	r0, 1796 <led_init+0x8e>
        printk("Error %d: failed to configure pin %d '%s'\n",
    178a:	4601      	mov	r1, r0
    178c:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
    1790:	4804      	ldr	r0, [pc, #16]	; (17a4 <led_init+0x9c>)
    1792:	f013 f9ca 	bl	14b2a <printk>
            ret, led->gpio_pin, led->gpio_pin_name);
    }
    gpio_pin_set(led->dev, led->gpio_pin, 0);
    1796:	7a21      	ldrb	r1, [r4, #8]
    1798:	6920      	ldr	r0, [r4, #16]
    179a:	2200      	movs	r2, #0
}
    179c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    gpio_pin_set(led->dev, led->gpio_pin, 0);
    17a0:	f013 b87b 	b.w	1489a <gpio_pin_set>
    17a4:	00019df7 	.word	0x00019df7

000017a8 <cdc_interrupt_handler>:

K_THREAD_DEFINE(bt_adv_id, STACKSIZE, bt_adv, NULL, NULL, NULL,
            3, 0, 0);

static void cdc_interrupt_handler(struct device *dev)
{
    17a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    while (uart_irq_update(dev) && uart_irq_is_pending(dev)&&(usb_error==0)) {
    17ac:	4f36      	ldr	r7, [pc, #216]	; (1888 <cdc_interrupt_handler+0xe0>)
 *
 * @return Ring buffer free space (in 32-bit words or bytes).
 */
static inline u32_t ring_buf_space_get(struct ring_buf *buf)
{
	return z_ring_buf_custom_space_get(buf->size, buf->head, buf->tail);
    17ae:	4e37      	ldr	r6, [pc, #220]	; (188c <cdc_interrupt_handler+0xe4>)
{
    17b0:	b090      	sub	sp, #64	; 0x40
    17b2:	4604      	mov	r4, r0

            recv_len = uart_fifo_read(dev, buffer, len);

            rb_len = ring_buf_put(&inringbuf, buffer, recv_len);
            if (rb_len < recv_len) {
                printk("Drop %u bytes\n", recv_len - rb_len);
    17b4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 1898 <cdc_interrupt_handler+0xf0>
static inline int z_impl_uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_update) {
    17b8:	6863      	ldr	r3, [r4, #4]
    17ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    17bc:	b153      	cbz	r3, 17d4 <cdc_interrupt_handler+0x2c>
		return api->irq_update(dev);
    17be:	4620      	mov	r0, r4
    17c0:	4798      	blx	r3
    while (uart_irq_update(dev) && uart_irq_is_pending(dev)&&(usb_error==0)) {
    17c2:	b138      	cbz	r0, 17d4 <cdc_interrupt_handler+0x2c>
	if (api->irq_is_pending)	{
    17c4:	6863      	ldr	r3, [r4, #4]
    17c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    17c8:	b123      	cbz	r3, 17d4 <cdc_interrupt_handler+0x2c>
		return api->irq_is_pending(dev);
    17ca:	4620      	mov	r0, r4
    17cc:	4798      	blx	r3
    17ce:	b108      	cbz	r0, 17d4 <cdc_interrupt_handler+0x2c>
    17d0:	783b      	ldrb	r3, [r7, #0]
    17d2:	b113      	cbz	r3, 17da <cdc_interrupt_handler+0x32>
            }

            // LOG_DBG("outringbuf -> tty fifo %d bytes", send_len);
        }
    }
}
    17d4:	b010      	add	sp, #64	; 0x40
    17d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (api->irq_rx_ready) {
    17da:	6863      	ldr	r3, [r4, #4]
    17dc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    17de:	b313      	cbz	r3, 1826 <cdc_interrupt_handler+0x7e>
		return api->irq_rx_ready(dev);
    17e0:	4620      	mov	r0, r4
    17e2:	4798      	blx	r3
        if (uart_irq_rx_ready(dev)) {
    17e4:	b1f8      	cbz	r0, 1826 <cdc_interrupt_handler+0x7e>
    17e6:	e9d6 1200 	ldrd	r1, r2, [r6]
    17ea:	6933      	ldr	r3, [r6, #16]
	if (tail < head) {
    17ec:	4291      	cmp	r1, r2
	return (size - tail) + head - 1;
    17ee:	bf96      	itet	ls
    17f0:	185b      	addls	r3, r3, r1
		return head - tail - 1;
    17f2:	f101 33ff 	addhi.w	r3, r1, #4294967295	; 0xffffffff
	return (size - tail) + head - 1;
    17f6:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
    17fa:	1a9a      	subs	r2, r3, r2
	if (api->fifo_read) {
    17fc:	6863      	ldr	r3, [r4, #4]
    17fe:	699d      	ldr	r5, [r3, #24]
            size_t len = MIN(ring_buf_space_get(&inringbuf),
    1800:	2a40      	cmp	r2, #64	; 0x40
    1802:	bf28      	it	cs
    1804:	2240      	movcs	r2, #64	; 0x40
    1806:	b11d      	cbz	r5, 1810 <cdc_interrupt_handler+0x68>
		return api->fifo_read(dev, rx_data, size);
    1808:	4669      	mov	r1, sp
    180a:	4620      	mov	r0, r4
    180c:	47a8      	blx	r5
    180e:	4605      	mov	r5, r0
            rb_len = ring_buf_put(&inringbuf, buffer, recv_len);
    1810:	462a      	mov	r2, r5
    1812:	4669      	mov	r1, sp
    1814:	4630      	mov	r0, r6
    1816:	f013 fc5d 	bl	150d4 <ring_buf_put>
            if (rb_len < recv_len) {
    181a:	42a8      	cmp	r0, r5
    181c:	da03      	bge.n	1826 <cdc_interrupt_handler+0x7e>
                printk("Drop %u bytes\n", recv_len - rb_len);
    181e:	1a29      	subs	r1, r5, r0
    1820:	4640      	mov	r0, r8
    1822:	f013 f982 	bl	14b2a <printk>
	if (api->irq_tx_ready) {
    1826:	6863      	ldr	r3, [r4, #4]
    1828:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    182a:	2b00      	cmp	r3, #0
    182c:	d0c4      	beq.n	17b8 <cdc_interrupt_handler+0x10>
		return api->irq_tx_ready(dev);
    182e:	4620      	mov	r0, r4
    1830:	4798      	blx	r3
        if (uart_irq_tx_ready(dev)) {
    1832:	2800      	cmp	r0, #0
    1834:	d0be      	beq.n	17b4 <cdc_interrupt_handler+0xc>
	__asm__ volatile(
    1836:	f04f 0320 	mov.w	r3, #32
    183a:	f3ef 8811 	mrs	r8, BASEPRI
    183e:	f383 8811 	msr	BASEPRI, r3
    1842:	f3bf 8f6f 	isb	sy
            rb_len = ring_buf_get(&outringbuf, buffer, sizeof(buffer));
    1846:	2240      	movs	r2, #64	; 0x40
    1848:	4669      	mov	r1, sp
    184a:	4811      	ldr	r0, [pc, #68]	; (1890 <cdc_interrupt_handler+0xe8>)
    184c:	f013 fc9a 	bl	15184 <ring_buf_get>
    1850:	4605      	mov	r5, r0
	__asm__ volatile(
    1852:	f388 8811 	msr	BASEPRI, r8
    1856:	f3bf 8f6f 	isb	sy
            if (!rb_len) {
    185a:	b930      	cbnz	r0, 186a <cdc_interrupt_handler+0xc2>
	if (api->irq_tx_disable) {
    185c:	6863      	ldr	r3, [r4, #4]
    185e:	6a1b      	ldr	r3, [r3, #32]
    1860:	2b00      	cmp	r3, #0
    1862:	d0a7      	beq.n	17b4 <cdc_interrupt_handler+0xc>
		api->irq_tx_disable(dev);
    1864:	4620      	mov	r0, r4
    1866:	4798      	blx	r3
    1868:	e7a4      	b.n	17b4 <cdc_interrupt_handler+0xc>
	if (api->fifo_fill) {
    186a:	6863      	ldr	r3, [r4, #4]
    186c:	695b      	ldr	r3, [r3, #20]
    186e:	b123      	cbz	r3, 187a <cdc_interrupt_handler+0xd2>
		return api->fifo_fill(dev, tx_data, size);
    1870:	4602      	mov	r2, r0
    1872:	4669      	mov	r1, sp
    1874:	4620      	mov	r0, r4
    1876:	4798      	blx	r3
    1878:	4603      	mov	r3, r0
            if (send_len < rb_len) {
    187a:	429d      	cmp	r5, r3
    187c:	dd9a      	ble.n	17b4 <cdc_interrupt_handler+0xc>
                printk("Drop %d bytes\n", rb_len - send_len);
    187e:	4805      	ldr	r0, [pc, #20]	; (1894 <cdc_interrupt_handler+0xec>)
    1880:	1ae9      	subs	r1, r5, r3
    1882:	f013 f952 	bl	14b2a <printk>
                continue;
    1886:	e795      	b.n	17b4 <cdc_interrupt_handler+0xc>
    1888:	20007a36 	.word	0x20007a36
    188c:	200010bc 	.word	0x200010bc
    1890:	200010e0 	.word	0x200010e0
    1894:	00019e31 	.word	0x00019e31
    1898:	00019e22 	.word	0x00019e22

0000189c <cdc_init>:
{
    189c:	b508      	push	{r3, lr}
    printk("cdc_init\n");
    189e:	4807      	ldr	r0, [pc, #28]	; (18bc <cdc_init+0x20>)
    18a0:	f013 f943 	bl	14b2a <printk>
    18a4:	4806      	ldr	r0, [pc, #24]	; (18c0 <cdc_init+0x24>)
    18a6:	f011 fee1 	bl	1366c <z_impl_device_get_binding>
    cdc_dev = device_get_binding("CDC_ACM_0");
    18aa:	4b06      	ldr	r3, [pc, #24]	; (18c4 <cdc_init+0x28>)
    18ac:	6018      	str	r0, [r3, #0]
    if (!cdc_dev) {
    18ae:	b920      	cbnz	r0, 18ba <cdc_init+0x1e>
}
    18b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        printk("CDC ACM device not found\n");
    18b4:	4804      	ldr	r0, [pc, #16]	; (18c8 <cdc_init+0x2c>)
    18b6:	f013 b938 	b.w	14b2a <printk>
}
    18ba:	bd08      	pop	{r3, pc}
    18bc:	00019e40 	.word	0x00019e40
    18c0:	00019e4a 	.word	0x00019e4a
    18c4:	20000090 	.word	0x20000090
    18c8:	00019e54 	.word	0x00019e54

000018cc <usb_init>:
void usb_init(void) {
    18cc:	b510      	push	{r4, lr}
    int ret = usb_enable(NULL);
    18ce:	2000      	movs	r0, #0
    18d0:	f002 f8dc 	bl	3a8c <usb_enable>
    18d4:	4604      	mov	r4, r0
    printk("usb_init\n");
    18d6:	4805      	ldr	r0, [pc, #20]	; (18ec <usb_init+0x20>)
    18d8:	f013 f927 	bl	14b2a <printk>
    if (ret != 0) {
    18dc:	b124      	cbz	r4, 18e8 <usb_init+0x1c>
}
    18de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        printk("Failed to enable USB\n");
    18e2:	4803      	ldr	r0, [pc, #12]	; (18f0 <usb_init+0x24>)
    18e4:	f013 b921 	b.w	14b2a <printk>
}
    18e8:	bd10      	pop	{r4, pc}
    18ea:	bf00      	nop
    18ec:	00019e6e 	.word	0x00019e6e
    18f0:	00019e78 	.word	0x00019e78

000018f4 <dtr_init>:
void dtr_init(void) {
    18f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    u32_t baudrate, dtr = 0U;
    18f6:	2300      	movs	r3, #0
    int ret;

    printk("Wait for DTR");
    18f8:	482d      	ldr	r0, [pc, #180]	; (19b0 <dtr_init+0xbc>)
    while (true) {
        uart_line_ctrl_get(cdc_dev, UART_LINE_CTRL_DTR, &dtr);
    18fa:	4d2e      	ldr	r5, [pc, #184]	; (19b4 <dtr_init+0xc0>)
    u32_t baudrate, dtr = 0U;
    18fc:	9301      	str	r3, [sp, #4]
    printk("Wait for DTR");
    18fe:	f013 f914 	bl	14b2a <printk>
    1902:	462c      	mov	r4, r5
        uart_line_ctrl_get(cdc_dev, UART_LINE_CTRL_DTR, &dtr);
    1904:	6828      	ldr	r0, [r5, #0]
__syscall int uart_line_ctrl_get(struct device *dev, u32_t ctrl, u32_t *val);

static inline int z_impl_uart_line_ctrl_get(struct device *dev,
					   u32_t ctrl, u32_t *val)
{
	const struct uart_driver_api *api =
    1906:	6843      	ldr	r3, [r0, #4]
		(const struct uart_driver_api *)dev->driver_api;

	if (api && api->line_ctrl_get) {
    1908:	b123      	cbz	r3, 1914 <dtr_init+0x20>
    190a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    190c:	b113      	cbz	r3, 1914 <dtr_init+0x20>
		return api->line_ctrl_get(dev, ctrl, val);
    190e:	aa01      	add	r2, sp, #4
    1910:	2104      	movs	r1, #4
    1912:	4798      	blx	r3
        if (dtr) {
    1914:	9b01      	ldr	r3, [sp, #4]
    1916:	b91b      	cbnz	r3, 1920 <dtr_init+0x2c>
    1918:	2064      	movs	r0, #100	; 0x64
    191a:	f012 fcb9 	bl	14290 <z_impl_k_sleep>
    191e:	e7f1      	b.n	1904 <dtr_init+0x10>
        } else {
            /* Give CPU resources to low priority threads. */
            k_sleep(K_MSEC(100));
        }
    }
    printk("DTR set");
    1920:	4825      	ldr	r0, [pc, #148]	; (19b8 <dtr_init+0xc4>)
    1922:	f013 f902 	bl	14b2a <printk>

    /* They are optional, we use them to test the interrupt endpoint */
    ret = uart_line_ctrl_set(cdc_dev, UART_LINE_CTRL_DCD, 1);
    1926:	6820      	ldr	r0, [r4, #0]
	if (api->line_ctrl_set) {
    1928:	6843      	ldr	r3, [r0, #4]
    192a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    192c:	2b00      	cmp	r3, #0
    192e:	d032      	beq.n	1996 <dtr_init+0xa2>
		return api->line_ctrl_set(dev, ctrl, val);
    1930:	2108      	movs	r1, #8
    1932:	2201      	movs	r2, #1
    1934:	4798      	blx	r3
    if (ret) {
    1936:	4601      	mov	r1, r0
    1938:	b110      	cbz	r0, 1940 <dtr_init+0x4c>
        printk("Failed to set DCD, ret code %d", ret);
    193a:	4820      	ldr	r0, [pc, #128]	; (19bc <dtr_init+0xc8>)
    193c:	f013 f8f5 	bl	14b2a <printk>
    }

    ret = uart_line_ctrl_set(cdc_dev, UART_LINE_CTRL_DSR, 1);
    1940:	6820      	ldr	r0, [r4, #0]
	if (api->line_ctrl_set) {
    1942:	6843      	ldr	r3, [r0, #4]
    1944:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1946:	b34b      	cbz	r3, 199c <dtr_init+0xa8>
		return api->line_ctrl_set(dev, ctrl, val);
    1948:	2110      	movs	r1, #16
    194a:	2201      	movs	r2, #1
    194c:	4798      	blx	r3
    if (ret) {
    194e:	4601      	mov	r1, r0
    1950:	b110      	cbz	r0, 1958 <dtr_init+0x64>
        printk("Failed to set DSR, ret code %d", ret);
    1952:	481b      	ldr	r0, [pc, #108]	; (19c0 <dtr_init+0xcc>)
    1954:	f013 f8e9 	bl	14b2a <printk>
	z_impl_k_busy_wait(usec_to_wait);
    1958:	481a      	ldr	r0, [pc, #104]	; (19c4 <dtr_init+0xd0>)
    195a:	f017 faec 	bl	18f36 <z_impl_k_busy_wait>
    }

    /* Wait 1 sec for the host to do all settings */
    k_busy_wait(1000000);

    ret = uart_line_ctrl_get(cdc_dev, UART_LINE_CTRL_BAUD_RATE, &baudrate);
    195e:	6820      	ldr	r0, [r4, #0]
	const struct uart_driver_api *api =
    1960:	6843      	ldr	r3, [r0, #4]
	if (api && api->line_ctrl_get) {
    1962:	b1f3      	cbz	r3, 19a2 <dtr_init+0xae>
    1964:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1966:	b1e3      	cbz	r3, 19a2 <dtr_init+0xae>
		return api->line_ctrl_get(dev, ctrl, val);
    1968:	2101      	movs	r1, #1
    196a:	466a      	mov	r2, sp
    196c:	4798      	blx	r3
    if (ret) {
    196e:	4601      	mov	r1, r0
    1970:	b1d0      	cbz	r0, 19a8 <dtr_init+0xb4>
        printk("Failed to get baudrate, ret code %d", ret);
    1972:	4815      	ldr	r0, [pc, #84]	; (19c8 <dtr_init+0xd4>)
    } else {
        printk("Baudrate detected: %d\n", baudrate);
    1974:	f013 f8d9 	bl	14b2a <printk>
    }

    uart_irq_callback_set(cdc_dev, cdc_interrupt_handler);
    1978:	6822      	ldr	r2, [r4, #0]
	const struct uart_driver_api *api =
    197a:	6853      	ldr	r3, [r2, #4]
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    197c:	b123      	cbz	r3, 1988 <dtr_init+0x94>
    197e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1980:	b113      	cbz	r3, 1988 <dtr_init+0x94>
		api->irq_callback_set(dev, cb, user_data);
    1982:	4912      	ldr	r1, [pc, #72]	; (19cc <dtr_init+0xd8>)
    1984:	4610      	mov	r0, r2
    1986:	4798      	blx	r3

    /* Enable rx interrupts */
    uart_irq_rx_enable(cdc_dev);
    1988:	6820      	ldr	r0, [r4, #0]
	if (api->irq_rx_enable) {
    198a:	6843      	ldr	r3, [r0, #4]
    198c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    198e:	b103      	cbz	r3, 1992 <dtr_init+0x9e>
		api->irq_rx_enable(dev);
    1990:	4798      	blx	r3
}
    1992:	b003      	add	sp, #12
    1994:	bd30      	pop	{r4, r5, pc}
	return -ENOTSUP;
    1996:	f06f 0122 	mvn.w	r1, #34	; 0x22
    199a:	e7ce      	b.n	193a <dtr_init+0x46>
    199c:	f06f 0122 	mvn.w	r1, #34	; 0x22
    19a0:	e7d7      	b.n	1952 <dtr_init+0x5e>
	}

	return -ENOTSUP;
    19a2:	f06f 0122 	mvn.w	r1, #34	; 0x22
    19a6:	e7e4      	b.n	1972 <dtr_init+0x7e>
        printk("Baudrate detected: %d\n", baudrate);
    19a8:	9900      	ldr	r1, [sp, #0]
    19aa:	4809      	ldr	r0, [pc, #36]	; (19d0 <dtr_init+0xdc>)
    19ac:	e7e2      	b.n	1974 <dtr_init+0x80>
    19ae:	bf00      	nop
    19b0:	00019e8e 	.word	0x00019e8e
    19b4:	20000090 	.word	0x20000090
    19b8:	00019e9b 	.word	0x00019e9b
    19bc:	00019ea3 	.word	0x00019ea3
    19c0:	00019ec2 	.word	0x00019ec2
    19c4:	000f4240 	.word	0x000f4240
    19c8:	00019ee1 	.word	0x00019ee1
    19cc:	000017a9 	.word	0x000017a9
    19d0:	00019f05 	.word	0x00019f05

000019d4 <clear_encounter>:

void clear_encounter(void) {
    19d4:	b570      	push	{r4, r5, r6, lr}

    write_flash = false;
    //  Wait to finish any writes...

    //
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    19d6:	4b15      	ldr	r3, [pc, #84]	; (1a2c <clear_encounter+0x58>)
    bool pause = write_flash;
    19d8:	4c15      	ldr	r4, [pc, #84]	; (1a30 <clear_encounter+0x5c>)
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    19da:	681b      	ldr	r3, [r3, #0]
    19dc:	4a15      	ldr	r2, [pc, #84]	; (1a34 <clear_encounter+0x60>)
    19de:	68db      	ldr	r3, [r3, #12]
    bool pause = write_flash;
    19e0:	7826      	ldrb	r6, [r4, #0]
void clear_encounter(void) {
    19e2:	b0c0      	sub	sp, #256	; 0x100
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    19e4:	21ff      	movs	r1, #255	; 0xff
    write_flash = false;
    19e6:	2500      	movs	r5, #0
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    19e8:	4668      	mov	r0, sp
    write_flash = false;
    19ea:	7025      	strb	r5, [r4, #0]
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    19ec:	f005 f9b8 	bl	6d60 <snprintf>
    rc = fs_close(&encounter_file);
    19f0:	4811      	ldr	r0, [pc, #68]	; (1a38 <clear_encounter+0x64>)
    19f2:	f00b f8c3 	bl	cb7c <fs_close>
    19f6:	4601      	mov	r1, r0
    printk("close rc: %d\n", rc);
    19f8:	4810      	ldr	r0, [pc, #64]	; (1a3c <clear_encounter+0x68>)
    19fa:	f013 f896 	bl	14b2a <printk>
    // delete file with "unlink"
    rc = fs_unlink(fname);
    19fe:	4668      	mov	r0, sp
    1a00:	f00b fa7e 	bl	cf00 <fs_unlink>
    1a04:	4601      	mov	r1, r0
    printk("unlink rc: %d\n", rc);
    1a06:	480e      	ldr	r0, [pc, #56]	; (1a40 <clear_encounter+0x6c>)
    1a08:	f013 f88f 	bl	14b2a <printk>

    rc = fs_open(&encounter_file, fname);
    1a0c:	480a      	ldr	r0, [pc, #40]	; (1a38 <clear_encounter+0x64>)
    1a0e:	4669      	mov	r1, sp
    1a10:	f00b f864 	bl	cadc <fs_open>
    if (rc < 0) {
    1a14:	1e02      	subs	r2, r0, #0
    1a16:	da05      	bge.n	1a24 <clear_encounter+0x50>
        printk("FAIL: open %s: %d\n", fname, rc);
    1a18:	480a      	ldr	r0, [pc, #40]	; (1a44 <clear_encounter+0x70>)
    1a1a:	4669      	mov	r1, sp
    1a1c:	f013 f885 	bl	14b2a <printk>
        return;
    }
    write_flash = pause;
    flash_full = false;
}
    1a20:	b040      	add	sp, #256	; 0x100
    1a22:	bd70      	pop	{r4, r5, r6, pc}
    flash_full = false;
    1a24:	4b08      	ldr	r3, [pc, #32]	; (1a48 <clear_encounter+0x74>)
    write_flash = pause;
    1a26:	7026      	strb	r6, [r4, #0]
    flash_full = false;
    1a28:	701d      	strb	r5, [r3, #0]
    1a2a:	e7f9      	b.n	1a20 <clear_encounter+0x4c>
    1a2c:	2000bb98 	.word	0x2000bb98
    1a30:	20007a37 	.word	0x20007a37
    1a34:	00019c58 	.word	0x00019c58
    1a38:	20000094 	.word	0x20000094
    1a3c:	00019f1c 	.word	0x00019f1c
    1a40:	00019f2a 	.word	0x00019f2a
    1a44:	00019d5d 	.word	0x00019d5d
    1a48:	200051f0 	.word	0x200051f0

00001a4c <uart_print>:

void uart_print(char *buffer, int len){
    1a4c:	b510      	push	{r4, lr}
    1a4e:	460a      	mov	r2, r1
	__asm__ volatile(
    1a50:	f04f 0320 	mov.w	r3, #32
    1a54:	f3ef 8411 	mrs	r4, BASEPRI
    1a58:	f383 8811 	msr	BASEPRI, r3
    1a5c:	f3bf 8f6f 	isb	sy
    unsigned int key = irq_lock();
    ring_buf_put(&outringbuf, buffer, len);
    1a60:	4601      	mov	r1, r0
    1a62:	4806      	ldr	r0, [pc, #24]	; (1a7c <uart_print+0x30>)
    1a64:	f013 fb36 	bl	150d4 <ring_buf_put>
	__asm__ volatile(
    1a68:	f384 8811 	msr	BASEPRI, r4
    1a6c:	f3bf 8f6f 	isb	sy
    irq_unlock(key);
    uart_irq_tx_enable(cdc_dev);
    1a70:	4b03      	ldr	r3, [pc, #12]	; (1a80 <uart_print+0x34>)
    1a72:	6818      	ldr	r0, [r3, #0]
}
    1a74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_enable(dev);
    1a78:	f012 bf49 	b.w	1490e <z_impl_uart_irq_tx_enable>
    1a7c:	200010e0 	.word	0x200010e0
    1a80:	20000090 	.word	0x20000090

00001a84 <uart_printf>:

void uart_printf(char *format, ...) {
    1a84:	b40f      	push	{r0, r1, r2, r3}
    1a86:	b537      	push	{r0, r1, r2, r4, r5, lr}
    va_list arg;
    va_start(arg, format);
    int len;
    static char buffer[64];

    len = vsnprintf(buffer, 64,format, arg);
    1a88:	4c11      	ldr	r4, [pc, #68]	; (1ad0 <uart_printf+0x4c>)
void uart_printf(char *format, ...) {
    1a8a:	ab06      	add	r3, sp, #24
    len = vsnprintf(buffer, 64,format, arg);
    1a8c:	2140      	movs	r1, #64	; 0x40
void uart_printf(char *format, ...) {
    1a8e:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start(arg, format);
    1a92:	9301      	str	r3, [sp, #4]
    len = vsnprintf(buffer, 64,format, arg);
    1a94:	4620      	mov	r0, r4
    1a96:	f005 f993 	bl	6dc0 <vsnprintf>
    1a9a:	4602      	mov	r2, r0
	__asm__ volatile(
    1a9c:	f04f 0320 	mov.w	r3, #32
    1aa0:	f3ef 8511 	mrs	r5, BASEPRI
    1aa4:	f383 8811 	msr	BASEPRI, r3
    1aa8:	f3bf 8f6f 	isb	sy

    unsigned int key = irq_lock();
    ring_buf_put(&outringbuf, buffer, len);
    1aac:	4809      	ldr	r0, [pc, #36]	; (1ad4 <uart_printf+0x50>)
    1aae:	4621      	mov	r1, r4
    1ab0:	f013 fb10 	bl	150d4 <ring_buf_put>
	__asm__ volatile(
    1ab4:	f385 8811 	msr	BASEPRI, r5
    1ab8:	f3bf 8f6f 	isb	sy
    irq_unlock(key);
    uart_irq_tx_enable(cdc_dev);
    1abc:	4b06      	ldr	r3, [pc, #24]	; (1ad8 <uart_printf+0x54>)
    1abe:	6818      	ldr	r0, [r3, #0]
    1ac0:	f012 ff25 	bl	1490e <z_impl_uart_irq_tx_enable>
}
    1ac4:	b003      	add	sp, #12
    1ac6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1aca:	b004      	add	sp, #16
    1acc:	4770      	bx	lr
    1ace:	bf00      	nop
    1ad0:	200041af 	.word	0x200041af
    1ad4:	200010e0 	.word	0x200010e0
    1ad8:	20000090 	.word	0x20000090

00001adc <write_time>:

void write_time (uint32_t local, uint32_t rawtime) {
    1adc:	b500      	push	{lr}
    int rc;
    char fname[MAX_PATH_LEN];
    struct fs_file_t time_file;

    snprintf(fname, sizeof(fname), "%s/timeinfo", mp->mnt_point);
    1ade:	4b13      	ldr	r3, [pc, #76]	; (1b2c <write_time+0x50>)
    1ae0:	4a13      	ldr	r2, [pc, #76]	; (1b30 <write_time+0x54>)
    1ae2:	681b      	ldr	r3, [r3, #0]
void write_time (uint32_t local, uint32_t rawtime) {
    1ae4:	b0c5      	sub	sp, #276	; 0x114
    1ae6:	e9cd 1000 	strd	r1, r0, [sp]
    snprintf(fname, sizeof(fname), "%s/timeinfo", mp->mnt_point);
    1aea:	68db      	ldr	r3, [r3, #12]
    1aec:	21ff      	movs	r1, #255	; 0xff
    1aee:	a804      	add	r0, sp, #16
    1af0:	f005 f936 	bl	6d60 <snprintf>

    rc = fs_open(&time_file, fname);
    1af4:	a904      	add	r1, sp, #16
    1af6:	a802      	add	r0, sp, #8
    1af8:	f00a fff0 	bl	cadc <fs_open>
    if (rc < 0) {
    1afc:	1e02      	subs	r2, r0, #0
    1afe:	da06      	bge.n	1b0e <write_time+0x32>
        uart_printf("FAIL: open %s: %d\n", fname, rc);
    1b00:	480c      	ldr	r0, [pc, #48]	; (1b34 <write_time+0x58>)
    1b02:	a904      	add	r1, sp, #16
    1b04:	f7ff ffbe 	bl	1a84 <uart_printf>
    //     printk("%s read count %u: %d\n", fname, boot_count, rc);

    rc = fs_write(&time_file, &local, sizeof(local));
    rc = fs_write(&time_file, &rawtime, sizeof(rawtime));
    rc = fs_close(&time_file);
}
    1b08:	b045      	add	sp, #276	; 0x114
    1b0a:	f85d fb04 	ldr.w	pc, [sp], #4
    rc = fs_write(&time_file, &local, sizeof(local));
    1b0e:	2204      	movs	r2, #4
    1b10:	eb0d 0102 	add.w	r1, sp, r2
    1b14:	a802      	add	r0, sp, #8
    1b16:	f00b f871 	bl	cbfc <fs_write>
    rc = fs_write(&time_file, &rawtime, sizeof(rawtime));
    1b1a:	2204      	movs	r2, #4
    1b1c:	4669      	mov	r1, sp
    1b1e:	a802      	add	r0, sp, #8
    1b20:	f00b f86c 	bl	cbfc <fs_write>
    rc = fs_close(&time_file);
    1b24:	a802      	add	r0, sp, #8
    1b26:	f00b f829 	bl	cb7c <fs_close>
    1b2a:	e7ed      	b.n	1b08 <write_time+0x2c>
    1b2c:	2000bb98 	.word	0x2000bb98
    1b30:	00019f39 	.word	0x00019f39
    1b34:	00019d5d 	.word	0x00019d5d

00001b38 <read_time>:

void read_time(uint32_t *local, uint32_t *rawtime) {
    1b38:	b530      	push	{r4, r5, lr}
    int rc;
    char fname[MAX_PATH_LEN];
    struct fs_file_t time_file;

    snprintf(fname, sizeof(fname), "%s/timeinfo", mp->mnt_point);
    1b3a:	4b12      	ldr	r3, [pc, #72]	; (1b84 <read_time+0x4c>)
    1b3c:	4a12      	ldr	r2, [pc, #72]	; (1b88 <read_time+0x50>)
    1b3e:	681b      	ldr	r3, [r3, #0]
void read_time(uint32_t *local, uint32_t *rawtime) {
    1b40:	b0c3      	sub	sp, #268	; 0x10c
    snprintf(fname, sizeof(fname), "%s/timeinfo", mp->mnt_point);
    1b42:	68db      	ldr	r3, [r3, #12]
void read_time(uint32_t *local, uint32_t *rawtime) {
    1b44:	4605      	mov	r5, r0
    1b46:	460c      	mov	r4, r1
    snprintf(fname, sizeof(fname), "%s/timeinfo", mp->mnt_point);
    1b48:	a802      	add	r0, sp, #8
    1b4a:	21ff      	movs	r1, #255	; 0xff
    1b4c:	f005 f908 	bl	6d60 <snprintf>

    rc = fs_open(&time_file, fname);
    1b50:	a902      	add	r1, sp, #8
    1b52:	4668      	mov	r0, sp
    1b54:	f00a ffc2 	bl	cadc <fs_open>
    if (rc < 0) {
    1b58:	1e02      	subs	r2, r0, #0
    1b5a:	da05      	bge.n	1b68 <read_time+0x30>
        uart_printf("FAIL: open %s: %d\n", fname, rc);
    1b5c:	480b      	ldr	r0, [pc, #44]	; (1b8c <read_time+0x54>)
    1b5e:	a902      	add	r1, sp, #8
    1b60:	f7ff ff90 	bl	1a84 <uart_printf>

    rc = fs_read(&time_file, local, 4);
    rc = fs_read(&time_file, rawtime, 4);
    rc = fs_close(&time_file);

}
    1b64:	b043      	add	sp, #268	; 0x10c
    1b66:	bd30      	pop	{r4, r5, pc}
    rc = fs_read(&time_file, local, 4);
    1b68:	4629      	mov	r1, r5
    1b6a:	2204      	movs	r2, #4
    1b6c:	4668      	mov	r0, sp
    1b6e:	f00b f827 	bl	cbc0 <fs_read>
    rc = fs_read(&time_file, rawtime, 4);
    1b72:	2204      	movs	r2, #4
    1b74:	4621      	mov	r1, r4
    1b76:	4668      	mov	r0, sp
    1b78:	f00b f822 	bl	cbc0 <fs_read>
    rc = fs_close(&time_file);
    1b7c:	4668      	mov	r0, sp
    1b7e:	f00a fffd 	bl	cb7c <fs_close>
    1b82:	e7ef      	b.n	1b64 <read_time+0x2c>
    1b84:	2000bb98 	.word	0x2000bb98
    1b88:	00019f39 	.word	0x00019f39
    1b8c:	00019d5d 	.word	0x00019d5d

00001b90 <got_g>:

void got_g(void) {
    1b90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1b94:	b0e2      	sub	sp, #392	; 0x188
    int rc;
    int total_bytes = 0;
    int pos = 0;
    int record_length = 0;
    int out_len = 0;
    memset(line, 0, 128);
    1b96:	af02      	add	r7, sp, #8
    1b98:	2280      	movs	r2, #128	; 0x80
    1b9a:	2100      	movs	r1, #0
    1b9c:	4638      	mov	r0, r7
    1b9e:	f014 fa77 	bl	16090 <memset>

    if (show_binary) {
    1ba2:	4b2c      	ldr	r3, [pc, #176]	; (1c54 <got_g+0xc4>)
        record_length = 32;
    } else {
        record_length = 100;
    }

    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    1ba4:	4a2c      	ldr	r2, [pc, #176]	; (1c58 <got_g+0xc8>)
    if (show_binary) {
    1ba6:	781b      	ldrb	r3, [r3, #0]
        record_length = 100;
    1ba8:	2b00      	cmp	r3, #0
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    1baa:	4b2c      	ldr	r3, [pc, #176]	; (1c5c <got_g+0xcc>)
    1bac:	681b      	ldr	r3, [r3, #0]
    1bae:	f04f 01ff 	mov.w	r1, #255	; 0xff
    1bb2:	68db      	ldr	r3, [r3, #12]
    1bb4:	a822      	add	r0, sp, #136	; 0x88
        record_length = 100;
    1bb6:	bf14      	ite	ne
    1bb8:	2420      	movne	r4, #32
    1bba:	2464      	moveq	r4, #100	; 0x64
    snprintf(fname, sizeof(fname), "%s/encounters", mp->mnt_point);
    1bbc:	f005 f8d0 	bl	6d60 <snprintf>

    rc = fs_open(&file, fname);
    1bc0:	a922      	add	r1, sp, #136	; 0x88
    1bc2:	4668      	mov	r0, sp
    1bc4:	f00a ff8a 	bl	cadc <fs_open>
    if (rc < 0) {
    1bc8:	1e02      	subs	r2, r0, #0
    1bca:	da06      	bge.n	1bda <got_g+0x4a>
        printk("FAIL: open %s: %d\n", fname, rc);
    1bcc:	4824      	ldr	r0, [pc, #144]	; (1c60 <got_g+0xd0>)
    1bce:	a922      	add	r1, sp, #136	; 0x88
    1bd0:	f012 ffab 	bl	14b2a <printk>
    pos = fs_tell(&file);
    rc = fs_close(&file);
    // printk("Close file rc: %d\n", rc);
    uart_printf("total_bytes: %d\n", total_bytes);
    // uart_print(line, rc);
}
    1bd4:	b062      	add	sp, #392	; 0x188
    1bd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    printk("Opened file rc: %d\n", rc);
    1bda:	4822      	ldr	r0, [pc, #136]	; (1c64 <got_g+0xd4>)
            out_len = ring_buf_put(&outringbuf, line, rc);
    1bdc:	f8df 9094 	ldr.w	r9, [pc, #148]	; 1c74 <got_g+0xe4>
    printk("Opened file rc: %d\n", rc);
    1be0:	4611      	mov	r1, r2
    1be2:	f012 ffa2 	bl	14b2a <printk>
    int total_bytes = 0;
    1be6:	2600      	movs	r6, #0
        line[rc] = 0;
    1be8:	46b0      	mov	r8, r6
    while((rc = fs_read(&file, line, record_length))) {
    1bea:	4622      	mov	r2, r4
    1bec:	4639      	mov	r1, r7
    1bee:	4668      	mov	r0, sp
    1bf0:	f00a ffe6 	bl	cbc0 <fs_read>
    1bf4:	b950      	cbnz	r0, 1c0c <got_g+0x7c>
    pos = fs_tell(&file);
    1bf6:	4668      	mov	r0, sp
    1bf8:	f00b f83c 	bl	cc74 <fs_tell>
    rc = fs_close(&file);
    1bfc:	4668      	mov	r0, sp
    1bfe:	f00a ffbd 	bl	cb7c <fs_close>
    uart_printf("total_bytes: %d\n", total_bytes);
    1c02:	4819      	ldr	r0, [pc, #100]	; (1c68 <got_g+0xd8>)
    1c04:	4631      	mov	r1, r6
    1c06:	f7ff ff3d 	bl	1a84 <uart_printf>
    1c0a:	e7e3      	b.n	1bd4 <got_g+0x44>
        if (rc == record_length) {
    1c0c:	4284      	cmp	r4, r0
        line[rc] = 0;
    1c0e:	f807 8000 	strb.w	r8, [r7, r0]
        if (rc == record_length) {
    1c12:	d1ea      	bne.n	1bea <got_g+0x5a>
	__asm__ volatile(
    1c14:	f04f 0320 	mov.w	r3, #32
    1c18:	f3ef 8a11 	mrs	sl, BASEPRI
    1c1c:	f383 8811 	msr	BASEPRI, r3
    1c20:	f3bf 8f6f 	isb	sy
            out_len = ring_buf_put(&outringbuf, line, rc);
    1c24:	4622      	mov	r2, r4
    1c26:	4639      	mov	r1, r7
    1c28:	4648      	mov	r0, r9
    1c2a:	f013 fa53 	bl	150d4 <ring_buf_put>
    1c2e:	4605      	mov	r5, r0
	__asm__ volatile(
    1c30:	f38a 8811 	msr	BASEPRI, sl
    1c34:	f3bf 8f6f 	isb	sy
            uart_irq_tx_enable(cdc_dev);
    1c38:	4b0c      	ldr	r3, [pc, #48]	; (1c6c <got_g+0xdc>)
    1c3a:	6818      	ldr	r0, [r3, #0]
    1c3c:	f012 fe67 	bl	1490e <z_impl_uart_irq_tx_enable>
            if (out_len < rc) {
    1c40:	42ac      	cmp	r4, r5
    1c42:	dd04      	ble.n	1c4e <got_g+0xbe>
                uart_printf("problem got_g, out_len: %d, line_len: %d\n", out_len, rc);
    1c44:	480a      	ldr	r0, [pc, #40]	; (1c70 <got_g+0xe0>)
    1c46:	4622      	mov	r2, r4
    1c48:	4629      	mov	r1, r5
    1c4a:	f7ff ff1b 	bl	1a84 <uart_printf>
            total_bytes += out_len;
    1c4e:	442e      	add	r6, r5
            line_count++;
    1c50:	e7cb      	b.n	1bea <got_g+0x5a>
    1c52:	bf00      	nop
    1c54:	2000c15d 	.word	0x2000c15d
    1c58:	00019c58 	.word	0x00019c58
    1c5c:	2000bb98 	.word	0x2000bb98
    1c60:	00019d5d 	.word	0x00019d5d
    1c64:	00019f45 	.word	0x00019f45
    1c68:	00019f83 	.word	0x00019f83
    1c6c:	20000090 	.word	0x20000090
    1c70:	00019f59 	.word	0x00019f59
    1c74:	200010e0 	.word	0x200010e0

00001c78 <cleanup_cache>:

void cleanup_cache(void) {
    1c78:	b570      	push	{r4, r5, r6, lr}
    int total_len;
    // unsigned int key;
    char buffer[64];
    int len;
    int record_length, number_of_events;
    if (show_binary) {
    1c7a:	4b18      	ldr	r3, [pc, #96]	; (1cdc <cleanup_cache+0x64>)
        record_length = 32;
    } else {
        record_length = 100;
    }

    total_len = ring_buf_get(&flashringbuf, flash_buffer, 4096);
    1c7c:	4d18      	ldr	r5, [pc, #96]	; (1ce0 <cleanup_cache+0x68>)
    if (show_binary) {
    1c7e:	781b      	ldrb	r3, [r3, #0]
    total_len = ring_buf_get(&flashringbuf, flash_buffer, 4096);
    1c80:	4918      	ldr	r1, [pc, #96]	; (1ce4 <cleanup_cache+0x6c>)
void cleanup_cache(void) {
    1c82:	b090      	sub	sp, #64	; 0x40
    if (show_binary) {
    1c84:	2b00      	cmp	r3, #0
    total_len = ring_buf_get(&flashringbuf, flash_buffer, 4096);
    1c86:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    1c8a:	4628      	mov	r0, r5
        record_length = 100;
    1c8c:	bf14      	ite	ne
    1c8e:	2620      	movne	r6, #32
    1c90:	2664      	moveq	r6, #100	; 0x64
    total_len = ring_buf_get(&flashringbuf, flash_buffer, 4096);
    1c92:	f013 fa77 	bl	15184 <ring_buf_get>
	memset(&buf->misc, 0, sizeof(buf->misc));
    1c96:	2208      	movs	r2, #8
    1c98:	4604      	mov	r4, r0
	buf->head = 0;
    1c9a:	2100      	movs	r1, #0
	memset(&buf->misc, 0, sizeof(buf->misc));
    1c9c:	18a8      	adds	r0, r5, r2
	buf->tail = 0;
    1c9e:	e9c5 1100 	strd	r1, r1, [r5]
	memset(&buf->misc, 0, sizeof(buf->misc));
    1ca2:	f014 f9f5 	bl	16090 <memset>
    //         total_written, total_cache, total_len);
    // uart_print(buffer, len);

    ring_buf_reset(&flashringbuf);

    number_of_events = total_len / record_length;
    1ca6:	fb94 f2f6 	sdiv	r2, r4, r6
    total_len = number_of_events * record_length; 

    // len = sprintf(buffer, "len to write to file: %d\n", total_len);
    // uart_print(buffer, len);

    int len_written = fs_write(&encounter_file, flash_buffer, total_len);
    1caa:	490e      	ldr	r1, [pc, #56]	; (1ce4 <cleanup_cache+0x6c>)
    1cac:	480e      	ldr	r0, [pc, #56]	; (1ce8 <cleanup_cache+0x70>)
    1cae:	4372      	muls	r2, r6
    1cb0:	f00a ffa4 	bl	cbfc <fs_write>
    1cb4:	4604      	mov	r4, r0
    fs_sync(&encounter_file);
    1cb6:	480c      	ldr	r0, [pc, #48]	; (1ce8 <cleanup_cache+0x70>)
    1cb8:	f00a fffa 	bl	ccb0 <fs_sync>
    total_written += len_written;
    1cbc:	4b0b      	ldr	r3, [pc, #44]	; (1cec <cleanup_cache+0x74>)

    len = sprintf(buffer, "cleanup cache total_written:  %d, total_cache: %d\n",
    1cbe:	490c      	ldr	r1, [pc, #48]	; (1cf0 <cleanup_cache+0x78>)
    total_written += len_written;
    1cc0:	681a      	ldr	r2, [r3, #0]
    1cc2:	4422      	add	r2, r4
    1cc4:	601a      	str	r2, [r3, #0]
    len = sprintf(buffer, "cleanup cache total_written:  %d, total_cache: %d\n",
    1cc6:	4b0b      	ldr	r3, [pc, #44]	; (1cf4 <cleanup_cache+0x7c>)
    1cc8:	4668      	mov	r0, sp
    1cca:	681b      	ldr	r3, [r3, #0]
    1ccc:	f005 f860 	bl	6d90 <sprintf>
    1cd0:	4601      	mov	r1, r0
            total_written, total_cache);
    uart_print(buffer, len);
    1cd2:	4668      	mov	r0, sp
    1cd4:	f7ff feba 	bl	1a4c <uart_print>
}
    1cd8:	b010      	add	sp, #64	; 0x40
    1cda:	bd70      	pop	{r4, r5, r6, pc}
    1cdc:	2000c15d 	.word	0x2000c15d
    1ce0:	200010a0 	.word	0x200010a0
    1ce4:	200041f0 	.word	0x200041f0
    1ce8:	20000094 	.word	0x20000094
    1cec:	200011a4 	.word	0x200011a4
    1cf0:	00019f94 	.word	0x00019f94
    1cf4:	200011a0 	.word	0x200011a0

00001cf8 <flash_store>:
void flash_store(void) {
    1cf8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    Encounter_record *current_encounter;
    uint32_t start = p_fifo_last_idx;
    1cfc:	4b1e      	ldr	r3, [pc, #120]	; (1d78 <flash_store+0x80>)
    if (start==c_fifo_last_idx) return;
    1cfe:	4d1f      	ldr	r5, [pc, #124]	; (1d7c <flash_store+0x84>)
    uint32_t start = p_fifo_last_idx;
    1d00:	681e      	ldr	r6, [r3, #0]
    if (start==c_fifo_last_idx) return;
    1d02:	682b      	ldr	r3, [r5, #0]
    1d04:	42b3      	cmp	r3, r6
    1d06:	d01e      	beq.n	1d46 <flash_store+0x4e>
	return z_impl_k_uptime_ticks();
    1d08:	f017 f960 	bl	18fcc <z_impl_k_uptime_ticks>
    1d0c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1d10:	460b      	mov	r3, r1
    1d12:	fba0 0102 	umull	r0, r1, r0, r2
    1d16:	fb02 1103 	mla	r1, r2, r3, r1
    1d1a:	0bc3      	lsrs	r3, r0, #15
    1d1c:	ea43 4341 	orr.w	r3, r3, r1, lsl #17

    uint32_t timestamp = k_uptime_get_32();
    uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    1d20:	4917      	ldr	r1, [pc, #92]	; (1d80 <flash_store+0x88>)

    while (c_fifo_last_idx > start) {

        current_encounter = encounters + (start & 0x3F);
    1d22:	f8df 9068 	ldr.w	r9, [pc, #104]	; 1d8c <flash_store+0x94>
    uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    1d26:	680c      	ldr	r4, [r1, #0]
        if (current_encounter->minute < epoch_minute) { // this is an old record write to flash

            int len_written = fs_write(&encounter_file, (uint8_t *)current_encounter, 64);
    1d28:	4f16      	ldr	r7, [pc, #88]	; (1d84 <flash_store+0x8c>)
            fs_sync(&encounter_file);
            total_written += len_written;
    1d2a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 1d90 <flash_store+0x98>
    uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    1d2e:	1b1c      	subs	r4, r3, r4
    1d30:	4b15      	ldr	r3, [pc, #84]	; (1d88 <flash_store+0x90>)
    1d32:	fbb4 f4f2 	udiv	r4, r4, r2
    1d36:	681b      	ldr	r3, [r3, #0]
    1d38:	441c      	add	r4, r3
    1d3a:	233c      	movs	r3, #60	; 0x3c
    1d3c:	fbb4 f4f3 	udiv	r4, r4, r3
    while (c_fifo_last_idx > start) {
    1d40:	682b      	ldr	r3, [r5, #0]
    1d42:	42b3      	cmp	r3, r6
    1d44:	d801      	bhi.n	1d4a <flash_store+0x52>
        } else {
            return;
        }
    }

}
    1d46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        current_encounter = encounters + (start & 0x3F);
    1d4a:	f006 013f 	and.w	r1, r6, #63	; 0x3f
    1d4e:	eb09 1181 	add.w	r1, r9, r1, lsl #6
        if (current_encounter->minute < epoch_minute) { // this is an old record write to flash
    1d52:	688b      	ldr	r3, [r1, #8]
    1d54:	42a3      	cmp	r3, r4
    1d56:	d2f6      	bcs.n	1d46 <flash_store+0x4e>
            int len_written = fs_write(&encounter_file, (uint8_t *)current_encounter, 64);
    1d58:	2240      	movs	r2, #64	; 0x40
    1d5a:	4638      	mov	r0, r7
    1d5c:	f00a ff4e 	bl	cbfc <fs_write>
    1d60:	4682      	mov	sl, r0
            fs_sync(&encounter_file);
    1d62:	4638      	mov	r0, r7
    1d64:	f00a ffa4 	bl	ccb0 <fs_sync>
            total_written += len_written;
    1d68:	f8d8 3000 	ldr.w	r3, [r8]
    1d6c:	4453      	add	r3, sl
    1d6e:	f8c8 3000 	str.w	r3, [r8]
            start++;
    1d72:	3601      	adds	r6, #1
    1d74:	e7e4      	b.n	1d40 <flash_store+0x48>
    1d76:	bf00      	nop
    1d78:	200010fc 	.word	0x200010fc
    1d7c:	2000008c 	.word	0x2000008c
    1d80:	200010dc 	.word	0x200010dc
    1d84:	20000094 	.word	0x20000094
    1d88:	2000109c 	.word	0x2000109c
    1d8c:	2000009c 	.word	0x2000009c
    1d90:	200011a4 	.word	0x200011a4

00001d94 <parse_command>:
            printk("Disk full???\n");
        }
    }
}

void parse_command(char c) {
    1d94:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d96:	f1a0 0362 	sub.w	r3, r0, #98	; 0x62
    1d9a:	b095      	sub	sp, #84	; 0x54
    1d9c:	4601      	mov	r1, r0
    1d9e:	2b18      	cmp	r3, #24
    1da0:	f200 80f7 	bhi.w	1f92 <parse_command+0x1fe>
    1da4:	e8df f013 	tbh	[pc, r3, lsl #1]
    1da8:	005b009d 	.word	0x005b009d
    1dac:	003e0041 	.word	0x003e0041
    1db0:	00550090 	.word	0x00550090
    1db4:	004500f5 	.word	0x004500f5
    1db8:	006900e6 	.word	0x006900e6
    1dbc:	00f5007c 	.word	0x00f5007c
    1dc0:	001b00a2 	.word	0x001b00a2
    1dc4:	00f300f1 	.word	0x00f300f1
    1dc8:	00870072 	.word	0x00870072
    1dcc:	00a700b1 	.word	0x00a700b1
    1dd0:	00820020 	.word	0x00820020
    1dd4:	0019001d 	.word	0x0019001d
    1dd8:	0077      	.short	0x0077
    // int total_len, len_written;
            switch (c) {
                case 'y':  // start_scan
                    {
                    start_scan();
    1dda:	f000 fb43 	bl	2464 <start_scan>
                    {
                    printk("got %c, not defined\n", c);
                    break;
                    }
            }
}
    1dde:	b015      	add	sp, #84	; 0x54
    1de0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    stop_scan();
    1de2:	f000 fb59 	bl	2498 <stop_scan>
                    break;
    1de6:	e7fa      	b.n	1dde <parse_command+0x4a>
                        len += ring_buf_get(&inringbuf, (uint8_t *)&(interval)+len, 1);
    1de8:	4d6c      	ldr	r5, [pc, #432]	; (1f9c <parse_command+0x208>)
void parse_command(char c) {
    1dea:	2400      	movs	r4, #0
                        len += ring_buf_get(&inringbuf, (uint8_t *)&(interval)+len, 1);
    1dec:	ab03      	add	r3, sp, #12
    1dee:	1919      	adds	r1, r3, r4
    1df0:	2201      	movs	r2, #1
    1df2:	4628      	mov	r0, r5
    1df4:	f013 f9c6 	bl	15184 <ring_buf_get>
    1df8:	4404      	add	r4, r0
                    } while (len < 2);
    1dfa:	2c01      	cmp	r4, #1
    1dfc:	ddf6      	ble.n	1dec <parse_command+0x58>
                        len += ring_buf_get(&inringbuf, (uint8_t *)&(window)+len, 1);
    1dfe:	4d67      	ldr	r5, [pc, #412]	; (1f9c <parse_command+0x208>)
                    len =0;
    1e00:	2400      	movs	r4, #0
                        len += ring_buf_get(&inringbuf, (uint8_t *)&(window)+len, 1);
    1e02:	ab04      	add	r3, sp, #16
    1e04:	1919      	adds	r1, r3, r4
    1e06:	2201      	movs	r2, #1
    1e08:	4628      	mov	r0, r5
    1e0a:	f013 f9bb 	bl	15184 <ring_buf_get>
    1e0e:	4404      	add	r4, r0
                    } while (len < 2);
    1e10:	2c01      	cmp	r4, #1
    1e12:	ddf6      	ble.n	1e02 <parse_command+0x6e>
                    scan_param.interval = interval;
    1e14:	4b62      	ldr	r3, [pc, #392]	; (1fa0 <parse_command+0x20c>)
    1e16:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    1e1a:	811a      	strh	r2, [r3, #8]
                    scan_param.window = window;
    1e1c:	f8bd 2010 	ldrh.w	r2, [sp, #16]
    1e20:	815a      	strh	r2, [r3, #10]
                    break;
    1e22:	e7dc      	b.n	1dde <parse_command+0x4a>
                    start_adv = true;
    1e24:	4b5f      	ldr	r3, [pc, #380]	; (1fa4 <parse_command+0x210>)
                    hide_mac = true;
    1e26:	2201      	movs	r2, #1
    1e28:	e001      	b.n	1e2e <parse_command+0x9a>
                    start_adv = false;
    1e2a:	4b5e      	ldr	r3, [pc, #376]	; (1fa4 <parse_command+0x210>)
                    hide_mac = false;
    1e2c:	2200      	movs	r2, #0
                    hide_mac = true;
    1e2e:	701a      	strb	r2, [r3, #0]
                    break;
    1e30:	e7d5      	b.n	1dde <parse_command+0x4a>
                    uart_printf("start_adv:%d, raw:%d, binary:%d, write_flash:%d, hide:%d\n", 
    1e32:	4b5d      	ldr	r3, [pc, #372]	; (1fa8 <parse_command+0x214>)
    1e34:	4a5d      	ldr	r2, [pc, #372]	; (1fac <parse_command+0x218>)
    1e36:	781b      	ldrb	r3, [r3, #0]
    1e38:	9301      	str	r3, [sp, #4]
    1e3a:	4b5d      	ldr	r3, [pc, #372]	; (1fb0 <parse_command+0x21c>)
    1e3c:	4959      	ldr	r1, [pc, #356]	; (1fa4 <parse_command+0x210>)
    1e3e:	781b      	ldrb	r3, [r3, #0]
    1e40:	9300      	str	r3, [sp, #0]
    1e42:	4b5c      	ldr	r3, [pc, #368]	; (1fb4 <parse_command+0x220>)
    1e44:	7812      	ldrb	r2, [r2, #0]
    1e46:	781b      	ldrb	r3, [r3, #0]
    1e48:	7809      	ldrb	r1, [r1, #0]
    1e4a:	485b      	ldr	r0, [pc, #364]	; (1fb8 <parse_command+0x224>)
    1e4c:	f7ff fe1a 	bl	1a84 <uart_printf>
                    break;
    1e50:	e7c5      	b.n	1dde <parse_command+0x4a>
                    printk("got g\n");
    1e52:	485a      	ldr	r0, [pc, #360]	; (1fbc <parse_command+0x228>)
    1e54:	f012 fe69 	bl	14b2a <printk>
                    got_g();
    1e58:	f7ff fe9a 	bl	1b90 <got_g>
                    break;
    1e5c:	e7bf      	b.n	1dde <parse_command+0x4a>
                    printk("got c\n");
    1e5e:	4858      	ldr	r0, [pc, #352]	; (1fc0 <parse_command+0x22c>)
    1e60:	f012 fe63 	bl	14b2a <printk>
                    clear_encounter();
    1e64:	f7ff fdb6 	bl	19d4 <clear_encounter>
                    total_written = 0;
    1e68:	4a56      	ldr	r2, [pc, #344]	; (1fc4 <parse_command+0x230>)
                    printk("done clear\n");
    1e6a:	4857      	ldr	r0, [pc, #348]	; (1fc8 <parse_command+0x234>)
                    total_written = 0;
    1e6c:	2300      	movs	r3, #0
    1e6e:	6013      	str	r3, [r2, #0]
                    total_cache = 0;
    1e70:	4a56      	ldr	r2, [pc, #344]	; (1fcc <parse_command+0x238>)
    1e72:	6013      	str	r3, [r2, #0]
                    printk("done clear\n");
    1e74:	f012 fe59 	bl	14b2a <printk>
                    break;
    1e78:	e7b1      	b.n	1dde <parse_command+0x4a>
                    printk("got k\n");
    1e7a:	4855      	ldr	r0, [pc, #340]	; (1fd0 <parse_command+0x23c>)
    1e7c:	f012 fe55 	bl	14b2a <printk>
                    show_kernel = !show_kernel ;
    1e80:	4a54      	ldr	r2, [pc, #336]	; (1fd4 <parse_command+0x240>)
    1e82:	7813      	ldrb	r3, [r2, #0]
    1e84:	f083 0301 	eor.w	r3, r3, #1
    1e88:	7013      	strb	r3, [r2, #0]
                    break;
    1e8a:	e7a8      	b.n	1dde <parse_command+0x4a>
                    printk("got r\n");
    1e8c:	4852      	ldr	r0, [pc, #328]	; (1fd8 <parse_command+0x244>)
    1e8e:	f012 fe4c 	bl	14b2a <printk>
                    show_raw = true ;
    1e92:	4b46      	ldr	r3, [pc, #280]	; (1fac <parse_command+0x218>)
    1e94:	e7c7      	b.n	1e26 <parse_command+0x92>
                    printk("got z\n");
    1e96:	4851      	ldr	r0, [pc, #324]	; (1fdc <parse_command+0x248>)
    1e98:	f012 fe47 	bl	14b2a <printk>
                    show_raw = false ;
    1e9c:	4b43      	ldr	r3, [pc, #268]	; (1fac <parse_command+0x218>)
    1e9e:	e7c5      	b.n	1e2c <parse_command+0x98>
                    printk("got l\n");
    1ea0:	484f      	ldr	r0, [pc, #316]	; (1fe0 <parse_command+0x24c>)
    1ea2:	f012 fe42 	bl	14b2a <printk>
                    ls();
    1ea6:	f7ff fab7 	bl	1418 <ls>
                    break;
    1eaa:	e798      	b.n	1dde <parse_command+0x4a>
                    printk("got w\n");
    1eac:	484d      	ldr	r0, [pc, #308]	; (1fe4 <parse_command+0x250>)
    1eae:	f012 fe3c 	bl	14b2a <printk>
                    write_flash = true ;
    1eb2:	4b3f      	ldr	r3, [pc, #252]	; (1fb0 <parse_command+0x21c>)
    1eb4:	e7b7      	b.n	1e26 <parse_command+0x92>
                    printk("got s\n");
    1eb6:	484c      	ldr	r0, [pc, #304]	; (1fe8 <parse_command+0x254>)
    1eb8:	f012 fe37 	bl	14b2a <printk>
                    write_flash = false;
    1ebc:	4b3c      	ldr	r3, [pc, #240]	; (1fb0 <parse_command+0x21c>)
    1ebe:	2200      	movs	r2, #0
    1ec0:	701a      	strb	r2, [r3, #0]
                    cleanup_cache();
    1ec2:	f7ff fed9 	bl	1c78 <cleanup_cache>
                    break;
    1ec6:	e78a      	b.n	1dde <parse_command+0x4a>
                    int len = sprintf(buffer, "total_written:  %d, total_cache: %d\n",
    1ec8:	4b40      	ldr	r3, [pc, #256]	; (1fcc <parse_command+0x238>)
    1eca:	4a3e      	ldr	r2, [pc, #248]	; (1fc4 <parse_command+0x230>)
    1ecc:	681b      	ldr	r3, [r3, #0]
    1ece:	6812      	ldr	r2, [r2, #0]
    1ed0:	4946      	ldr	r1, [pc, #280]	; (1fec <parse_command+0x258>)
    1ed2:	a804      	add	r0, sp, #16
    1ed4:	f004 ff5c 	bl	6d90 <sprintf>
    1ed8:	4601      	mov	r1, r0
                    uart_print(buffer, len);
    1eda:	a804      	add	r0, sp, #16
    1edc:	f7ff fdb6 	bl	1a4c <uart_print>
                    break;
    1ee0:	e77d      	b.n	1dde <parse_command+0x4a>
                    printk("got b\n");
    1ee2:	4843      	ldr	r0, [pc, #268]	; (1ff0 <parse_command+0x25c>)
    1ee4:	f012 fe21 	bl	14b2a <printk>
                    show_binary = true ;
    1ee8:	4b32      	ldr	r3, [pc, #200]	; (1fb4 <parse_command+0x220>)
    1eea:	e79c      	b.n	1e26 <parse_command+0x92>
                    printk("got n\n");
    1eec:	4841      	ldr	r0, [pc, #260]	; (1ff4 <parse_command+0x260>)
    1eee:	f012 fe1c 	bl	14b2a <printk>
                    show_binary = false ;
    1ef2:	4b30      	ldr	r3, [pc, #192]	; (1fb4 <parse_command+0x220>)
    1ef4:	e79a      	b.n	1e2c <parse_command+0x98>
                    read_time(&local, &human); 
    1ef6:	a904      	add	r1, sp, #16
    1ef8:	a803      	add	r0, sp, #12
    1efa:	f7ff fe1d 	bl	1b38 <read_time>
                    uart_printf("%u, %u\n", local, human);
    1efe:	e9dd 1203 	ldrd	r1, r2, [sp, #12]
    1f02:	483d      	ldr	r0, [pc, #244]	; (1ff8 <parse_command+0x264>)
    1f04:	f7ff fdbe 	bl	1a84 <uart_printf>
                    break;
    1f08:	e769      	b.n	1dde <parse_command+0x4a>
                    printk("got t\n");
    1f0a:	483c      	ldr	r0, [pc, #240]	; (1ffc <parse_command+0x268>)
    1f0c:	f012 fe0d 	bl	14b2a <printk>
    1f10:	f017 f85c 	bl	18fcc <z_impl_k_uptime_ticks>
    1f14:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    1f18:	460a      	mov	r2, r1
    1f1a:	fba0 0103 	umull	r0, r1, r0, r3
    1f1e:	fb03 1102 	mla	r1, r3, r2, r1
                        len += ring_buf_get(&inringbuf, temp+len, 1);
    1f22:	4e37      	ldr	r6, [pc, #220]	; (2000 <parse_command+0x26c>)
    1f24:	4f1d      	ldr	r7, [pc, #116]	; (1f9c <parse_command+0x208>)
    1f26:	0bc3      	lsrs	r3, r0, #15
    1f28:	ea43 4441 	orr.w	r4, r3, r1, lsl #17
                    int len = 0;
    1f2c:	2500      	movs	r5, #0
                        len += ring_buf_get(&inringbuf, temp+len, 1);
    1f2e:	1971      	adds	r1, r6, r5
    1f30:	2201      	movs	r2, #1
    1f32:	4638      	mov	r0, r7
    1f34:	f013 f926 	bl	15184 <ring_buf_get>
    1f38:	4405      	add	r5, r0
                    } while (len < 4);
    1f3a:	2d03      	cmp	r5, #3
    1f3c:	ddf7      	ble.n	1f2e <parse_command+0x19a>
                    write_time(timestamp, epochtimesync);
    1f3e:	6831      	ldr	r1, [r6, #0]
    1f40:	4620      	mov	r0, r4
    1f42:	f7ff fdcb 	bl	1adc <write_time>
                    offsettime = timestamp;
    1f46:	4b2f      	ldr	r3, [pc, #188]	; (2004 <parse_command+0x270>)
    1f48:	601c      	str	r4, [r3, #0]
                    time_t rawtime = (const time_t) epochtimesync;
    1f4a:	6833      	ldr	r3, [r6, #0]
    1f4c:	9304      	str	r3, [sp, #16]
                    ts = *gmtime(&rawtime);
    1f4e:	a804      	add	r0, sp, #16
                    time_t rawtime = (const time_t) epochtimesync;
    1f50:	2300      	movs	r3, #0
    1f52:	9305      	str	r3, [sp, #20]
                    ts = *gmtime(&rawtime);
    1f54:	f005 f82c 	bl	6fb0 <gmtime>
    1f58:	6802      	ldr	r2, [r0, #0]
                    int delta = 60 - ts.tm_sec;
    1f5a:	f1c2 033c 	rsb	r3, r2, #60	; 0x3c
                    if (delta <= 0) {
    1f5e:	2b00      	cmp	r3, #0
                        delta += 60;
    1f60:	bfd8      	it	le
    1f62:	f1c2 0378 	rsble	r3, r2, #120	; 0x78
                    next_minute = timestamp + delta * 1000;
    1f66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1f6a:	fb02 4303 	mla	r3, r2, r3, r4
    1f6e:	4a26      	ldr	r2, [pc, #152]	; (2008 <parse_command+0x274>)
    1f70:	6013      	str	r3, [r2, #0]
                    break;
    1f72:	e734      	b.n	1dde <parse_command+0x4a>
                            scan_param.interval, scan_param.window);
    1f74:	4b0a      	ldr	r3, [pc, #40]	; (1fa0 <parse_command+0x20c>)
                    uart_printf("scan interval %u, window: %u\n", 
    1f76:	4825      	ldr	r0, [pc, #148]	; (200c <parse_command+0x278>)
    1f78:	8919      	ldrh	r1, [r3, #8]
    1f7a:	895a      	ldrh	r2, [r3, #10]
    1f7c:	f7ff fd82 	bl	1a84 <uart_printf>
                    uart_printf("sizeof encounter struct: %d\n", sizeof(Encounter_record));
    1f80:	4823      	ldr	r0, [pc, #140]	; (2010 <parse_command+0x27c>)
    1f82:	2140      	movs	r1, #64	; 0x40
    1f84:	f7ff fd7e 	bl	1a84 <uart_printf>
                    break;
    1f88:	e729      	b.n	1dde <parse_command+0x4a>
                    hide_mac = false;
    1f8a:	4b07      	ldr	r3, [pc, #28]	; (1fa8 <parse_command+0x214>)
    1f8c:	e74e      	b.n	1e2c <parse_command+0x98>
                    hide_mac = true;
    1f8e:	4b06      	ldr	r3, [pc, #24]	; (1fa8 <parse_command+0x214>)
    1f90:	e749      	b.n	1e26 <parse_command+0x92>
                    printk("got %c, not defined\n", c);
    1f92:	4820      	ldr	r0, [pc, #128]	; (2014 <parse_command+0x280>)
    1f94:	f012 fdc9 	bl	14b2a <printk>
}
    1f98:	e721      	b.n	1dde <parse_command+0x4a>
    1f9a:	bf00      	nop
    1f9c:	200010bc 	.word	0x200010bc
    1fa0:	2000bb9c 	.word	0x2000bb9c
    1fa4:	20007a35 	.word	0x20007a35
    1fa8:	2000c15c 	.word	0x2000c15c
    1fac:	20007a34 	.word	0x20007a34
    1fb0:	20007a37 	.word	0x20007a37
    1fb4:	2000c15d 	.word	0x2000c15d
    1fb8:	00019fc7 	.word	0x00019fc7
    1fbc:	0001a001 	.word	0x0001a001
    1fc0:	0001a008 	.word	0x0001a008
    1fc4:	200011a4 	.word	0x200011a4
    1fc8:	0001a00f 	.word	0x0001a00f
    1fcc:	200011a0 	.word	0x200011a0
    1fd0:	0001a01b 	.word	0x0001a01b
    1fd4:	20007a33 	.word	0x20007a33
    1fd8:	0001a022 	.word	0x0001a022
    1fdc:	0001a029 	.word	0x0001a029
    1fe0:	0001a030 	.word	0x0001a030
    1fe4:	0001a037 	.word	0x0001a037
    1fe8:	0001a03e 	.word	0x0001a03e
    1fec:	00019fa2 	.word	0x00019fa2
    1ff0:	0001a045 	.word	0x0001a045
    1ff4:	0001a04c 	.word	0x0001a04c
    1ff8:	0001a053 	.word	0x0001a053
    1ffc:	0001a05b 	.word	0x0001a05b
    2000:	2000109c 	.word	0x2000109c
    2004:	200010dc 	.word	0x200010dc
    2008:	200010d8 	.word	0x200010d8
    200c:	0001a062 	.word	0x0001a062
    2010:	0001a080 	.word	0x0001a080
    2014:	0001a09d 	.word	0x0001a09d

00002018 <main>:

void main(void)
{
    2018:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    // int err;
    led_init(&led1);
    201c:	483b      	ldr	r0, [pc, #236]	; (210c <main+0xf4>)
    led_init(&led2);
    led_init(&led3);
    led_init(&led4);
    for (int i=0; i<5; i++){
        flash(&led1);
        flash(&led2);
    201e:	4e3c      	ldr	r6, [pc, #240]	; (2110 <main+0xf8>)
        flash(&led3);
    2020:	4c3c      	ldr	r4, [pc, #240]	; (2114 <main+0xfc>)
    led_init(&led1);
    2022:	f7ff fb71 	bl	1708 <led_init>
    led_init(&led2);
    2026:	483a      	ldr	r0, [pc, #232]	; (2110 <main+0xf8>)
    2028:	f7ff fb6e 	bl	1708 <led_init>
    led_init(&led3);
    202c:	4839      	ldr	r0, [pc, #228]	; (2114 <main+0xfc>)
    202e:	f7ff fb6b 	bl	1708 <led_init>
    led_init(&led4);
    2032:	4839      	ldr	r0, [pc, #228]	; (2118 <main+0x100>)
    2034:	f7ff fb68 	bl	1708 <led_init>
    2038:	2505      	movs	r5, #5
        flash(&led1);
    203a:	4834      	ldr	r0, [pc, #208]	; (210c <main+0xf4>)
    203c:	f012 fc56 	bl	148ec <flash>
        flash(&led2);
    2040:	4630      	mov	r0, r6
    2042:	f012 fc53 	bl	148ec <flash>
        flash(&led3);
    2046:	4620      	mov	r0, r4
    2048:	f012 fc50 	bl	148ec <flash>
        flash(&led4);
    204c:	4832      	ldr	r0, [pc, #200]	; (2118 <main+0x100>)
    204e:	f012 fc4d 	bl	148ec <flash>
    for (int i=0; i<5; i++){
    2052:	3d01      	subs	r5, #1
    2054:	d1f1      	bne.n	203a <main+0x22>
	memset(buf, 0, sizeof(struct ring_buf));
    2056:	4c31      	ldr	r4, [pc, #196]	; (211c <main+0x104>)
    2058:	4e31      	ldr	r6, [pc, #196]	; (2120 <main+0x108>)
    }
    button_init();
    205a:	f7ff f9ad 	bl	13b8 <button_init>
    205e:	221c      	movs	r2, #28
    2060:	4629      	mov	r1, r5
    2062:	4620      	mov	r0, r4
    2064:	f014 f814 	bl	16090 <memset>
	buf->size = size;
    2068:	f44f 6880 	mov.w	r8, #1024	; 0x400
	buf->buf.buf32 = (u32_t *)data;
    206c:	4b2d      	ldr	r3, [pc, #180]	; (2124 <main+0x10c>)
    206e:	6163      	str	r3, [r4, #20]
		buf->mask = size - 1;
    2070:	f240 37ff 	movw	r7, #1023	; 0x3ff
	memset(buf, 0, sizeof(struct ring_buf));
    2074:	221c      	movs	r2, #28
    2076:	4629      	mov	r1, r5
    2078:	4630      	mov	r0, r6
	buf->size = size;
    207a:	f8c4 8010 	str.w	r8, [r4, #16]
		buf->mask = size - 1;
    207e:	61a7      	str	r7, [r4, #24]
	memset(buf, 0, sizeof(struct ring_buf));
    2080:	f014 f806 	bl	16090 <memset>
	buf->buf.buf32 = (u32_t *)data;
    2084:	4b28      	ldr	r3, [pc, #160]	; (2128 <main+0x110>)
	buf->size = size;
    2086:	f8c6 8010 	str.w	r8, [r6, #16]
		buf->mask = size - 1;
    208a:	e9c6 3705 	strd	r3, r7, [r6, #20]
	memset(buf, 0, sizeof(struct ring_buf));
    208e:	4e27      	ldr	r6, [pc, #156]	; (212c <main+0x114>)
    2090:	221c      	movs	r2, #28
    2092:	4629      	mov	r1, r5
    2094:	4630      	mov	r0, r6
    2096:	f013 fffb 	bl	16090 <memset>
	buf->size = size;
    209a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    209e:	6133      	str	r3, [r6, #16]
	buf->buf.buf32 = (u32_t *)data;
    20a0:	4b23      	ldr	r3, [pc, #140]	; (2130 <main+0x118>)
    20a2:	6173      	str	r3, [r6, #20]
		buf->mask = size - 1;
    20a4:	f641 73ff 	movw	r3, #8191	; 0x1fff
    20a8:	61b3      	str	r3, [r6, #24]
    // printk("Starting Scanner/Advertiser Demo\n");
    ring_buf_init(&inringbuf, sizeof(in_ring_buffer), in_ring_buffer);
    ring_buf_init(&outringbuf, sizeof(out_ring_buffer), out_ring_buffer);
    ring_buf_init(&flashringbuf, sizeof(flash_ring_buffer), flash_ring_buffer);
    flash_init();
    20aa:	f7ff fa33 	bl	1514 <flash_init>
    for (int i=0; i<5; i++){
        flash(&led1);
    20ae:	4817      	ldr	r0, [pc, #92]	; (210c <main+0xf4>)
    20b0:	f012 fc1c 	bl	148ec <flash>
    20b4:	4815      	ldr	r0, [pc, #84]	; (210c <main+0xf4>)
    20b6:	f012 fc19 	bl	148ec <flash>
    20ba:	4814      	ldr	r0, [pc, #80]	; (210c <main+0xf4>)
    20bc:	f012 fc16 	bl	148ec <flash>
    20c0:	4812      	ldr	r0, [pc, #72]	; (210c <main+0xf4>)
    20c2:	f012 fc13 	bl	148ec <flash>
    20c6:	4811      	ldr	r0, [pc, #68]	; (210c <main+0xf4>)
    20c8:	f012 fc10 	bl	148ec <flash>
    }
    // printk("Bluetooth initialized\n");
    bt_init();
    20cc:	f7ff f850 	bl	1170 <bt_init>
    // start_adv = true;
    // There is a thread that runs the bt_adv
    // bt_adv();
    //
    start_scan();
    20d0:	f000 f9c8 	bl	2464 <start_scan>
    cdc_init();
    20d4:	f7ff fbe2 	bl	189c <cdc_init>
    usb_init();
    20d8:	f7ff fbf8 	bl	18cc <usb_init>
    dtr_init();
    20dc:	f7ff fc0a 	bl	18f4 <dtr_init>
    cdc_open=true;
    20e0:	4b14      	ldr	r3, [pc, #80]	; (2134 <main+0x11c>)
    20e2:	2201      	movs	r2, #1
    20e4:	701a      	strb	r2, [r3, #0]
    u8_t c;
    while (true) {
        while(ring_buf_get(&inringbuf, &c, 1)){
    20e6:	2201      	movs	r2, #1
    20e8:	f10d 0107 	add.w	r1, sp, #7
    20ec:	4620      	mov	r0, r4
    20ee:	f013 f849 	bl	15184 <ring_buf_get>
    20f2:	b930      	cbnz	r0, 2102 <main+0xea>
            parse_command(c);
        }
        flash_store();
    20f4:	f7ff fe00 	bl	1cf8 <flash_store>
	return z_impl_k_sleep(timeout);
    20f8:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
    20fc:	f012 f8c8 	bl	14290 <z_impl_k_sleep>
    2100:	e7f1      	b.n	20e6 <main+0xce>
            parse_command(c);
    2102:	f89d 0007 	ldrb.w	r0, [sp, #7]
    2106:	f7ff fe45 	bl	1d94 <parse_command>
    210a:	e7ec      	b.n	20e6 <main+0xce>
    210c:	2000bb28 	.word	0x2000bb28
    2110:	2000bb3c 	.word	0x2000bb3c
    2114:	2000bb50 	.word	0x2000bb50
    2118:	2000bb64 	.word	0x2000bb64
    211c:	200010bc 	.word	0x200010bc
    2120:	200010e0 	.word	0x200010e0
    2124:	200071f1 	.word	0x200071f1
    2128:	200075f1 	.word	0x200075f1
    212c:	200010a0 	.word	0x200010a0
    2130:	200051f1 	.word	0x200051f1
    2134:	200041ef 	.word	0x200041ef

00002138 <bt_addr_le_to_str.constprop.0>:
 *  @param len Length of data to be copied to user string buffer. Refer to
 *  BT_ADDR_LE_STR_LEN about recommended value.
 *
 *  @return Number of successfully formatted bytes from binary address.
 */
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
    2138:	b570      	push	{r4, r5, r6, lr}
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    213a:	7803      	ldrb	r3, [r0, #0]
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
    213c:	b08a      	sub	sp, #40	; 0x28
    213e:	4604      	mov	r4, r0
    2140:	460e      	mov	r6, r1
    2142:	ad07      	add	r5, sp, #28
    2144:	2b03      	cmp	r3, #3
    2146:	d820      	bhi.n	218a <bt_addr_le_to_str.constprop.0+0x52>
    2148:	e8df f003 	tbb	[pc, r3]
    214c:	1d1b1902 	.word	0x1d1b1902
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    2150:	4911      	ldr	r1, [pc, #68]	; (2198 <bt_addr_le_to_str.constprop.0+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    2152:	4628      	mov	r0, r5
    2154:	f013 ff14 	bl	15f80 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    2158:	7863      	ldrb	r3, [r4, #1]
    215a:	9304      	str	r3, [sp, #16]
    215c:	78a3      	ldrb	r3, [r4, #2]
    215e:	9303      	str	r3, [sp, #12]
    2160:	78e3      	ldrb	r3, [r4, #3]
    2162:	9302      	str	r3, [sp, #8]
    2164:	7923      	ldrb	r3, [r4, #4]
    2166:	9301      	str	r3, [sp, #4]
    2168:	7963      	ldrb	r3, [r4, #5]
    216a:	9300      	str	r3, [sp, #0]
    216c:	4a0b      	ldr	r2, [pc, #44]	; (219c <bt_addr_le_to_str.constprop.0+0x64>)
    216e:	79a3      	ldrb	r3, [r4, #6]
    2170:	9505      	str	r5, [sp, #20]
    2172:	2112      	movs	r1, #18
    2174:	4630      	mov	r0, r6
    2176:	f012 fce5 	bl	14b44 <snprintk>
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
}
    217a:	b00a      	add	sp, #40	; 0x28
    217c:	bd70      	pop	{r4, r5, r6, pc}
		strcpy(type, "random");
    217e:	4908      	ldr	r1, [pc, #32]	; (21a0 <bt_addr_le_to_str.constprop.0+0x68>)
    2180:	e7e7      	b.n	2152 <bt_addr_le_to_str.constprop.0+0x1a>
		strcpy(type, "public-id");
    2182:	4908      	ldr	r1, [pc, #32]	; (21a4 <bt_addr_le_to_str.constprop.0+0x6c>)
    2184:	e7e5      	b.n	2152 <bt_addr_le_to_str.constprop.0+0x1a>
		strcpy(type, "random-id");
    2186:	4908      	ldr	r1, [pc, #32]	; (21a8 <bt_addr_le_to_str.constprop.0+0x70>)
    2188:	e7e3      	b.n	2152 <bt_addr_le_to_str.constprop.0+0x1a>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    218a:	4a08      	ldr	r2, [pc, #32]	; (21ac <bt_addr_le_to_str.constprop.0+0x74>)
    218c:	210a      	movs	r1, #10
    218e:	4628      	mov	r0, r5
    2190:	f012 fcd8 	bl	14b44 <snprintk>
		break;
    2194:	e7e0      	b.n	2158 <bt_addr_le_to_str.constprop.0+0x20>
    2196:	bf00      	nop
    2198:	0001a0f1 	.word	0x0001a0f1
    219c:	0001a113 	.word	0x0001a113
    21a0:	0001a0f8 	.word	0x0001a0f8
    21a4:	0001a0ff 	.word	0x0001a0ff
    21a8:	0001a109 	.word	0x0001a109
    21ac:	0001a828 	.word	0x0001a828

000021b0 <uart_ch_rssi>:
    default:
        return true;
    }
}

void uart_ch_rssi(struct Ch_data e) {
    21b0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    21b2:	ab04      	add	r3, sp, #16
    21b4:	e903 0003 	stmdb	r3, {r0, r1}
    uart_printf("%d %d %d %d %d\n", e.n, e.max, e.min, e.mean, e.var);
    21b8:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    21bc:	9301      	str	r3, [sp, #4]
    21be:	f89d 3008 	ldrb.w	r3, [sp, #8]
    21c2:	9300      	str	r3, [sp, #0]
    21c4:	f89d 200b 	ldrb.w	r2, [sp, #11]
    21c8:	f89d 300a 	ldrb.w	r3, [sp, #10]
    21cc:	f89d 1009 	ldrb.w	r1, [sp, #9]
    21d0:	4802      	ldr	r0, [pc, #8]	; (21dc <uart_ch_rssi+0x2c>)
    21d2:	f7ff fc57 	bl	1a84 <uart_printf>

}
    21d6:	b005      	add	sp, #20
    21d8:	f85d fb04 	ldr.w	pc, [sp], #4
    21dc:	0001a136 	.word	0x0001a136

000021e0 <in_encounters_fifo>:

int in_encounters_fifo(const uint8_t * mac, uint32_t epoch_minute) {
    21e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     *
     * Search backward during the "last minutes" worth of encounters
     *
     */
    Encounter_record *current_encounter;
    if (c_fifo_last_idx == 0) return -1;
    21e2:	4b0c      	ldr	r3, [pc, #48]	; (2214 <in_encounters_fifo+0x34>)
    21e4:	681c      	ldr	r4, [r3, #0]
int in_encounters_fifo(const uint8_t * mac, uint32_t epoch_minute) {
    21e6:	4605      	mov	r5, r0
    21e8:	460e      	mov	r6, r1
    if (c_fifo_last_idx == 0) return -1;
    21ea:	b17c      	cbz	r4, 220c <in_encounters_fifo+0x2c>
    int start = c_fifo_last_idx - 1;
    do {
        current_encounter = encounters + (start & 0x3F);
    21ec:	4f0a      	ldr	r7, [pc, #40]	; (2218 <in_encounters_fifo+0x38>)
    int start = c_fifo_last_idx - 1;
    21ee:	3c01      	subs	r4, #1
        current_encounter = encounters + (start & 0x3F);
    21f0:	f004 033f 	and.w	r3, r4, #63	; 0x3f
    21f4:	eb07 1083 	add.w	r0, r7, r3, lsl #6
        if (current_encounter->minute < epoch_minute) return -1;
    21f8:	6883      	ldr	r3, [r0, #8]
    21fa:	42b3      	cmp	r3, r6
    21fc:	d306      	bcc.n	220c <in_encounters_fifo+0x2c>
        if (memcmp(current_encounter->mac, mac, 6) == 0) return start;
    21fe:	2206      	movs	r2, #6
    2200:	4629      	mov	r1, r5
    2202:	f013 ff0a 	bl	1601a <memcmp>
    2206:	b118      	cbz	r0, 2210 <in_encounters_fifo+0x30>
        start--;
    } while (start>=0);
    2208:	3c01      	subs	r4, #1
    220a:	d5f1      	bpl.n	21f0 <in_encounters_fifo+0x10>
    if (c_fifo_last_idx == 0) return -1;
    220c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    return -1;
}
    2210:	4620      	mov	r0, r4
    2212:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2214:	2000008c 	.word	0x2000008c
    2218:	2000009c 	.word	0x2000009c

0000221c <scan_cb_orig>:

static void scan_cb_orig(const bt_addr_le_t *addr, s8_t rssi, u8_t adv_type,
            struct net_buf_simple *buf)
{
    221c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2220:	b095      	sub	sp, #84	; 0x54
    // flash(&led2);
    u8_t uuid16[2] = {0, 0};
    2222:	2500      	movs	r5, #0
{
    2224:	4683      	mov	fp, r0
    2226:	460f      	mov	r7, r1
    2228:	4698      	mov	r8, r3
    u8_t uuid16[2] = {0, 0};
    222a:	f8ad 5000 	strh.w	r5, [sp]
	return z_impl_k_uptime_ticks();
    222e:	f016 fecd 	bl	18fcc <z_impl_k_uptime_ticks>
    2232:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    2236:	460a      	mov	r2, r1
    2238:	fba0 0103 	umull	r0, r1, r0, r3
    223c:	fb03 1102 	mla	r1, r3, r2, r1
    2240:	0bc4      	lsrs	r4, r0, #15
    2242:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
    // uint8_t raw_event[32];
    char rpi_string[64];
    bt_addr_le_t a[CONFIG_BT_ID_MAX];
    int count;
    
    bt_id_get(a, &count);
    2246:	a802      	add	r0, sp, #8
    2248:	a901      	add	r1, sp, #4
    224a:	f005 fd77 	bl	7d3c <bt_id_get>
    uart_printf("num of id: %d\n", count);
    224e:	9901      	ldr	r1, [sp, #4]
    2250:	4876      	ldr	r0, [pc, #472]	; (242c <scan_cb_orig+0x210>)
    for (int i=0; i<count; i++) {
        bt_addr_le_to_str(a+i, rpi_string, BT_ADDR_STR_LEN);
        uart_printf("id %d: %s\n", i, rpi_string);
    2252:	4e77      	ldr	r6, [pc, #476]	; (2430 <scan_cb_orig+0x214>)
    uart_printf("num of id: %d\n", count);
    2254:	f7ff fc16 	bl	1a84 <uart_printf>
    for (int i=0; i<count; i++) {
    2258:	9b01      	ldr	r3, [sp, #4]
    225a:	42ab      	cmp	r3, r5
    225c:	f300 80a0 	bgt.w	23a0 <scan_cb_orig+0x184>
    int size = 0;
    for(u8_t i=0; i<buf->len; i++) {
        size += sprintf(rpi_string+size, "%02X", buf->data[i]);
    }
    */
    uart_printf("name: %s\n", bt_get_name());
    2260:	f005 fd68 	bl	7d34 <bt_get_name>
    2264:	4601      	mov	r1, r0
    2266:	4873      	ldr	r0, [pc, #460]	; (2434 <scan_cb_orig+0x218>)
        raw_event[10] = saewoo_hack[0]+37;
        raw_event[11] = rssi;
        memcpy(raw_event+12, buf->data+6, 20);  // skip 0x6FFD patterns
        */

        uart_printf("ch: %d, rssi: %d ", 37+saewoo_hack[0], rssi);
    2268:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 245c <scan_cb_orig+0x240>
    uart_printf("name: %s\n", bt_get_name());
    226c:	f7ff fc0a 	bl	1a84 <uart_printf>
    bt_addr_le_to_str(addr, rpi_string, BT_ADDR_STR_LEN);
    2270:	a904      	add	r1, sp, #16
    2272:	4658      	mov	r0, fp
    2274:	f7ff ff60 	bl	2138 <bt_addr_le_to_str.constprop.0>
    uart_printf("%s  ", rpi_string);
    2278:	486f      	ldr	r0, [pc, #444]	; (2438 <scan_cb_orig+0x21c>)
    227a:	a904      	add	r1, sp, #16
    227c:	f7ff fc02 	bl	1a84 <uart_printf>
    bt_data_parse(buf, data_cb_local, uuid16);
    2280:	496e      	ldr	r1, [pc, #440]	; (243c <scan_cb_orig+0x220>)
    2282:	466a      	mov	r2, sp
    2284:	4640      	mov	r0, r8
    2286:	f005 fb77 	bl	7978 <bt_data_parse>
    rssi = -rssi;
    228a:	427f      	negs	r7, r7
        flash(&led2);
    228c:	486c      	ldr	r0, [pc, #432]	; (2440 <scan_cb_orig+0x224>)
    228e:	f012 fb2d 	bl	148ec <flash>
    rssi = -rssi;
    2292:	b2ff      	uxtb	r7, r7
        uart_printf("ch: %d, rssi: %d ", 37+saewoo_hack[0], rssi);
    2294:	f89a 1000 	ldrb.w	r1, [sl]
    2298:	486a      	ldr	r0, [pc, #424]	; (2444 <scan_cb_orig+0x228>)
    229a:	fa4f f987 	sxtb.w	r9, r7
    229e:	464a      	mov	r2, r9
    22a0:	3125      	adds	r1, #37	; 0x25
    22a2:	f7ff fbef 	bl	1a84 <uart_printf>

        int sec_timestamp = (timestamp - (next_minute - 60000)) / 1000;
    22a6:	4b68      	ldr	r3, [pc, #416]	; (2448 <scan_cb_orig+0x22c>)
        uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    22a8:	4a68      	ldr	r2, [pc, #416]	; (244c <scan_cb_orig+0x230>)
        int sec_timestamp = (timestamp - (next_minute - 60000)) / 1000;
    22aa:	681e      	ldr	r6, [r3, #0]
        uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    22ac:	6815      	ldr	r5, [r2, #0]
        int sec_timestamp = (timestamp - (next_minute - 60000)) / 1000;
    22ae:	f5c6 466a 	rsb	r6, r6, #59904	; 0xea00
    22b2:	3660      	adds	r6, #96	; 0x60
    22b4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    22b8:	4426      	add	r6, r4
        uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    22ba:	1b65      	subs	r5, r4, r5
        int sec_timestamp = (timestamp - (next_minute - 60000)) / 1000;
    22bc:	fbb6 f6f3 	udiv	r6, r6, r3
        uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    22c0:	fbb5 f5f3 	udiv	r5, r5, r3
    22c4:	4b62      	ldr	r3, [pc, #392]	; (2450 <scan_cb_orig+0x234>)
    22c6:	681c      	ldr	r4, [r3, #0]
        // Check if record already exists by mac
        int idx = in_encounters_fifo(addr->a.val, epoch_minute);
    22c8:	f10b 0b01 	add.w	fp, fp, #1
        uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    22cc:	233c      	movs	r3, #60	; 0x3c
    22ce:	4425      	add	r5, r4
        int idx = in_encounters_fifo(addr->a.val, epoch_minute);
    22d0:	4658      	mov	r0, fp
        uint32_t epoch_minute = ((timestamp-offsettime) / 1000 + epochtimesync)/60;
    22d2:	fbb5 f5f3 	udiv	r5, r5, r3
        int idx = in_encounters_fifo(addr->a.val, epoch_minute);
    22d6:	4629      	mov	r1, r5
    22d8:	f7ff ff82 	bl	21e0 <in_encounters_fifo>
        uart_printf("idx:%d  ", idx);
    22dc:	4601      	mov	r1, r0
        int idx = in_encounters_fifo(addr->a.val, epoch_minute);
    22de:	4604      	mov	r4, r0
        uart_printf("idx:%d  ", idx);
    22e0:	485c      	ldr	r0, [pc, #368]	; (2454 <scan_cb_orig+0x238>)
    22e2:	f7ff fbcf 	bl	1a84 <uart_printf>
        if (idx<0) {
    22e6:	2c00      	cmp	r4, #0
    22e8:	495b      	ldr	r1, [pc, #364]	; (2458 <scan_cb_orig+0x23c>)
    22ea:	b2f6      	uxtb	r6, r6
    22ec:	da66      	bge.n	23bc <scan_cb_orig+0x1a0>
            // No index returned
            current_encounter = encounters + (c_fifo_last_idx & 0x3F);
    22ee:	f8df 9170 	ldr.w	r9, [pc, #368]	; 2460 <scan_cb_orig+0x244>
    22f2:	f8d9 3000 	ldr.w	r3, [r9]
    22f6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    22fa:	eb01 1483 	add.w	r4, r1, r3, lsl #6
            //memcpy(encounters[c_fifo_last_idx&0x3F].mac, addr->a.val, 6);
            memcpy(current_encounter->mac, addr->a.val, 6);
    22fe:	2206      	movs	r2, #6
    2300:	4659      	mov	r1, fp
    2302:	4620      	mov	r0, r4
    2304:	f013 fe99 	bl	1603a <memcpy>
            current_encounter->rssi_data[saewoo_hack[0]].n = 1;
    2308:	f89a 2000 	ldrb.w	r2, [sl]
    230c:	2306      	movs	r3, #6
    230e:	fb03 4202 	mla	r2, r3, r2, r4
    2312:	2301      	movs	r3, #1
    2314:	f882 302d 	strb.w	r3, [r2, #45]	; 0x2d
            current_encounter->rssi_data[saewoo_hack[0]].max = rssi;
            current_encounter->rssi_data[saewoo_hack[0]].min = rssi;
            current_encounter->rssi_data[saewoo_hack[0]].mean = rssi;
            current_encounter->rssi_data[saewoo_hack[0]].var = 0;
    2318:	2300      	movs	r3, #0
    231a:	8613      	strh	r3, [r2, #48]	; 0x30
            current_encounter->rssi_data[saewoo_hack[0]].max = rssi;
    231c:	f882 702f 	strb.w	r7, [r2, #47]	; 0x2f
            current_encounter->rssi_data[saewoo_hack[0]].min = rssi;
    2320:	f882 702e 	strb.w	r7, [r2, #46]	; 0x2e
            current_encounter->rssi_data[saewoo_hack[0]].mean = rssi;
    2324:	f882 702c 	strb.w	r7, [r2, #44]	; 0x2c
            current_encounter->first_time = sec_timestamp;
    2328:	71a6      	strb	r6, [r4, #6]
            current_encounter->last_time = sec_timestamp;
    232a:	71e6      	strb	r6, [r4, #7]
            current_encounter->minute = epoch_minute;
    232c:	60a5      	str	r5, [r4, #8]
            uart_ch_rssi(current_encounter->rssi_data[saewoo_hack[0]]);
    232e:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
    2330:	8e11      	ldrh	r1, [r2, #48]	; 0x30
    2332:	f7ff ff3d 	bl	21b0 <uart_ch_rssi>
            c_fifo_last_idx++;
    2336:	f8d9 3000 	ldr.w	r3, [r9]
    233a:	3301      	adds	r3, #1
    233c:	f8c9 3000 	str.w	r3, [r9]
            current_encounter->minute = epoch_minute;
            uart_ch_rssi(current_encounter->rssi_data[saewoo_hack[0]]);
        }
        // Update bobs shared key
        uint8_t hi_lo_byte = *(buf->data+6);
        if (( current_encounter->flag &0x3) < 3) {
    2340:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    2344:	f003 0203 	and.w	r2, r3, #3
    2348:	2a03      	cmp	r2, #3
    234a:	d026      	beq.n	239a <scan_cb_orig+0x17e>
        uint8_t hi_lo_byte = *(buf->data+6);
    234c:	f8d8 1000 	ldr.w	r1, [r8]
    2350:	798d      	ldrb	r5, [r1, #6]
            if (((current_encounter->flag & 0x1) == 0) && (hi_lo_byte==0)) {
    2352:	f003 0301 	and.w	r3, r3, #1
    2356:	432b      	orrs	r3, r5
    2358:	d10b      	bne.n	2372 <scan_cb_orig+0x156>
                memcpy(current_encounter->public_key, buf->data+6+4, 16);
    235a:	2210      	movs	r2, #16
    235c:	310a      	adds	r1, #10
    235e:	f104 000c 	add.w	r0, r4, #12
    2362:	f013 fe6a 	bl	1603a <memcpy>
                current_encounter->flag |= 0x1;
    2366:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    236a:	f043 0301 	orr.w	r3, r3, #1
    236e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
            }
            if (((current_encounter->flag & 0x2) == 0) && (hi_lo_byte==1)) {
    2372:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    2376:	079b      	lsls	r3, r3, #30
    2378:	d40f      	bmi.n	239a <scan_cb_orig+0x17e>
    237a:	2d01      	cmp	r5, #1
    237c:	d10d      	bne.n	239a <scan_cb_orig+0x17e>
                memcpy(current_encounter->public_key+16, buf->data+6+4, 16);
    237e:	f8d8 1000 	ldr.w	r1, [r8]
    2382:	2210      	movs	r2, #16
    2384:	310a      	adds	r1, #10
    2386:	f104 001c 	add.w	r0, r4, #28
    238a:	f013 fe56 	bl	1603a <memcpy>
                current_encounter->flag |= 0x2;
    238e:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    2392:	f043 0302 	orr.w	r3, r3, #2
    2396:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
            }
        }

        // uart_encounter(*current_encounter);
    }
}
    239a:	b015      	add	sp, #84	; 0x54
    239c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bt_addr_le_to_str(a+i, rpi_string, BT_ADDR_STR_LEN);
    23a0:	ab02      	add	r3, sp, #8
    23a2:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    23a6:	a904      	add	r1, sp, #16
    23a8:	4418      	add	r0, r3
    23aa:	f7ff fec5 	bl	2138 <bt_addr_le_to_str.constprop.0>
        uart_printf("id %d: %s\n", i, rpi_string);
    23ae:	4629      	mov	r1, r5
    23b0:	aa04      	add	r2, sp, #16
    23b2:	4630      	mov	r0, r6
    23b4:	f7ff fb66 	bl	1a84 <uart_printf>
    for (int i=0; i<count; i++) {
    23b8:	3501      	adds	r5, #1
    23ba:	e74d      	b.n	2258 <scan_cb_orig+0x3c>
            current_encounter = encounters + idx;
    23bc:	eb01 1484 	add.w	r4, r1, r4, lsl #6
            int n = ++current_encounter->rssi_data[saewoo_hack[0]].n;
    23c0:	f89a 1000 	ldrb.w	r1, [sl]
    23c4:	2206      	movs	r2, #6
    23c6:	fb02 4001 	mla	r0, r2, r1, r4
            if (rssi < current_encounter->rssi_data[saewoo_hack[0]].max) {
    23ca:	fb02 4201 	mla	r2, r2, r1, r4
            int n = ++current_encounter->rssi_data[saewoo_hack[0]].n;
    23ce:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
            if (rssi > current_encounter->rssi_data[saewoo_hack[0]].max) {
    23d2:	f890 c02f 	ldrb.w	ip, [r0, #47]	; 0x2f
            int n = ++current_encounter->rssi_data[saewoo_hack[0]].n;
    23d6:	3301      	adds	r3, #1
            if (rssi > current_encounter->rssi_data[saewoo_hack[0]].max) {
    23d8:	45e1      	cmp	r9, ip
            int n = ++current_encounter->rssi_data[saewoo_hack[0]].n;
    23da:	b2db      	uxtb	r3, r3
                current_encounter->rssi_data[saewoo_hack[0]].max = rssi;
    23dc:	bfc8      	it	gt
    23de:	f880 702f 	strbgt.w	r7, [r0, #47]	; 0x2f
            int n = ++current_encounter->rssi_data[saewoo_hack[0]].n;
    23e2:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
            if (rssi < current_encounter->rssi_data[saewoo_hack[0]].max) {
    23e6:	f892 002f 	ldrb.w	r0, [r2, #47]	; 0x2f
    23ea:	4581      	cmp	r9, r0
                current_encounter->rssi_data[saewoo_hack[0]].min = rssi;
    23ec:	bfb8      	it	lt
    23ee:	f882 702e 	strblt.w	r7, [r2, #46]	; 0x2e
            int mean = current_encounter->rssi_data[saewoo_hack[0]].mean;
    23f2:	2206      	movs	r2, #6
    23f4:	fb02 4101 	mla	r1, r2, r1, r4
    23f8:	f891 702c 	ldrb.w	r7, [r1, #44]	; 0x2c
            int new_mean = mean + (rssi - mean + n/2)/n;
    23fc:	eba9 0007 	sub.w	r0, r9, r7
    2400:	eb00 0253 	add.w	r2, r0, r3, lsr #1
    2404:	fb92 f3f3 	sdiv	r3, r2, r3
    2408:	19da      	adds	r2, r3, r7
            current_encounter->rssi_data[saewoo_hack[0]].mean = new_mean;
    240a:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
            current_encounter->rssi_data[saewoo_hack[0]].var += (rssi-new_mean)*(rssi-mean);
    240e:	eba9 0902 	sub.w	r9, r9, r2
    2412:	8e0a      	ldrh	r2, [r1, #48]	; 0x30
    2414:	fb09 2900 	mla	r9, r9, r0, r2
    2418:	f8a1 9030 	strh.w	r9, [r1, #48]	; 0x30
            current_encounter->last_time = sec_timestamp;
    241c:	71e6      	strb	r6, [r4, #7]
            current_encounter->minute = epoch_minute;
    241e:	60a5      	str	r5, [r4, #8]
            uart_ch_rssi(current_encounter->rssi_data[saewoo_hack[0]]);
    2420:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
    2422:	8e09      	ldrh	r1, [r1, #48]	; 0x30
    2424:	f7ff fec4 	bl	21b0 <uart_ch_rssi>
    2428:	e78a      	b.n	2340 <scan_cb_orig+0x124>
    242a:	bf00      	nop
    242c:	0001a146 	.word	0x0001a146
    2430:	0001a155 	.word	0x0001a155
    2434:	0001a160 	.word	0x0001a160
    2438:	0001a16a 	.word	0x0001a16a
    243c:	00014919 	.word	0x00014919
    2440:	2000bb3c 	.word	0x2000bb3c
    2444:	0001a16f 	.word	0x0001a16f
    2448:	200010d8 	.word	0x200010d8
    244c:	200010dc 	.word	0x200010dc
    2450:	2000109c 	.word	0x2000109c
    2454:	0001a181 	.word	0x0001a181
    2458:	2000009c 	.word	0x2000009c
    245c:	20007a31 	.word	0x20007a31
    2460:	2000008c 	.word	0x2000008c

00002464 <start_scan>:


void start_scan(void) {
    //  Start Scan
    int err = bt_le_scan_start(&scan_param, scan_cb_orig);
    2464:	4908      	ldr	r1, [pc, #32]	; (2488 <start_scan+0x24>)
    2466:	4809      	ldr	r0, [pc, #36]	; (248c <start_scan+0x28>)
void start_scan(void) {
    2468:	b508      	push	{r3, lr}
    int err = bt_le_scan_start(&scan_param, scan_cb_orig);
    246a:	f006 f901 	bl	8670 <bt_le_scan_start>
    if (err) {
    246e:	4601      	mov	r1, r0
    2470:	b120      	cbz	r0, 247c <start_scan+0x18>
        return;
    } else {
        printk("Scan started\n");
    }

}
    2472:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        printk("Starting scanning failed (err %d)\n", err);
    2476:	4806      	ldr	r0, [pc, #24]	; (2490 <start_scan+0x2c>)
    2478:	f012 bb57 	b.w	14b2a <printk>
}
    247c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        printk("Scan started\n");
    2480:	4804      	ldr	r0, [pc, #16]	; (2494 <start_scan+0x30>)
    2482:	f012 bb52 	b.w	14b2a <printk>
    2486:	bf00      	nop
    2488:	0000221d 	.word	0x0000221d
    248c:	2000bb9c 	.word	0x2000bb9c
    2490:	0001a18a 	.word	0x0001a18a
    2494:	0001a1ad 	.word	0x0001a1ad

00002498 <stop_scan>:

void stop_scan(void) {
    2498:	b508      	push	{r3, lr}
    int err = bt_le_scan_stop();
    249a:	f006 f99f 	bl	87dc <bt_le_scan_stop>
    if (err) {
    249e:	4601      	mov	r1, r0
    24a0:	b120      	cbz	r0, 24ac <stop_scan+0x14>
        printk("Stop scanning failed (err %d)\n", err);
        return;
    } else {
        printk("Scan stopped\n");
    }
}
    24a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        printk("Stop scanning failed (err %d)\n", err);
    24a6:	4804      	ldr	r0, [pc, #16]	; (24b8 <stop_scan+0x20>)
    24a8:	f012 bb3f 	b.w	14b2a <printk>
}
    24ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        printk("Scan stopped\n");
    24b0:	4802      	ldr	r0, [pc, #8]	; (24bc <stop_scan+0x24>)
    24b2:	f012 bb3a 	b.w	14b2a <printk>
    24b6:	bf00      	nop
    24b8:	0001a1bb 	.word	0x0001a1bb
    24bc:	0001a1da 	.word	0x0001a1da

000024c0 <sys_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
    24c0:	68c2      	ldr	r2, [r0, #12]
{
    24c2:	b508      	push	{r3, lr}
	if (mutex->kernel_mutex.lock_count == 0) {
    24c4:	b142      	cbz	r2, 24d8 <sys_mutex_unlock+0x18>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
    24c6:	4b07      	ldr	r3, [pc, #28]	; (24e4 <sys_mutex_unlock+0x24>)
    24c8:	6882      	ldr	r2, [r0, #8]
    24ca:	689b      	ldr	r3, [r3, #8]
    24cc:	429a      	cmp	r2, r3
    24ce:	d106      	bne.n	24de <sys_mutex_unlock+0x1e>
	return z_impl_k_mutex_unlock(mutex);
    24d0:	f011 fb70 	bl	13bb4 <z_impl_k_mutex_unlock>
		return -EPERM;
	}

	k_mutex_unlock(&mutex->kernel_mutex);
	return 0;
    24d4:	2000      	movs	r0, #0
}
    24d6:	bd08      	pop	{r3, pc}
		return -EINVAL;
    24d8:	f06f 0015 	mvn.w	r0, #21
    24dc:	e7fb      	b.n	24d6 <sys_mutex_unlock+0x16>
		return -EPERM;
    24de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    24e2:	e7f8      	b.n	24d6 <sys_mutex_unlock+0x16>
    24e4:	200040e8 	.word	0x200040e8

000024e8 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    24e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    24ec:	b085      	sub	sp, #20
    24ee:	469b      	mov	fp, r3
    24f0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    24f2:	f8df 9090 	ldr.w	r9, [pc, #144]	; 2584 <_printk_dec_ulong+0x9c>
    24f6:	2c01      	cmp	r4, #1
    24f8:	bfb8      	it	lt
    24fa:	2401      	movlt	r4, #1
    24fc:	2b01      	cmp	r3, #1
    24fe:	bf0c      	ite	eq
    2500:	2330      	moveq	r3, #48	; 0x30
    2502:	2320      	movne	r3, #32
    2504:	4615      	mov	r5, r2
    2506:	4606      	mov	r6, r0
    2508:	468a      	mov	sl, r1
    250a:	9302      	str	r3, [sp, #8]
    250c:	2701      	movs	r7, #1
    250e:	f04f 080a 	mov.w	r8, #10
    2512:	2200      	movs	r2, #0
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    2514:	fbb5 f3f9 	udiv	r3, r5, r9
    2518:	9301      	str	r3, [sp, #4]
    251a:	b90a      	cbnz	r2, 2520 <_printk_dec_ulong+0x38>
    251c:	45a9      	cmp	r9, r5
    251e:	d81f      	bhi.n	2560 <_printk_dec_ulong+0x78>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    2520:	9b01      	ldr	r3, [sp, #4]
    2522:	4651      	mov	r1, sl
    2524:	f103 0030 	add.w	r0, r3, #48	; 0x30
    2528:	47b0      	blx	r6
			digits++;
    252a:	3701      	adds	r7, #1
			found_largest_digit = 1;
    252c:	2201      	movs	r2, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    252e:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    2530:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
	while (pos >= 10) {
    2534:	f1b8 0f01 	cmp.w	r8, #1
		remainder %= pos;
    2538:	fb09 5513 	mls	r5, r9, r3, r5
		pos /= 10;
    253c:	f04f 030a 	mov.w	r3, #10
    2540:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    2544:	d1e6      	bne.n	2514 <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
    2546:	4651      	mov	r1, sl
    2548:	f105 0030 	add.w	r0, r5, #48	; 0x30
    254c:	47b0      	blx	r6

	if (padding == PAD_SPACE_AFTER) {
    254e:	f1bb 0f03 	cmp.w	fp, #3
    2552:	d102      	bne.n	255a <_printk_dec_ulong+0x72>
		remaining = min_width - digits;
    2554:	1be4      	subs	r4, r4, r7
		while (remaining-- > 0) {
    2556:	2c00      	cmp	r4, #0
    2558:	dc0e      	bgt.n	2578 <_printk_dec_ulong+0x90>
			out(' ', ctx);
		}
	}
}
    255a:	b005      	add	sp, #20
    255c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    2560:	4544      	cmp	r4, r8
    2562:	dbe4      	blt.n	252e <_printk_dec_ulong+0x46>
				&& padding < PAD_SPACE_AFTER) {
    2564:	f1bb 0f02 	cmp.w	fp, #2
    2568:	d8e1      	bhi.n	252e <_printk_dec_ulong+0x46>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    256a:	9802      	ldr	r0, [sp, #8]
    256c:	9203      	str	r2, [sp, #12]
    256e:	4651      	mov	r1, sl
    2570:	47b0      	blx	r6
			digits++;
    2572:	3701      	adds	r7, #1
    2574:	9a03      	ldr	r2, [sp, #12]
    2576:	e7da      	b.n	252e <_printk_dec_ulong+0x46>
			out(' ', ctx);
    2578:	4651      	mov	r1, sl
    257a:	2020      	movs	r0, #32
    257c:	47b0      	blx	r6
    257e:	3c01      	subs	r4, #1
    2580:	e7e9      	b.n	2556 <_printk_dec_ulong+0x6e>
    2582:	bf00      	nop
    2584:	3b9aca00 	.word	0x3b9aca00

00002588 <__printk_hook_install>:
	_char_out = fn;
    2588:	4b01      	ldr	r3, [pc, #4]	; (2590 <__printk_hook_install+0x8>)
    258a:	6018      	str	r0, [r3, #0]
}
    258c:	4770      	bx	lr
    258e:	bf00      	nop
    2590:	2000bcb0 	.word	0x2000bcb0

00002594 <z_vprintk>:
{
    2594:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2598:	b08d      	sub	sp, #52	; 0x34
    259a:	461c      	mov	r4, r3
	char length_mod = 0;
    259c:	2700      	movs	r7, #0
    259e:	1e53      	subs	r3, r2, #1
{
    25a0:	4605      	mov	r5, r0
    25a2:	468b      	mov	fp, r1
    25a4:	9303      	str	r3, [sp, #12]
	int min_width = -1;
    25a6:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
    25aa:	46b8      	mov	r8, r7
			might_format = 0;
    25ac:	2600      	movs	r6, #0
					break;
    25ae:	e005      	b.n	25bc <z_vprintk+0x28>
		if (!might_format) {
    25b0:	b96e      	cbnz	r6, 25ce <z_vprintk+0x3a>
			if (*fmt != '%') {
    25b2:	2825      	cmp	r0, #37	; 0x25
    25b4:	f000 8171 	beq.w	289a <z_vprintk+0x306>
				out((int)*fmt, ctx);
    25b8:	4659      	mov	r1, fp
    25ba:	47a8      	blx	r5
	while (*fmt) {
    25bc:	9b03      	ldr	r3, [sp, #12]
    25be:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    25c2:	9303      	str	r3, [sp, #12]
    25c4:	2800      	cmp	r0, #0
    25c6:	d1f3      	bne.n	25b0 <z_vprintk+0x1c>
}
    25c8:	b00d      	add	sp, #52	; 0x34
    25ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
    25ce:	287a      	cmp	r0, #122	; 0x7a
    25d0:	d80a      	bhi.n	25e8 <z_vprintk+0x54>
    25d2:	2862      	cmp	r0, #98	; 0x62
    25d4:	d810      	bhi.n	25f8 <z_vprintk+0x64>
    25d6:	2830      	cmp	r0, #48	; 0x30
    25d8:	d054      	beq.n	2684 <z_vprintk+0xf0>
    25da:	d845      	bhi.n	2668 <z_vprintk+0xd4>
    25dc:	2825      	cmp	r0, #37	; 0x25
    25de:	f000 815a 	beq.w	2896 <z_vprintk+0x302>
    25e2:	282d      	cmp	r0, #45	; 0x2d
    25e4:	f000 815f 	beq.w	28a6 <z_vprintk+0x312>
					out((int)'%', ctx);
    25e8:	4659      	mov	r1, fp
    25ea:	2025      	movs	r0, #37	; 0x25
    25ec:	47a8      	blx	r5
					out((int)*fmt, ctx);
    25ee:	9b03      	ldr	r3, [sp, #12]
    25f0:	7818      	ldrb	r0, [r3, #0]
    25f2:	4659      	mov	r1, fp
    25f4:	47a8      	blx	r5
    25f6:	e7d9      	b.n	25ac <z_vprintk+0x18>
    25f8:	f1a0 0363 	sub.w	r3, r0, #99	; 0x63
    25fc:	2b17      	cmp	r3, #23
    25fe:	d8f3      	bhi.n	25e8 <z_vprintk+0x54>
    2600:	a201      	add	r2, pc, #4	; (adr r2, 2608 <z_vprintk+0x74>)
    2602:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2606:	bf00      	nop
    2608:	0000288f 	.word	0x0000288f
    260c:	000026d3 	.word	0x000026d3
    2610:	000025e9 	.word	0x000025e9
    2614:	000025e9 	.word	0x000025e9
    2618:	000025e9 	.word	0x000025e9
    261c:	000026b5 	.word	0x000026b5
    2620:	000026d3 	.word	0x000026d3
    2624:	000025e9 	.word	0x000025e9
    2628:	000025e9 	.word	0x000025e9
    262c:	000026b5 	.word	0x000026b5
    2630:	000025e9 	.word	0x000025e9
    2634:	000025e9 	.word	0x000025e9
    2638:	000025e9 	.word	0x000025e9
    263c:	00002775 	.word	0x00002775
    2640:	000025e9 	.word	0x000025e9
    2644:	000025e9 	.word	0x000025e9
    2648:	0000285f 	.word	0x0000285f
    264c:	000025e9 	.word	0x000025e9
    2650:	00002743 	.word	0x00002743
    2654:	000025e9 	.word	0x000025e9
    2658:	000025e9 	.word	0x000025e9
    265c:	00002671 	.word	0x00002671
    2660:	000025e9 	.word	0x000025e9
    2664:	000026b5 	.word	0x000026b5
			switch (*fmt) {
    2668:	2839      	cmp	r0, #57	; 0x39
    266a:	d91a      	bls.n	26a2 <z_vprintk+0x10e>
    266c:	2858      	cmp	r0, #88	; 0x58
    266e:	d1bb      	bne.n	25e8 <z_vprintk+0x54>
				if (*fmt == 'p') {
    2670:	9b03      	ldr	r3, [sp, #12]
    2672:	781b      	ldrb	r3, [r3, #0]
    2674:	2b70      	cmp	r3, #112	; 0x70
    2676:	f040 8088 	bne.w	278a <z_vprintk+0x1f6>
					x = va_arg(ap, unsigned int);
    267a:	f854 3b04 	ldr.w	r3, [r4], #4
    267e:	9306      	str	r3, [sp, #24]
    2680:	2200      	movs	r2, #0
    2682:	e090      	b.n	27a6 <z_vprintk+0x212>
				if (min_width < 0 && padding == PAD_NONE) {
    2684:	f1b9 0f00 	cmp.w	r9, #0
    2688:	da0e      	bge.n	26a8 <z_vprintk+0x114>
    268a:	f1b8 0f00 	cmp.w	r8, #0
    268e:	f000 810d 	beq.w	28ac <z_vprintk+0x318>
					min_width = *fmt - '0';
    2692:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
    2696:	f1b8 0f00 	cmp.w	r8, #0
    269a:	bf08      	it	eq
    269c:	f04f 0802 	moveq.w	r8, #2
    26a0:	e78c      	b.n	25bc <z_vprintk+0x28>
				if (min_width < 0) {
    26a2:	f1b9 0f00 	cmp.w	r9, #0
    26a6:	dbf4      	blt.n	2692 <z_vprintk+0xfe>
					min_width = 10 * min_width + *fmt - '0';
    26a8:	230a      	movs	r3, #10
    26aa:	fb03 0909 	mla	r9, r3, r9, r0
    26ae:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
    26b2:	e7f0      	b.n	2696 <z_vprintk+0x102>
				if (*fmt == 'h' && length_mod == 'h') {
    26b4:	2868      	cmp	r0, #104	; 0x68
    26b6:	d103      	bne.n	26c0 <z_vprintk+0x12c>
    26b8:	2f68      	cmp	r7, #104	; 0x68
    26ba:	d106      	bne.n	26ca <z_vprintk+0x136>
					length_mod = 'H';
    26bc:	2748      	movs	r7, #72	; 0x48
    26be:	e77d      	b.n	25bc <z_vprintk+0x28>
				} else if (*fmt == 'l' && length_mod == 'l') {
    26c0:	286c      	cmp	r0, #108	; 0x6c
    26c2:	d102      	bne.n	26ca <z_vprintk+0x136>
    26c4:	2f6c      	cmp	r7, #108	; 0x6c
    26c6:	f000 80f4 	beq.w	28b2 <z_vprintk+0x31e>
				} else if (length_mod == 0) {
    26ca:	2f00      	cmp	r7, #0
    26cc:	d18c      	bne.n	25e8 <z_vprintk+0x54>
    26ce:	4607      	mov	r7, r0
    26d0:	e774      	b.n	25bc <z_vprintk+0x28>
				if (length_mod == 'z') {
    26d2:	2f7a      	cmp	r7, #122	; 0x7a
    26d4:	d102      	bne.n	26dc <z_vprintk+0x148>
					d = va_arg(ap, int);
    26d6:	f854 6b04 	ldr.w	r6, [r4], #4
    26da:	e021      	b.n	2720 <z_vprintk+0x18c>
				} else if (length_mod == 'l') {
    26dc:	2f6c      	cmp	r7, #108	; 0x6c
    26de:	d0fa      	beq.n	26d6 <z_vprintk+0x142>
				} else if (length_mod == 'L') {
    26e0:	2f4c      	cmp	r7, #76	; 0x4c
    26e2:	d1f8      	bne.n	26d6 <z_vprintk+0x142>
					long long lld = va_arg(ap, long long);
    26e4:	3407      	adds	r4, #7
    26e6:	f024 0407 	bic.w	r4, r4, #7
    26ea:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    26ee:	e9cd 2304 	strd	r2, r3, [sp, #16]
					if (lld > __LONG_MAX__ ||
    26f2:	9b04      	ldr	r3, [sp, #16]
    26f4:	f113 4100 	adds.w	r1, r3, #2147483648	; 0x80000000
    26f8:	9b05      	ldr	r3, [sp, #20]
    26fa:	9108      	str	r1, [sp, #32]
    26fc:	f143 0100 	adc.w	r1, r3, #0
    2700:	9109      	str	r1, [sp, #36]	; 0x24
    2702:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    2706:	2100      	movs	r1, #0
    2708:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    270c:	4299      	cmp	r1, r3
    270e:	bf08      	it	eq
    2710:	4290      	cmpeq	r0, r2
    2712:	d204      	bcs.n	271e <z_vprintk+0x18a>
						print_err(out, ctx);
    2714:	4659      	mov	r1, fp
    2716:	4628      	mov	r0, r5
    2718:	f012 f9e6 	bl	14ae8 <print_err>
						break;
    271c:	e746      	b.n	25ac <z_vprintk+0x18>
					d = lld;
    271e:	9e04      	ldr	r6, [sp, #16]
				if (d < 0) {
    2720:	2e00      	cmp	r6, #0
    2722:	da05      	bge.n	2730 <z_vprintk+0x19c>
					out((int)'-', ctx);
    2724:	4659      	mov	r1, fp
    2726:	202d      	movs	r0, #45	; 0x2d
    2728:	47a8      	blx	r5
					d = -d;
    272a:	4276      	negs	r6, r6
					min_width--;
    272c:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
    2730:	f8cd 9000 	str.w	r9, [sp]
    2734:	4643      	mov	r3, r8
    2736:	4632      	mov	r2, r6
				_printk_dec_ulong(out, ctx, u, padding,
    2738:	4659      	mov	r1, fp
    273a:	4628      	mov	r0, r5
    273c:	f7ff fed4 	bl	24e8 <_printk_dec_ulong>
				break;
    2740:	e734      	b.n	25ac <z_vprintk+0x18>
				if (length_mod == 'z') {
    2742:	2f7a      	cmp	r7, #122	; 0x7a
    2744:	d102      	bne.n	274c <z_vprintk+0x1b8>
					u = va_arg(ap, unsigned int);
    2746:	f854 2b04 	ldr.w	r2, [r4], #4
    274a:	e00f      	b.n	276c <z_vprintk+0x1d8>
				} else if (length_mod == 'l') {
    274c:	2f6c      	cmp	r7, #108	; 0x6c
    274e:	d0fa      	beq.n	2746 <z_vprintk+0x1b2>
				} else if (length_mod == 'L') {
    2750:	2f4c      	cmp	r7, #76	; 0x4c
    2752:	d1f8      	bne.n	2746 <z_vprintk+0x1b2>
					unsigned long long llu =
    2754:	3407      	adds	r4, #7
    2756:	f024 0407 	bic.w	r4, r4, #7
    275a:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
    275e:	2100      	movs	r1, #0
    2760:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2764:	4299      	cmp	r1, r3
    2766:	bf08      	it	eq
    2768:	4290      	cmpeq	r0, r2
    276a:	d3d3      	bcc.n	2714 <z_vprintk+0x180>
				_printk_dec_ulong(out, ctx, u, padding,
    276c:	f8cd 9000 	str.w	r9, [sp]
    2770:	4643      	mov	r3, r8
    2772:	e7e1      	b.n	2738 <z_vprintk+0x1a4>
				out('0', ctx);
    2774:	4659      	mov	r1, fp
    2776:	2030      	movs	r0, #48	; 0x30
    2778:	47a8      	blx	r5
				out('x', ctx);
    277a:	4659      	mov	r1, fp
    277c:	2078      	movs	r0, #120	; 0x78
    277e:	47a8      	blx	r5
					min_width = 8;
    2780:	f04f 0908 	mov.w	r9, #8
				padding = PAD_ZERO_BEFORE;
    2784:	f04f 0801 	mov.w	r8, #1
    2788:	e772      	b.n	2670 <z_vprintk+0xdc>
				} else if (length_mod == 'l') {
    278a:	2f6c      	cmp	r7, #108	; 0x6c
    278c:	f43f af75 	beq.w	267a <z_vprintk+0xe6>
				} else if (length_mod == 'L') {
    2790:	2f4c      	cmp	r7, #76	; 0x4c
    2792:	f47f af72 	bne.w	267a <z_vprintk+0xe6>
					x = va_arg(ap, unsigned long long);
    2796:	1de3      	adds	r3, r4, #7
    2798:	f023 0307 	bic.w	r3, r3, #7
    279c:	461c      	mov	r4, r3
    279e:	f854 2b08 	ldr.w	r2, [r4], #8
    27a2:	9206      	str	r2, [sp, #24]
    27a4:	685a      	ldr	r2, [r3, #4]
	int digits = 0;
    27a6:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
    27a8:	2310      	movs	r3, #16
	int digits = 0;
    27aa:	9104      	str	r1, [sp, #16]
	int found_largest_digit = 0;
    27ac:	9107      	str	r1, [sp, #28]
	int shift = sizeof(num) * 8;
    27ae:	f04f 0a40 	mov.w	sl, #64	; 0x40
		shift -= 4;
    27b2:	f1aa 0a04 	sub.w	sl, sl, #4
		nibble = (num >> shift) & 0xf;
    27b6:	9906      	ldr	r1, [sp, #24]
    27b8:	f1ca 0e20 	rsb	lr, sl, #32
    27bc:	f1aa 0c20 	sub.w	ip, sl, #32
    27c0:	fa21 f00a 	lsr.w	r0, r1, sl
    27c4:	fa02 fe0e 	lsl.w	lr, r2, lr
    27c8:	ea40 000e 	orr.w	r0, r0, lr
    27cc:	fa22 fc0c 	lsr.w	ip, r2, ip
    27d0:	ea40 000c 	orr.w	r0, r0, ip
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    27d4:	f010 000f 	ands.w	r0, r0, #15
    27d8:	d107      	bne.n	27ea <z_vprintk+0x256>
    27da:	9907      	ldr	r1, [sp, #28]
    27dc:	b911      	cbnz	r1, 27e4 <z_vprintk+0x250>
    27de:	f1ba 0f00 	cmp.w	sl, #0
    27e2:	d125      	bne.n	2830 <z_vprintk+0x29c>
			nibble += nibble > 9 ? 87 : 48;
    27e4:	f04f 0c30 	mov.w	ip, #48	; 0x30
    27e8:	e005      	b.n	27f6 <z_vprintk+0x262>
    27ea:	2809      	cmp	r0, #9
    27ec:	bf8c      	ite	hi
    27ee:	f04f 0c57 	movhi.w	ip, #87	; 0x57
    27f2:	f04f 0c30 	movls.w	ip, #48	; 0x30
    27f6:	4460      	add	r0, ip
			out((int)nibble, ctx);
    27f8:	4659      	mov	r1, fp
    27fa:	b240      	sxtb	r0, r0
    27fc:	920a      	str	r2, [sp, #40]	; 0x28
    27fe:	9307      	str	r3, [sp, #28]
    2800:	47a8      	blx	r5
			digits++;
    2802:	9b04      	ldr	r3, [sp, #16]
	while (shift >= 4) {
    2804:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			digits++;
    2806:	3301      	adds	r3, #1
    2808:	9304      	str	r3, [sp, #16]
	while (shift >= 4) {
    280a:	9b07      	ldr	r3, [sp, #28]
    280c:	f1ba 0f00 	cmp.w	sl, #0
    2810:	d123      	bne.n	285a <z_vprintk+0x2c6>
	if (padding == PAD_SPACE_AFTER) {
    2812:	f1b8 0f03 	cmp.w	r8, #3
    2816:	f47f aec9 	bne.w	25ac <z_vprintk+0x18>
		remaining = min_width * 2 - digits;
    281a:	9b04      	ldr	r3, [sp, #16]
    281c:	ebc3 0649 	rsb	r6, r3, r9, lsl #1
		while (remaining-- > 0) {
    2820:	2e00      	cmp	r6, #0
    2822:	f77f aec3 	ble.w	25ac <z_vprintk+0x18>
			out(' ', ctx);
    2826:	4659      	mov	r1, fp
    2828:	2020      	movs	r0, #32
    282a:	47a8      	blx	r5
    282c:	3e01      	subs	r6, #1
    282e:	e7f7      	b.n	2820 <z_vprintk+0x28c>
		if (remaining-- <= min_width) {
    2830:	1e59      	subs	r1, r3, #1
    2832:	4599      	cmp	r9, r3
    2834:	910a      	str	r1, [sp, #40]	; 0x28
    2836:	db07      	blt.n	2848 <z_vprintk+0x2b4>
			if (padding == PAD_ZERO_BEFORE) {
    2838:	f1b8 0f01 	cmp.w	r8, #1
    283c:	d106      	bne.n	284c <z_vprintk+0x2b8>
    283e:	920b      	str	r2, [sp, #44]	; 0x2c
				out('0', ctx);
    2840:	4659      	mov	r1, fp
    2842:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
    2844:	47a8      	blx	r5
    2846:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
			nibble += nibble > 9 ? 87 : 48;
    2848:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    284a:	e7b2      	b.n	27b2 <z_vprintk+0x21e>
			} else if (padding == PAD_SPACE_BEFORE) {
    284c:	f1b8 0f02 	cmp.w	r8, #2
    2850:	d1fa      	bne.n	2848 <z_vprintk+0x2b4>
    2852:	920b      	str	r2, [sp, #44]	; 0x2c
				out(' ', ctx);
    2854:	4659      	mov	r1, fp
    2856:	2020      	movs	r0, #32
    2858:	e7f4      	b.n	2844 <z_vprintk+0x2b0>
			found_largest_digit = 1;
    285a:	9607      	str	r6, [sp, #28]
    285c:	e7a9      	b.n	27b2 <z_vprintk+0x21e>
				char *s = va_arg(ap, char *);
    285e:	f854 6b04 	ldr.w	r6, [r4], #4
				while (*s) {
    2862:	46b2      	mov	sl, r6
    2864:	4653      	mov	r3, sl
    2866:	f81a 0b01 	ldrb.w	r0, [sl], #1
    286a:	b968      	cbnz	r0, 2888 <z_vprintk+0x2f4>
				if (padding == PAD_SPACE_AFTER) {
    286c:	f1b8 0f03 	cmp.w	r8, #3
    2870:	d121      	bne.n	28b6 <z_vprintk+0x322>
					int remaining = min_width - (s - start);
    2872:	1b9e      	subs	r6, r3, r6
    2874:	eba9 0606 	sub.w	r6, r9, r6
					while (remaining-- > 0) {
    2878:	2e00      	cmp	r6, #0
    287a:	f77f ae97 	ble.w	25ac <z_vprintk+0x18>
						out(' ', ctx);
    287e:	4659      	mov	r1, fp
    2880:	2020      	movs	r0, #32
    2882:	47a8      	blx	r5
    2884:	3e01      	subs	r6, #1
    2886:	e7f7      	b.n	2878 <z_vprintk+0x2e4>
					out((int)(*s++), ctx);
    2888:	4659      	mov	r1, fp
    288a:	47a8      	blx	r5
    288c:	e7ea      	b.n	2864 <z_vprintk+0x2d0>
				out(c, ctx);
    288e:	f854 0b04 	ldr.w	r0, [r4], #4
    2892:	4659      	mov	r1, fp
    2894:	e6ae      	b.n	25f4 <z_vprintk+0x60>
				out((int)'%', ctx);
    2896:	4659      	mov	r1, fp
    2898:	e6ac      	b.n	25f4 <z_vprintk+0x60>
				length_mod = 0;
    289a:	4637      	mov	r7, r6
				padding = PAD_NONE;
    289c:	46b0      	mov	r8, r6
				min_width = -1;
    289e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
				might_format = 1;
    28a2:	2601      	movs	r6, #1
    28a4:	e68a      	b.n	25bc <z_vprintk+0x28>
			switch (*fmt) {
    28a6:	f04f 0803 	mov.w	r8, #3
    28aa:	e687      	b.n	25bc <z_vprintk+0x28>
					padding = PAD_ZERO_BEFORE;
    28ac:	f04f 0801 	mov.w	r8, #1
    28b0:	e684      	b.n	25bc <z_vprintk+0x28>
					length_mod = 'L';
    28b2:	274c      	movs	r7, #76	; 0x4c
    28b4:	e682      	b.n	25bc <z_vprintk+0x28>
			might_format = 0;
    28b6:	4606      	mov	r6, r0
		++fmt;
    28b8:	e680      	b.n	25bc <z_vprintk+0x28>
    28ba:	bf00      	nop

000028bc <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    28bc:	b530      	push	{r4, r5, lr}
    28be:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    28c0:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    28c4:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    28c6:	2500      	movs	r5, #0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    28c8:	4805      	ldr	r0, [pc, #20]	; (28e0 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    28ca:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    28cc:	a901      	add	r1, sp, #4
    28ce:	f7ff fe61 	bl	2594 <z_vprintk>

	if (ctx.count < ctx.max) {
    28d2:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    28d6:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    28d8:	bfb8      	it	lt
    28da:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    28dc:	b005      	add	sp, #20
    28de:	bd30      	pop	{r4, r5, pc}
    28e0:	00014b05 	.word	0x00014b05

000028e4 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    28e4:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    28e6:	490e      	ldr	r1, [pc, #56]	; (2920 <enable_logger+0x3c>)
    28e8:	480e      	ldr	r0, [pc, #56]	; (2924 <enable_logger+0x40>)
{
    28ea:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
    28ec:	2200      	movs	r2, #0
    28ee:	f016 fb96 	bl	1901e <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    28f2:	4d0d      	ldr	r5, [pc, #52]	; (2928 <enable_logger+0x44>)
    28f4:	490d      	ldr	r1, [pc, #52]	; (292c <enable_logger+0x48>)
    28f6:	2400      	movs	r4, #0
    28f8:	230e      	movs	r3, #14
    28fa:	e9cd 4302 	strd	r4, r3, [sp, #8]
    28fe:	e9cd 4404 	strd	r4, r4, [sp, #16]
    2902:	e9cd 4400 	strd	r4, r4, [sp]
    2906:	4b0a      	ldr	r3, [pc, #40]	; (2930 <enable_logger+0x4c>)
    2908:	f44f 7240 	mov.w	r2, #768	; 0x300
    290c:	4628      	mov	r0, r5
    290e:	f011 fd73 	bl	143f8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    2912:	4908      	ldr	r1, [pc, #32]	; (2934 <enable_logger+0x50>)
    2914:	4628      	mov	r0, r5
    2916:	f016 fb10 	bl	18f3a <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    291a:	4620      	mov	r0, r4
    291c:	b007      	add	sp, #28
    291e:	bd30      	pop	{r4, r5, pc}
    2920:	00002939 	.word	0x00002939
    2924:	200011bc 	.word	0x200011bc
    2928:	20001204 	.word	0x20001204
    292c:	20008be0 	.word	0x20008be0
    2930:	00002d45 	.word	0x00002d45
    2934:	0001a1e8 	.word	0x0001a1e8

00002938 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    2938:	4801      	ldr	r0, [pc, #4]	; (2940 <log_process_thread_timer_expiry_fn+0x8>)
    293a:	f011 bcd7 	b.w	142ec <z_impl_k_sem_give>
    293e:	bf00      	nop
    2940:	2000c344 	.word	0x2000c344

00002944 <log_core_init>:
{
    2944:	b508      	push	{r3, lr}
		log_msg_pool_init();
    2946:	f000 fa5d 	bl	2e04 <log_msg_pool_init>
		log_list_init(&list);
    294a:	4809      	ldr	r0, [pc, #36]	; (2970 <log_core_init+0x2c>)
    294c:	f012 fc3a 	bl	151c4 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    2950:	2304      	movs	r3, #4
    2952:	2228      	movs	r2, #40	; 0x28
    2954:	4907      	ldr	r1, [pc, #28]	; (2974 <log_core_init+0x30>)
    2956:	4808      	ldr	r0, [pc, #32]	; (2978 <log_core_init+0x34>)
    2958:	f016 f883 	bl	18a62 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
    295c:	4b07      	ldr	r3, [pc, #28]	; (297c <log_core_init+0x38>)
    295e:	4a08      	ldr	r2, [pc, #32]	; (2980 <log_core_init+0x3c>)
    2960:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    2962:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
    2966:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
    296a:	f000 bc8f 	b.w	328c <log_output_timestamp_freq_set>
    296e:	bf00      	nop
    2970:	200011b4 	.word	0x200011b4
    2974:	2000b060 	.word	0x2000b060
    2978:	200011e8 	.word	0x200011e8
    297c:	2000bcb4 	.word	0x2000bcb4
    2980:	00015203 	.word	0x00015203

00002984 <dropped_notify>:
{
    2984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2986:	4b0f      	ldr	r3, [pc, #60]	; (29c4 <dropped_notify+0x40>)
    2988:	f3bf 8f5b 	dmb	ish
    298c:	2500      	movs	r5, #0
    298e:	e853 7f00 	ldrex	r7, [r3]
    2992:	e843 5200 	strex	r2, r5, [r3]
    2996:	2a00      	cmp	r2, #0
    2998:	d1f9      	bne.n	298e <dropped_notify+0xa>
    299a:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    299e:	4c0a      	ldr	r4, [pc, #40]	; (29c8 <dropped_notify+0x44>)
    29a0:	4e0a      	ldr	r6, [pc, #40]	; (29cc <dropped_notify+0x48>)
    29a2:	1b36      	subs	r6, r6, r4
    29a4:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    29a6:	42b5      	cmp	r5, r6
    29a8:	db00      	blt.n	29ac <dropped_notify+0x28>
}
    29aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    29ac:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    29ae:	795b      	ldrb	r3, [r3, #5]
    29b0:	b12b      	cbz	r3, 29be <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
    29b2:	6823      	ldr	r3, [r4, #0]
    29b4:	68db      	ldr	r3, [r3, #12]
    29b6:	b113      	cbz	r3, 29be <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
    29b8:	4639      	mov	r1, r7
    29ba:	4620      	mov	r0, r4
    29bc:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    29be:	3501      	adds	r5, #1
    29c0:	3410      	adds	r4, #16
    29c2:	e7f0      	b.n	29a6 <dropped_notify+0x22>
    29c4:	200011ac 	.word	0x200011ac
    29c8:	0001968c 	.word	0x0001968c
    29cc:	000196ac 	.word	0x000196ac

000029d0 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    29d0:	4b06      	ldr	r3, [pc, #24]	; (29ec <log_dropped+0x1c>)
    29d2:	f3bf 8f5b 	dmb	ish
    29d6:	e853 2f00 	ldrex	r2, [r3]
    29da:	3201      	adds	r2, #1
    29dc:	e843 2100 	strex	r1, r2, [r3]
    29e0:	2900      	cmp	r1, #0
    29e2:	d1f8      	bne.n	29d6 <log_dropped+0x6>
    29e4:	f3bf 8f5b 	dmb	ish
}
    29e8:	4770      	bx	lr
    29ea:	bf00      	nop
    29ec:	200011ac 	.word	0x200011ac

000029f0 <log_source_name_get>:
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    29f0:	4a04      	ldr	r2, [pc, #16]	; (2a04 <log_source_name_get+0x14>)
    29f2:	4b05      	ldr	r3, [pc, #20]	; (2a08 <log_source_name_get+0x18>)
    29f4:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    29f6:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
    29fa:	bf34      	ite	cc
    29fc:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
    2a00:	2000      	movcs	r0, #0
}
    2a02:	4770      	bx	lr
    2a04:	0001956c 	.word	0x0001956c
    2a08:	0001968c 	.word	0x0001968c

00002a0c <log_backend_enable>:
	id += backend - log_backend_get(0);
    2a0c:	4b09      	ldr	r3, [pc, #36]	; (2a34 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
    2a0e:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
    2a10:	1ac3      	subs	r3, r0, r3
    2a12:	111b      	asrs	r3, r3, #4
    2a14:	3301      	adds	r3, #1
{
    2a16:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
    2a18:	7113      	strb	r3, [r2, #4]
	log_backend_activate(backend, ctx);
    2a1a:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
    2a1c:	4c06      	ldr	r4, [pc, #24]	; (2a38 <log_backend_enable+0x2c>)
	backend->cb->ctx = ctx;
    2a1e:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    2a20:	2201      	movs	r2, #1
    2a22:	715a      	strb	r2, [r3, #5]
    2a24:	7822      	ldrb	r2, [r4, #0]
    2a26:	b912      	cbnz	r2, 2a2e <log_backend_enable+0x22>
    2a28:	4804      	ldr	r0, [pc, #16]	; (2a3c <log_backend_enable+0x30>)
    2a2a:	f011 fc5f 	bl	142ec <z_impl_k_sem_give>
	backend_attached = true;
    2a2e:	2301      	movs	r3, #1
    2a30:	7023      	strb	r3, [r4, #0]
}
    2a32:	bd10      	pop	{r4, pc}
    2a34:	0001968c 	.word	0x0001968c
    2a38:	20007a38 	.word	0x20007a38
    2a3c:	2000c344 	.word	0x2000c344

00002a40 <log_init>:
{
    2a40:	b570      	push	{r4, r5, r6, lr}
    2a42:	4b11      	ldr	r3, [pc, #68]	; (2a88 <log_init+0x48>)
    2a44:	f3bf 8f5b 	dmb	ish
    2a48:	e853 5f00 	ldrex	r5, [r3]
    2a4c:	1c6a      	adds	r2, r5, #1
    2a4e:	e843 2100 	strex	r1, r2, [r3]
    2a52:	2900      	cmp	r1, #0
    2a54:	d1f8      	bne.n	2a48 <log_init+0x8>
    2a56:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    2a5a:	b92d      	cbnz	r5, 2a68 <log_init+0x28>
	return __log_backends_end - __log_backends_start;
    2a5c:	4c0b      	ldr	r4, [pc, #44]	; (2a8c <log_init+0x4c>)
    2a5e:	4e0c      	ldr	r6, [pc, #48]	; (2a90 <log_init+0x50>)
    2a60:	1b36      	subs	r6, r6, r4
    2a62:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    2a64:	42b5      	cmp	r5, r6
    2a66:	db00      	blt.n	2a6a <log_init+0x2a>
}
    2a68:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    2a6a:	7b23      	ldrb	r3, [r4, #12]
    2a6c:	b143      	cbz	r3, 2a80 <log_init+0x40>
			if (backend->api->init != NULL) {
    2a6e:	6823      	ldr	r3, [r4, #0]
    2a70:	695b      	ldr	r3, [r3, #20]
    2a72:	b103      	cbz	r3, 2a76 <log_init+0x36>
				backend->api->init();
    2a74:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    2a76:	2204      	movs	r2, #4
    2a78:	2100      	movs	r1, #0
    2a7a:	4620      	mov	r0, r4
    2a7c:	f7ff ffc6 	bl	2a0c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    2a80:	3501      	adds	r5, #1
    2a82:	3410      	adds	r4, #16
    2a84:	e7ee      	b.n	2a64 <log_init+0x24>
    2a86:	bf00      	nop
    2a88:	200011b0 	.word	0x200011b0
    2a8c:	0001968c 	.word	0x0001968c
    2a90:	000196ac 	.word	0x000196ac

00002a94 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
    2a94:	4b16      	ldr	r3, [pc, #88]	; (2af0 <log_strdup+0x5c>)
    2a96:	4298      	cmp	r0, r3
{
    2a98:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2a9a:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    2a9c:	d302      	bcc.n	2aa4 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    2a9e:	4b15      	ldr	r3, [pc, #84]	; (2af4 <log_strdup+0x60>)
    2aa0:	4298      	cmp	r0, r3
    2aa2:	d31f      	bcc.n	2ae4 <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    2aa4:	4814      	ldr	r0, [pc, #80]	; (2af8 <log_strdup+0x64>)
    2aa6:	2200      	movs	r2, #0
    2aa8:	a901      	add	r1, sp, #4
    2aaa:	f010 ffa5 	bl	139f8 <k_mem_slab_alloc>
	if (err != 0) {
    2aae:	4605      	mov	r5, r0
    2ab0:	b9d8      	cbnz	r0, 2aea <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2ab2:	2201      	movs	r2, #1
    2ab4:	9b01      	ldr	r3, [sp, #4]
    2ab6:	f3bf 8f5b 	dmb	ish
    2aba:	e853 1f00 	ldrex	r1, [r3]
    2abe:	e843 2000 	strex	r0, r2, [r3]
    2ac2:	2800      	cmp	r0, #0
    2ac4:	d1f9      	bne.n	2aba <log_strdup+0x26>
    2ac6:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    2aca:	9801      	ldr	r0, [sp, #4]
    2acc:	4621      	mov	r1, r4
    2ace:	221f      	movs	r2, #31
    2ad0:	3004      	adds	r0, #4
    2ad2:	f013 fa5f 	bl	15f94 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    2ad6:	9c01      	ldr	r4, [sp, #4]
    2ad8:	237e      	movs	r3, #126	; 0x7e
    2ada:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    2ade:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
    2ae2:	3404      	adds	r4, #4
}
    2ae4:	4620      	mov	r0, r4
    2ae6:	b003      	add	sp, #12
    2ae8:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
    2aea:	4c04      	ldr	r4, [pc, #16]	; (2afc <log_strdup+0x68>)
    2aec:	e7fa      	b.n	2ae4 <log_strdup+0x50>
    2aee:	bf00      	nop
    2af0:	000192c0 	.word	0x000192c0
    2af4:	0001c2cc 	.word	0x0001c2cc
    2af8:	200011e8 	.word	0x200011e8
    2afc:	0001a1f0 	.word	0x0001a1f0

00002b00 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
    2b00:	b148      	cbz	r0, 2b16 <log_is_strdup+0x16>
    2b02:	4b05      	ldr	r3, [pc, #20]	; (2b18 <log_is_strdup+0x18>)
    2b04:	4298      	cmp	r0, r3
    2b06:	d305      	bcc.n	2b14 <log_is_strdup+0x14>
    2b08:	33a0      	adds	r3, #160	; 0xa0
    2b0a:	4298      	cmp	r0, r3
    2b0c:	bf2c      	ite	cs
    2b0e:	2000      	movcs	r0, #0
    2b10:	2001      	movcc	r0, #1
    2b12:	4770      	bx	lr
    2b14:	2000      	movs	r0, #0
}
    2b16:	4770      	bx	lr
    2b18:	2000b060 	.word	0x2000b060

00002b1c <z_impl_log_process>:
{
    2b1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
    2b20:	4b4c      	ldr	r3, [pc, #304]	; (2c54 <z_impl_log_process+0x138>)
    2b22:	781b      	ldrb	r3, [r3, #0]
{
    2b24:	b085      	sub	sp, #20
    2b26:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
    2b28:	b903      	cbnz	r3, 2b2c <z_impl_log_process+0x10>
    2b2a:	b360      	cbz	r0, 2b86 <z_impl_log_process+0x6a>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    2b2c:	f04f 0320 	mov.w	r3, #32
    2b30:	f3ef 8611 	mrs	r6, BASEPRI
    2b34:	f383 8811 	msr	BASEPRI, r3
    2b38:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
    2b3c:	4846      	ldr	r0, [pc, #280]	; (2c58 <z_impl_log_process+0x13c>)
    2b3e:	f012 fb51 	bl	151e4 <log_list_head_get>
    2b42:	4605      	mov	r5, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    2b44:	f386 8811 	msr	BASEPRI, r6
    2b48:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
    2b4c:	b178      	cbz	r0, 2b6e <z_impl_log_process+0x52>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2b4e:	f3bf 8f5b 	dmb	ish
    2b52:	4b42      	ldr	r3, [pc, #264]	; (2c5c <z_impl_log_process+0x140>)
    2b54:	e853 2f00 	ldrex	r2, [r3]
    2b58:	3a01      	subs	r2, #1
    2b5a:	e843 2100 	strex	r1, r2, [r3]
    2b5e:	2900      	cmp	r1, #0
    2b60:	d1f8      	bne.n	2b54 <z_impl_log_process+0x38>
    2b62:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
    2b66:	b194      	cbz	r4, 2b8e <z_impl_log_process+0x72>
	log_msg_put(msg);
    2b68:	4628      	mov	r0, r5
    2b6a:	f012 fc69 	bl	15440 <log_msg_put>
	if (!bypass && dropped_cnt) {
    2b6e:	b924      	cbnz	r4, 2b7a <z_impl_log_process+0x5e>
    2b70:	4b3b      	ldr	r3, [pc, #236]	; (2c60 <z_impl_log_process+0x144>)
    2b72:	681b      	ldr	r3, [r3, #0]
    2b74:	b10b      	cbz	r3, 2b7a <z_impl_log_process+0x5e>
		dropped_notify();
    2b76:	f7ff ff05 	bl	2984 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    2b7a:	4837      	ldr	r0, [pc, #220]	; (2c58 <z_impl_log_process+0x13c>)
    2b7c:	f012 fb30 	bl	151e0 <log_list_head_peek>
    2b80:	1e04      	subs	r4, r0, #0
    2b82:	bf18      	it	ne
    2b84:	2401      	movne	r4, #1
}
    2b86:	4620      	mov	r0, r4
    2b88:	b005      	add	sp, #20
    2b8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
    2b8e:	4b35      	ldr	r3, [pc, #212]	; (2c64 <z_impl_log_process+0x148>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    2b90:	781b      	ldrb	r3, [r3, #0]
    2b92:	b9cb      	cbnz	r3, 2bc8 <z_impl_log_process+0xac>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    2b94:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
    2b96:	07db      	lsls	r3, r3, #31
    2b98:	d416      	bmi.n	2bc8 <z_impl_log_process+0xac>
	msg_str = log_msg_str_get(msg);
    2b9a:	f012 fc64 	bl	15466 <log_msg_str_get>
    2b9e:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    2ba0:	4628      	mov	r0, r5
    2ba2:	f012 fc2b 	bl	153fc <log_msg_nargs_get>
    2ba6:	4601      	mov	r1, r0
    2ba8:	4640      	mov	r0, r8
    2baa:	f012 fb2e 	bl	1520a <z_log_get_s_mask>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    2bae:	4f2e      	ldr	r7, [pc, #184]	; (2c68 <z_impl_log_process+0x14c>)
    2bb0:	4b2e      	ldr	r3, [pc, #184]	; (2c6c <z_impl_log_process+0x150>)
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    2bb2:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 2c88 <z_impl_log_process+0x16c>
    2bb6:	1bdb      	subs	r3, r3, r7
    2bb8:	08db      	lsrs	r3, r3, #3
    2bba:	9303      	str	r3, [sp, #12]
    2bbc:	4b2c      	ldr	r3, [pc, #176]	; (2c70 <z_impl_log_process+0x154>)
    2bbe:	1bdb      	subs	r3, r3, r7
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    2bc0:	4606      	mov	r6, r0
    2bc2:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
	while (mask) {
    2bc6:	b936      	cbnz	r6, 2bd6 <z_impl_log_process+0xba>
    2bc8:	4e2a      	ldr	r6, [pc, #168]	; (2c74 <z_impl_log_process+0x158>)
    2bca:	4f2b      	ldr	r7, [pc, #172]	; (2c78 <z_impl_log_process+0x15c>)
    2bcc:	1bbf      	subs	r7, r7, r6
    2bce:	113f      	asrs	r7, r7, #4
    2bd0:	f04f 0800 	mov.w	r8, #0
    2bd4:	e03a      	b.n	2c4c <z_impl_log_process+0x130>
		idx = 31 - __builtin_clz(mask);
    2bd6:	fab6 f186 	clz	r1, r6
    2bda:	f1c1 091f 	rsb	r9, r1, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    2bde:	4649      	mov	r1, r9
    2be0:	4628      	mov	r0, r5
    2be2:	f012 fc0e 	bl	15402 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
    2be6:	4b25      	ldr	r3, [pc, #148]	; (2c7c <z_impl_log_process+0x160>)
    2be8:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
    2bea:	4601      	mov	r1, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    2bec:	d302      	bcc.n	2bf4 <z_impl_log_process+0xd8>
		if (!is_rodata(str) && !log_is_strdup(str) &&
    2bee:	4b24      	ldr	r3, [pc, #144]	; (2c80 <z_impl_log_process+0x164>)
    2bf0:	4298      	cmp	r0, r3
    2bf2:	d31a      	bcc.n	2c2a <z_impl_log_process+0x10e>
    2bf4:	4608      	mov	r0, r1
    2bf6:	f7ff ff83 	bl	2b00 <log_is_strdup>
    2bfa:	4602      	mov	r2, r0
    2bfc:	b9a8      	cbnz	r0, 2c2a <z_impl_log_process+0x10e>
    2bfe:	4b21      	ldr	r3, [pc, #132]	; (2c84 <z_impl_log_process+0x168>)
    2c00:	4299      	cmp	r1, r3
    2c02:	d012      	beq.n	2c2a <z_impl_log_process+0x10e>
	return msg->hdr.ids.source_id;
    2c04:	896b      	ldrh	r3, [r5, #10]
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    2c06:	9903      	ldr	r1, [sp, #12]
    2c08:	f3c3 1389 	ubfx	r3, r3, #6, #10
    2c0c:	428b      	cmp	r3, r1
	return __log_const_start[source_id].name;
    2c0e:	bf38      	it	cc
    2c10:	f857 2033 	ldrcc.w	r2, [r7, r3, lsl #3]
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    2c14:	ea4f 138a 	mov.w	r3, sl, lsl #6
    2c18:	f043 0301 	orr.w	r3, r3, #1
    2c1c:	f8ad 3000 	strh.w	r3, [sp]
    2c20:	4649      	mov	r1, r9
    2c22:	4643      	mov	r3, r8
    2c24:	4658      	mov	r0, fp
    2c26:	f012 fb4a 	bl	152be <log_3>
		mask &= ~BIT(idx);
    2c2a:	2101      	movs	r1, #1
    2c2c:	fa01 f109 	lsl.w	r1, r1, r9
    2c30:	ea26 0601 	bic.w	r6, r6, r1
    2c34:	e7c7      	b.n	2bc6 <z_impl_log_process+0xaa>
	return backend->cb->active;
    2c36:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
    2c38:	795b      	ldrb	r3, [r3, #5]
    2c3a:	b123      	cbz	r3, 2c46 <z_impl_log_process+0x12a>
	backend->api->put(backend, msg);
    2c3c:	6833      	ldr	r3, [r6, #0]
    2c3e:	4629      	mov	r1, r5
    2c40:	681b      	ldr	r3, [r3, #0]
    2c42:	4630      	mov	r0, r6
    2c44:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    2c46:	f108 0801 	add.w	r8, r8, #1
    2c4a:	3610      	adds	r6, #16
    2c4c:	45b8      	cmp	r8, r7
    2c4e:	dbf2      	blt.n	2c36 <z_impl_log_process+0x11a>
    2c50:	e78a      	b.n	2b68 <z_impl_log_process+0x4c>
    2c52:	bf00      	nop
    2c54:	20007a38 	.word	0x20007a38
    2c58:	200011b4 	.word	0x200011b4
    2c5c:	200011a8 	.word	0x200011a8
    2c60:	200011ac 	.word	0x200011ac
    2c64:	20007a39 	.word	0x20007a39
    2c68:	0001956c 	.word	0x0001956c
    2c6c:	0001968c 	.word	0x0001968c
    2c70:	00019614 	.word	0x00019614
    2c74:	0001968c 	.word	0x0001968c
    2c78:	000196ac 	.word	0x000196ac
    2c7c:	000192c0 	.word	0x000192c0
    2c80:	0001c2cc 	.word	0x0001c2cc
    2c84:	0001a1f0 	.word	0x0001a1f0
    2c88:	0001a20a 	.word	0x0001a20a

00002c8c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
    2c8c:	4b26      	ldr	r3, [pc, #152]	; (2d28 <msg_finalize+0x9c>)
{
    2c8e:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
    2c90:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
    2c92:	8141      	strh	r1, [r0, #10]
{
    2c94:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
    2c96:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    2c98:	4d24      	ldr	r5, [pc, #144]	; (2d2c <msg_finalize+0xa0>)
    2c9a:	60e0      	str	r0, [r4, #12]
    2c9c:	f3bf 8f5b 	dmb	ish
    2ca0:	e855 3f00 	ldrex	r3, [r5]
    2ca4:	3301      	adds	r3, #1
    2ca6:	e845 3200 	strex	r2, r3, [r5]
    2caa:	2a00      	cmp	r2, #0
    2cac:	d1f8      	bne.n	2ca0 <msg_finalize+0x14>
    2cae:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    2cb2:	f04f 0320 	mov.w	r3, #32
    2cb6:	f3ef 8611 	mrs	r6, BASEPRI
    2cba:	f383 8811 	msr	BASEPRI, r3
    2cbe:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    2cc2:	481b      	ldr	r0, [pc, #108]	; (2d30 <msg_finalize+0xa4>)
    2cc4:	4621      	mov	r1, r4
    2cc6:	f012 fa81 	bl	151cc <log_list_add_tail>
	__asm__ volatile(
    2cca:	f386 8811 	msr	BASEPRI, r6
    2cce:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    2cd2:	4b18      	ldr	r3, [pc, #96]	; (2d34 <msg_finalize+0xa8>)
    2cd4:	781a      	ldrb	r2, [r3, #0]
    2cd6:	b17a      	cbz	r2, 2cf8 <msg_finalize+0x6c>
	__asm__ volatile(
    2cd8:	f04f 0320 	mov.w	r3, #32
    2cdc:	f3ef 8411 	mrs	r4, BASEPRI
    2ce0:	f383 8811 	msr	BASEPRI, r3
    2ce4:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    2ce8:	2000      	movs	r0, #0
    2cea:	f7ff ff17 	bl	2b1c <z_impl_log_process>
	__asm__ volatile(
    2cee:	f384 8811 	msr	BASEPRI, r4
    2cf2:	f3bf 8f6f 	isb	sy
}
    2cf6:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    2cf8:	490f      	ldr	r1, [pc, #60]	; (2d38 <msg_finalize+0xac>)
    2cfa:	682b      	ldr	r3, [r5, #0]
    2cfc:	6809      	ldr	r1, [r1, #0]
    2cfe:	2900      	cmp	r1, #0
    2d00:	d0f9      	beq.n	2cf6 <msg_finalize+0x6a>
    2d02:	2b01      	cmp	r3, #1
    2d04:	d106      	bne.n	2d14 <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
    2d06:	480d      	ldr	r0, [pc, #52]	; (2d3c <msg_finalize+0xb0>)
}
    2d08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2d0c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    2d10:	f011 bd2c 	b.w	1476c <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    2d14:	2b0a      	cmp	r3, #10
    2d16:	d1ee      	bne.n	2cf6 <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
    2d18:	4808      	ldr	r0, [pc, #32]	; (2d3c <msg_finalize+0xb0>)
    2d1a:	f016 f98c 	bl	19036 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    2d1e:	4808      	ldr	r0, [pc, #32]	; (2d40 <msg_finalize+0xb4>)
}
    2d20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2d24:	f011 bae2 	b.w	142ec <z_impl_k_sem_give>
    2d28:	2000bcb4 	.word	0x2000bcb4
    2d2c:	200011a8 	.word	0x200011a8
    2d30:	200011b4 	.word	0x200011b4
    2d34:	20007a39 	.word	0x20007a39
    2d38:	20001278 	.word	0x20001278
    2d3c:	200011bc 	.word	0x200011bc
    2d40:	2000c344 	.word	0x2000c344

00002d44 <log_process_thread_func>:
{
    2d44:	b508      	push	{r3, lr}
	log_init();
    2d46:	f7ff fe7b 	bl	2a40 <log_init>
	return z_impl_k_current_get();
    2d4a:	f011 fac9 	bl	142e0 <z_impl_k_current_get>
	proc_tid = process_tid;
    2d4e:	4b0b      	ldr	r3, [pc, #44]	; (2d7c <log_process_thread_func+0x38>)
    2d50:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    2d52:	b130      	cbz	r0, 2d62 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    2d54:	4b0a      	ldr	r3, [pc, #40]	; (2d80 <log_process_thread_func+0x3c>)
	    process_tid &&
    2d56:	681b      	ldr	r3, [r3, #0]
    2d58:	2b09      	cmp	r3, #9
    2d5a:	dd02      	ble.n	2d62 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
    2d5c:	4809      	ldr	r0, [pc, #36]	; (2d84 <log_process_thread_func+0x40>)
    2d5e:	f011 fac5 	bl	142ec <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    2d62:	4c08      	ldr	r4, [pc, #32]	; (2d84 <log_process_thread_func+0x40>)
    2d64:	2000      	movs	r0, #0
    2d66:	f7ff fed9 	bl	2b1c <z_impl_log_process>
		if (log_process(false) == false) {
    2d6a:	2800      	cmp	r0, #0
    2d6c:	d1fa      	bne.n	2d64 <log_process_thread_func+0x20>
    2d6e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2d72:	4620      	mov	r0, r4
    2d74:	f011 fae0 	bl	14338 <z_impl_k_sem_take>
    2d78:	e7f4      	b.n	2d64 <log_process_thread_func+0x20>
    2d7a:	bf00      	nop
    2d7c:	20001278 	.word	0x20001278
    2d80:	200011a8 	.word	0x200011a8
    2d84:	2000c344 	.word	0x2000c344

00002d88 <z_impl_log_panic>:
{
    2d88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    2d8a:	4f0e      	ldr	r7, [pc, #56]	; (2dc4 <z_impl_log_panic+0x3c>)
    2d8c:	783d      	ldrb	r5, [r7, #0]
    2d8e:	b975      	cbnz	r5, 2dae <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
    2d90:	4c0d      	ldr	r4, [pc, #52]	; (2dc8 <z_impl_log_panic+0x40>)
    2d92:	4e0e      	ldr	r6, [pc, #56]	; (2dcc <z_impl_log_panic+0x44>)
	log_init();
    2d94:	f7ff fe54 	bl	2a40 <log_init>
    2d98:	1b36      	subs	r6, r6, r4
    2d9a:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    2d9c:	42b5      	cmp	r5, r6
    2d9e:	db07      	blt.n	2db0 <z_impl_log_panic+0x28>
    2da0:	2000      	movs	r0, #0
    2da2:	f7ff febb 	bl	2b1c <z_impl_log_process>
		while (log_process(false) == true) {
    2da6:	2800      	cmp	r0, #0
    2da8:	d1fa      	bne.n	2da0 <z_impl_log_panic+0x18>
	panic_mode = true;
    2daa:	2301      	movs	r3, #1
    2dac:	703b      	strb	r3, [r7, #0]
}
    2dae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
    2db0:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    2db2:	795b      	ldrb	r3, [r3, #5]
    2db4:	b11b      	cbz	r3, 2dbe <z_impl_log_panic+0x36>
	backend->api->panic(backend);
    2db6:	6823      	ldr	r3, [r4, #0]
    2db8:	4620      	mov	r0, r4
    2dba:	691b      	ldr	r3, [r3, #16]
    2dbc:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    2dbe:	3501      	adds	r5, #1
    2dc0:	3410      	adds	r4, #16
    2dc2:	e7eb      	b.n	2d9c <z_impl_log_panic+0x14>
    2dc4:	20007a39 	.word	0x20007a39
    2dc8:	0001968c 	.word	0x0001968c
    2dcc:	000196ac 	.word	0x000196ac

00002dd0 <log_free>:
{
    2dd0:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    2dd2:	3804      	subs	r0, #4
    2dd4:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2dd6:	f3bf 8f5b 	dmb	ish
    2dda:	e850 3f00 	ldrex	r3, [r0]
    2dde:	1e5a      	subs	r2, r3, #1
    2de0:	e840 2100 	strex	r1, r2, [r0]
    2de4:	2900      	cmp	r1, #0
    2de6:	d1f8      	bne.n	2dda <log_free+0xa>
    2de8:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    2dec:	2b01      	cmp	r3, #1
    2dee:	d103      	bne.n	2df8 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    2df0:	4803      	ldr	r0, [pc, #12]	; (2e00 <log_free+0x30>)
    2df2:	a901      	add	r1, sp, #4
    2df4:	f010 fe2c 	bl	13a50 <k_mem_slab_free>
}
    2df8:	b003      	add	sp, #12
    2dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    2dfe:	bf00      	nop
    2e00:	200011e8 	.word	0x200011e8

00002e04 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    2e04:	2320      	movs	r3, #32
    2e06:	4902      	ldr	r1, [pc, #8]	; (2e10 <log_msg_pool_init+0xc>)
    2e08:	4802      	ldr	r0, [pc, #8]	; (2e14 <log_msg_pool_init+0x10>)
    2e0a:	461a      	mov	r2, r3
    2e0c:	f015 be29 	b.w	18a62 <k_mem_slab_init>
    2e10:	2000b100 	.word	0x2000b100
    2e14:	2000127c 	.word	0x2000127c

00002e18 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    2e18:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
    2e1a:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
    2e1c:	4d09      	ldr	r5, [pc, #36]	; (2e44 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
    2e1e:	9301      	str	r3, [sp, #4]
    2e20:	2001      	movs	r0, #1
    2e22:	f7ff fe7b 	bl	2b1c <z_impl_log_process>
    2e26:	4604      	mov	r4, r0
			log_dropped();
    2e28:	f7ff fdd2 	bl	29d0 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    2e2c:	2200      	movs	r2, #0
    2e2e:	a901      	add	r1, sp, #4
    2e30:	4628      	mov	r0, r5
    2e32:	f010 fde1 	bl	139f8 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    2e36:	b108      	cbz	r0, 2e3c <log_msg_no_space_handle+0x24>
    2e38:	2c00      	cmp	r4, #0
    2e3a:	d1f1      	bne.n	2e20 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
    2e3c:	9801      	ldr	r0, [sp, #4]
    2e3e:	b003      	add	sp, #12
    2e40:	bd30      	pop	{r4, r5, pc}
    2e42:	bf00      	nop
    2e44:	2000127c 	.word	0x2000127c

00002e48 <log_msg_chunk_alloc>:
{
    2e48:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
    2e4a:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    2e4c:	4806      	ldr	r0, [pc, #24]	; (2e68 <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
    2e4e:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    2e50:	a901      	add	r1, sp, #4
    2e52:	f010 fdd1 	bl	139f8 <k_mem_slab_alloc>
	if (err != 0) {
    2e56:	b110      	cbz	r0, 2e5e <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
    2e58:	f7ff ffde 	bl	2e18 <log_msg_no_space_handle>
    2e5c:	9001      	str	r0, [sp, #4]
}
    2e5e:	9801      	ldr	r0, [sp, #4]
    2e60:	b003      	add	sp, #12
    2e62:	f85d fb04 	ldr.w	pc, [sp], #4
    2e66:	bf00      	nop
    2e68:	2000127c 	.word	0x2000127c

00002e6c <msg_free>:
{
    2e6c:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    2e6e:	7a03      	ldrb	r3, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
    2e70:	7a45      	ldrb	r5, [r0, #9]
{
    2e72:	b085      	sub	sp, #20
	return msg->hdr.params.std.nargs;
    2e74:	092d      	lsrs	r5, r5, #4
{
    2e76:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
    2e78:	07d8      	lsls	r0, r3, #31
    2e7a:	d41c      	bmi.n	2eb6 <msg_free+0x4a>
    2e7c:	b1dd      	cbz	r5, 2eb6 <msg_free+0x4a>
		u32_t smask = 0;
    2e7e:	2400      	movs	r4, #0
		for (i = 0; i < nargs; i++) {
    2e80:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
    2e82:	9801      	ldr	r0, [sp, #4]
    2e84:	4631      	mov	r1, r6
    2e86:	f012 fabc 	bl	15402 <log_msg_arg_get>
    2e8a:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
    2e8c:	f7ff fe38 	bl	2b00 <log_is_strdup>
    2e90:	b170      	cbz	r0, 2eb0 <msg_free+0x44>
				if (smask == 0) {
    2e92:	b934      	cbnz	r4, 2ea2 <msg_free+0x36>
					smask = z_log_get_s_mask(
    2e94:	9b01      	ldr	r3, [sp, #4]
    2e96:	4629      	mov	r1, r5
    2e98:	6918      	ldr	r0, [r3, #16]
    2e9a:	f012 f9b6 	bl	1520a <z_log_get_s_mask>
					if (smask == 0) {
    2e9e:	4604      	mov	r4, r0
    2ea0:	b148      	cbz	r0, 2eb6 <msg_free+0x4a>
				if (smask & BIT(i)) {
    2ea2:	fa24 f306 	lsr.w	r3, r4, r6
    2ea6:	07d9      	lsls	r1, r3, #31
    2ea8:	d502      	bpl.n	2eb0 <msg_free+0x44>
					log_free(buf);
    2eaa:	4638      	mov	r0, r7
    2eac:	f7ff ff90 	bl	2dd0 <log_free>
		for (i = 0; i < nargs; i++) {
    2eb0:	3601      	adds	r6, #1
    2eb2:	42ae      	cmp	r6, r5
    2eb4:	d3e5      	bcc.n	2e82 <msg_free+0x16>
	if (msg->hdr.params.generic.ext == 1) {
    2eb6:	9b01      	ldr	r3, [sp, #4]
    2eb8:	7a1a      	ldrb	r2, [r3, #8]
    2eba:	0792      	lsls	r2, r2, #30
    2ebc:	d504      	bpl.n	2ec8 <msg_free+0x5c>
		cont_free(msg->payload.ext.next);
    2ebe:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    2ec0:	4c08      	ldr	r4, [pc, #32]	; (2ee4 <msg_free+0x78>)
    2ec2:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
    2ec4:	9b03      	ldr	r3, [sp, #12]
    2ec6:	b92b      	cbnz	r3, 2ed4 <msg_free+0x68>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    2ec8:	4806      	ldr	r0, [pc, #24]	; (2ee4 <msg_free+0x78>)
    2eca:	a901      	add	r1, sp, #4
    2ecc:	f010 fdc0 	bl	13a50 <k_mem_slab_free>
}
    2ed0:	b005      	add	sp, #20
    2ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
    2ed4:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    2ed6:	a903      	add	r1, sp, #12
    2ed8:	4620      	mov	r0, r4
    2eda:	f010 fdb9 	bl	13a50 <k_mem_slab_free>
		cont = next;
    2ede:	9503      	str	r5, [sp, #12]
    2ee0:	e7f0      	b.n	2ec4 <msg_free+0x58>
    2ee2:	bf00      	nop
    2ee4:	2000127c 	.word	0x2000127c

00002ee8 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
    2ee8:	b40e      	push	{r1, r2, r3}
    2eea:	b503      	push	{r0, r1, lr}
    2eec:	ab03      	add	r3, sp, #12
    2eee:	4601      	mov	r1, r0
    2ef0:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
    2ef4:	4804      	ldr	r0, [pc, #16]	; (2f08 <print_formatted+0x20>)
	va_start(args, fmt);
    2ef6:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
    2ef8:	f7ff fb4c 	bl	2594 <z_vprintk>
#endif
	va_end(args);

	return length;
}
    2efc:	2000      	movs	r0, #0
    2efe:	b002      	add	sp, #8
    2f00:	f85d eb04 	ldr.w	lr, [sp], #4
    2f04:	b003      	add	sp, #12
    2f06:	4770      	bx	lr
    2f08:	000158b5 	.word	0x000158b5

00002f0c <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
    2f0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2f10:	b085      	sub	sp, #20
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    2f12:	f011 0402 	ands.w	r4, r1, #2
{
    2f16:	4690      	mov	r8, r2
    2f18:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
    2f1c:	4606      	mov	r6, r0
    2f1e:	461a      	mov	r2, r3
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    2f20:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    2f24:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
    2f28:	d007      	beq.n	2f3a <prefix_print+0x2e>
	if (!format) {
    2f2a:	f011 0f44 	tst.w	r1, #68	; 0x44
    2f2e:	d137      	bne.n	2fa0 <prefix_print+0x94>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    2f30:	4932      	ldr	r1, [pc, #200]	; (2ffc <prefix_print+0xf0>)
    2f32:	f7ff ffd9 	bl	2ee8 <print_formatted>
			length = print_formatted(log_output,
    2f36:	4601      	mov	r1, r0
		length += timestamp_print(log_output, flags, timestamp);
    2f38:	460c      	mov	r4, r1
	if (color) {
    2f3a:	f1b9 0f00 	cmp.w	r9, #0
    2f3e:	d00a      	beq.n	2f56 <prefix_print+0x4a>
		const char *color = start && (colors[level] != NULL) ?
    2f40:	4b2f      	ldr	r3, [pc, #188]	; (3000 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
    2f42:	4930      	ldr	r1, [pc, #192]	; (3004 <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
    2f44:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
    2f48:	4b2f      	ldr	r3, [pc, #188]	; (3008 <prefix_print+0xfc>)
    2f4a:	4630      	mov	r0, r6
    2f4c:	2a00      	cmp	r2, #0
    2f4e:	bf08      	it	eq
    2f50:	461a      	moveq	r2, r3
    2f52:	f7ff ffc9 	bl	2ee8 <print_formatted>
	if (level_on) {
    2f56:	b13d      	cbz	r5, 2f68 <prefix_print+0x5c>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    2f58:	4b2c      	ldr	r3, [pc, #176]	; (300c <prefix_print+0x100>)
    2f5a:	492d      	ldr	r1, [pc, #180]	; (3010 <prefix_print+0x104>)
    2f5c:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
    2f60:	4630      	mov	r0, r6
    2f62:	f7ff ffc1 	bl	2ee8 <print_formatted>
    2f66:	4605      	mov	r5, r0
	total += print_formatted(log_output,
    2f68:	f1b8 0f00 	cmp.w	r8, #0
    2f6c:	d043      	beq.n	2ff6 <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    2f6e:	2301      	movs	r3, #1
    2f70:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
    2f74:	4b27      	ldr	r3, [pc, #156]	; (3014 <prefix_print+0x108>)
    2f76:	f017 0f10 	tst.w	r7, #16
    2f7a:	4f27      	ldr	r7, [pc, #156]	; (3018 <prefix_print+0x10c>)
    2f7c:	bf18      	it	ne
    2f7e:	461f      	movne	r7, r3
    2f80:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
    2f84:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
    2f88:	f7ff fd32 	bl	29f0 <log_source_name_get>
    2f8c:	4639      	mov	r1, r7
    2f8e:	4602      	mov	r2, r0
    2f90:	4630      	mov	r0, r6
    2f92:	f7ff ffa9 	bl	2ee8 <print_formatted>
    2f96:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
    2f98:	4420      	add	r0, r4
    2f9a:	b005      	add	sp, #20
    2f9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
    2fa0:	4b1e      	ldr	r3, [pc, #120]	; (301c <prefix_print+0x110>)
    2fa2:	6819      	ldr	r1, [r3, #0]
    2fa4:	2900      	cmp	r1, #0
    2fa6:	d0c7      	beq.n	2f38 <prefix_print+0x2c>
		timestamp /= timestamp_div;
    2fa8:	4b1d      	ldr	r3, [pc, #116]	; (3020 <prefix_print+0x114>)
    2faa:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
    2fae:	681b      	ldr	r3, [r3, #0]
    2fb0:	fbb2 f3f3 	udiv	r3, r2, r3
		ms = (remainder * 1000U) / freq;
    2fb4:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		seconds = timestamp / freq;
    2fb8:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
    2fbc:	fbb4 f2fe 	udiv	r2, r4, lr
    2fc0:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
    2fc4:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
    2fc8:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
    2fcc:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    2fd0:	fbb4 fbf1 	udiv	fp, r4, r1
    2fd4:	fb01 441b 	mls	r4, r1, fp, r4
    2fd8:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
    2fdc:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    2fe0:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
    2fe4:	e9cd b101 	strd	fp, r1, [sp, #4]
    2fe8:	fb0a e113 	mls	r1, sl, r3, lr
    2fec:	9100      	str	r1, [sp, #0]
    2fee:	490d      	ldr	r1, [pc, #52]	; (3024 <prefix_print+0x118>)
    2ff0:	f7ff ff7a 	bl	2ee8 <print_formatted>
    2ff4:	e79f      	b.n	2f36 <prefix_print+0x2a>
	total += print_formatted(log_output,
    2ff6:	4f08      	ldr	r7, [pc, #32]	; (3018 <prefix_print+0x10c>)
    2ff8:	e7c2      	b.n	2f80 <prefix_print+0x74>
    2ffa:	bf00      	nop
    2ffc:	0001a25b 	.word	0x0001a25b
    3000:	00019728 	.word	0x00019728
    3004:	0001bd9d 	.word	0x0001bd9d
    3008:	0001a24d 	.word	0x0001a24d
    300c:	0001973c 	.word	0x0001973c
    3010:	0001a280 	.word	0x0001a280
    3014:	0001a257 	.word	0x0001a257
    3018:	0001a252 	.word	0x0001a252
    301c:	20001298 	.word	0x20001298
    3020:	2000129c 	.word	0x2000129c
    3024:	0001a264 	.word	0x0001a264

00003028 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
    3028:	b538      	push	{r3, r4, r5, lr}
    302a:	460c      	mov	r4, r1
	if (color) {
    302c:	07e1      	lsls	r1, r4, #31
{
    302e:	4605      	mov	r5, r0
	if (color) {
    3030:	d503      	bpl.n	303a <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
    3032:	4a08      	ldr	r2, [pc, #32]	; (3054 <postfix_print+0x2c>)
    3034:	4908      	ldr	r1, [pc, #32]	; (3058 <postfix_print+0x30>)
    3036:	f7ff ff57 	bl	2ee8 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    303a:	06e2      	lsls	r2, r4, #27
    303c:	d408      	bmi.n	3050 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    303e:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
    3040:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
    3042:	bf4c      	ite	mi
    3044:	4905      	ldrmi	r1, [pc, #20]	; (305c <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
    3046:	4906      	ldrpl	r1, [pc, #24]	; (3060 <postfix_print+0x38>)
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
    3048:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
    304c:	f7ff bf4c 	b.w	2ee8 <print_formatted>
}
    3050:	bd38      	pop	{r3, r4, r5, pc}
    3052:	bf00      	nop
    3054:	0001a24d 	.word	0x0001a24d
    3058:	0001bd9d 	.word	0x0001bd9d
    305c:	00019ce0 	.word	0x00019ce0
    3060:	0001a286 	.word	0x0001a286

00003064 <hexdump_line_print>:
{
    3064:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3068:	461d      	mov	r5, r3
    306a:	9b08      	ldr	r3, [sp, #32]
    306c:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    306e:	06da      	lsls	r2, r3, #27
{
    3070:	4604      	mov	r4, r0
    3072:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    3074:	d405      	bmi.n	3082 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    3076:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
    3078:	bf4c      	ite	mi
    307a:	492a      	ldrmi	r1, [pc, #168]	; (3124 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
    307c:	492a      	ldrpl	r1, [pc, #168]	; (3128 <hexdump_line_print+0xc4>)
    307e:	f7ff ff33 	bl	2ee8 <print_formatted>
		print_formatted(log_output, " ");
    3082:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 3130 <hexdump_line_print+0xcc>
{
    3086:	f04f 0800 	mov.w	r8, #0
	for (int i = 0; i < prefix_offset; i++) {
    308a:	45a8      	cmp	r8, r5
    308c:	db2a      	blt.n	30e4 <hexdump_line_print+0x80>
			print_formatted(log_output, "   ");
    308e:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 3134 <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
    3092:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 3138 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
    3096:	f8df a098 	ldr.w	sl, [pc, #152]	; 3130 <hexdump_line_print+0xcc>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    309a:	2500      	movs	r5, #0
		if (i < length) {
    309c:	42bd      	cmp	r5, r7
    309e:	d22f      	bcs.n	3100 <hexdump_line_print+0x9c>
			print_formatted(log_output, "%02x ", data[i]);
    30a0:	5d72      	ldrb	r2, [r6, r5]
    30a2:	4649      	mov	r1, r9
    30a4:	4620      	mov	r0, r4
    30a6:	f7ff ff1f 	bl	2ee8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    30aa:	3501      	adds	r5, #1
    30ac:	2d10      	cmp	r5, #16
    30ae:	d120      	bne.n	30f2 <hexdump_line_print+0x8e>
	print_formatted(log_output, "|");
    30b0:	491e      	ldr	r1, [pc, #120]	; (312c <hexdump_line_print+0xc8>)
			print_formatted(log_output, " ");
    30b2:	f8df 807c 	ldr.w	r8, [pc, #124]	; 3130 <hexdump_line_print+0xcc>
			print_formatted(log_output, "%c",
    30b6:	f8df 9084 	ldr.w	r9, [pc, #132]	; 313c <hexdump_line_print+0xd8>
	print_formatted(log_output, "|");
    30ba:	4620      	mov	r0, r4
    30bc:	f7ff ff14 	bl	2ee8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    30c0:	2500      	movs	r5, #0
		if (i < length) {
    30c2:	42af      	cmp	r7, r5
    30c4:	d928      	bls.n	3118 <hexdump_line_print+0xb4>
			char c = (char)data[i];
    30c6:	5d72      	ldrb	r2, [r6, r5]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
    30c8:	f1a2 0320 	sub.w	r3, r2, #32
    30cc:	2b5f      	cmp	r3, #95	; 0x5f
			print_formatted(log_output, "%c",
    30ce:	bf28      	it	cs
    30d0:	222e      	movcs	r2, #46	; 0x2e
    30d2:	4649      	mov	r1, r9
    30d4:	4620      	mov	r0, r4
    30d6:	f7ff ff07 	bl	2ee8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    30da:	3501      	adds	r5, #1
    30dc:	2d10      	cmp	r5, #16
    30de:	d114      	bne.n	310a <hexdump_line_print+0xa6>
}
    30e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
    30e4:	4649      	mov	r1, r9
    30e6:	4620      	mov	r0, r4
    30e8:	f7ff fefe 	bl	2ee8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    30ec:	f108 0801 	add.w	r8, r8, #1
    30f0:	e7cb      	b.n	308a <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
    30f2:	076a      	lsls	r2, r5, #29
    30f4:	d1d2      	bne.n	309c <hexdump_line_print+0x38>
			print_formatted(log_output, " ");
    30f6:	4651      	mov	r1, sl
    30f8:	4620      	mov	r0, r4
    30fa:	f7ff fef5 	bl	2ee8 <print_formatted>
    30fe:	e7cd      	b.n	309c <hexdump_line_print+0x38>
			print_formatted(log_output, "   ");
    3100:	4641      	mov	r1, r8
    3102:	4620      	mov	r0, r4
    3104:	f7ff fef0 	bl	2ee8 <print_formatted>
    3108:	e7cf      	b.n	30aa <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
    310a:	076b      	lsls	r3, r5, #29
    310c:	d1d9      	bne.n	30c2 <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
    310e:	4641      	mov	r1, r8
    3110:	4620      	mov	r0, r4
    3112:	f7ff fee9 	bl	2ee8 <print_formatted>
    3116:	e7d4      	b.n	30c2 <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
    3118:	4641      	mov	r1, r8
    311a:	4620      	mov	r0, r4
    311c:	f7ff fee4 	bl	2ee8 <print_formatted>
    3120:	e7db      	b.n	30da <hexdump_line_print+0x76>
    3122:	bf00      	nop
    3124:	00019ce0 	.word	0x00019ce0
    3128:	0001a286 	.word	0x0001a286
    312c:	0001a293 	.word	0x0001a293
    3130:	0001a291 	.word	0x0001a291
    3134:	0001a28f 	.word	0x0001a28f
    3138:	0001a289 	.word	0x0001a289
    313c:	0001a295 	.word	0x0001a295

00003140 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
    3140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
    3144:	7a8b      	ldrb	r3, [r1, #10]
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    3146:	f013 0807 	ands.w	r8, r3, #7
{
    314a:	4617      	mov	r7, r2
    314c:	b08a      	sub	sp, #40	; 0x28
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    314e:	7a0a      	ldrb	r2, [r1, #8]
    3150:	4605      	mov	r5, r0
    3152:	460e      	mov	r6, r1
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    3154:	d021      	beq.n	319a <log_output_msg_process+0x5a>
	return msg->hdr.ids.source_id;
    3156:	8949      	ldrh	r1, [r1, #10]
    3158:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    315c:	f3c1 1189 	ubfx	r1, r1, #6, #10
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    3160:	43d2      	mvns	r2, r2
    3162:	e9cd 8300 	strd	r8, r3, [sp]
    3166:	9102      	str	r1, [sp, #8]
    3168:	68f3      	ldr	r3, [r6, #12]
    316a:	f002 0201 	and.w	r2, r2, #1
    316e:	4639      	mov	r1, r7
    3170:	f7ff fecc 	bl	2f0c <prefix_print>
    3174:	4681      	mov	r9, r0
    3176:	7a34      	ldrb	r4, [r6, #8]
    3178:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    317a:	f014 0401 	ands.w	r4, r4, #1
    317e:	d00e      	beq.n	319e <log_output_msg_process+0x5e>
		std_print(msg, log_output);
    3180:	4629      	mov	r1, r5
    3182:	4630      	mov	r0, r6
    3184:	f012 fa2c 	bl	155e0 <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
    3188:	f1b8 0f00 	cmp.w	r8, #0
    318c:	d02b      	beq.n	31e6 <log_output_msg_process+0xa6>
		postfix_print(log_output, flags, level);
    318e:	4642      	mov	r2, r8
    3190:	4639      	mov	r1, r7
    3192:	4628      	mov	r0, r5
    3194:	f7ff ff48 	bl	3028 <postfix_print>
    3198:	e025      	b.n	31e6 <log_output_msg_process+0xa6>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    319a:	46c1      	mov	r9, r8
    319c:	e7eb      	b.n	3176 <log_output_msg_process+0x36>
	} else if (raw_string) {
    319e:	f1b8 0f00 	cmp.w	r8, #0
    31a2:	d126      	bne.n	31f2 <log_output_msg_process+0xb2>
	size_t offset = 0;
    31a4:	4627      	mov	r7, r4
		length = log_output->size;
    31a6:	68eb      	ldr	r3, [r5, #12]
    31a8:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    31aa:	aa06      	add	r2, sp, #24
    31ac:	463b      	mov	r3, r7
    31ae:	68a9      	ldr	r1, [r5, #8]
    31b0:	4630      	mov	r0, r6
    31b2:	f012 fa01 	bl	155b8 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    31b6:	9a06      	ldr	r2, [sp, #24]
    31b8:	686b      	ldr	r3, [r5, #4]
    31ba:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    31bc:	b13a      	cbz	r2, 31ce <log_output_msg_process+0x8e>
			eol = (log_output->buf[length - 1] == '\n');
    31be:	68ab      	ldr	r3, [r5, #8]
    31c0:	4413      	add	r3, r2
    31c2:	f813 4c01 	ldrb.w	r4, [r3, #-1]
    31c6:	f1a4 030a 	sub.w	r3, r4, #10
    31ca:	425c      	negs	r4, r3
    31cc:	415c      	adcs	r4, r3
		log_output_flush(log_output);
    31ce:	4628      	mov	r0, r5
    31d0:	f012 fb63 	bl	1589a <log_output_flush>
		offset += length;
    31d4:	9b06      	ldr	r3, [sp, #24]
    31d6:	441f      	add	r7, r3
	} while (length > 0);
    31d8:	2b00      	cmp	r3, #0
    31da:	d1e4      	bne.n	31a6 <log_output_msg_process+0x66>
	if (eol) {
    31dc:	b11c      	cbz	r4, 31e6 <log_output_msg_process+0xa6>
		print_formatted(log_output, "\r");
    31de:	4914      	ldr	r1, [pc, #80]	; (3230 <log_output_msg_process+0xf0>)
    31e0:	4628      	mov	r0, r5
    31e2:	f7ff fe81 	bl	2ee8 <print_formatted>
	}

	log_output_flush(log_output);
    31e6:	4628      	mov	r0, r5
    31e8:	f012 fb57 	bl	1589a <log_output_flush>
}
    31ec:	b00a      	add	sp, #40	; 0x28
    31ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    31f2:	4630      	mov	r0, r6
    31f4:	f012 f937 	bl	15466 <log_msg_str_get>
    31f8:	490e      	ldr	r1, [pc, #56]	; (3234 <log_output_msg_process+0xf4>)
    31fa:	4602      	mov	r2, r0
    31fc:	4628      	mov	r0, r5
    31fe:	f7ff fe73 	bl	2ee8 <print_formatted>
		length = sizeof(buf);
    3202:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    3206:	aa05      	add	r2, sp, #20
    3208:	4623      	mov	r3, r4
    320a:	a906      	add	r1, sp, #24
    320c:	4630      	mov	r0, r6
		length = sizeof(buf);
    320e:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    3212:	f012 f9d1 	bl	155b8 <log_msg_hexdump_data_get>
		if (length) {
    3216:	9a05      	ldr	r2, [sp, #20]
    3218:	2a00      	cmp	r2, #0
    321a:	d0b8      	beq.n	318e <log_output_msg_process+0x4e>
			hexdump_line_print(log_output, buf, length,
    321c:	464b      	mov	r3, r9
    321e:	9700      	str	r7, [sp, #0]
    3220:	a906      	add	r1, sp, #24
    3222:	4628      	mov	r0, r5
    3224:	f7ff ff1e 	bl	3064 <hexdump_line_print>
			offset += length;
    3228:	9b05      	ldr	r3, [sp, #20]
    322a:	441c      	add	r4, r3
		length = sizeof(buf);
    322c:	e7eb      	b.n	3206 <log_output_msg_process+0xc6>
    322e:	bf00      	nop
    3230:	0001a298 	.word	0x0001a298
    3234:	0001bd9d 	.word	0x0001bd9d

00003238 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
    3238:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
    323a:	e9d0 4300 	ldrd	r4, r3, [r0]
    323e:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    3240:	4a0f      	ldr	r2, [pc, #60]	; (3280 <log_output_dropped_process+0x48>)
    3242:	f242 730f 	movw	r3, #9999	; 0x270f
    3246:	428b      	cmp	r3, r1
    3248:	bf28      	it	cs
    324a:	460b      	movcs	r3, r1
    324c:	4668      	mov	r0, sp
    324e:	2105      	movs	r1, #5
    3250:	f003 fd86 	bl	6d60 <snprintf>

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    3254:	462b      	mov	r3, r5
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    3256:	4606      	mov	r6, r0
	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    3258:	490a      	ldr	r1, [pc, #40]	; (3284 <log_output_dropped_process+0x4c>)
    325a:	4620      	mov	r0, r4
    325c:	220b      	movs	r2, #11
    325e:	f012 f9b2 	bl	155c6 <buffer_write>
	buffer_write(outf, buf, len, dev);
    3262:	462b      	mov	r3, r5
    3264:	4632      	mov	r2, r6
    3266:	4669      	mov	r1, sp
    3268:	4620      	mov	r0, r4
    326a:	f012 f9ac 	bl	155c6 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
    326e:	4906      	ldr	r1, [pc, #24]	; (3288 <log_output_dropped_process+0x50>)
    3270:	462b      	mov	r3, r5
    3272:	221b      	movs	r2, #27
    3274:	4620      	mov	r0, r4
    3276:	f012 f9a6 	bl	155c6 <buffer_write>
}
    327a:	b002      	add	sp, #8
    327c:	bd70      	pop	{r4, r5, r6, pc}
    327e:	bf00      	nop
    3280:	0001a77b 	.word	0x0001a77b
    3284:	0001a2d2 	.word	0x0001a2d2
    3288:	0001a2b6 	.word	0x0001a2b6

0000328c <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
    328c:	4a08      	ldr	r2, [pc, #32]	; (32b0 <log_output_timestamp_freq_set+0x24>)
{
    328e:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    3290:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    3292:	4c08      	ldr	r4, [pc, #32]	; (32b4 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    3294:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    3296:	2100      	movs	r1, #0
    3298:	42a0      	cmp	r0, r4
    329a:	d804      	bhi.n	32a6 <log_output_timestamp_freq_set+0x1a>
    329c:	b101      	cbz	r1, 32a0 <log_output_timestamp_freq_set+0x14>
    329e:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    32a0:	4b05      	ldr	r3, [pc, #20]	; (32b8 <log_output_timestamp_freq_set+0x2c>)
    32a2:	6018      	str	r0, [r3, #0]
}
    32a4:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    32a6:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    32a8:	005b      	lsls	r3, r3, #1
    32aa:	2101      	movs	r1, #1
    32ac:	e7f4      	b.n	3298 <log_output_timestamp_freq_set+0xc>
    32ae:	bf00      	nop
    32b0:	2000129c 	.word	0x2000129c
    32b4:	000f4240 	.word	0x000f4240
    32b8:	20001298 	.word	0x20001298

000032bc <panic>:
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
    32bc:	4801      	ldr	r0, [pc, #4]	; (32c4 <panic+0x8>)
    32be:	f012 baec 	b.w	1589a <log_output_flush>
    32c2:	bf00      	nop
    32c4:	00019768 	.word	0x00019768

000032c8 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
	log_output_dropped_process(log_output, cnt);
    32c8:	4801      	ldr	r0, [pc, #4]	; (32d0 <dropped+0x8>)
    32ca:	f7ff bfb5 	b.w	3238 <log_output_dropped_process>
    32ce:	bf00      	nop
    32d0:	00019768 	.word	0x00019768

000032d4 <log_backend_uart_init>:

	log_backend_std_put(&log_output, flag, msg);
}

static void log_backend_uart_init(void)
{
    32d4:	b508      	push	{r3, lr}
    32d6:	4803      	ldr	r0, [pc, #12]	; (32e4 <log_backend_uart_init+0x10>)
    32d8:	f010 f9c8 	bl	1366c <z_impl_device_get_binding>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
    32dc:	4b02      	ldr	r3, [pc, #8]	; (32e8 <log_backend_uart_init+0x14>)
    32de:	6058      	str	r0, [r3, #4]

	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	assert(dev);

	log_output_ctx_set(&log_output, dev);
}
    32e0:	bd08      	pop	{r3, pc}
    32e2:	bf00      	nop
    32e4:	0001a2de 	.word	0x0001a2de
    32e8:	200012a8 	.word	0x200012a8

000032ec <put>:
{
    32ec:	b510      	push	{r4, lr}
	log_msg_get(msg);
    32ee:	4608      	mov	r0, r1
    32f0:	460c      	mov	r4, r1
    32f2:	f012 f876 	bl	153e2 <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    32f6:	4805      	ldr	r0, [pc, #20]	; (330c <put+0x20>)
    32f8:	4621      	mov	r1, r4
    32fa:	220f      	movs	r2, #15
    32fc:	f7ff ff20 	bl	3140 <log_output_msg_process>
	log_msg_put(msg);
    3300:	4620      	mov	r0, r4
}
    3302:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    3306:	f012 b89b 	b.w	15440 <log_msg_put>
    330a:	bf00      	nop
    330c:	00019768 	.word	0x00019768

00003310 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    3310:	4b01      	ldr	r3, [pc, #4]	; (3318 <log_backend_rtt_init+0x8>)
    3312:	2201      	movs	r2, #1
    3314:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    3316:	4770      	bx	lr
    3318:	20007a4b 	.word	0x20007a4b

0000331c <panic>:

static void panic(struct log_backend const *const backend)
{
    331c:	b508      	push	{r3, lr}
	log_output_flush(log_output);
    331e:	4803      	ldr	r0, [pc, #12]	; (332c <panic+0x10>)
    3320:	f012 fabb 	bl	1589a <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
    3324:	4b02      	ldr	r3, [pc, #8]	; (3330 <panic+0x14>)
    3326:	2201      	movs	r2, #1
    3328:	701a      	strb	r2, [r3, #0]
}
    332a:	bd08      	pop	{r3, pc}
    332c:	00019790 	.word	0x00019790
    3330:	20007a4c 	.word	0x20007a4c

00003334 <dropped>:
	log_output_dropped_process(log_output, cnt);
    3334:	4801      	ldr	r0, [pc, #4]	; (333c <dropped+0x8>)
    3336:	f7ff bf7f 	b.w	3238 <log_output_dropped_process>
    333a:	bf00      	nop
    333c:	00019790 	.word	0x00019790

00003340 <put>:
{
    3340:	b510      	push	{r4, lr}
	log_msg_get(msg);
    3342:	4608      	mov	r0, r1
    3344:	460c      	mov	r4, r1
    3346:	f012 f84c 	bl	153e2 <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    334a:	4805      	ldr	r0, [pc, #20]	; (3360 <put+0x20>)
    334c:	4621      	mov	r1, r4
    334e:	220f      	movs	r2, #15
    3350:	f7ff fef6 	bl	3140 <log_output_msg_process>
	log_msg_put(msg);
    3354:	4620      	mov	r0, r4
}
    3356:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    335a:	f012 b871 	b.w	15440 <log_msg_put>
    335e:	bf00      	nop
    3360:	00019790 	.word	0x00019790

00003364 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    3364:	4b04      	ldr	r3, [pc, #16]	; (3378 <on_failed_write.part.0+0x14>)
	} else if (is_sync_mode()) {
    3366:	781b      	ldrb	r3, [r3, #0]
    3368:	b11b      	cbz	r3, 3372 <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
    336a:	f241 3088 	movw	r0, #5000	; 0x1388
    336e:	f015 bde2 	b.w	18f36 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
    3372:	2005      	movs	r0, #5
    3374:	f010 bf8c 	b.w	14290 <z_impl_k_sleep>
    3378:	20007a4c 	.word	0x20007a4c

0000337c <data_out_block_mode>:
{
    337c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    3380:	f8df 908c 	ldr.w	r9, [pc, #140]	; 3410 <data_out_block_mode+0x94>
	return z_impl_k_mutex_lock(mutex, timeout);
    3384:	f8df b08c 	ldr.w	fp, [pc, #140]	; 3414 <data_out_block_mode+0x98>
{
    3388:	4607      	mov	r7, r0
    338a:	460e      	mov	r6, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
    338c:	2404      	movs	r4, #4
    338e:	46ca      	mov	sl, r9
		if (!is_sync_mode()) {
    3390:	f899 3000 	ldrb.w	r3, [r9]
    3394:	b923      	cbnz	r3, 33a0 <data_out_block_mode+0x24>
    3396:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    339a:	4658      	mov	r0, fp
    339c:	f010 fb98 	bl	13ad0 <z_impl_k_mutex_lock>
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    33a0:	4632      	mov	r2, r6
    33a2:	4639      	mov	r1, r7
    33a4:	2000      	movs	r0, #0
    33a6:	f002 fabf 	bl	5928 <SEGGER_RTT_WriteSkipNoLock>
		if (!is_sync_mode()) {
    33aa:	f89a 3000 	ldrb.w	r3, [sl]
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    33ae:	4680      	mov	r8, r0
		if (!is_sync_mode()) {
    33b0:	b913      	cbnz	r3, 33b8 <data_out_block_mode+0x3c>
	return z_impl_k_mutex_unlock(mutex);
    33b2:	4658      	mov	r0, fp
    33b4:	f010 fbfe 	bl	13bb4 <z_impl_k_mutex_unlock>
		if (ret) {
    33b8:	4d14      	ldr	r5, [pc, #80]	; (340c <data_out_block_mode+0x90>)
    33ba:	f1b8 0f00 	cmp.w	r8, #0
    33be:	d018      	beq.n	33f2 <data_out_block_mode+0x76>
	host_present = true;
    33c0:	2301      	movs	r3, #1
    33c2:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
    33c4:	f89a 3000 	ldrb.w	r3, [sl]
    33c8:	b933      	cbnz	r3, 33d8 <data_out_block_mode+0x5c>
}
    33ca:	4630      	mov	r0, r6
    33cc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (retry_cnt == 0) {
    33d0:	b95c      	cbnz	r4, 33ea <data_out_block_mode+0x6e>
		host_present = false;
    33d2:	702c      	strb	r4, [r5, #0]
    33d4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    33d8:	2000      	movs	r0, #0
    33da:	f002 fb25 	bl	5a28 <SEGGER_RTT_HasDataUp>
    33de:	2800      	cmp	r0, #0
    33e0:	d0f3      	beq.n	33ca <data_out_block_mode+0x4e>
    33e2:	782b      	ldrb	r3, [r5, #0]
    33e4:	2b00      	cmp	r3, #0
    33e6:	d1f3      	bne.n	33d0 <data_out_block_mode+0x54>
    33e8:	e7ef      	b.n	33ca <data_out_block_mode+0x4e>
			on_failed_write(retry_cnt--);
    33ea:	3c01      	subs	r4, #1
    33ec:	f7ff ffba 	bl	3364 <on_failed_write.part.0>
    33f0:	e7f2      	b.n	33d8 <data_out_block_mode+0x5c>
		} else if (host_present) {
    33f2:	782b      	ldrb	r3, [r5, #0]
    33f4:	b113      	cbz	r3, 33fc <data_out_block_mode+0x80>
	if (retry_cnt == 0) {
    33f6:	3c01      	subs	r4, #1
    33f8:	d104      	bne.n	3404 <data_out_block_mode+0x88>
		host_present = false;
    33fa:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
    33fc:	782b      	ldrb	r3, [r5, #0]
    33fe:	2b00      	cmp	r3, #0
    3400:	d1c6      	bne.n	3390 <data_out_block_mode+0x14>
    3402:	e7e2      	b.n	33ca <data_out_block_mode+0x4e>
    3404:	f7ff ffae 	bl	3364 <on_failed_write.part.0>
    3408:	e7f8      	b.n	33fc <data_out_block_mode+0x80>
    340a:	bf00      	nop
    340c:	20007a4b 	.word	0x20007a4b
    3410:	20007a4c 	.word	0x20007a4c
    3414:	2000c39c 	.word	0x2000c39c

00003418 <class_handler>:
 * usb_enable() is no longer needed.
 */

static int class_handler(struct usb_setup_packet *pSetup,
			 s32_t *len, u8_t **data)
{
    3418:	b5f0      	push	{r4, r5, r6, r7, lr}
	size_t size = (__usb_data_end - __usb_data_start);
    341a:	4b10      	ldr	r3, [pc, #64]	; (345c <class_handler+0x44>)
    341c:	4c10      	ldr	r4, [pc, #64]	; (3460 <class_handler+0x48>)
    341e:	4d11      	ldr	r5, [pc, #68]	; (3464 <class_handler+0x4c>)
    3420:	1ae4      	subs	r4, r4, r3
    3422:	10a4      	asrs	r4, r4, #2
    3424:	436c      	muls	r4, r5
		if_descr = __usb_data_start[i].interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((u8_t *)if_descr < usb_dev.descriptors) {
    3426:	4d10      	ldr	r5, [pc, #64]	; (3468 <class_handler+0x50>)
    3428:	f8d5 c024 	ldr.w	ip, [r5, #36]	; 0x24
	for (size_t i = 0; i < size; i++) {
    342c:	2500      	movs	r5, #0
    342e:	42a5      	cmp	r5, r4
    3430:	d102      	bne.n	3438 <class_handler+0x20>
			return iface->class_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
    3432:	f06f 0022 	mvn.w	r0, #34	; 0x22
    3436:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if_descr = __usb_data_start[i].interface_descriptor;
    3438:	685f      	ldr	r7, [r3, #4]
		if ((u8_t *)if_descr < usb_dev.descriptors) {
    343a:	4567      	cmp	r7, ip
    343c:	d30a      	bcc.n	3454 <class_handler+0x3c>
		if ((iface->class_handler) &&
    343e:	691e      	ldr	r6, [r3, #16]
    3440:	b146      	cbz	r6, 3454 <class_handler+0x3c>
		    (if_descr->bInterfaceNumber ==
    3442:	f897 e002 	ldrb.w	lr, [r7, #2]
		     (sys_le16_to_cpu(pSetup->wIndex) & 0xFF))) {
    3446:	7907      	ldrb	r7, [r0, #4]
		if ((iface->class_handler) &&
    3448:	45be      	cmp	lr, r7
    344a:	d103      	bne.n	3454 <class_handler+0x3c>
			return iface->class_handler(pSetup, len, data);
    344c:	4633      	mov	r3, r6
}
    344e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			return iface->class_handler(pSetup, len, data);
    3452:	4718      	bx	r3
	for (size_t i = 0; i < size; i++) {
    3454:	3501      	adds	r5, #1
    3456:	3324      	adds	r3, #36	; 0x24
    3458:	e7e9      	b.n	342e <class_handler+0x16>
    345a:	bf00      	nop
    345c:	2000c4ec 	.word	0x2000c4ec
    3460:	2000c510 	.word	0x2000c510
    3464:	38e38e39 	.word	0x38e38e39
    3468:	200012c8 	.word	0x200012c8

0000346c <custom_handler>:

static int custom_handler(struct usb_setup_packet *pSetup,
			  s32_t *len, u8_t **data)
{
    346c:	b5f0      	push	{r4, r5, r6, r7, lr}
	size_t size = (__usb_data_end - __usb_data_start);
    346e:	4b10      	ldr	r3, [pc, #64]	; (34b0 <custom_handler+0x44>)
    3470:	4c10      	ldr	r4, [pc, #64]	; (34b4 <custom_handler+0x48>)
    3472:	4d11      	ldr	r5, [pc, #68]	; (34b8 <custom_handler+0x4c>)
    3474:	1ae4      	subs	r4, r4, r3
    3476:	10a4      	asrs	r4, r4, #2
    3478:	436c      	muls	r4, r5
		if_descr = __usb_data_start[i].interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((u8_t *)if_descr < usb_dev.descriptors) {
    347a:	4d10      	ldr	r5, [pc, #64]	; (34bc <custom_handler+0x50>)
    347c:	f8d5 c024 	ldr.w	ip, [r5, #36]	; 0x24
	for (size_t i = 0; i < size; i++) {
    3480:	2500      	movs	r5, #0
    3482:	42a5      	cmp	r5, r4
    3484:	d102      	bne.n	348c <custom_handler+0x20>
			return iface->custom_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
    3486:	f06f 0022 	mvn.w	r0, #34	; 0x22
    348a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if_descr = __usb_data_start[i].interface_descriptor;
    348c:	685f      	ldr	r7, [r3, #4]
		if ((u8_t *)if_descr < usb_dev.descriptors) {
    348e:	4567      	cmp	r7, ip
    3490:	d30a      	bcc.n	34a8 <custom_handler+0x3c>
		if ((iface->custom_handler) &&
    3492:	699e      	ldr	r6, [r3, #24]
    3494:	b146      	cbz	r6, 34a8 <custom_handler+0x3c>
    3496:	f897 e002 	ldrb.w	lr, [r7, #2]
    349a:	8887      	ldrh	r7, [r0, #4]
    349c:	45be      	cmp	lr, r7
    349e:	d103      	bne.n	34a8 <custom_handler+0x3c>
			return iface->custom_handler(pSetup, len, data);
    34a0:	4633      	mov	r3, r6
}
    34a2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			return iface->custom_handler(pSetup, len, data);
    34a6:	4718      	bx	r3
	for (size_t i = 0; i < size; i++) {
    34a8:	3501      	adds	r5, #1
    34aa:	3324      	adds	r3, #36	; 0x24
    34ac:	e7e9      	b.n	3482 <custom_handler+0x16>
    34ae:	bf00      	nop
    34b0:	2000c4ec 	.word	0x2000c4ec
    34b4:	2000c510 	.word	0x2000c510
    34b8:	38e38e39 	.word	0x38e38e39
    34bc:	200012c8 	.word	0x200012c8

000034c0 <vendor_handler>:

static int vendor_handler(struct usb_setup_packet *pSetup,
			  s32_t *len, u8_t **data)
{
    34c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	size_t size = (__usb_data_end - __usb_data_start);
    34c4:	4c0f      	ldr	r4, [pc, #60]	; (3504 <vendor_handler+0x44>)
    34c6:	4b10      	ldr	r3, [pc, #64]	; (3508 <vendor_handler+0x48>)
{
    34c8:	4617      	mov	r7, r2
	size_t size = (__usb_data_end - __usb_data_start);
    34ca:	1b1b      	subs	r3, r3, r4
    34cc:	4a0f      	ldr	r2, [pc, #60]	; (350c <vendor_handler+0x4c>)
    34ce:	109b      	asrs	r3, r3, #2
{
    34d0:	4605      	mov	r5, r0
    34d2:	460e      	mov	r6, r1
	size_t size = (__usb_data_end - __usb_data_start);
    34d4:	fb02 f903 	mul.w	r9, r2, r3
		if (!usb_handle_os_desc_feature(pSetup, len, data)) {
			return 0;
		}
	}

	for (size_t i = 0; i < size; i++) {
    34d8:	f04f 0800 	mov.w	r8, #0
    34dc:	45c1      	cmp	r9, r8
    34de:	d102      	bne.n	34e6 <vendor_handler+0x26>
				return 0;
			}
		}
	}

	return -ENOTSUP;
    34e0:	f06f 0022 	mvn.w	r0, #34	; 0x22
    34e4:	e00b      	b.n	34fe <vendor_handler+0x3e>
		if (iface->vendor_handler) {
    34e6:	6963      	ldr	r3, [r4, #20]
    34e8:	b91b      	cbnz	r3, 34f2 <vendor_handler+0x32>
	for (size_t i = 0; i < size; i++) {
    34ea:	f108 0801 	add.w	r8, r8, #1
    34ee:	3424      	adds	r4, #36	; 0x24
    34f0:	e7f4      	b.n	34dc <vendor_handler+0x1c>
			if (!iface->vendor_handler(pSetup, len, data)) {
    34f2:	463a      	mov	r2, r7
    34f4:	4631      	mov	r1, r6
    34f6:	4628      	mov	r0, r5
    34f8:	4798      	blx	r3
    34fa:	2800      	cmp	r0, #0
    34fc:	d1f5      	bne.n	34ea <vendor_handler+0x2a>
}
    34fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3502:	bf00      	nop
    3504:	2000c4ec 	.word	0x2000c4ec
    3508:	2000c510 	.word	0x2000c510
    350c:	38e38e39 	.word	0x38e38e39

00003510 <set_endpoint>:
{
    3510:	b507      	push	{r0, r1, r2, lr}
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
    3512:	7883      	ldrb	r3, [r0, #2]
    3514:	f88d 3000 	strb.w	r3, [sp]
	ep_cfg.ep_mps = sys_le16_to_cpu(ep_desc->wMaxPacketSize);
    3518:	7903      	ldrb	r3, [r0, #4]
    351a:	7942      	ldrb	r2, [r0, #5]
    351c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    3520:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
    3524:	78c3      	ldrb	r3, [r0, #3]
	ret = usb_dc_ep_configure(&ep_cfg);
    3526:	4668      	mov	r0, sp
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
    3528:	f003 0303 	and.w	r3, r3, #3
    352c:	f88d 3004 	strb.w	r3, [sp, #4]
	ret = usb_dc_ep_configure(&ep_cfg);
    3530:	f001 fea8 	bl	5284 <usb_dc_ep_configure>
	if (ret == -EALREADY) {
    3534:	f110 0f45 	cmn.w	r0, #69	; 0x45
    3538:	f89d 1000 	ldrb.w	r1, [sp]
    353c:	d00e      	beq.n	355c <set_endpoint+0x4c>
	} else if (ret) {
    353e:	b168      	cbz	r0, 355c <set_endpoint+0x4c>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    3540:	4a12      	ldr	r2, [pc, #72]	; (358c <set_endpoint+0x7c>)
    3542:	4b13      	ldr	r3, [pc, #76]	; (3590 <set_endpoint+0x80>)
		LOG_ERR("Failed to configure endpoint 0x%02x", ep_cfg.ep_addr);
    3544:	4813      	ldr	r0, [pc, #76]	; (3594 <set_endpoint+0x84>)
    3546:	1ad2      	subs	r2, r2, r3
    3548:	08d2      	lsrs	r2, r2, #3
    354a:	0192      	lsls	r2, r2, #6
    354c:	f042 0201 	orr.w	r2, r2, #1
		LOG_ERR("Failed to enable endpoint 0x%02x", ep_cfg.ep_addr);
    3550:	f011 fe88 	bl	15264 <log_1>
		return false;
    3554:	2000      	movs	r0, #0
}
    3556:	b003      	add	sp, #12
    3558:	f85d fb04 	ldr.w	pc, [sp], #4
	ret = usb_dc_ep_enable(ep_cfg.ep_addr);
    355c:	4608      	mov	r0, r1
    355e:	f001 ff2b 	bl	53b8 <usb_dc_ep_enable>
	if (ret == -EALREADY) {
    3562:	f110 0f45 	cmn.w	r0, #69	; 0x45
    3566:	d00b      	beq.n	3580 <set_endpoint+0x70>
	} else if (ret) {
    3568:	b150      	cbz	r0, 3580 <set_endpoint+0x70>
    356a:	4a08      	ldr	r2, [pc, #32]	; (358c <set_endpoint+0x7c>)
    356c:	4b08      	ldr	r3, [pc, #32]	; (3590 <set_endpoint+0x80>)
		LOG_ERR("Failed to enable endpoint 0x%02x", ep_cfg.ep_addr);
    356e:	f89d 1000 	ldrb.w	r1, [sp]
    3572:	4809      	ldr	r0, [pc, #36]	; (3598 <set_endpoint+0x88>)
    3574:	1ad2      	subs	r2, r2, r3
    3576:	08d2      	lsrs	r2, r2, #3
    3578:	0192      	lsls	r2, r2, #6
    357a:	f042 0201 	orr.w	r2, r2, #1
    357e:	e7e7      	b.n	3550 <set_endpoint+0x40>
	usb_dev.configured = true;
    3580:	4b06      	ldr	r3, [pc, #24]	; (359c <set_endpoint+0x8c>)
    3582:	2001      	movs	r0, #1
    3584:	f883 00b9 	strb.w	r0, [r3, #185]	; 0xb9
	return true;
    3588:	e7e5      	b.n	3556 <set_endpoint+0x46>
    358a:	bf00      	nop
    358c:	00019674 	.word	0x00019674
    3590:	0001956c 	.word	0x0001956c
    3594:	0001a306 	.word	0x0001a306
    3598:	0001a32a 	.word	0x0001a32a
    359c:	200012c8 	.word	0x200012c8

000035a0 <forward_status_cb>:
{
    35a0:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t size = (__usb_data_end - __usb_data_start);
    35a4:	4b25      	ldr	r3, [pc, #148]	; (363c <forward_status_cb+0x9c>)
    35a6:	4c26      	ldr	r4, [pc, #152]	; (3640 <forward_status_cb+0xa0>)
    35a8:	4f26      	ldr	r7, [pc, #152]	; (3644 <forward_status_cb+0xa4>)
    35aa:	1b1b      	subs	r3, r3, r4
    35ac:	109b      	asrs	r3, r3, #2
    35ae:	435f      	muls	r7, r3
	if (status == USB_DC_DISCONNECTED || status == USB_DC_SUSPEND) {
    35b0:	1f03      	subs	r3, r0, #4
    35b2:	2b01      	cmp	r3, #1
{
    35b4:	4605      	mov	r5, r0
    35b6:	460e      	mov	r6, r1
	if (status == USB_DC_DISCONNECTED || status == USB_DC_SUSPEND) {
    35b8:	d825      	bhi.n	3606 <forward_status_cb+0x66>
		if (usb_dev.configured) {
    35ba:	4b23      	ldr	r3, [pc, #140]	; (3648 <forward_status_cb+0xa8>)
    35bc:	f893 20b9 	ldrb.w	r2, [r3, #185]	; 0xb9
    35c0:	4698      	mov	r8, r3
    35c2:	b302      	cbz	r2, 3606 <forward_status_cb+0x66>
			usb_cancel_transfers();
    35c4:	f000 fe12 	bl	41ec <usb_cancel_transfers>
			if (status == USB_DC_DISCONNECTED) {
    35c8:	2d04      	cmp	r5, #4
    35ca:	d11c      	bne.n	3606 <forward_status_cb+0x66>
	for (size_t i = 0; i < size; i++) {
    35cc:	f04f 0900 	mov.w	r9, #0
    35d0:	454f      	cmp	r7, r9
    35d2:	d015      	beq.n	3600 <forward_status_cb+0x60>
		struct usb_ep_cfg_data *ep_data = cfg->endpoint;
    35d4:	f8d4 b020 	ldr.w	fp, [r4, #32]
		for (u8_t n = 0; n < cfg->num_endpoints; n++) {
    35d8:	f04f 0a00 	mov.w	sl, #0
    35dc:	7f22      	ldrb	r2, [r4, #28]
    35de:	fa5f f38a 	uxtb.w	r3, sl
    35e2:	429a      	cmp	r2, r3
    35e4:	d803      	bhi.n	35ee <forward_status_cb+0x4e>
	for (size_t i = 0; i < size; i++) {
    35e6:	f109 0901 	add.w	r9, r9, #1
    35ea:	3424      	adds	r4, #36	; 0x24
    35ec:	e7f0      	b.n	35d0 <forward_status_cb+0x30>
	return usb_dc_ep_disable(ep_data->ep_addr);
    35ee:	eb0b 03c3 	add.w	r3, fp, r3, lsl #3
    35f2:	f10a 0a01 	add.w	sl, sl, #1
    35f6:	7918      	ldrb	r0, [r3, #4]
    35f8:	f001 ff00 	bl	53fc <usb_dc_ep_disable>
			if (ret < 0) {
    35fc:	2800      	cmp	r0, #0
    35fe:	daed      	bge.n	35dc <forward_status_cb+0x3c>
				usb_dev.configured = false;
    3600:	2300      	movs	r3, #0
    3602:	f888 30b9 	strb.w	r3, [r8, #185]	; 0xb9
    3606:	4c0e      	ldr	r4, [pc, #56]	; (3640 <forward_status_cb+0xa0>)
	for (size_t i = 0; i < size; i++) {
    3608:	f04f 0800 	mov.w	r8, #0
	for (size_t i = 0; i < size; i++) {
    360c:	45b8      	cmp	r8, r7
    360e:	d108      	bne.n	3622 <forward_status_cb+0x82>
	if (usb_dev.user_status_callback) {
    3610:	4b0d      	ldr	r3, [pc, #52]	; (3648 <forward_status_cb+0xa8>)
    3612:	6a1b      	ldr	r3, [r3, #32]
    3614:	b17b      	cbz	r3, 3636 <forward_status_cb+0x96>
		usb_dev.user_status_callback(status, param);
    3616:	4631      	mov	r1, r6
    3618:	4628      	mov	r0, r5
}
    361a:	b001      	add	sp, #4
    361c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		usb_dev.user_status_callback(status, param);
    3620:	4718      	bx	r3
		if (cfg->cb_usb_status) {
    3622:	68e3      	ldr	r3, [r4, #12]
    3624:	b11b      	cbz	r3, 362e <forward_status_cb+0x8e>
			cfg->cb_usb_status(cfg, status, param);
    3626:	4632      	mov	r2, r6
    3628:	4629      	mov	r1, r5
    362a:	4620      	mov	r0, r4
    362c:	4798      	blx	r3
	for (size_t i = 0; i < size; i++) {
    362e:	f108 0801 	add.w	r8, r8, #1
    3632:	3424      	adds	r4, #36	; 0x24
    3634:	e7ea      	b.n	360c <forward_status_cb+0x6c>
}
    3636:	b001      	add	sp, #4
    3638:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    363c:	2000c510 	.word	0x2000c510
    3640:	2000c4ec 	.word	0x2000c4ec
    3644:	38e38e39 	.word	0x38e38e39
    3648:	200012c8 	.word	0x200012c8

0000364c <usb_handle_standard_request>:
{
    364c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (usb_dev.custom_req_handler &&
    3650:	4c97      	ldr	r4, [pc, #604]	; (38b0 <usb_handle_standard_request+0x264>)
    3652:	69a3      	ldr	r3, [r4, #24]
{
    3654:	b085      	sub	sp, #20
    3656:	4607      	mov	r7, r0
    3658:	460d      	mov	r5, r1
    365a:	4616      	mov	r6, r2
	if (usb_dev.custom_req_handler &&
    365c:	b98b      	cbnz	r3, 3682 <usb_handle_standard_request+0x36>
	switch (REQTYPE_GET_RECIP(setup->bmRequestType)) {
    365e:	f897 8000 	ldrb.w	r8, [r7]
    3662:	f008 081f 	and.w	r8, r8, #31
    3666:	f1b8 0f01 	cmp.w	r8, #1
    366a:	f000 808a 	beq.w	3782 <usb_handle_standard_request+0x136>
    366e:	f1b8 0f02 	cmp.w	r8, #2
    3672:	f000 80e3 	beq.w	383c <usb_handle_standard_request+0x1f0>
    3676:	f1b8 0f00 	cmp.w	r8, #0
    367a:	d008      	beq.n	368e <usb_handle_standard_request+0x42>
	switch (setup->bRequest) {
    367c:	f06f 0015 	mvn.w	r0, #21
    3680:	e002      	b.n	3688 <usb_handle_standard_request+0x3c>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
    3682:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
    3684:	2800      	cmp	r0, #0
    3686:	d1ea      	bne.n	365e <usb_handle_standard_request+0x12>
}
    3688:	b005      	add	sp, #20
    368a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u16_t value = sys_le16_to_cpu(setup->wValue);
    368e:	787a      	ldrb	r2, [r7, #1]
    3690:	8878      	ldrh	r0, [r7, #2]
	u8_t *data = *data_buf;
    3692:	6833      	ldr	r3, [r6, #0]
	switch (setup->bRequest) {
    3694:	2a09      	cmp	r2, #9
    3696:	d8f1      	bhi.n	367c <usb_handle_standard_request+0x30>
    3698:	a101      	add	r1, pc, #4	; (adr r1, 36a0 <usb_handle_standard_request+0x54>)
    369a:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    369e:	bf00      	nop
    36a0:	000036c9 	.word	0x000036c9
    36a4:	0000367d 	.word	0x0000367d
    36a8:	0000367d 	.word	0x0000367d
    36ac:	0000367d 	.word	0x0000367d
    36b0:	0000367d 	.word	0x0000367d
    36b4:	000036d5 	.word	0x000036d5
    36b8:	000036df 	.word	0x000036df
    36bc:	0000367d 	.word	0x0000367d
    36c0:	0000370d 	.word	0x0000370d
    36c4:	00003717 	.word	0x00003717
		data[0] = 0U;
    36c8:	2000      	movs	r0, #0
		data[0] = 0U;
    36ca:	7018      	strb	r0, [r3, #0]
		data[1] = 0U;
    36cc:	7058      	strb	r0, [r3, #1]
		*len = 2;
    36ce:	2302      	movs	r3, #2
    36d0:	602b      	str	r3, [r5, #0]
		break;
    36d2:	e7d9      	b.n	3688 <usb_handle_standard_request+0x3c>
		usb_dc_set_address(value);
    36d4:	b2c0      	uxtb	r0, r0
    36d6:	f001 fd95 	bl	5204 <usb_dc_set_address>
	int rc = 0;
    36da:	2000      	movs	r0, #0
    36dc:	e7d4      	b.n	3688 <usb_handle_standard_request+0x3c>
	type = GET_DESC_TYPE(type_index);
    36de:	0a02      	lsrs	r2, r0, #8
	if ((type == USB_INTERFACE_DESC) || (type == USB_ENDPOINT_DESC) ||
    36e0:	1f13      	subs	r3, r2, #4
    36e2:	2b01      	cmp	r3, #1
    36e4:	d9ca      	bls.n	367c <usb_handle_standard_request+0x30>
    36e6:	2a07      	cmp	r2, #7
    36e8:	d8c8      	bhi.n	367c <usb_handle_standard_request+0x30>
	p = (u8_t *)usb_dev.descriptors;
    36ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
	index = GET_DESC_INDEX(type_index);
    36ec:	b2c0      	uxtb	r0, r0
	cur_index = 0;
    36ee:	2100      	movs	r1, #0
	while (p[DESC_bLength] != 0U) {
    36f0:	781c      	ldrb	r4, [r3, #0]
    36f2:	2c00      	cmp	r4, #0
    36f4:	d0c2      	beq.n	367c <usb_handle_standard_request+0x30>
		if (p[DESC_bDescriptorType] == type) {
    36f6:	785f      	ldrb	r7, [r3, #1]
    36f8:	4297      	cmp	r7, r2
    36fa:	d103      	bne.n	3704 <usb_handle_standard_request+0xb8>
			if (cur_index == index) {
    36fc:	4288      	cmp	r0, r1
    36fe:	f000 80cf 	beq.w	38a0 <usb_handle_standard_request+0x254>
			cur_index++;
    3702:	3101      	adds	r1, #1
		p += p[DESC_bLength];
    3704:	4423      	add	r3, r4
    3706:	e7f3      	b.n	36f0 <usb_handle_standard_request+0xa4>
			*len = p[DESC_bLength];
    3708:	781b      	ldrb	r3, [r3, #0]
    370a:	e0ce      	b.n	38aa <usb_handle_standard_request+0x25e>
		data[0] = usb_dev.configuration;
    370c:	f894 20ba 	ldrb.w	r2, [r4, #186]	; 0xba
    3710:	701a      	strb	r2, [r3, #0]
		*len = 1;
    3712:	2301      	movs	r3, #1
    3714:	e0c9      	b.n	38aa <usb_handle_standard_request+0x25e>
		if (!usb_set_configuration(value, 0)) {
    3716:	b2c7      	uxtb	r7, r0
    3718:	f88d 700f 	strb.w	r7, [sp, #15]
	if (config_index == 0U) {
    371c:	b177      	cbz	r7, 373c <usb_handle_standard_request+0xf0>
	u8_t cur_config = 0xFF;
    371e:	f04f 08ff 	mov.w	r8, #255	; 0xff
	u8_t *p = (u8_t *)usb_dev.descriptors;
    3722:	6a65      	ldr	r5, [r4, #36]	; 0x24
	bool found = false;
    3724:	2600      	movs	r6, #0
	u8_t cur_alt_setting = 0xFF;
    3726:	46c1      	mov	r9, r8
	while (p[DESC_bLength] != 0U) {
    3728:	782b      	ldrb	r3, [r5, #0]
    372a:	b953      	cbnz	r3, 3742 <usb_handle_standard_request+0xf6>
	if (usb_dev.status_callback) {
    372c:	69e3      	ldr	r3, [r4, #28]
    372e:	b11b      	cbz	r3, 3738 <usb_handle_standard_request+0xec>
		usb_dev.status_callback(USB_DC_CONFIGURED, &config_index);
    3730:	f10d 010f 	add.w	r1, sp, #15
    3734:	2003      	movs	r0, #3
    3736:	4798      	blx	r3
		if (!usb_set_configuration(value, 0)) {
    3738:	2e00      	cmp	r6, #0
    373a:	d09f      	beq.n	367c <usb_handle_standard_request+0x30>
			usb_dev.configuration = value;
    373c:	f884 70ba 	strb.w	r7, [r4, #186]	; 0xba
	return ret;
    3740:	e7cb      	b.n	36da <usb_handle_standard_request+0x8e>
		switch (p[DESC_bDescriptorType]) {
    3742:	786b      	ldrb	r3, [r5, #1]
    3744:	2b04      	cmp	r3, #4
    3746:	d00d      	beq.n	3764 <usb_handle_standard_request+0x118>
    3748:	2b05      	cmp	r3, #5
    374a:	d00e      	beq.n	376a <usb_handle_standard_request+0x11e>
    374c:	2b02      	cmp	r3, #2
    374e:	d106      	bne.n	375e <usb_handle_standard_request+0x112>
			cur_config = p[CONF_DESC_bConfigurationValue];
    3750:	f895 8005 	ldrb.w	r8, [r5, #5]
			if (cur_config == config_index) {
    3754:	f89d 300f 	ldrb.w	r3, [sp, #15]
				found = true;
    3758:	4543      	cmp	r3, r8
    375a:	bf08      	it	eq
    375c:	2601      	moveq	r6, #1
		p += p[DESC_bLength];
    375e:	782b      	ldrb	r3, [r5, #0]
    3760:	441d      	add	r5, r3
    3762:	e7e1      	b.n	3728 <usb_handle_standard_request+0xdc>
			cur_alt_setting =
    3764:	f895 9003 	ldrb.w	r9, [r5, #3]
			break;
    3768:	e7f9      	b.n	375e <usb_handle_standard_request+0x112>
			if ((cur_config != config_index) ||
    376a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    376e:	4543      	cmp	r3, r8
    3770:	d1f5      	bne.n	375e <usb_handle_standard_request+0x112>
    3772:	f1b9 0f00 	cmp.w	r9, #0
    3776:	d1f2      	bne.n	375e <usb_handle_standard_request+0x112>
			found = set_endpoint((struct usb_ep_descriptor *)p);
    3778:	4628      	mov	r0, r5
    377a:	f7ff fec9 	bl	3510 <set_endpoint>
    377e:	4606      	mov	r6, r0
			break;
    3780:	e7ed      	b.n	375e <usb_handle_standard_request+0x112>
	switch (setup->bRequest) {
    3782:	7878      	ldrb	r0, [r7, #1]
		if (usb_handle_std_interface_req(setup, len, data_buf) == false) {
    3784:	6833      	ldr	r3, [r6, #0]
	switch (setup->bRequest) {
    3786:	280a      	cmp	r0, #10
    3788:	d005      	beq.n	3796 <usb_handle_standard_request+0x14a>
    378a:	280b      	cmp	r0, #11
    378c:	d008      	beq.n	37a0 <usb_handle_standard_request+0x154>
    378e:	2800      	cmp	r0, #0
    3790:	f47f af74 	bne.w	367c <usb_handle_standard_request+0x30>
    3794:	e799      	b.n	36ca <usb_handle_standard_request+0x7e>
		data[0] = 0U;
    3796:	2000      	movs	r0, #0
    3798:	7018      	strb	r0, [r3, #0]
		*len = 1;
    379a:	f8c5 8000 	str.w	r8, [r5]
		break;
    379e:	e773      	b.n	3688 <usb_handle_standard_request+0x3c>
    37a0:	4a44      	ldr	r2, [pc, #272]	; (38b4 <usb_handle_standard_request+0x268>)
    37a2:	4945      	ldr	r1, [pc, #276]	; (38b8 <usb_handle_standard_request+0x26c>)
		usb_set_interface(sys_le16_to_cpu(setup->wIndex),
    37a4:	793b      	ldrb	r3, [r7, #4]
    37a6:	9300      	str	r3, [sp, #0]
    37a8:	1a52      	subs	r2, r2, r1
    37aa:	08d2      	lsrs	r2, r2, #3
		LOG_ERR("Failed to disable endpoint 0x%02x", ep_cfg.ep_addr);
    37ac:	0192      	lsls	r2, r2, #6
	u8_t cur_iface = 0xFF;
    37ae:	26ff      	movs	r6, #255	; 0xff
		LOG_ERR("Failed to disable endpoint 0x%02x", ep_cfg.ep_addr);
    37b0:	f042 0301 	orr.w	r3, r2, #1
	const u8_t *p = usb_dev.descriptors;
    37b4:	f8d4 b024 	ldr.w	fp, [r4, #36]	; 0x24
		usb_set_interface(sys_le16_to_cpu(setup->wIndex),
    37b8:	f897 a002 	ldrb.w	sl, [r7, #2]
		LOG_ERR("Failed to disable endpoint 0x%02x", ep_cfg.ep_addr);
    37bc:	9301      	str	r3, [sp, #4]
	u8_t cur_alt_setting = 0xFF;
    37be:	46b0      	mov	r8, r6
	const u8_t *if_desc = NULL;
    37c0:	2700      	movs	r7, #0
	while (p[DESC_bLength] != 0U) {
    37c2:	f89b 2000 	ldrb.w	r2, [fp]
    37c6:	b93a      	cbnz	r2, 37d8 <usb_handle_standard_request+0x18c>
	if (usb_dev.status_callback) {
    37c8:	69e3      	ldr	r3, [r4, #28]
    37ca:	b113      	cbz	r3, 37d2 <usb_handle_standard_request+0x186>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
    37cc:	4639      	mov	r1, r7
    37ce:	2007      	movs	r0, #7
    37d0:	4798      	blx	r3
		*len = 0;
    37d2:	2000      	movs	r0, #0
    37d4:	6028      	str	r0, [r5, #0]
		break;
    37d6:	e757      	b.n	3688 <usb_handle_standard_request+0x3c>
		switch (p[DESC_bDescriptorType]) {
    37d8:	f89b 2001 	ldrb.w	r2, [fp, #1]
    37dc:	2a04      	cmp	r2, #4
    37de:	d005      	beq.n	37ec <usb_handle_standard_request+0x1a0>
    37e0:	2a05      	cmp	r2, #5
    37e2:	d00e      	beq.n	3802 <usb_handle_standard_request+0x1b6>
		p += p[DESC_bLength];
    37e4:	f89b 2000 	ldrb.w	r2, [fp]
    37e8:	4493      	add	fp, r2
    37ea:	e7ea      	b.n	37c2 <usb_handle_standard_request+0x176>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
    37ec:	f89b 6002 	ldrb.w	r6, [fp, #2]
			if (cur_iface == iface &&
    37f0:	9b00      	ldr	r3, [sp, #0]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
    37f2:	f89b 8003 	ldrb.w	r8, [fp, #3]
			if (cur_iface == iface &&
    37f6:	42b3      	cmp	r3, r6
    37f8:	d1f4      	bne.n	37e4 <usb_handle_standard_request+0x198>
    37fa:	45c2      	cmp	sl, r8
    37fc:	bf08      	it	eq
    37fe:	465f      	moveq	r7, fp
    3800:	e7f0      	b.n	37e4 <usb_handle_standard_request+0x198>
			if (cur_iface == iface) {
    3802:	9b00      	ldr	r3, [sp, #0]
    3804:	42b3      	cmp	r3, r6
    3806:	d1ed      	bne.n	37e4 <usb_handle_standard_request+0x198>
	if (cur_alt_setting != alt_setting) {
    3808:	45c2      	cmp	sl, r8
    380a:	d013      	beq.n	3834 <usb_handle_standard_request+0x1e8>
		ret = reset_endpoint(ep_desc);
    380c:	f89b 9002 	ldrb.w	r9, [fp, #2]
	usb_cancel_transfer(ep_cfg.ep_addr);
    3810:	4648      	mov	r0, r9
    3812:	f000 fcc3 	bl	419c <usb_cancel_transfer>
	ret = usb_dc_ep_disable(ep_cfg.ep_addr);
    3816:	4648      	mov	r0, r9
    3818:	f001 fdf0 	bl	53fc <usb_dc_ep_disable>
	if (ret == -EALREADY) {
    381c:	f110 0f45 	cmn.w	r0, #69	; 0x45
    3820:	d0e0      	beq.n	37e4 <usb_handle_standard_request+0x198>
	} else if (ret) {
    3822:	2800      	cmp	r0, #0
    3824:	d0de      	beq.n	37e4 <usb_handle_standard_request+0x198>
		LOG_ERR("Failed to disable endpoint 0x%02x", ep_cfg.ep_addr);
    3826:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    382a:	4824      	ldr	r0, [pc, #144]	; (38bc <usb_handle_standard_request+0x270>)
    382c:	4649      	mov	r1, r9
    382e:	f011 fd19 	bl	15264 <log_1>
		return false;
    3832:	e7d7      	b.n	37e4 <usb_handle_standard_request+0x198>
		ret = set_endpoint(ep_desc);
    3834:	4658      	mov	r0, fp
    3836:	f7ff fe6b 	bl	3510 <set_endpoint>
    383a:	e7d3      	b.n	37e4 <usb_handle_standard_request+0x198>
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false) {
    383c:	f8d6 9000 	ldr.w	r9, [r6]
	switch (setup->bRequest) {
    3840:	787e      	ldrb	r6, [r7, #1]
	u8_t ep = sys_le16_to_cpu(setup->wIndex);
    3842:	7938      	ldrb	r0, [r7, #4]
    3844:	f88d 000f 	strb.w	r0, [sp, #15]
	switch (setup->bRequest) {
    3848:	2e01      	cmp	r6, #1
    384a:	d00c      	beq.n	3866 <usb_handle_standard_request+0x21a>
    384c:	2e03      	cmp	r6, #3
    384e:	d019      	beq.n	3884 <usb_handle_standard_request+0x238>
    3850:	2e00      	cmp	r6, #0
    3852:	f47f af13 	bne.w	367c <usb_handle_standard_request+0x30>
		usb_dc_ep_is_stalled(ep, &data[0]);
    3856:	4649      	mov	r1, r9
    3858:	f001 fd94 	bl	5384 <usb_dc_ep_is_stalled>
		data[1] = 0U;
    385c:	f889 6001 	strb.w	r6, [r9, #1]
		*len = 2;
    3860:	f8c5 8000 	str.w	r8, [r5]
		break;
    3864:	e739      	b.n	36da <usb_handle_standard_request+0x8e>
		if (sys_le16_to_cpu(setup->wValue) == FEA_ENDPOINT_HALT) {
    3866:	887d      	ldrh	r5, [r7, #2]
    3868:	2d00      	cmp	r5, #0
    386a:	f47f af07 	bne.w	367c <usb_handle_standard_request+0x30>
			usb_dc_ep_clear_stall(ep);
    386e:	f001 fd6f 	bl	5350 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
    3872:	69e3      	ldr	r3, [r4, #28]
    3874:	2b00      	cmp	r3, #0
    3876:	f43f af30 	beq.w	36da <usb_handle_standard_request+0x8e>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
    387a:	f10d 010f 	add.w	r1, sp, #15
    387e:	2009      	movs	r0, #9
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
    3880:	4798      	blx	r3
    3882:	e72a      	b.n	36da <usb_handle_standard_request+0x8e>
		if (sys_le16_to_cpu(setup->wValue) == FEA_ENDPOINT_HALT) {
    3884:	887d      	ldrh	r5, [r7, #2]
    3886:	2d00      	cmp	r5, #0
    3888:	f47f aef8 	bne.w	367c <usb_handle_standard_request+0x30>
			usb_dc_ep_set_stall(ep);
    388c:	f001 fd2a 	bl	52e4 <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
    3890:	69e3      	ldr	r3, [r4, #28]
    3892:	2b00      	cmp	r3, #0
    3894:	f43f af21 	beq.w	36da <usb_handle_standard_request+0x8e>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
    3898:	f10d 010f 	add.w	r1, sp, #15
    389c:	2008      	movs	r0, #8
    389e:	e7ef      	b.n	3880 <usb_handle_standard_request+0x234>
		if (type == USB_CONFIGURATION_DESC) {
    38a0:	2a02      	cmp	r2, #2
		*data = p;
    38a2:	6033      	str	r3, [r6, #0]
		if (type == USB_CONFIGURATION_DESC) {
    38a4:	f47f af30 	bne.w	3708 <usb_handle_standard_request+0xbc>
			*len = (p[CONF_DESC_wTotalLength]) |
    38a8:	885b      	ldrh	r3, [r3, #2]
    38aa:	602b      	str	r3, [r5, #0]
    38ac:	e715      	b.n	36da <usb_handle_standard_request+0x8e>
    38ae:	bf00      	nop
    38b0:	200012c8 	.word	0x200012c8
    38b4:	00019674 	.word	0x00019674
    38b8:	0001956c 	.word	0x0001956c
    38bc:	0001a34b 	.word	0x0001a34b

000038c0 <usb_handle_request.constprop.0>:
static bool usb_handle_request(struct usb_setup_packet *setup,
    38c0:	b508      	push	{r3, lr}
	usb_request_handler handler = usb_dev.req_handlers[type];
    38c2:	4809      	ldr	r0, [pc, #36]	; (38e8 <usb_handle_request.constprop.0+0x28>)
	u32_t type = REQTYPE_GET_TYPE(setup->bmRequestType);
    38c4:	7803      	ldrb	r3, [r0, #0]
    38c6:	f3c3 1341 	ubfx	r3, r3, #5, #2
	usb_request_handler handler = usb_dev.req_handlers[type];
    38ca:	330a      	adds	r3, #10
    38cc:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if (handler == NULL) {
    38d0:	b13b      	cbz	r3, 38e2 <usb_handle_request.constprop.0+0x22>
	if ((*handler)(setup, len, data) < 0) {
    38d2:	f100 0208 	add.w	r2, r0, #8
    38d6:	f100 0110 	add.w	r1, r0, #16
    38da:	4798      	blx	r3
    38dc:	43c0      	mvns	r0, r0
    38de:	0fc0      	lsrs	r0, r0, #31
}
    38e0:	bd08      	pop	{r3, pc}
		return false;
    38e2:	4618      	mov	r0, r3
    38e4:	e7fc      	b.n	38e0 <usb_handle_request.constprop.0+0x20>
    38e6:	bf00      	nop
    38e8:	200012c8 	.word	0x200012c8

000038ec <usb_data_to_host.isra.0>:
static void usb_data_to_host(u16_t len)
    38ec:	b513      	push	{r0, r1, r4, lr}
	if (usb_dev.zlp_flag == false) {
    38ee:	4c0d      	ldr	r4, [pc, #52]	; (3924 <usb_data_to_host.isra.0+0x38>)
    38f0:	7d23      	ldrb	r3, [r4, #20]
    38f2:	b97b      	cbnz	r3, 3914 <usb_data_to_host.isra.0+0x28>
		u32_t chunk = usb_dev.data_buf_residue;
    38f4:	68e2      	ldr	r2, [r4, #12]
		usb_write(USB_CONTROL_IN_EP0, usb_dev.data_buf,
    38f6:	68a1      	ldr	r1, [r4, #8]
		u32_t chunk = usb_dev.data_buf_residue;
    38f8:	9201      	str	r2, [sp, #4]
		usb_write(USB_CONTROL_IN_EP0, usb_dev.data_buf,
    38fa:	ab01      	add	r3, sp, #4
    38fc:	2080      	movs	r0, #128	; 0x80
    38fe:	f012 f804 	bl	1590a <usb_write>
		usb_dev.data_buf += chunk;
    3902:	9901      	ldr	r1, [sp, #4]
    3904:	68a2      	ldr	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    3906:	68e3      	ldr	r3, [r4, #12]
		usb_dev.data_buf += chunk;
    3908:	440a      	add	r2, r1
		usb_dev.data_buf_residue -= chunk;
    390a:	1a5b      	subs	r3, r3, r1
		usb_dev.data_buf += chunk;
    390c:	60a2      	str	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    390e:	60e3      	str	r3, [r4, #12]
}
    3910:	b002      	add	sp, #8
    3912:	bd10      	pop	{r4, pc}
		usb_dev.zlp_flag = false;
    3914:	2300      	movs	r3, #0
		usb_dc_ep_write(USB_CONTROL_IN_EP0, NULL, 0, NULL);
    3916:	461a      	mov	r2, r3
    3918:	4619      	mov	r1, r3
    391a:	2080      	movs	r0, #128	; 0x80
		usb_dev.zlp_flag = false;
    391c:	7523      	strb	r3, [r4, #20]
		usb_dc_ep_write(USB_CONTROL_IN_EP0, NULL, 0, NULL);
    391e:	f001 fd8b 	bl	5438 <usb_dc_ep_write>
}
    3922:	e7f5      	b.n	3910 <usb_data_to_host.isra.0+0x24>
    3924:	200012c8 	.word	0x200012c8

00003928 <usb_handle_control_transfer>:
{
    3928:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u32_t chunk = 0U;
    392a:	2200      	movs	r2, #0
{
    392c:	460b      	mov	r3, r1
	u32_t chunk = 0U;
    392e:	9201      	str	r2, [sp, #4]
	if (ep == USB_CONTROL_OUT_EP0 && ep_status == USB_DC_EP_SETUP) {
    3930:	4605      	mov	r5, r0
    3932:	2800      	cmp	r0, #0
    3934:	d15d      	bne.n	39f2 <usb_handle_control_transfer+0xca>
    3936:	4c34      	ldr	r4, [pc, #208]	; (3a08 <usb_handle_control_transfer+0xe0>)
    3938:	2900      	cmp	r1, #0
    393a:	d135      	bne.n	39a8 <usb_handle_control_transfer+0x80>
		if (usb_dc_ep_read(ep,
    393c:	2208      	movs	r2, #8
    393e:	4621      	mov	r1, r4
    3940:	f012 fa64 	bl	15e0c <usb_dc_ep_read>
    3944:	2800      	cmp	r0, #0
    3946:	da04      	bge.n	3952 <usb_handle_control_transfer+0x2a>
			usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);
    3948:	2080      	movs	r0, #128	; 0x80
				usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);
    394a:	f001 fccb 	bl	52e4 <usb_dc_ep_set_stall>
}
    394e:	b002      	add	sp, #8
    3950:	bd70      	pop	{r4, r5, r6, pc}
		length = sys_le16_to_cpu(setup->wLength);
    3952:	88e5      	ldrh	r5, [r4, #6]
		if (length > CONFIG_USB_REQUEST_BUFFER_SIZE) {
    3954:	2d80      	cmp	r5, #128	; 0x80
    3956:	d911      	bls.n	397c <usb_handle_control_transfer+0x54>
			if (REQTYPE_GET_DIR(setup->bmRequestType)
    3958:	7820      	ldrb	r0, [r4, #0]
    395a:	09c6      	lsrs	r6, r0, #7
    395c:	d10e      	bne.n	397c <usb_handle_control_transfer+0x54>
    395e:	4b2b      	ldr	r3, [pc, #172]	; (3a0c <usb_handle_control_transfer+0xe4>)
    3960:	492b      	ldr	r1, [pc, #172]	; (3a10 <usb_handle_control_transfer+0xe8>)
				LOG_ERR("Request buffer too small");
    3962:	482c      	ldr	r0, [pc, #176]	; (3a14 <usb_handle_control_transfer+0xec>)
    3964:	1ac9      	subs	r1, r1, r3
    3966:	08c9      	lsrs	r1, r1, #3
    3968:	0189      	lsls	r1, r1, #6
    396a:	f041 0101 	orr.w	r1, r1, #1
    396e:	f011 fc6c 	bl	1524a <log_0>
				usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);
    3972:	2080      	movs	r0, #128	; 0x80
    3974:	f001 fcb6 	bl	52e4 <usb_dc_ep_set_stall>
				usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);
    3978:	4630      	mov	r0, r6
    397a:	e7e6      	b.n	394a <usb_handle_control_transfer+0x22>
		usb_dev.data_buf = usb_dev.req_data;
    397c:	4b26      	ldr	r3, [pc, #152]	; (3a18 <usb_handle_control_transfer+0xf0>)
		usb_dev.data_buf_len = length;
    397e:	6125      	str	r5, [r4, #16]
		usb_dev.data_buf_residue = length;
    3980:	e9c4 3502 	strd	r3, r5, [r4, #8]
		usb_dev.zlp_flag = false;
    3984:	2300      	movs	r3, #0
    3986:	7523      	strb	r3, [r4, #20]
		if (length &&
    3988:	b115      	cbz	r5, 3990 <usb_handle_control_transfer+0x68>
		    REQTYPE_GET_DIR(setup->bmRequestType)
    398a:	7823      	ldrb	r3, [r4, #0]
		if (length &&
    398c:	09db      	lsrs	r3, r3, #7
    398e:	d0de      	beq.n	394e <usb_handle_control_transfer+0x26>
		if (!usb_handle_request(setup,
    3990:	f7ff ff96 	bl	38c0 <usb_handle_request.constprop.0>
    3994:	2800      	cmp	r0, #0
    3996:	d0d7      	beq.n	3948 <usb_handle_control_transfer+0x20>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len, length);
    3998:	6923      	ldr	r3, [r4, #16]
    399a:	42ab      	cmp	r3, r5
    399c:	bfd4      	ite	le
    399e:	60e3      	strle	r3, [r4, #12]
    39a0:	60e5      	strgt	r5, [r4, #12]
			usb_data_to_host(sys_le16_to_cpu(setup->wLength));
    39a2:	f7ff ffa3 	bl	38ec <usb_data_to_host.isra.0>
    39a6:	e7d2      	b.n	394e <usb_handle_control_transfer+0x26>
		if (usb_dev.data_buf_residue <= 0) {
    39a8:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
    39ac:	2a00      	cmp	r2, #0
			if (usb_dc_ep_read(USB_CONTROL_OUT_EP0,
    39ae:	ab01      	add	r3, sp, #4
		if (usb_dev.data_buf_residue <= 0) {
    39b0:	dc05      	bgt.n	39be <usb_handle_control_transfer+0x96>
			if (usb_dc_ep_read(USB_CONTROL_OUT_EP0,
    39b2:	4602      	mov	r2, r0
    39b4:	f012 fa2a 	bl	15e0c <usb_dc_ep_read>
    39b8:	2800      	cmp	r0, #0
    39ba:	dac8      	bge.n	394e <usb_handle_control_transfer+0x26>
    39bc:	e7c4      	b.n	3948 <usb_handle_control_transfer+0x20>
		if (usb_dc_ep_read(USB_CONTROL_OUT_EP0,
    39be:	f012 fa25 	bl	15e0c <usb_dc_ep_read>
    39c2:	2800      	cmp	r0, #0
    39c4:	da04      	bge.n	39d0 <usb_handle_control_transfer+0xa8>
			usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);
    39c6:	2080      	movs	r0, #128	; 0x80
    39c8:	f001 fc8c 	bl	52e4 <usb_dc_ep_set_stall>
			usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);
    39cc:	4628      	mov	r0, r5
    39ce:	e7bc      	b.n	394a <usb_handle_control_transfer+0x22>
		usb_dev.data_buf += chunk;
    39d0:	9901      	ldr	r1, [sp, #4]
    39d2:	68a2      	ldr	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    39d4:	68e3      	ldr	r3, [r4, #12]
		usb_dev.data_buf += chunk;
    39d6:	440a      	add	r2, r1
		usb_dev.data_buf_residue -= chunk;
    39d8:	1a5b      	subs	r3, r3, r1
		usb_dev.data_buf += chunk;
    39da:	60a2      	str	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    39dc:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
    39de:	2b00      	cmp	r3, #0
    39e0:	d1b5      	bne.n	394e <usb_handle_control_transfer+0x26>
			usb_dev.data_buf = usb_dev.req_data;
    39e2:	f104 0338 	add.w	r3, r4, #56	; 0x38
    39e6:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
    39e8:	f7ff ff6a 	bl	38c0 <usb_handle_request.constprop.0>
    39ec:	2800      	cmp	r0, #0
    39ee:	d1d8      	bne.n	39a2 <usb_handle_control_transfer+0x7a>
    39f0:	e7aa      	b.n	3948 <usb_handle_control_transfer+0x20>
	} else if (ep == USB_CONTROL_IN_EP0) {
    39f2:	2880      	cmp	r0, #128	; 0x80
    39f4:	d1ab      	bne.n	394e <usb_handle_control_transfer+0x26>
		if (usb_dev.data_buf_residue != 0 || usb_dev.zlp_flag == true) {
    39f6:	4b04      	ldr	r3, [pc, #16]	; (3a08 <usb_handle_control_transfer+0xe0>)
    39f8:	68da      	ldr	r2, [r3, #12]
    39fa:	2a00      	cmp	r2, #0
    39fc:	d1d1      	bne.n	39a2 <usb_handle_control_transfer+0x7a>
    39fe:	7d1b      	ldrb	r3, [r3, #20]
    3a00:	2b00      	cmp	r3, #0
    3a02:	d1ce      	bne.n	39a2 <usb_handle_control_transfer+0x7a>
    3a04:	e7a3      	b.n	394e <usb_handle_control_transfer+0x26>
    3a06:	bf00      	nop
    3a08:	200012c8 	.word	0x200012c8
    3a0c:	0001956c 	.word	0x0001956c
    3a10:	00019674 	.word	0x00019674
    3a14:	0001a36d 	.word	0x0001a36d
    3a18:	20001300 	.word	0x20001300

00003a1c <usb_set_config>:
	usb_dev.descriptors = usb_descriptors;
    3a1c:	4b05      	ldr	r3, [pc, #20]	; (3a34 <usb_set_config+0x18>)
	usb_dev.req_handlers[type] = handler;
    3a1e:	4a06      	ldr	r2, [pc, #24]	; (3a38 <usb_set_config+0x1c>)
    3a20:	629a      	str	r2, [r3, #40]	; 0x28
    3a22:	4a06      	ldr	r2, [pc, #24]	; (3a3c <usb_set_config+0x20>)
    3a24:	62da      	str	r2, [r3, #44]	; 0x2c
    3a26:	4a06      	ldr	r2, [pc, #24]	; (3a40 <usb_set_config+0x24>)
    3a28:	631a      	str	r2, [r3, #48]	; 0x30
	usb_dev.custom_req_handler = handler;
    3a2a:	4a06      	ldr	r2, [pc, #24]	; (3a44 <usb_set_config+0x28>)
	usb_dev.descriptors = usb_descriptors;
    3a2c:	6258      	str	r0, [r3, #36]	; 0x24
	usb_dev.custom_req_handler = handler;
    3a2e:	619a      	str	r2, [r3, #24]

	/* register class request handlers for each interface*/
	usb_register_custom_req_handler(custom_handler);

	return 0;
}
    3a30:	2000      	movs	r0, #0
    3a32:	4770      	bx	lr
    3a34:	200012c8 	.word	0x200012c8
    3a38:	0000364d 	.word	0x0000364d
    3a3c:	00003419 	.word	0x00003419
    3a40:	000034c1 	.word	0x000034c1
    3a44:	0000346d 	.word	0x0000346d

00003a48 <usb_device_init>:
 */
static int usb_device_init(struct device *dev)
{
	u8_t *device_descriptor;

	if (usb_dev.enabled == true) {
    3a48:	4b0c      	ldr	r3, [pc, #48]	; (3a7c <usb_device_init+0x34>)
{
    3a4a:	b510      	push	{r4, lr}
	if (usb_dev.enabled == true) {
    3a4c:	f893 40b8 	ldrb.w	r4, [r3, #184]	; 0xb8
    3a50:	b98c      	cbnz	r4, 3a76 <usb_device_init+0x2e>
		return 0;
	}

	/* register device descriptor */
	device_descriptor = usb_get_device_descriptor();
    3a52:	f000 f9f1 	bl	3e38 <usb_get_device_descriptor>
	if (!device_descriptor) {
    3a56:	b960      	cbnz	r0, 3a72 <usb_device_init+0x2a>
    3a58:	4b09      	ldr	r3, [pc, #36]	; (3a80 <usb_device_init+0x38>)
    3a5a:	490a      	ldr	r1, [pc, #40]	; (3a84 <usb_device_init+0x3c>)
		LOG_ERR("Failed to configure USB device stack");
    3a5c:	480a      	ldr	r0, [pc, #40]	; (3a88 <usb_device_init+0x40>)
    3a5e:	1ac9      	subs	r1, r1, r3
    3a60:	08c9      	lsrs	r1, r1, #3
    3a62:	0189      	lsls	r1, r1, #6
    3a64:	f041 0101 	orr.w	r1, r1, #1
    3a68:	f011 fbef 	bl	1524a <log_0>
		return -1;
    3a6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	usb_set_config(device_descriptor);

	return 0;
}
    3a70:	bd10      	pop	{r4, pc}
	usb_set_config(device_descriptor);
    3a72:	f7ff ffd3 	bl	3a1c <usb_set_config>
		return 0;
    3a76:	2000      	movs	r0, #0
    3a78:	e7fa      	b.n	3a70 <usb_device_init+0x28>
    3a7a:	bf00      	nop
    3a7c:	200012c8 	.word	0x200012c8
    3a80:	0001956c 	.word	0x0001956c
    3a84:	00019674 	.word	0x00019674
    3a88:	0001a386 	.word	0x0001a386

00003a8c <usb_enable>:
{
    3a8c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    3a90:	4604      	mov	r4, r0
	if (usb_dev.enabled == true) {
    3a92:	4d36      	ldr	r5, [pc, #216]	; (3b6c <usb_enable+0xe0>)
	return z_impl_k_mutex_lock(mutex, timeout);
    3a94:	4836      	ldr	r0, [pc, #216]	; (3b70 <usb_enable+0xe4>)
    3a96:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3a9a:	f010 f819 	bl	13ad0 <z_impl_k_mutex_lock>
    3a9e:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
    3aa2:	2e00      	cmp	r6, #0
    3aa4:	d142      	bne.n	3b2c <usb_enable+0xa0>
	usb_dev.status_callback = cb;
    3aa6:	4833      	ldr	r0, [pc, #204]	; (3b74 <usb_enable+0xe8>)
	usb_dev.user_status_callback = status_cb;
    3aa8:	622c      	str	r4, [r5, #32]
	usb_dev.status_callback = cb;
    3aaa:	61e8      	str	r0, [r5, #28]
	usb_dc_set_status_callback(forward_status_cb);
    3aac:	f001 fe00 	bl	56b0 <usb_dc_set_status_callback>
	ret = usb_dc_attach();
    3ab0:	f001 fb5c 	bl	516c <usb_dc_attach>
	if (ret < 0) {
    3ab4:	1e04      	subs	r4, r0, #0
    3ab6:	db3a      	blt.n	3b2e <usb_enable+0xa2>
	ret = usb_transfer_init();
    3ab8:	f000 fbba 	bl	4230 <usb_transfer_init>
	if (ret < 0) {
    3abc:	1e04      	subs	r4, r0, #0
    3abe:	db36      	blt.n	3b2e <usb_enable+0xa2>
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
    3ac0:	2340      	movs	r3, #64	; 0x40
	ret = usb_dc_ep_configure(&ep0_cfg);
    3ac2:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
    3ac4:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
    3ac8:	f88d 6004 	strb.w	r6, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_OUT_EP0;
    3acc:	f88d 6000 	strb.w	r6, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
    3ad0:	f001 fbd8 	bl	5284 <usb_dc_ep_configure>
	if (ret < 0) {
    3ad4:	1e04      	subs	r4, r0, #0
    3ad6:	db2a      	blt.n	3b2e <usb_enable+0xa2>
	ep0_cfg.ep_addr = USB_CONTROL_IN_EP0;
    3ad8:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
    3ada:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_IN_EP0;
    3adc:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
    3ae0:	f001 fbd0 	bl	5284 <usb_dc_ep_configure>
	if (ret < 0) {
    3ae4:	1e04      	subs	r4, r0, #0
    3ae6:	db22      	blt.n	3b2e <usb_enable+0xa2>
	ret = usb_dc_ep_set_callback(USB_CONTROL_OUT_EP0,
    3ae8:	4923      	ldr	r1, [pc, #140]	; (3b78 <usb_enable+0xec>)
    3aea:	4630      	mov	r0, r6
    3aec:	f001 fdce 	bl	568c <usb_dc_ep_set_callback>
	if (ret < 0) {
    3af0:	1e04      	subs	r4, r0, #0
    3af2:	db1c      	blt.n	3b2e <usb_enable+0xa2>
	ret = usb_dc_ep_set_callback(USB_CONTROL_IN_EP0,
    3af4:	4920      	ldr	r1, [pc, #128]	; (3b78 <usb_enable+0xec>)
    3af6:	4638      	mov	r0, r7
    3af8:	f001 fdc8 	bl	568c <usb_dc_ep_set_callback>
	if (ret < 0) {
    3afc:	1e04      	subs	r4, r0, #0
    3afe:	db16      	blt.n	3b2e <usb_enable+0xa2>
	size_t size = (__usb_data_end - __usb_data_start);
    3b00:	4c1e      	ldr	r4, [pc, #120]	; (3b7c <usb_enable+0xf0>)
    3b02:	4b1f      	ldr	r3, [pc, #124]	; (3b80 <usb_enable+0xf4>)
    3b04:	4a1f      	ldr	r2, [pc, #124]	; (3b84 <usb_enable+0xf8>)
    3b06:	1b1b      	subs	r3, r3, r4
    3b08:	109b      	asrs	r3, r3, #2
    3b0a:	fb02 f903 	mul.w	r9, r2, r3
	for (size_t i = 0; i < size; i++) {
    3b0e:	45b1      	cmp	r9, r6
    3b10:	d114      	bne.n	3b3c <usb_enable+0xb0>
	ret = usb_dc_ep_enable(USB_CONTROL_OUT_EP0);
    3b12:	2000      	movs	r0, #0
    3b14:	f001 fc50 	bl	53b8 <usb_dc_ep_enable>
	if (ret < 0) {
    3b18:	1e04      	subs	r4, r0, #0
    3b1a:	db08      	blt.n	3b2e <usb_enable+0xa2>
	ret = usb_dc_ep_enable(USB_CONTROL_IN_EP0);
    3b1c:	2080      	movs	r0, #128	; 0x80
    3b1e:	f001 fc4b 	bl	53b8 <usb_dc_ep_enable>
	if (ret < 0) {
    3b22:	1e04      	subs	r4, r0, #0
    3b24:	db03      	blt.n	3b2e <usb_enable+0xa2>
	usb_dev.enabled = true;
    3b26:	2301      	movs	r3, #1
    3b28:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
		ret = 0;
    3b2c:	2400      	movs	r4, #0
	return z_impl_k_mutex_unlock(mutex);
    3b2e:	4810      	ldr	r0, [pc, #64]	; (3b70 <usb_enable+0xe4>)
    3b30:	f010 f840 	bl	13bb4 <z_impl_k_mutex_unlock>
}
    3b34:	4620      	mov	r0, r4
    3b36:	b003      	add	sp, #12
    3b38:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		ep_data = __usb_data_start[i].endpoint;
    3b3c:	f8d4 8020 	ldr.w	r8, [r4, #32]
		for (u8_t n = 0; n < __usb_data_start[i].num_endpoints; n++) {
    3b40:	2700      	movs	r7, #0
    3b42:	7f23      	ldrb	r3, [r4, #28]
    3b44:	b2fa      	uxtb	r2, r7
    3b46:	4293      	cmp	r3, r2
    3b48:	d802      	bhi.n	3b50 <usb_enable+0xc4>
	for (size_t i = 0; i < size; i++) {
    3b4a:	3601      	adds	r6, #1
    3b4c:	3424      	adds	r4, #36	; 0x24
    3b4e:	e7de      	b.n	3b0e <usb_enable+0x82>
			if (usb_dc_ep_set_callback(ep_data[n].ep_addr,
    3b50:	eb08 03c2 	add.w	r3, r8, r2, lsl #3
    3b54:	f858 1032 	ldr.w	r1, [r8, r2, lsl #3]
    3b58:	7918      	ldrb	r0, [r3, #4]
    3b5a:	f001 fd97 	bl	568c <usb_dc_ep_set_callback>
    3b5e:	3701      	adds	r7, #1
    3b60:	2800      	cmp	r0, #0
    3b62:	d0ee      	beq.n	3b42 <usb_enable+0xb6>
    3b64:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    3b68:	e7e1      	b.n	3b2e <usb_enable+0xa2>
    3b6a:	bf00      	nop
    3b6c:	200012c8 	.word	0x200012c8
    3b70:	2000c388 	.word	0x2000c388
    3b74:	000035a1 	.word	0x000035a1
    3b78:	00003929 	.word	0x00003929
    3b7c:	2000c4ec 	.word	0x2000c4ec
    3b80:	2000c510 	.word	0x2000c510
    3b84:	38e38e39 	.word	0x38e38e39

00003b88 <usb_update_sn_string_descriptor>:
 * Hardware Information Driver (HWINFO). User can implement own variant
 * of this function. Please note that the length of the new Serial Number
 * descriptor may not exceed the length of the CONFIG_USB_DEVICE_SN.
 */
__weak u8_t *usb_update_sn_string_descriptor(void)
{
    3b88:	b530      	push	{r4, r5, lr}
	u8_t hwid[sizeof(CONFIG_USB_DEVICE_SN) / 2];
	static u8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
	const char hex[] = "0123456789ABCDEF";
    3b8a:	4b1c      	ldr	r3, [pc, #112]	; (3bfc <usb_update_sn_string_descriptor+0x74>)
{
    3b8c:	b089      	sub	sp, #36	; 0x24
	const char hex[] = "0123456789ABCDEF";
    3b8e:	aa03      	add	r2, sp, #12
    3b90:	f103 0510 	add.w	r5, r3, #16
    3b94:	6818      	ldr	r0, [r3, #0]
    3b96:	6859      	ldr	r1, [r3, #4]
    3b98:	4614      	mov	r4, r2
    3b9a:	c403      	stmia	r4!, {r0, r1}
    3b9c:	3308      	adds	r3, #8
    3b9e:	42ab      	cmp	r3, r5
    3ba0:	4622      	mov	r2, r4
    3ba2:	d1f7      	bne.n	3b94 <usb_update_sn_string_descriptor+0xc>
    3ba4:	781b      	ldrb	r3, [r3, #0]
    3ba6:	7023      	strb	r3, [r4, #0]

	memset(hwid, 0, sizeof(hwid));
    3ba8:	2208      	movs	r2, #8
    3baa:	2100      	movs	r1, #0
    3bac:	a801      	add	r0, sp, #4
    3bae:	f012 fa6f 	bl	16090 <memset>
	memset(sn, 0, sizeof(sn));
    3bb2:	2212      	movs	r2, #18
    3bb4:	2100      	movs	r1, #0
    3bb6:	4812      	ldr	r0, [pc, #72]	; (3c00 <usb_update_sn_string_descriptor+0x78>)
    3bb8:	f012 fa6a 	bl	16090 <memset>
	if (z_syscall_trap()) {
		return (ssize_t) arch_syscall_invoke2(*(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
    3bbc:	2108      	movs	r1, #8
    3bbe:	a801      	add	r0, sp, #4
    3bc0:	f012 f933 	bl	15e2a <z_impl_hwinfo_get_device_id>

	if (hwinfo_get_device_id(hwid, sizeof(hwid)) > 0) {
    3bc4:	2800      	cmp	r0, #0
    3bc6:	dd16      	ble.n	3bf6 <usb_update_sn_string_descriptor+0x6e>
    3bc8:	490d      	ldr	r1, [pc, #52]	; (3c00 <usb_update_sn_string_descriptor+0x78>)
    3bca:	aa01      	add	r2, sp, #4
		LOG_HEXDUMP_DBG(hwid, sizeof(hwid), "Serial Number");
		for (int i = 0; i < sizeof(hwid); i++) {
    3bcc:	2000      	movs	r0, #0
			sn[i * 2] = hex[hwid[i] >> 4];
    3bce:	f812 3b01 	ldrb.w	r3, [r2], #1
    3bd2:	ac08      	add	r4, sp, #32
    3bd4:	eb04 1413 	add.w	r4, r4, r3, lsr #4
			sn[i * 2 + 1] = hex[hwid[i] & 0xF];
    3bd8:	f003 030f 	and.w	r3, r3, #15
			sn[i * 2] = hex[hwid[i] >> 4];
    3bdc:	f814 4c14 	ldrb.w	r4, [r4, #-20]
    3be0:	700c      	strb	r4, [r1, #0]
			sn[i * 2 + 1] = hex[hwid[i] & 0xF];
    3be2:	ac08      	add	r4, sp, #32
    3be4:	4423      	add	r3, r4
		for (int i = 0; i < sizeof(hwid); i++) {
    3be6:	3001      	adds	r0, #1
			sn[i * 2 + 1] = hex[hwid[i] & 0xF];
    3be8:	f813 3c14 	ldrb.w	r3, [r3, #-20]
    3bec:	704b      	strb	r3, [r1, #1]
		for (int i = 0; i < sizeof(hwid); i++) {
    3bee:	2808      	cmp	r0, #8
    3bf0:	f101 0102 	add.w	r1, r1, #2
    3bf4:	d1eb      	bne.n	3bce <usb_update_sn_string_descriptor+0x46>
		}
	}

	return sn;
}
    3bf6:	4802      	ldr	r0, [pc, #8]	; (3c00 <usb_update_sn_string_descriptor+0x78>)
    3bf8:	b009      	add	sp, #36	; 0x24
    3bfa:	bd30      	pop	{r4, r5, pc}
    3bfc:	0001a3b6 	.word	0x0001a3b6
    3c00:	20007a4d 	.word	0x20007a4d

00003c04 <usb_fix_descriptor>:
 * Restrictions:
 * - just one device configuration (there is only one)
 * - string descriptor must be present
 */
static int usb_fix_descriptor(struct usb_desc_header *head)
{
    3c04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t length = (__usb_data_end - __usb_data_start);
    3c08:	4a7f      	ldr	r2, [pc, #508]	; (3e08 <usb_fix_descriptor+0x204>)
    3c0a:	4b80      	ldr	r3, [pc, #512]	; (3e0c <usb_fix_descriptor+0x208>)
    3c0c:	4d80      	ldr	r5, [pc, #512]	; (3e10 <usb_fix_descriptor+0x20c>)
    3c0e:	4981      	ldr	r1, [pc, #516]	; (3e14 <usb_fix_descriptor+0x210>)
    3c10:	1a9b      	subs	r3, r3, r2
    3c12:	4a81      	ldr	r2, [pc, #516]	; (3e18 <usb_fix_descriptor+0x214>)
{
    3c14:	b087      	sub	sp, #28
	size_t length = (__usb_data_end - __usb_data_start);
    3c16:	109b      	asrs	r3, r3, #2
	struct usb_cfg_descriptor *cfg_descr = NULL;
	struct usb_if_descriptor *if_descr = NULL;
	struct usb_cfg_data *cfg_data = NULL;
	struct usb_ep_descriptor *ep_descr = NULL;
	u8_t numof_ifaces = 0U;
	u8_t str_descr_idx = 0U;
    3c18:	2700      	movs	r7, #0
	size_t length = (__usb_data_end - __usb_data_start);
    3c1a:	4353      	muls	r3, r2
    3c1c:	1a6d      	subs	r5, r5, r1
{
    3c1e:	4604      	mov	r4, r0
	size_t length = (__usb_data_end - __usb_data_start);
    3c20:	9301      	str	r3, [sp, #4]
    3c22:	08ed      	lsrs	r5, r5, #3
	u32_t requested_ep = BIT(16) | BIT(0);
    3c24:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
	u8_t numof_ifaces = 0U;
    3c28:	46b9      	mov	r9, r7
	struct usb_cfg_data *cfg_data = NULL;
    3c2a:	46b8      	mov	r8, r7
	struct usb_cfg_descriptor *cfg_descr = NULL;
    3c2c:	46ba      	mov	sl, r7

	while (head->bLength != 0U) {
    3c2e:	7823      	ldrb	r3, [r4, #0]
    3c30:	b94b      	cbnz	r3, 3c46 <usb_fix_descriptor+0x42>

		/* Move to next descriptor */
		head = (struct usb_desc_header *)((u8_t *)head + head->bLength);
	}

	if ((head + 1) != __usb_descriptor_end) {
    3c32:	4a7a      	ldr	r2, [pc, #488]	; (3e1c <usb_fix_descriptor+0x218>)
    3c34:	1ca0      	adds	r0, r4, #2
    3c36:	4290      	cmp	r0, r2
    3c38:	f000 80e3 	beq.w	3e02 <usb_fix_descriptor+0x1fe>
		LOG_DBG("try to fix next descriptor at %p", head + 1);
		return usb_fix_descriptor(head + 1);
    3c3c:	f7ff ffe2 	bl	3c04 <usb_fix_descriptor>
	}

	return 0;
}
    3c40:	b007      	add	sp, #28
    3c42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch (head->bDescriptorType) {
    3c46:	7863      	ldrb	r3, [r4, #1]
    3c48:	2b05      	cmp	r3, #5
    3c4a:	d805      	bhi.n	3c58 <usb_fix_descriptor+0x54>
    3c4c:	e8df f003 	tbb	[pc, r3]
    3c50:	95030495 	.word	0x95030495
    3c54:	3007      	.short	0x3007
    3c56:	46a2      	mov	sl, r4
		head = (struct usb_desc_header *)((u8_t *)head + head->bLength);
    3c58:	7823      	ldrb	r3, [r4, #0]
    3c5a:	441c      	add	r4, r3
    3c5c:	e7e7      	b.n	3c2e <usb_fix_descriptor+0x2a>
			if (if_descr->bAlternateSetting) {
    3c5e:	78e3      	ldrb	r3, [r4, #3]
    3c60:	2b00      	cmp	r3, #0
    3c62:	d1f9      	bne.n	3c58 <usb_fix_descriptor+0x54>
			if (if_descr->bInterfaceNumber == 0U) {
    3c64:	78a3      	ldrb	r3, [r4, #2]
    3c66:	b9c3      	cbnz	r3, 3c9a <usb_fix_descriptor+0x96>
    3c68:	4a67      	ldr	r2, [pc, #412]	; (3e08 <usb_fix_descriptor+0x204>)
    3c6a:	4610      	mov	r0, r2
	for (size_t i = 0; i < length; i++) {
    3c6c:	9901      	ldr	r1, [sp, #4]
    3c6e:	4299      	cmp	r1, r3
    3c70:	d107      	bne.n	3c82 <usb_fix_descriptor+0x7e>
					LOG_ERR("There is no usb_cfg_data "
    3c72:	01aa      	lsls	r2, r5, #6
    3c74:	486a      	ldr	r0, [pc, #424]	; (3e20 <usb_fix_descriptor+0x21c>)
    3c76:	f042 0201 	orr.w	r2, r2, #1
    3c7a:	4621      	mov	r1, r4
    3c7c:	f011 faf2 	bl	15264 <log_1>
    3c80:	e01f      	b.n	3cc2 <usb_fix_descriptor+0xbe>
		if (__usb_data_start[i].interface_descriptor == iface) {
    3c82:	6851      	ldr	r1, [r2, #4]
    3c84:	428c      	cmp	r4, r1
    3c86:	f102 0224 	add.w	r2, r2, #36	; 0x24
    3c8a:	d10b      	bne.n	3ca4 <usb_fix_descriptor+0xa0>
			return &__usb_data_start[i];
    3c8c:	f04f 0824 	mov.w	r8, #36	; 0x24
    3c90:	fb08 0803 	mla	r8, r8, r3, r0
				if (cfg_data->interface_config) {
    3c94:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3c98:	b933      	cbnz	r3, 3ca8 <usb_fix_descriptor+0xa4>
			numof_ifaces++;
    3c9a:	f109 0901 	add.w	r9, r9, #1
    3c9e:	fa5f f989 	uxtb.w	r9, r9
			break;
    3ca2:	e7d9      	b.n	3c58 <usb_fix_descriptor+0x54>
	for (size_t i = 0; i < length; i++) {
    3ca4:	3301      	adds	r3, #1
    3ca6:	e7e1      	b.n	3c6c <usb_fix_descriptor+0x68>
					cfg_data->interface_config(head,
    3ca8:	4649      	mov	r1, r9
    3caa:	4620      	mov	r0, r4
    3cac:	4798      	blx	r3
    3cae:	e7f4      	b.n	3c9a <usb_fix_descriptor+0x96>
			if (!cfg_data) {
    3cb0:	f1b8 0f00 	cmp.w	r8, #0
    3cb4:	d15e      	bne.n	3d74 <usb_fix_descriptor+0x170>
				LOG_ERR("Uninitialized usb_cfg_data pointer, "
    3cb6:	01a9      	lsls	r1, r5, #6
    3cb8:	485a      	ldr	r0, [pc, #360]	; (3e24 <usb_fix_descriptor+0x220>)
    3cba:	f041 0101 	orr.w	r1, r1, #1
				LOG_ERR("Failed to validate endpoints");
    3cbe:	f011 fac4 	bl	1524a <log_0>
					return -1;
    3cc2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    3cc6:	e7bb      	b.n	3c40 <usb_fix_descriptor+0x3c>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
    3cc8:	f8d8 2020 	ldr.w	r2, [r8, #32]
    3ccc:	78a6      	ldrb	r6, [r4, #2]
    3cce:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    3cd2:	7910      	ldrb	r0, [r2, #4]
    3cd4:	4286      	cmp	r6, r0
    3cd6:	d009      	beq.n	3cec <usb_fix_descriptor+0xe8>
	for (int i = 0; i < cfg_data->num_endpoints; i++) {
    3cd8:	3301      	adds	r3, #1
    3cda:	f898 201c 	ldrb.w	r2, [r8, #28]
    3cde:	4293      	cmp	r3, r2
    3ce0:	dbf2      	blt.n	3cc8 <usb_fix_descriptor+0xc4>
				LOG_ERR("Failed to validate endpoints");
    3ce2:	01a9      	lsls	r1, r5, #6
    3ce4:	4850      	ldr	r0, [pc, #320]	; (3e28 <usb_fix_descriptor+0x224>)
    3ce6:	f041 0101 	orr.w	r1, r1, #1
    3cea:	e7e8      	b.n	3cbe <usb_fix_descriptor+0xba>
    3cec:	2601      	movs	r6, #1
			ep_cfg.ep_type = (ep_descr->bmAttributes &
    3cee:	f894 c003 	ldrb.w	ip, [r4, #3]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
    3cf2:	f894 e005 	ldrb.w	lr, [r4, #5]
			ep_cfg.ep_type = (ep_descr->bmAttributes &
    3cf6:	f00c 0c03 	and.w	ip, ip, #3
    3cfa:	f88d c014 	strb.w	ip, [sp, #20]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
    3cfe:	f894 c004 	ldrb.w	ip, [r4, #4]
    3d02:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
    3d06:	f8ad c012 	strh.w	ip, [sp, #18]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    3d0a:	f994 c002 	ldrsb.w	ip, [r4, #2]
    3d0e:	f1bc 0f00 	cmp.w	ip, #0
    3d12:	b2f0      	uxtb	r0, r6
    3d14:	da25      	bge.n	3d62 <usb_fix_descriptor+0x15e>
				if ((*requested_ep & (1 << (idx + 16)))) {
    3d16:	f106 0c10 	add.w	ip, r6, #16
    3d1a:	fa01 fc0c 	lsl.w	ip, r1, ip
    3d1e:	ea1c 0f0b 	tst.w	ip, fp
    3d22:	d123      	bne.n	3d6c <usb_fix_descriptor+0x168>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
    3d24:	f060 007f 	orn	r0, r0, #127	; 0x7f
				ep_cfg.ep_addr = idx;
    3d28:	f88d 0010 	strb.w	r0, [sp, #16]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
    3d2c:	a804      	add	r0, sp, #16
    3d2e:	e9cd 3202 	strd	r3, r2, [sp, #8]
    3d32:	f001 fa77 	bl	5224 <usb_dc_ep_check_cap>
    3d36:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    3d3a:	2101      	movs	r1, #1
    3d3c:	b9b0      	cbnz	r0, 3d6c <usb_fix_descriptor+0x168>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
    3d3e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3d42:	70a3      	strb	r3, [r4, #2]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    3d44:	f013 0f80 	tst.w	r3, #128	; 0x80
				ep_data[i].ep_addr = ep_cfg.ep_addr;
    3d48:	7113      	strb	r3, [r2, #4]
					*requested_ep |= (1 << (idx + 16));
    3d4a:	bf18      	it	ne
    3d4c:	3610      	addne	r6, #16
    3d4e:	460b      	mov	r3, r1
    3d50:	bf15      	itete	ne
    3d52:	40b3      	lslne	r3, r6
					*requested_ep |= (1 << idx);
    3d54:	fa03 f606 	lsleq.w	r6, r3, r6
					*requested_ep |= (1 << (idx + 16));
    3d58:	ea4b 0b03 	orrne.w	fp, fp, r3
					*requested_ep |= (1 << idx);
    3d5c:	ea4b 0b06 	orreq.w	fp, fp, r6
				return 0;
    3d60:	e77a      	b.n	3c58 <usb_fix_descriptor+0x54>
				if ((*requested_ep & (1 << (idx)))) {
    3d62:	fa01 fc06 	lsl.w	ip, r1, r6
    3d66:	ea1c 0f0b 	tst.w	ip, fp
    3d6a:	d0dd      	beq.n	3d28 <usb_fix_descriptor+0x124>
		for (u8_t idx = 1; idx < 16; idx++) {
    3d6c:	3601      	adds	r6, #1
    3d6e:	2e10      	cmp	r6, #16
    3d70:	d1bd      	bne.n	3cee <usb_fix_descriptor+0xea>
    3d72:	e7b1      	b.n	3cd8 <usb_fix_descriptor+0xd4>
	for (int i = 0; i < cfg_data->num_endpoints; i++) {
    3d74:	2300      	movs	r3, #0
    3d76:	2101      	movs	r1, #1
    3d78:	e7af      	b.n	3cda <usb_fix_descriptor+0xd6>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
    3d7a:	2f03      	cmp	r7, #3
    3d7c:	d125      	bne.n	3dca <usb_fix_descriptor+0x1c6>
	u8_t *runtime_sn =  usb_update_sn_string_descriptor();
    3d7e:	f7ff ff03 	bl	3b88 <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
    3d82:	4606      	mov	r6, r0
    3d84:	b178      	cbz	r0, 3da6 <usb_fix_descriptor+0x1a2>
	runtime_sn_len = strlen(runtime_sn);
    3d86:	f012 f926 	bl	15fd6 <strlen>
	if (!runtime_sn_len) {
    3d8a:	9002      	str	r0, [sp, #8]
    3d8c:	b158      	cbz	r0, 3da6 <usb_fix_descriptor+0x1a2>
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
    3d8e:	4827      	ldr	r0, [pc, #156]	; (3e2c <usb_fix_descriptor+0x228>)
    3d90:	f012 f921 	bl	15fd6 <strlen>
	if (runtime_sn_len != default_sn_len) {
    3d94:	9a02      	ldr	r2, [sp, #8]
    3d96:	4282      	cmp	r2, r0
    3d98:	d012      	beq.n	3dc0 <usb_fix_descriptor+0x1bc>
		LOG_ERR("the new SN descriptor doesn't have the same "
    3d9a:	01a9      	lsls	r1, r5, #6
    3d9c:	4824      	ldr	r0, [pc, #144]	; (3e30 <usb_fix_descriptor+0x22c>)
    3d9e:	f041 0101 	orr.w	r1, r1, #1
    3da2:	f011 fa52 	bl	1524a <log_0>
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
    3da6:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
    3da8:	f06f 0102 	mvn.w	r1, #2
    3dac:	18e2      	adds	r2, r4, r3
    3dae:	1b09      	subs	r1, r1, r4
    3db0:	eb04 0353 	add.w	r3, r4, r3, lsr #1
		buf[i] = 0U;
    3db4:	2000      	movs	r0, #0
	for (int i = idx_max; i >= 0; i -= 2) {
    3db6:	42d1      	cmn	r1, r2
    3db8:	d511      	bpl.n	3dde <usb_fix_descriptor+0x1da>
			str_descr_idx += 1U;
    3dba:	3701      	adds	r7, #1
    3dbc:	b2ff      	uxtb	r7, r7
			break;
    3dbe:	e74b      	b.n	3c58 <usb_fix_descriptor+0x54>
	memcpy(sn->bString, runtime_sn, runtime_sn_len);
    3dc0:	4631      	mov	r1, r6
    3dc2:	1ca0      	adds	r0, r4, #2
    3dc4:	f012 f939 	bl	1603a <memcpy>
    3dc8:	e7ed      	b.n	3da6 <usb_fix_descriptor+0x1a2>
			if (str_descr_idx) {
    3dca:	2f00      	cmp	r7, #0
    3dcc:	d1eb      	bne.n	3da6 <usb_fix_descriptor+0x1a2>
				if (!cfg_descr) {
    3dce:	f1ba 0f00 	cmp.w	sl, #0
    3dd2:	d10b      	bne.n	3dec <usb_fix_descriptor+0x1e8>
					LOG_ERR("Incomplete device descriptor");
    3dd4:	01a9      	lsls	r1, r5, #6
    3dd6:	4817      	ldr	r0, [pc, #92]	; (3e34 <usb_fix_descriptor+0x230>)
    3dd8:	f041 0101 	orr.w	r1, r1, #1
    3ddc:	e76f      	b.n	3cbe <usb_fix_descriptor+0xba>
		buf[i] = 0U;
    3dde:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
    3de2:	f813 6901 	ldrb.w	r6, [r3], #-1
    3de6:	f802 6d02 	strb.w	r6, [r2, #-2]!
	for (int i = idx_max; i >= 0; i -= 2) {
    3dea:	e7e4      	b.n	3db6 <usb_fix_descriptor+0x1b2>
				sys_put_le16((u8_t *)head - (u8_t *)cfg_descr,
    3dec:	eba4 030a 	sub.w	r3, r4, sl
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(u16_t val, u8_t dst[2])
{
	dst[0] = val;
    3df0:	f88a 3002 	strb.w	r3, [sl, #2]
	dst[1] = val >> 8;
    3df4:	f3c3 2307 	ubfx	r3, r3, #8, #8
    3df8:	f88a 3003 	strb.w	r3, [sl, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
    3dfc:	f88a 9004 	strb.w	r9, [sl, #4]
    3e00:	e7db      	b.n	3dba <usb_fix_descriptor+0x1b6>
	return 0;
    3e02:	4618      	mov	r0, r3
    3e04:	e71c      	b.n	3c40 <usb_fix_descriptor+0x3c>
    3e06:	bf00      	nop
    3e08:	2000c4ec 	.word	0x2000c4ec
    3e0c:	2000c510 	.word	0x2000c510
    3e10:	0001966c 	.word	0x0001966c
    3e14:	0001956c 	.word	0x0001956c
    3e18:	38e38e39 	.word	0x38e38e39
    3e1c:	2000c4eb 	.word	0x2000c4eb
    3e20:	0001a48d 	.word	0x0001a48d
    3e24:	0001a3c7 	.word	0x0001a3c7
    3e28:	0001a408 	.word	0x0001a408
    3e2c:	0001a3b6 	.word	0x0001a3b6
    3e30:	0001a425 	.word	0x0001a425
    3e34:	0001a470 	.word	0x0001a470

00003e38 <usb_get_device_descriptor>:


u8_t *usb_get_device_descriptor(void)
{
    3e38:	b508      	push	{r3, lr}
	LOG_DBG("__usb_descriptor_start %p", __usb_descriptor_start);
	LOG_DBG("__usb_descriptor_end %p", __usb_descriptor_end);

	if (usb_fix_descriptor(__usb_descriptor_start)) {
    3e3a:	4809      	ldr	r0, [pc, #36]	; (3e60 <usb_get_device_descriptor+0x28>)
    3e3c:	f7ff fee2 	bl	3c04 <usb_fix_descriptor>
    3e40:	b158      	cbz	r0, 3e5a <usb_get_device_descriptor+0x22>
    3e42:	4b08      	ldr	r3, [pc, #32]	; (3e64 <usb_get_device_descriptor+0x2c>)
    3e44:	4908      	ldr	r1, [pc, #32]	; (3e68 <usb_get_device_descriptor+0x30>)
		LOG_ERR("Failed to fixup USB descriptor");
    3e46:	4809      	ldr	r0, [pc, #36]	; (3e6c <usb_get_device_descriptor+0x34>)
    3e48:	1ac9      	subs	r1, r1, r3
    3e4a:	08c9      	lsrs	r1, r1, #3
    3e4c:	0189      	lsls	r1, r1, #6
    3e4e:	f041 0101 	orr.w	r1, r1, #1
    3e52:	f011 f9fa 	bl	1524a <log_0>
		return NULL;
    3e56:	2000      	movs	r0, #0
	}

	return (u8_t *) __usb_descriptor_start;
}
    3e58:	bd08      	pop	{r3, pc}
	return (u8_t *) __usb_descriptor_start;
    3e5a:	4801      	ldr	r0, [pc, #4]	; (3e60 <usb_get_device_descriptor+0x28>)
    3e5c:	e7fc      	b.n	3e58 <usb_get_device_descriptor+0x20>
    3e5e:	bf00      	nop
    3e60:	2000c430 	.word	0x2000c430
    3e64:	0001956c 	.word	0x0001956c
    3e68:	0001966c 	.word	0x0001966c
    3e6c:	0001a4ad 	.word	0x0001a4ad

00003e70 <k_work_submit_to_queue.constprop.0>:
 * @param work_q Address of workqueue.
 * @param work Address of work item.
 *
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
    3e70:	4601      	mov	r1, r0
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    3e72:	f100 0308 	add.w	r3, r0, #8
    3e76:	f3bf 8f5b 	dmb	ish
    3e7a:	e853 2f00 	ldrex	r2, [r3]
    3e7e:	f042 0001 	orr.w	r0, r2, #1
    3e82:	e843 0c00 	strex	ip, r0, [r3]
    3e86:	f1bc 0f00 	cmp.w	ip, #0
    3e8a:	d1f6      	bne.n	3e7a <k_work_submit_to_queue.constprop.0+0xa>
    3e8c:	f3bf 8f5b 	dmb	ish
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    3e90:	07d3      	lsls	r3, r2, #31
    3e92:	d402      	bmi.n	3e9a <k_work_submit_to_queue.constprop.0+0x2a>
		k_queue_append(&work_q->queue, work);
    3e94:	4801      	ldr	r0, [pc, #4]	; (3e9c <k_work_submit_to_queue.constprop.0+0x2c>)
    3e96:	f014 be86 	b.w	18ba6 <k_queue_append>
	}
}
    3e9a:	4770      	bx	lr
    3e9c:	20004124 	.word	0x20004124

00003ea0 <usb_transfer_work>:

	return false;
}

static void usb_transfer_work(struct k_work *item)
{
    3ea0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	u8_t ep;

	trans = CONTAINER_OF(item, struct usb_transfer_data, work);
	ep = trans->ep;

	if (trans->status != -EBUSY) {
    3ea4:	f850 3c30 	ldr.w	r3, [r0, #-48]
	ep = trans->ep;
    3ea8:	f810 5c34 	ldrb.w	r5, [r0, #-52]
	if (trans->status != -EBUSY) {
    3eac:	3310      	adds	r3, #16
{
    3eae:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
    3eb0:	d110      	bne.n	3ed4 <usb_transfer_work+0x34>
		/* transfer cancelled or already completed */
		LOG_DBG("Transfer cancelled or completed, ep 0x%02x", ep);
		goto done;
	}

	if (trans->flags & USB_TRANS_WRITE) {
    3eb2:	68c3      	ldr	r3, [r0, #12]
    3eb4:	f850 2c28 	ldr.w	r2, [r0, #-40]
    3eb8:	0799      	lsls	r1, r3, #30
    3eba:	d547      	bpl.n	3f4c <usb_transfer_work+0xac>
		if (!trans->bsize) {
    3ebc:	b9fa      	cbnz	r2, 3efe <usb_transfer_work+0x5e>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
    3ebe:	f013 0304 	ands.w	r3, r3, #4
    3ec2:	d104      	bne.n	3ece <usb_transfer_work+0x2e>
				LOG_DBG("Transfer ZLP");
				usb_write(ep, NULL, 0, NULL);
    3ec4:	461a      	mov	r2, r3
    3ec6:	4619      	mov	r1, r3
    3ec8:	4628      	mov	r0, r5
    3eca:	f011 fd1e 	bl	1590a <usb_write>
			}
			trans->status = 0;
    3ece:	2300      	movs	r3, #0

		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
		if (ret) {
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
			/* transfer error */
			trans->status = -EINVAL;
    3ed0:	f844 3c30 	str.w	r3, [r4, #-48]
		/* we expect mote data, clear NAK */
		usb_dc_ep_read_continue(ep);
	}

done:
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
    3ed4:	f854 3c30 	ldr.w	r3, [r4, #-48]
    3ed8:	3310      	adds	r3, #16
    3eda:	d00d      	beq.n	3ef8 <usb_transfer_work+0x58>
    3edc:	f854 6c20 	ldr.w	r6, [r4, #-32]
    3ee0:	b156      	cbz	r6, 3ef8 <usb_transfer_work+0x58>
		usb_transfer_callback cb = trans->cb;
		int tsize = trans->tsize;
    3ee2:	f854 7c24 	ldr.w	r7, [r4, #-36]
		void *priv = trans->priv;
    3ee6:	f854 8c1c 	ldr.w	r8, [r4, #-28]

		if (k_is_in_isr()) {
    3eea:	f015 f81e 	bl	18f2a <k_is_in_isr>
    3eee:	2800      	cmp	r0, #0
    3ef0:	d058      	beq.n	3fa4 <usb_transfer_work+0x104>
 *
 * @return N/A
 */
static inline void k_work_submit(struct k_work *work)
{
	k_work_submit_to_queue(&k_sys_work_q, work);
    3ef2:	4620      	mov	r0, r4
    3ef4:	f7ff ffbc 	bl	3e70 <k_work_submit_to_queue.constprop.0>
		/* Transfer completion callback */
		if (trans->status != -ECANCELED) {
			cb(ep, tsize, priv);
		}
	}
}
    3ef8:	b002      	add	sp, #8
    3efa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
    3efe:	f850 1c2c 	ldr.w	r1, [r0, #-44]
    3f02:	ab01      	add	r3, sp, #4
    3f04:	4628      	mov	r0, r5
    3f06:	f011 fd00 	bl	1590a <usb_write>
		if (ret) {
    3f0a:	4601      	mov	r1, r0
    3f0c:	b168      	cbz	r0, 3f2a <usb_transfer_work+0x8a>
    3f0e:	4a2d      	ldr	r2, [pc, #180]	; (3fc4 <usb_transfer_work+0x124>)
    3f10:	4b2d      	ldr	r3, [pc, #180]	; (3fc8 <usb_transfer_work+0x128>)
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
    3f12:	482e      	ldr	r0, [pc, #184]	; (3fcc <usb_transfer_work+0x12c>)
    3f14:	1a9b      	subs	r3, r3, r2
    3f16:	08db      	lsrs	r3, r3, #3
    3f18:	019b      	lsls	r3, r3, #6
    3f1a:	f043 0301 	orr.w	r3, r3, #1
    3f1e:	462a      	mov	r2, r5
    3f20:	f011 f9b4 	bl	1528c <log_2>
			trans->status = -EINVAL;
    3f24:	f06f 0315 	mvn.w	r3, #21
    3f28:	e7d2      	b.n	3ed0 <usb_transfer_work+0x30>
		trans->buffer += bytes;
    3f2a:	9a01      	ldr	r2, [sp, #4]
    3f2c:	f854 3c2c 	ldr.w	r3, [r4, #-44]
    3f30:	4413      	add	r3, r2
    3f32:	f844 3c2c 	str.w	r3, [r4, #-44]
		trans->bsize -= bytes;
    3f36:	f854 3c28 	ldr.w	r3, [r4, #-40]
    3f3a:	1a9b      	subs	r3, r3, r2
    3f3c:	f844 3c28 	str.w	r3, [r4, #-40]
		trans->tsize += bytes;
    3f40:	f854 3c24 	ldr.w	r3, [r4, #-36]
    3f44:	4413      	add	r3, r2
    3f46:	f844 3c24 	str.w	r3, [r4, #-36]
    3f4a:	e7c3      	b.n	3ed4 <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
    3f4c:	f850 1c2c 	ldr.w	r1, [r0, #-44]
    3f50:	ab01      	add	r3, sp, #4
    3f52:	4628      	mov	r0, r5
    3f54:	f001 faf8 	bl	5548 <usb_dc_ep_read_wait>
		if (ret) {
    3f58:	4601      	mov	r1, r0
    3f5a:	2800      	cmp	r0, #0
    3f5c:	d1d7      	bne.n	3f0e <usb_transfer_work+0x6e>
		trans->buffer += bytes;
    3f5e:	9e01      	ldr	r6, [sp, #4]
    3f60:	f854 3c2c 	ldr.w	r3, [r4, #-44]
    3f64:	4433      	add	r3, r6
    3f66:	f844 3c2c 	str.w	r3, [r4, #-44]
		trans->bsize -= bytes;
    3f6a:	f854 3c28 	ldr.w	r3, [r4, #-40]
    3f6e:	1b9b      	subs	r3, r3, r6
    3f70:	f844 3c28 	str.w	r3, [r4, #-40]
		trans->tsize += bytes;
    3f74:	f854 3c24 	ldr.w	r3, [r4, #-36]
    3f78:	4433      	add	r3, r6
    3f7a:	f844 3c24 	str.w	r3, [r4, #-36]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
    3f7e:	2e00      	cmp	r6, #0
    3f80:	d0a5      	beq.n	3ece <usb_transfer_work+0x2e>
    3f82:	4628      	mov	r0, r5
    3f84:	f001 fb9a 	bl	56bc <usb_dc_ep_mps>
    3f88:	fbb6 f3f0 	udiv	r3, r6, r0
    3f8c:	fb03 6010 	mls	r0, r3, r0, r6
    3f90:	2800      	cmp	r0, #0
    3f92:	d19c      	bne.n	3ece <usb_transfer_work+0x2e>
    3f94:	f854 3c28 	ldr.w	r3, [r4, #-40]
    3f98:	2b00      	cmp	r3, #0
    3f9a:	d098      	beq.n	3ece <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
    3f9c:	4628      	mov	r0, r5
    3f9e:	f001 fb2b 	bl	55f8 <usb_dc_ep_read_continue>
    3fa2:	e797      	b.n	3ed4 <usb_transfer_work+0x34>
		trans->cb = NULL;
    3fa4:	f844 0c20 	str.w	r0, [r4, #-32]
	z_impl_k_sem_give(sem);
    3fa8:	f1a4 0018 	sub.w	r0, r4, #24
    3fac:	f010 f99e 	bl	142ec <z_impl_k_sem_give>
		if (trans->status != -ECANCELED) {
    3fb0:	f854 3c30 	ldr.w	r3, [r4, #-48]
    3fb4:	3348      	adds	r3, #72	; 0x48
    3fb6:	d09f      	beq.n	3ef8 <usb_transfer_work+0x58>
			cb(ep, tsize, priv);
    3fb8:	4642      	mov	r2, r8
    3fba:	4639      	mov	r1, r7
    3fbc:	4628      	mov	r0, r5
    3fbe:	47b0      	blx	r6
    3fc0:	e79a      	b.n	3ef8 <usb_transfer_work+0x58>
    3fc2:	bf00      	nop
    3fc4:	0001956c 	.word	0x0001956c
    3fc8:	00019684 	.word	0x00019684
    3fcc:	0001a4db 	.word	0x0001a4db

00003fd0 <usb_transfer_is_busy>:
		if (ut_data[i].ep == ep) {
    3fd0:	4a0a      	ldr	r2, [pc, #40]	; (3ffc <usb_transfer_is_busy+0x2c>)
{
    3fd2:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    3fd4:	2300      	movs	r3, #0
		if (ut_data[i].ep == ep) {
    3fd6:	2444      	movs	r4, #68	; 0x44
    3fd8:	fb04 f103 	mul.w	r1, r4, r3
    3fdc:	5c8d      	ldrb	r5, [r1, r2]
    3fde:	4285      	cmp	r5, r0
    3fe0:	d107      	bne.n	3ff2 <usb_transfer_is_busy+0x22>
	if (trans && trans->status == -EBUSY) {
    3fe2:	440a      	add	r2, r1
    3fe4:	6850      	ldr	r0, [r2, #4]
    3fe6:	f110 0f10 	cmn.w	r0, #16
    3fea:	bf14      	ite	ne
    3fec:	2000      	movne	r0, #0
    3fee:	2001      	moveq	r0, #1
}
    3ff0:	bd30      	pop	{r4, r5, pc}
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    3ff2:	3301      	adds	r3, #1
    3ff4:	2b04      	cmp	r3, #4
    3ff6:	d1ef      	bne.n	3fd8 <usb_transfer_is_busy+0x8>
	return false;
    3ff8:	2000      	movs	r0, #0
    3ffa:	e7f9      	b.n	3ff0 <usb_transfer_is_busy+0x20>
    3ffc:	20001384 	.word	0x20001384

00004000 <usb_transfer_ep_callback>:

void usb_transfer_ep_callback(u8_t ep, enum usb_dc_ep_cb_status_code status)
{
    4000:	b573      	push	{r0, r1, r4, r5, r6, lr}
		if (ut_data[i].ep == ep) {
    4002:	4c1d      	ldr	r4, [pc, #116]	; (4078 <usb_transfer_ep_callback+0x78>)
{
    4004:	4606      	mov	r6, r0
    4006:	460d      	mov	r5, r1
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    4008:	2300      	movs	r3, #0
    400a:	2244      	movs	r2, #68	; 0x44
		if (ut_data[i].ep == ep) {
    400c:	fb02 f003 	mul.w	r0, r2, r3
    4010:	5d01      	ldrb	r1, [r0, r4]
    4012:	42b1      	cmp	r1, r6
    4014:	d11c      	bne.n	4050 <usb_transfer_ep_callback+0x50>
			return &ut_data[i];
    4016:	4404      	add	r4, r0
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);

	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
    4018:	1e6b      	subs	r3, r5, #1
    401a:	2b01      	cmp	r3, #1
    401c:	d816      	bhi.n	404c <usb_transfer_ep_callback+0x4c>
		return;
	}

	if (!trans) {
    401e:	b9e4      	cbnz	r4, 405a <usb_transfer_ep_callback+0x5a>
		if (status == USB_DC_EP_DATA_OUT) {
    4020:	2d01      	cmp	r5, #1
    4022:	d113      	bne.n	404c <usb_transfer_ep_callback+0x4c>
			 * so drain it).
			 */
			do {
				u8_t data;

				usb_dc_ep_read_wait(ep, &data, 1, &bytes);
    4024:	ab01      	add	r3, sp, #4
    4026:	2201      	movs	r2, #1
    4028:	f10d 0103 	add.w	r1, sp, #3
    402c:	4630      	mov	r0, r6
    402e:	f001 fa8b 	bl	5548 <usb_dc_ep_read_wait>
			} while (bytes);
    4032:	9b01      	ldr	r3, [sp, #4]
    4034:	2b00      	cmp	r3, #0
    4036:	d1f5      	bne.n	4024 <usb_transfer_ep_callback+0x24>
    4038:	4910      	ldr	r1, [pc, #64]	; (407c <usb_transfer_ep_callback+0x7c>)
    403a:	4b11      	ldr	r3, [pc, #68]	; (4080 <usb_transfer_ep_callback+0x80>)

			LOG_ERR("RX data lost, no transfer");
    403c:	4811      	ldr	r0, [pc, #68]	; (4084 <usb_transfer_ep_callback+0x84>)
    403e:	1ac9      	subs	r1, r1, r3
    4040:	08c9      	lsrs	r1, r1, #3
    4042:	0189      	lsls	r1, r1, #6
    4044:	f041 0101 	orr.w	r1, r1, #1
    4048:	f011 f8ff 	bl	1524a <log_0>
		/* Read (out) needs to be done from ep_callback */
		usb_transfer_work(&trans->work);
	} else {
		k_work_submit(&trans->work);
	}
}
    404c:	b002      	add	sp, #8
    404e:	bd70      	pop	{r4, r5, r6, pc}
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    4050:	3301      	adds	r3, #1
    4052:	2b04      	cmp	r3, #4
    4054:	d1da      	bne.n	400c <usb_transfer_ep_callback+0xc>
	return NULL;
    4056:	2400      	movs	r4, #0
    4058:	e7de      	b.n	4018 <usb_transfer_ep_callback+0x18>
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
    405a:	f014 ff66 	bl	18f2a <k_is_in_isr>
    405e:	4603      	mov	r3, r0
    4060:	f104 0034 	add.w	r0, r4, #52	; 0x34
    4064:	b10b      	cbz	r3, 406a <usb_transfer_ep_callback+0x6a>
    4066:	2d01      	cmp	r5, #1
    4068:	d102      	bne.n	4070 <usb_transfer_ep_callback+0x70>
		usb_transfer_work(&trans->work);
    406a:	f7ff ff19 	bl	3ea0 <usb_transfer_work>
    406e:	e7ed      	b.n	404c <usb_transfer_ep_callback+0x4c>
    4070:	f7ff fefe 	bl	3e70 <k_work_submit_to_queue.constprop.0>
}
    4074:	e7ea      	b.n	404c <usb_transfer_ep_callback+0x4c>
    4076:	bf00      	nop
    4078:	20001384 	.word	0x20001384
    407c:	00019684 	.word	0x00019684
    4080:	0001956c 	.word	0x0001956c
    4084:	0001a4f8 	.word	0x0001a4f8

00004088 <usb_transfer>:

int usb_transfer(u8_t ep, u8_t *data, size_t dlen, unsigned int flags,
		 usb_transfer_callback cb, void *cb_data)
{
    4088:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    408c:	4605      	mov	r5, r0
    408e:	9100      	str	r1, [sp, #0]
    4090:	4690      	mov	r8, r2
    4092:	4699      	mov	r9, r3
	__asm__ volatile(
    4094:	f04f 0320 	mov.w	r3, #32
    4098:	f3ef 8211 	mrs	r2, BASEPRI
    409c:	f383 8811 	msr	BASEPRI, r3
    40a0:	f3bf 8f6f 	isb	sy
    40a4:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 4198 <usb_transfer+0x110>
    40a8:	9201      	str	r2, [sp, #4]
	LOG_DBG("Transfer start, ep 0x%02x, data %p, dlen %zd",
		ep, data, dlen);

	key = irq_lock();

	for (i = 0; i < ARRAY_SIZE(ut_data); i++) {
    40aa:	2400      	movs	r4, #0
    40ac:	2744      	movs	r7, #68	; 0x44
		if (!k_sem_take(&ut_data[i].sem, K_NO_WAIT)) {
    40ae:	fb07 f604 	mul.w	r6, r7, r4
	return z_impl_k_sem_take(sem, timeout);
    40b2:	2100      	movs	r1, #0
    40b4:	4658      	mov	r0, fp
    40b6:	f010 f93f 	bl	14338 <z_impl_k_sem_take>
    40ba:	b9f0      	cbnz	r0, 40fa <usb_transfer+0x72>
		LOG_ERR("No transfer slot available");
		ret = -ENOMEM;
		goto done;
	}

	if (trans->status == -EBUSY) {
    40bc:	4f31      	ldr	r7, [pc, #196]	; (4184 <usb_transfer+0xfc>)
    40be:	eb07 0a06 	add.w	sl, r7, r6
    40c2:	f8da 4004 	ldr.w	r4, [sl, #4]
    40c6:	f114 0f10 	cmn.w	r4, #16
    40ca:	d128      	bne.n	411e <usb_transfer+0x96>
    40cc:	492e      	ldr	r1, [pc, #184]	; (4188 <usb_transfer+0x100>)
    40ce:	4a2f      	ldr	r2, [pc, #188]	; (418c <usb_transfer+0x104>)
		/* A transfer is already ongoing and not completed */
		LOG_ERR("A transfer is already ongoing, ep 0x%02x", ep);
    40d0:	482f      	ldr	r0, [pc, #188]	; (4190 <usb_transfer+0x108>)
    40d2:	1a52      	subs	r2, r2, r1
    40d4:	08d2      	lsrs	r2, r2, #3
    40d6:	0192      	lsls	r2, r2, #6
    40d8:	f042 0201 	orr.w	r2, r2, #1
    40dc:	4629      	mov	r1, r5
    40de:	f011 f8c1 	bl	15264 <log_1>
	z_impl_k_sem_give(sem);
    40e2:	4658      	mov	r0, fp
    40e4:	f010 f902 	bl	142ec <z_impl_k_sem_give>
	__asm__ volatile(
    40e8:	9b01      	ldr	r3, [sp, #4]
    40ea:	f383 8811 	msr	BASEPRI, r3
    40ee:	f3bf 8f6f 	isb	sy
	}

done:
	irq_unlock(key);
	return ret;
}
    40f2:	4620      	mov	r0, r4
    40f4:	b003      	add	sp, #12
    40f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < ARRAY_SIZE(ut_data); i++) {
    40fa:	3401      	adds	r4, #1
    40fc:	2c04      	cmp	r4, #4
    40fe:	f10b 0b44 	add.w	fp, fp, #68	; 0x44
    4102:	d1d4      	bne.n	40ae <usb_transfer+0x26>
    4104:	4b20      	ldr	r3, [pc, #128]	; (4188 <usb_transfer+0x100>)
    4106:	4921      	ldr	r1, [pc, #132]	; (418c <usb_transfer+0x104>)
		LOG_ERR("No transfer slot available");
    4108:	4822      	ldr	r0, [pc, #136]	; (4194 <usb_transfer+0x10c>)
    410a:	1ac9      	subs	r1, r1, r3
    410c:	08c9      	lsrs	r1, r1, #3
    410e:	0189      	lsls	r1, r1, #6
    4110:	f041 0101 	orr.w	r1, r1, #1
    4114:	f011 f899 	bl	1524a <log_0>
		ret = -ENOMEM;
    4118:	f06f 040b 	mvn.w	r4, #11
		goto done;
    411c:	e7e4      	b.n	40e8 <usb_transfer+0x60>
	trans->buffer = data;
    411e:	9b00      	ldr	r3, [sp, #0]
	trans->tsize = 0;
    4120:	f8ca 0010 	str.w	r0, [sl, #16]
	trans->bsize = dlen;
    4124:	e9ca 3802 	strd	r3, r8, [sl, #8]
	trans->cb = cb;
    4128:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    412a:	f8ca 3014 	str.w	r3, [sl, #20]
	trans->priv = cb_data;
    412e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4130:	f8ca 3018 	str.w	r3, [sl, #24]
	trans->status = -EBUSY;
    4134:	f06f 030f 	mvn.w	r3, #15
	trans->ep = ep;
    4138:	55bd      	strb	r5, [r7, r6]
	trans->flags = flags;
    413a:	f8ca 9040 	str.w	r9, [sl, #64]	; 0x40
	trans->status = -EBUSY;
    413e:	f8ca 3004 	str.w	r3, [sl, #4]
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
    4142:	4628      	mov	r0, r5
    4144:	f001 faba 	bl	56bc <usb_dc_ep_mps>
    4148:	b168      	cbz	r0, 4166 <usb_transfer+0xde>
    414a:	4628      	mov	r0, r5
    414c:	f001 fab6 	bl	56bc <usb_dc_ep_mps>
    4150:	fbb8 f2f0 	udiv	r2, r8, r0
    4154:	fb02 8010 	mls	r0, r2, r0, r8
    4158:	b128      	cbz	r0, 4166 <usb_transfer+0xde>
		trans->flags |= USB_TRANS_NO_ZLP;
    415a:	f8da 3040 	ldr.w	r3, [sl, #64]	; 0x40
    415e:	f043 0304 	orr.w	r3, r3, #4
    4162:	f8ca 3040 	str.w	r3, [sl, #64]	; 0x40
	if (flags & USB_TRANS_WRITE) {
    4166:	f019 0f02 	tst.w	r9, #2
    416a:	d006      	beq.n	417a <usb_transfer+0xf2>
		k_work_submit(&trans->work);
    416c:	f106 0034 	add.w	r0, r6, #52	; 0x34
	k_work_submit_to_queue(&k_sys_work_q, work);
    4170:	4438      	add	r0, r7
    4172:	f7ff fe7d 	bl	3e70 <k_work_submit_to_queue.constprop.0>
	int i, key, ret = 0;
    4176:	2400      	movs	r4, #0
}
    4178:	e7b6      	b.n	40e8 <usb_transfer+0x60>
		ret = usb_dc_ep_read_continue(ep);
    417a:	4628      	mov	r0, r5
    417c:	f001 fa3c 	bl	55f8 <usb_dc_ep_read_continue>
    4180:	4604      	mov	r4, r0
    4182:	e7b1      	b.n	40e8 <usb_transfer+0x60>
    4184:	20001384 	.word	0x20001384
    4188:	0001956c 	.word	0x0001956c
    418c:	00019684 	.word	0x00019684
    4190:	0001a512 	.word	0x0001a512
    4194:	0001a53b 	.word	0x0001a53b
    4198:	200013a0 	.word	0x200013a0

0000419c <usb_cancel_transfer>:

void usb_cancel_transfer(u8_t ep)
{
    419c:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
    419e:	f04f 0320 	mov.w	r3, #32
    41a2:	f3ef 8411 	mrs	r4, BASEPRI
    41a6:	f383 8811 	msr	BASEPRI, r3
    41aa:	f3bf 8f6f 	isb	sy
		if (ut_data[i].ep == ep) {
    41ae:	490e      	ldr	r1, [pc, #56]	; (41e8 <usb_cancel_transfer+0x4c>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    41b0:	2200      	movs	r2, #0
    41b2:	2544      	movs	r5, #68	; 0x44
		if (ut_data[i].ep == ep) {
    41b4:	fb05 f302 	mul.w	r3, r5, r2
    41b8:	5c5e      	ldrb	r6, [r3, r1]
    41ba:	4286      	cmp	r6, r0
    41bc:	d10b      	bne.n	41d6 <usb_cancel_transfer+0x3a>
	trans = usb_ep_get_transfer(ep);
	if (!trans) {
		goto done;
	}

	if (trans->status != -EBUSY) {
    41be:	18ca      	adds	r2, r1, r3
    41c0:	6850      	ldr	r0, [r2, #4]
    41c2:	3010      	adds	r0, #16
    41c4:	d10a      	bne.n	41dc <usb_cancel_transfer+0x40>
		goto done;
	}

	trans->status = -ECANCELED;
    41c6:	f06f 0047 	mvn.w	r0, #71	; 0x47
	k_work_submit(&trans->work);
    41ca:	3334      	adds	r3, #52	; 0x34
	trans->status = -ECANCELED;
    41cc:	6050      	str	r0, [r2, #4]
	k_work_submit_to_queue(&k_sys_work_q, work);
    41ce:	18c8      	adds	r0, r1, r3
    41d0:	f7ff fe4e 	bl	3e70 <k_work_submit_to_queue.constprop.0>
}
    41d4:	e002      	b.n	41dc <usb_cancel_transfer+0x40>
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    41d6:	3201      	adds	r2, #1
    41d8:	2a04      	cmp	r2, #4
    41da:	d1eb      	bne.n	41b4 <usb_cancel_transfer+0x18>
	__asm__ volatile(
    41dc:	f384 8811 	msr	BASEPRI, r4
    41e0:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
    41e4:	bd70      	pop	{r4, r5, r6, pc}
    41e6:	bf00      	nop
    41e8:	20001384 	.word	0x20001384

000041ec <usb_cancel_transfers>:

void usb_cancel_transfers(void)
{
    41ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    41ee:	4c0f      	ldr	r4, [pc, #60]	; (422c <usb_cancel_transfers+0x40>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    41f0:	2500      	movs	r5, #0
		unsigned int key;

		key = irq_lock();

		if (trans->status == -EBUSY) {
			trans->status = -ECANCELED;
    41f2:	f06f 0747 	mvn.w	r7, #71	; 0x47
	__asm__ volatile(
    41f6:	f04f 0320 	mov.w	r3, #32
    41fa:	f3ef 8611 	mrs	r6, BASEPRI
    41fe:	f383 8811 	msr	BASEPRI, r3
    4202:	f3bf 8f6f 	isb	sy
		if (trans->status == -EBUSY) {
    4206:	6863      	ldr	r3, [r4, #4]
    4208:	3310      	adds	r3, #16
    420a:	d104      	bne.n	4216 <usb_cancel_transfers+0x2a>
	k_work_submit_to_queue(&k_sys_work_q, work);
    420c:	f104 0034 	add.w	r0, r4, #52	; 0x34
			trans->status = -ECANCELED;
    4210:	6067      	str	r7, [r4, #4]
    4212:	f7ff fe2d 	bl	3e70 <k_work_submit_to_queue.constprop.0>
	__asm__ volatile(
    4216:	f386 8811 	msr	BASEPRI, r6
    421a:	f3bf 8f6f 	isb	sy
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    421e:	3501      	adds	r5, #1
    4220:	2d04      	cmp	r5, #4
    4222:	f104 0444 	add.w	r4, r4, #68	; 0x44
    4226:	d1e6      	bne.n	41f6 <usb_cancel_transfers+0xa>
			LOG_DBG("Cancel transfer");
		}

		irq_unlock(key);
	}
}
    4228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    422a:	bf00      	nop
    422c:	20001384 	.word	0x20001384

00004230 <usb_transfer_init>:
	return pdata.tsize;
}

/* Init transfer slots */
int usb_transfer_init(void)
{
    4230:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    4232:	2500      	movs	r5, #0
    4234:	4c09      	ldr	r4, [pc, #36]	; (425c <usb_transfer_init+0x2c>)
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    4236:	4f0a      	ldr	r7, [pc, #40]	; (4260 <usb_transfer_init+0x30>)
    4238:	462e      	mov	r6, r5
    423a:	e9c4 670d 	strd	r6, r7, [r4, #52]	; 0x34
    423e:	63e6      	str	r6, [r4, #60]	; 0x3c
	return z_impl_k_sem_init(sem, initial_count, limit);
    4240:	2201      	movs	r2, #1
    4242:	f104 001c 	add.w	r0, r4, #28
    4246:	4611      	mov	r1, r2
    4248:	3501      	adds	r5, #1
    424a:	f014 fe5e 	bl	18f0a <z_impl_k_sem_init>
    424e:	2d04      	cmp	r5, #4
    4250:	f104 0444 	add.w	r4, r4, #68	; 0x44
    4254:	d1f1      	bne.n	423a <usb_transfer_init+0xa>
		k_work_init(&ut_data[i].work, usb_transfer_work);
		k_sem_init(&ut_data[i].sem, 1, 1);
	}

	return 0;
}
    4256:	2000      	movs	r0, #0
    4258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    425a:	bf00      	nop
    425c:	20001384 	.word	0x20001384
    4260:	00003ea1 	.word	0x00003ea1

00004264 <tx_work_handler>:

	k_work_submit(&dev_data->tx_work);
}

static void tx_work_handler(struct k_work *work)
{
    4264:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct cdc_acm_dev_data_t *dev_data =
		CONTAINER_OF(work, struct cdc_acm_dev_data_t, tx_work);
	struct device *dev = dev_data->common.dev;
	struct usb_cfg_data *cfg = (void *)dev->config->config_info;
    4266:	6e43      	ldr	r3, [r0, #100]	; 0x64
    4268:	681b      	ldr	r3, [r3, #0]
	u8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
    426a:	689b      	ldr	r3, [r3, #8]
    426c:	6a1b      	ldr	r3, [r3, #32]
    426e:	7d1e      	ldrb	r6, [r3, #20]
{
    4270:	4605      	mov	r5, r0
	u8_t *data;
	size_t len;

	if (usb_transfer_is_busy(ep)) {
    4272:	4630      	mov	r0, r6
    4274:	f7ff feac 	bl	3fd0 <usb_transfer_is_busy>
    4278:	b9d0      	cbnz	r0, 42b0 <tx_work_handler+0x4c>
		LOG_DBG("Transfer is ongoing");
		return;
	}

	len = ring_buf_get_claim(dev_data->tx_ringbuf, &data,
    427a:	6d68      	ldr	r0, [r5, #84]	; 0x54
    427c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    4280:	a903      	add	r1, sp, #12
    4282:	f010 ff46 	bl	15112 <ring_buf_get_claim>
				 CONFIG_USB_CDC_ACM_RINGBUF_SIZE);

	if (!len) {
    4286:	4604      	mov	r4, r0
    4288:	b190      	cbz	r0, 42b0 <tx_work_handler+0x4c>
	 * Transfer less data to avoid zero-length packet. The application
	 * running on the host may conclude that there is no more data to be
	 * received (i.e. the transaction has completed), hence not triggering
	 * another I/O Request Packet (IRP).
	 */
	if (!(len % CONFIG_CDC_ACM_BULK_EP_MPS)) {
    428a:	0683      	lsls	r3, r0, #26
	struct cdc_acm_dev_data_t *dev_data =
    428c:	f1a5 0318 	sub.w	r3, r5, #24
		len -= 1;
    4290:	bf08      	it	eq
    4292:	f100 34ff 	addeq.w	r4, r0, #4294967295	; 0xffffffff
	}

	LOG_DBG("Got %d bytes from ringbuffer send to ep %x", len, ep);

	usb_transfer(ep, data, len, USB_TRANS_WRITE,
    4296:	9301      	str	r3, [sp, #4]
    4298:	4b06      	ldr	r3, [pc, #24]	; (42b4 <tx_work_handler+0x50>)
    429a:	9903      	ldr	r1, [sp, #12]
    429c:	9300      	str	r3, [sp, #0]
    429e:	4622      	mov	r2, r4
    42a0:	2302      	movs	r3, #2
    42a2:	4630      	mov	r0, r6
    42a4:	f7ff fef0 	bl	4088 <usb_transfer>
		     cdc_acm_write_cb, dev_data);

	ring_buf_get_finish(dev_data->tx_ringbuf, len);
    42a8:	6d68      	ldr	r0, [r5, #84]	; 0x54
    42aa:	4621      	mov	r1, r4
    42ac:	f010 ff55 	bl	1515a <ring_buf_get_finish>
}
    42b0:	b004      	add	sp, #16
    42b2:	bd70      	pop	{r4, r5, r6, pc}
    42b4:	0000466d 	.word	0x0000466d

000042b8 <cdc_acm_class_handle_req>:
{
    42b8:	b570      	push	{r4, r5, r6, lr}
    42ba:	4604      	mov	r4, r0
    42bc:	460e      	mov	r6, r1
	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
    42be:	7901      	ldrb	r1, [r0, #4]
    42c0:	4816      	ldr	r0, [pc, #88]	; (431c <cdc_acm_class_handle_req+0x64>)
{
    42c2:	4615      	mov	r5, r2
	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
    42c4:	f011 fb49 	bl	1595a <usb_get_dev_data_by_iface>
	if (common == NULL) {
    42c8:	b968      	cbnz	r0, 42e6 <cdc_acm_class_handle_req+0x2e>
    42ca:	4b15      	ldr	r3, [pc, #84]	; (4320 <cdc_acm_class_handle_req+0x68>)
    42cc:	4a15      	ldr	r2, [pc, #84]	; (4324 <cdc_acm_class_handle_req+0x6c>)
		LOG_WRN("Device data not found for interface %u",
    42ce:	4816      	ldr	r0, [pc, #88]	; (4328 <cdc_acm_class_handle_req+0x70>)
    42d0:	88a1      	ldrh	r1, [r4, #4]
    42d2:	1ad2      	subs	r2, r2, r3
    42d4:	08d2      	lsrs	r2, r2, #3
    42d6:	0192      	lsls	r2, r2, #6
    42d8:	f042 0202 	orr.w	r2, r2, #2
    42dc:	f010 ffc2 	bl	15264 <log_1>
		return -ENODEV;
    42e0:	f06f 0012 	mvn.w	r0, #18
}
    42e4:	bd70      	pop	{r4, r5, r6, pc}
	switch (pSetup->bRequest) {
    42e6:	7863      	ldrb	r3, [r4, #1]
    42e8:	2b21      	cmp	r3, #33	; 0x21
    42ea:	d00e      	beq.n	430a <cdc_acm_class_handle_req+0x52>
    42ec:	2b22      	cmp	r3, #34	; 0x22
    42ee:	d008      	beq.n	4302 <cdc_acm_class_handle_req+0x4a>
    42f0:	2b20      	cmp	r3, #32
    42f2:	d10f      	bne.n	4314 <cdc_acm_class_handle_req+0x5c>
		memcpy(&dev_data->line_coding,
    42f4:	6829      	ldr	r1, [r5, #0]
    42f6:	2207      	movs	r2, #7
    42f8:	380c      	subs	r0, #12
    42fa:	f011 fe9e 	bl	1603a <memcpy>
	return 0;
    42fe:	2000      	movs	r0, #0
    4300:	e7f0      	b.n	42e4 <cdc_acm_class_handle_req+0x2c>
		dev_data->line_state = (u8_t)sys_le16_to_cpu(pSetup->wValue);
    4302:	8863      	ldrh	r3, [r4, #2]
    4304:	f800 3c05 	strb.w	r3, [r0, #-5]
		LOG_DBG("CDC_SET_CONTROL_LINE_STATE 0x%x",
    4308:	e7f9      	b.n	42fe <cdc_acm_class_handle_req+0x46>
		*data = (u8_t *)(&dev_data->line_coding);
    430a:	380c      	subs	r0, #12
		*len = sizeof(dev_data->line_coding);
    430c:	2307      	movs	r3, #7
		*data = (u8_t *)(&dev_data->line_coding);
    430e:	6028      	str	r0, [r5, #0]
		*len = sizeof(dev_data->line_coding);
    4310:	6033      	str	r3, [r6, #0]
    4312:	e7f4      	b.n	42fe <cdc_acm_class_handle_req+0x46>
	switch (pSetup->bRequest) {
    4314:	f06f 0015 	mvn.w	r0, #21
    4318:	e7e4      	b.n	42e4 <cdc_acm_class_handle_req+0x2c>
    431a:	bf00      	nop
    431c:	20001494 	.word	0x20001494
    4320:	0001956c 	.word	0x0001956c
    4324:	00019664 	.word	0x00019664
    4328:	0001a563 	.word	0x0001a563

0000432c <cdc_acm_int_in>:
 * @param ep_status Endpoint status code.
 *
 * @return  N/A.
 */
static void cdc_acm_int_in(u8_t ep, enum usb_dc_ep_cb_status_code ep_status)
{
    432c:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;

	ARG_UNUSED(ep_status);

	common = usb_get_dev_data_by_ep(&cdc_acm_data_devlist, ep);
    432e:	4601      	mov	r1, r0
{
    4330:	4604      	mov	r4, r0
	common = usb_get_dev_data_by_ep(&cdc_acm_data_devlist, ep);
    4332:	480a      	ldr	r0, [pc, #40]	; (435c <cdc_acm_int_in+0x30>)
    4334:	f011 fb23 	bl	1597e <usb_get_dev_data_by_ep>
	if (common == NULL) {
    4338:	b960      	cbnz	r0, 4354 <cdc_acm_int_in+0x28>
    433a:	4a09      	ldr	r2, [pc, #36]	; (4360 <cdc_acm_int_in+0x34>)
    433c:	4b09      	ldr	r3, [pc, #36]	; (4364 <cdc_acm_int_in+0x38>)
		LOG_WRN("Device data not found for endpoint %u", ep);
    433e:	480a      	ldr	r0, [pc, #40]	; (4368 <cdc_acm_int_in+0x3c>)
    4340:	1ad2      	subs	r2, r2, r3
    4342:	08d2      	lsrs	r2, r2, #3
    4344:	0192      	lsls	r2, r2, #6
    4346:	4621      	mov	r1, r4
    4348:	f042 0202 	orr.w	r2, r2, #2

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	dev_data->notification_sent = 1U;
	LOG_DBG("CDC_IntIN EP[%x]\r", ep);
}
    434c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LOG_WRN("Device data not found for endpoint %u", ep);
    4350:	f010 bf88 	b.w	15264 <log_1>
	dev_data->notification_sent = 1U;
    4354:	2301      	movs	r3, #1
    4356:	f800 3c03 	strb.w	r3, [r0, #-3]
}
    435a:	bd10      	pop	{r4, pc}
    435c:	20001494 	.word	0x20001494
    4360:	00019664 	.word	0x00019664
    4364:	0001956c 	.word	0x0001956c
    4368:	0001a58a 	.word	0x0001a58a

0000436c <cdc_acm_send_notification>:
 * @param ep_status Endpoint status code.
 *
 * @return  N/A.
 */
static int cdc_acm_send_notification(struct device *dev, u16_t serial_state)
{
    436c:	b530      	push	{r4, r5, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
	struct usb_cfg_data * const cfg = (void *)dev->config->config_info;
    436e:	6803      	ldr	r3, [r0, #0]
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    4370:	6885      	ldr	r5, [r0, #8]
	struct usb_cfg_data * const cfg = (void *)dev->config->config_info;
    4372:	689a      	ldr	r2, [r3, #8]

	usb_write(cfg->endpoint[ACM_INT_EP_IDX].ep_addr,
		  (const u8_t *)&notification, sizeof(notification), NULL);

	/* Wait for notification to be sent */
	while (!((volatile u8_t)dev_data->notification_sent)) {
    4374:	4c10      	ldr	r4, [pc, #64]	; (43b8 <cdc_acm_send_notification+0x4c>)
{
    4376:	b085      	sub	sp, #20
	notification.wIndex = 0U;
    4378:	f242 00a1 	movw	r0, #8353	; 0x20a1
    437c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    4380:	e9cd 0301 	strd	r0, r3, [sp, #4]
	dev_data->notification_sent = 0U;
    4384:	2300      	movs	r3, #0
    4386:	f885 3079 	strb.w	r3, [r5, #121]	; 0x79
	usb_write(cfg->endpoint[ACM_INT_EP_IDX].ep_addr,
    438a:	6a10      	ldr	r0, [r2, #32]
	notification.data = sys_cpu_to_le16(serial_state);
    438c:	f8ad 100c 	strh.w	r1, [sp, #12]
	usb_write(cfg->endpoint[ACM_INT_EP_IDX].ep_addr,
    4390:	7900      	ldrb	r0, [r0, #4]
    4392:	220a      	movs	r2, #10
    4394:	a901      	add	r1, sp, #4
    4396:	f011 fab8 	bl	1590a <usb_write>
	while (!((volatile u8_t)dev_data->notification_sent)) {
    439a:	f895 3079 	ldrb.w	r3, [r5, #121]	; 0x79
    439e:	b113      	cbz	r3, 43a6 <cdc_acm_send_notification+0x3a>
			LOG_DBG("CDC ACM notification timeout!");
			return -EIO;
		}
	}

	return 0;
    43a0:	2000      	movs	r0, #0
}
    43a2:	b005      	add	sp, #20
    43a4:	bd30      	pop	{r4, r5, pc}
	z_impl_k_busy_wait(usec_to_wait);
    43a6:	2001      	movs	r0, #1
    43a8:	f014 fdc5 	bl	18f36 <z_impl_k_busy_wait>
		if (++cnt > CDC_CONTROL_SERIAL_STATE_TIMEOUT_US) {
    43ac:	3c01      	subs	r4, #1
    43ae:	d1f4      	bne.n	439a <cdc_acm_send_notification+0x2e>
			return -EIO;
    43b0:	f06f 0004 	mvn.w	r0, #4
    43b4:	e7f5      	b.n	43a2 <cdc_acm_send_notification+0x36>
    43b6:	bf00      	nop
    43b8:	000186a1 	.word	0x000186a1

000043bc <cdc_acm_init>:
{
    43bc:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    43be:	6884      	ldr	r4, [r0, #8]
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
    43c0:	2300      	movs	r3, #0
    43c2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    43c6:	4b0d      	ldr	r3, [pc, #52]	; (43fc <cdc_acm_init+0x40>)
	dev_data->common.dev = dev;
    43c8:	67e0      	str	r0, [r4, #124]	; 0x7c
    43ca:	6859      	ldr	r1, [r3, #4]
	sys_slist_append(&cdc_acm_data_devlist, &dev_data->common.node);
    43cc:	f104 0280 	add.w	r2, r4, #128	; 0x80
    43d0:	b989      	cbnz	r1, 43f6 <cdc_acm_init+0x3a>
	list->head = node;
    43d2:	e9c3 2200 	strd	r2, r2, [r3]
	return z_impl_k_sem_init(sem, initial_count, limit);
    43d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    43da:	2100      	movs	r1, #0
    43dc:	4808      	ldr	r0, [pc, #32]	; (4400 <cdc_acm_init+0x44>)
    43de:	f014 fd94 	bl	18f0a <z_impl_k_sem_init>
    43e2:	4b08      	ldr	r3, [pc, #32]	; (4404 <cdc_acm_init+0x48>)
    43e4:	2000      	movs	r0, #0
    43e6:	e9c4 3004 	strd	r3, r0, [r4, #16]
    43ea:	4b07      	ldr	r3, [pc, #28]	; (4408 <cdc_acm_init+0x4c>)
    43ec:	60e0      	str	r0, [r4, #12]
    43ee:	e9c4 3007 	strd	r3, r0, [r4, #28]
    43f2:	61a0      	str	r0, [r4, #24]
}
    43f4:	bd10      	pop	{r4, pc}
	parent->next = child;
    43f6:	600a      	str	r2, [r1, #0]
	list->tail = node;
    43f8:	605a      	str	r2, [r3, #4]
}
    43fa:	e7ec      	b.n	43d6 <cdc_acm_init+0x1a>
    43fc:	20001494 	.word	0x20001494
    4400:	2000149c 	.word	0x2000149c
    4404:	000159c5 	.word	0x000159c5
    4408:	00004265 	.word	0x00004265

0000440c <k_work_submit_to_queue.constprop.0>:
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
    440c:	4601      	mov	r1, r0
    440e:	f100 0308 	add.w	r3, r0, #8
    4412:	f3bf 8f5b 	dmb	ish
    4416:	e853 2f00 	ldrex	r2, [r3]
    441a:	f042 0001 	orr.w	r0, r2, #1
    441e:	e843 0c00 	strex	ip, r0, [r3]
    4422:	f1bc 0f00 	cmp.w	ip, #0
    4426:	d1f6      	bne.n	4416 <k_work_submit_to_queue.constprop.0+0xa>
    4428:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    442c:	07d3      	lsls	r3, r2, #31
    442e:	d402      	bmi.n	4436 <k_work_submit_to_queue.constprop.0+0x2a>
		k_queue_append(&work_q->queue, work);
    4430:	4801      	ldr	r0, [pc, #4]	; (4438 <k_work_submit_to_queue.constprop.0+0x2c>)
    4432:	f014 bbb8 	b.w	18ba6 <k_queue_append>
}
    4436:	4770      	bx	lr
    4438:	20004124 	.word	0x20004124

0000443c <cdc_acm_read_cb>:
{
    443c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (size <= 0) {
    443e:	1e0d      	subs	r5, r1, #0
{
    4440:	4606      	mov	r6, r0
    4442:	4614      	mov	r4, r2
    4444:	f102 0728 	add.w	r7, r2, #40	; 0x28
	if (size <= 0) {
    4448:	dd11      	ble.n	446e <cdc_acm_read_cb+0x32>
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
    444a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    444c:	462a      	mov	r2, r5
    444e:	4639      	mov	r1, r7
    4450:	f010 fe40 	bl	150d4 <ring_buf_put>
	if (wrote < size) {
    4454:	4285      	cmp	r5, r0
    4456:	d90a      	bls.n	446e <cdc_acm_read_cb+0x32>
    4458:	4a10      	ldr	r2, [pc, #64]	; (449c <cdc_acm_read_cb+0x60>)
    445a:	4b11      	ldr	r3, [pc, #68]	; (44a0 <cdc_acm_read_cb+0x64>)
    445c:	1ad2      	subs	r2, r2, r3
    445e:	08d2      	lsrs	r2, r2, #3
		LOG_ERR("Ring buffer full, drop %d bytes", size - wrote);
    4460:	0192      	lsls	r2, r2, #6
    4462:	1a29      	subs	r1, r5, r0
    4464:	f042 0201 	orr.w	r2, r2, #1
    4468:	480e      	ldr	r0, [pc, #56]	; (44a4 <cdc_acm_read_cb+0x68>)
    446a:	f010 fefb 	bl	15264 <log_1>
	dev_data->rx_ready = true;
    446e:	2301      	movs	r3, #1
    4470:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	if (dev_data->cb && dev_data->rx_irq_ena) {
    4474:	6863      	ldr	r3, [r4, #4]
    4476:	b133      	cbz	r3, 4486 <cdc_acm_read_cb+0x4a>
    4478:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
    447c:	b11b      	cbz	r3, 4486 <cdc_acm_read_cb+0x4a>
	k_work_submit_to_queue(&k_sys_work_q, work);
    447e:	f104 000c 	add.w	r0, r4, #12
    4482:	f7ff ffc3 	bl	440c <k_work_submit_to_queue.constprop.0>
	usb_transfer(ep, dev_data->rx_buf, sizeof(dev_data->rx_buf),
    4486:	4b08      	ldr	r3, [pc, #32]	; (44a8 <cdc_acm_read_cb+0x6c>)
    4488:	9300      	str	r3, [sp, #0]
    448a:	9401      	str	r4, [sp, #4]
    448c:	2301      	movs	r3, #1
    448e:	2240      	movs	r2, #64	; 0x40
    4490:	4639      	mov	r1, r7
    4492:	4630      	mov	r0, r6
    4494:	f7ff fdf8 	bl	4088 <usb_transfer>
}
    4498:	b003      	add	sp, #12
    449a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    449c:	00019664 	.word	0x00019664
    44a0:	0001956c 	.word	0x0001956c
    44a4:	0001a5b0 	.word	0x0001a5b0
    44a8:	0000443d 	.word	0x0000443d

000044ac <cdc_acm_reset_port>:
{
    44ac:	b510      	push	{r4, lr}
    44ae:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
    44b0:	480c      	ldr	r0, [pc, #48]	; (44e4 <cdc_acm_reset_port+0x38>)
    44b2:	f00f ff1b 	bl	142ec <z_impl_k_sem_give>
	dev_data->line_coding = (struct cdc_acm_line_coding)
    44b6:	4b0c      	ldr	r3, [pc, #48]	; (44e8 <cdc_acm_reset_port+0x3c>)
	dev_data->tx_ready = false;
    44b8:	2100      	movs	r1, #0
	dev_data->line_coding = (struct cdc_acm_line_coding)
    44ba:	6818      	ldr	r0, [r3, #0]
    44bc:	889a      	ldrh	r2, [r3, #4]
    44be:	799b      	ldrb	r3, [r3, #6]
    44c0:	6720      	str	r0, [r4, #112]	; 0x70
    44c2:	f8a4 2074 	strh.w	r2, [r4, #116]	; 0x74
	dev_data->tx_ready = false;
    44c6:	6261      	str	r1, [r4, #36]	; 0x24
	dev_data->line_coding = (struct cdc_acm_line_coding)
    44c8:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
	dev_data->serial_state = 0;
    44cc:	f884 1078 	strb.w	r1, [r4, #120]	; 0x78
	dev_data->line_state = 0;
    44d0:	f884 1077 	strb.w	r1, [r4, #119]	; 0x77
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
    44d4:	f104 0028 	add.w	r0, r4, #40	; 0x28
    44d8:	2240      	movs	r2, #64	; 0x40
}
    44da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
    44de:	f011 bdd7 	b.w	16090 <memset>
    44e2:	bf00      	nop
    44e4:	2000149c 	.word	0x2000149c
    44e8:	00019700 	.word	0x00019700

000044ec <cdc_acm_dev_status_cb>:
{
    44ec:	b570      	push	{r4, r5, r6, lr}
    44ee:	4606      	mov	r6, r0
    44f0:	460d      	mov	r5, r1
	common = usb_get_dev_data_by_cfg(&cdc_acm_data_devlist, cfg);
    44f2:	4601      	mov	r1, r0
    44f4:	4831      	ldr	r0, [pc, #196]	; (45bc <cdc_acm_dev_status_cb+0xd0>)
    44f6:	f011 fa20 	bl	1593a <usb_get_dev_data_by_cfg>
	if (common == NULL) {
    44fa:	4604      	mov	r4, r0
    44fc:	b960      	cbnz	r0, 4518 <cdc_acm_dev_status_cb+0x2c>
    44fe:	4a30      	ldr	r2, [pc, #192]	; (45c0 <cdc_acm_dev_status_cb+0xd4>)
    4500:	4b30      	ldr	r3, [pc, #192]	; (45c4 <cdc_acm_dev_status_cb+0xd8>)
		LOG_WRN("Device data not found for cfg %p", cfg);
    4502:	4831      	ldr	r0, [pc, #196]	; (45c8 <cdc_acm_dev_status_cb+0xdc>)
    4504:	1ad2      	subs	r2, r2, r3
    4506:	08d2      	lsrs	r2, r2, #3
    4508:	0192      	lsls	r2, r2, #6
    450a:	4631      	mov	r1, r6
    450c:	f042 0202 	orr.w	r2, r2, #2
}
    4510:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_WRN("Device data not found for cfg %p", cfg);
    4514:	f010 bea6 	b.w	15264 <log_1>
	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);
    4518:	4606      	mov	r6, r0
	if (!(status == USB_DC_SOF || status == USB_DC_INTERFACE)) {
    451a:	2d0a      	cmp	r5, #10
	struct usb_cfg_data *cfg = (void *)dev->config->config_info;
    451c:	f856 397c 	ldr.w	r3, [r6], #-124
    4520:	681b      	ldr	r3, [r3, #0]
    4522:	689b      	ldr	r3, [r3, #8]
	if (!(status == USB_DC_SOF || status == USB_DC_INTERFACE)) {
    4524:	d048      	beq.n	45b8 <cdc_acm_dev_status_cb+0xcc>
    4526:	2d07      	cmp	r5, #7
    4528:	d046      	beq.n	45b8 <cdc_acm_dev_status_cb+0xcc>
		dev_data->usb_status = status;
    452a:	f800 5c7c 	strb.w	r5, [r0, #-124]
	switch (status) {
    452e:	3d01      	subs	r5, #1
    4530:	2d05      	cmp	r5, #5
    4532:	d841      	bhi.n	45b8 <cdc_acm_dev_status_cb+0xcc>
    4534:	e8df f005 	tbb	[pc, r5]
    4538:	1c034026 	.word	0x1c034026
    453c:	342b      	.short	0x342b
		cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0,
    453e:	6a1b      	ldr	r3, [r3, #32]
    4540:	2100      	movs	r1, #0
    4542:	7b18      	ldrb	r0, [r3, #12]
    4544:	4632      	mov	r2, r6
    4546:	f7ff ff79 	bl	443c <cdc_acm_read_cb>
		dev_data->tx_ready = true;
    454a:	2301      	movs	r3, #1
    454c:	491c      	ldr	r1, [pc, #112]	; (45c0 <cdc_acm_dev_status_cb+0xd4>)
    454e:	f804 3c58 	strb.w	r3, [r4, #-88]
		dev_data->tx_irq_ena = true;
    4552:	f804 3c56 	strb.w	r3, [r4, #-86]
		dev_data->rx_irq_ena = true;
    4556:	f804 3c55 	strb.w	r3, [r4, #-85]
    455a:	4b1a      	ldr	r3, [pc, #104]	; (45c4 <cdc_acm_dev_status_cb+0xd8>)
		LOG_INF("USB device configured");
    455c:	481b      	ldr	r0, [pc, #108]	; (45cc <cdc_acm_dev_status_cb+0xe0>)
    455e:	1ac9      	subs	r1, r1, r3
    4560:	08c9      	lsrs	r1, r1, #3
    4562:	0189      	lsls	r1, r1, #6
    4564:	f041 0103 	orr.w	r1, r1, #3
}
    4568:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("USB device resumed");
    456c:	f010 be6d 	b.w	1524a <log_0>
    4570:	4913      	ldr	r1, [pc, #76]	; (45c0 <cdc_acm_dev_status_cb+0xd4>)
    4572:	4b14      	ldr	r3, [pc, #80]	; (45c4 <cdc_acm_dev_status_cb+0xd8>)
		LOG_INF("USB device disconnected");
    4574:	4816      	ldr	r0, [pc, #88]	; (45d0 <cdc_acm_dev_status_cb+0xe4>)
    4576:	1ac9      	subs	r1, r1, r3
    4578:	08c9      	lsrs	r1, r1, #3
    457a:	0189      	lsls	r1, r1, #6
    457c:	f041 0103 	orr.w	r1, r1, #3
    4580:	f010 fe63 	bl	1524a <log_0>
		cdc_acm_reset_port(dev_data);
    4584:	4630      	mov	r0, r6
}
    4586:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		cdc_acm_reset_port(dev_data);
    458a:	f7ff bf8f 	b.w	44ac <cdc_acm_reset_port>
    458e:	490c      	ldr	r1, [pc, #48]	; (45c0 <cdc_acm_dev_status_cb+0xd4>)
    4590:	4b0c      	ldr	r3, [pc, #48]	; (45c4 <cdc_acm_dev_status_cb+0xd8>)
		LOG_INF("USB device suspended");
    4592:	4810      	ldr	r0, [pc, #64]	; (45d4 <cdc_acm_dev_status_cb+0xe8>)
    4594:	1ac9      	subs	r1, r1, r3
    4596:	08c9      	lsrs	r1, r1, #3
    4598:	0189      	lsls	r1, r1, #6
    459a:	f041 0103 	orr.w	r1, r1, #3
    459e:	e7e3      	b.n	4568 <cdc_acm_dev_status_cb+0x7c>
		dev_data->usb_status = USB_DC_CONFIGURED;
    45a0:	2303      	movs	r3, #3
    45a2:	f800 3c7c 	strb.w	r3, [r0, #-124]
    45a6:	4906      	ldr	r1, [pc, #24]	; (45c0 <cdc_acm_dev_status_cb+0xd4>)
    45a8:	4b06      	ldr	r3, [pc, #24]	; (45c4 <cdc_acm_dev_status_cb+0xd8>)
		LOG_INF("USB device resumed");
    45aa:	480b      	ldr	r0, [pc, #44]	; (45d8 <cdc_acm_dev_status_cb+0xec>)
    45ac:	1ac9      	subs	r1, r1, r3
    45ae:	08c9      	lsrs	r1, r1, #3
    45b0:	0189      	lsls	r1, r1, #6
    45b2:	f041 0103 	orr.w	r1, r1, #3
    45b6:	e7d7      	b.n	4568 <cdc_acm_dev_status_cb+0x7c>
}
    45b8:	bd70      	pop	{r4, r5, r6, pc}
    45ba:	bf00      	nop
    45bc:	20001494 	.word	0x20001494
    45c0:	00019664 	.word	0x00019664
    45c4:	0001956c 	.word	0x0001956c
    45c8:	0001a5d0 	.word	0x0001a5d0
    45cc:	0001a5f1 	.word	0x0001a5f1
    45d0:	0001a607 	.word	0x0001a607
    45d4:	0001a61f 	.word	0x0001a61f
    45d8:	0001a634 	.word	0x0001a634

000045dc <cdc_acm_fifo_fill>:
{
    45dc:	b570      	push	{r4, r5, r6, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    45de:	6886      	ldr	r6, [r0, #8]
	if (dev_data->usb_status != USB_DC_CONFIGURED) {
    45e0:	7833      	ldrb	r3, [r6, #0]
    45e2:	2b03      	cmp	r3, #3
{
    45e4:	4615      	mov	r5, r2
	if (dev_data->usb_status != USB_DC_CONFIGURED) {
    45e6:	d00c      	beq.n	4602 <cdc_acm_fifo_fill+0x26>
    45e8:	4a13      	ldr	r2, [pc, #76]	; (4638 <cdc_acm_fifo_fill+0x5c>)
    45ea:	4b14      	ldr	r3, [pc, #80]	; (463c <cdc_acm_fifo_fill+0x60>)
		LOG_WRN("Device not configured, drop %d bytes", len);
    45ec:	4814      	ldr	r0, [pc, #80]	; (4640 <cdc_acm_fifo_fill+0x64>)
    45ee:	1a9b      	subs	r3, r3, r2
    45f0:	08db      	lsrs	r3, r3, #3
    45f2:	019b      	lsls	r3, r3, #6
    45f4:	f043 0202 	orr.w	r2, r3, #2
    45f8:	4629      	mov	r1, r5
    45fa:	f010 fe33 	bl	15264 <log_1>
		return 0;
    45fe:	2000      	movs	r0, #0
}
    4600:	bd70      	pop	{r4, r5, r6, pc}
	dev_data->tx_ready = false;
    4602:	2300      	movs	r3, #0
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
    4604:	6ef0      	ldr	r0, [r6, #108]	; 0x6c
	dev_data->tx_ready = false;
    4606:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
    460a:	f010 fd63 	bl	150d4 <ring_buf_put>
	if (wrote < len) {
    460e:	42a8      	cmp	r0, r5
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
    4610:	4604      	mov	r4, r0
	if (wrote < len) {
    4612:	d20a      	bcs.n	462a <cdc_acm_fifo_fill+0x4e>
    4614:	4a08      	ldr	r2, [pc, #32]	; (4638 <cdc_acm_fifo_fill+0x5c>)
    4616:	4b09      	ldr	r3, [pc, #36]	; (463c <cdc_acm_fifo_fill+0x60>)
    4618:	1a9b      	subs	r3, r3, r2
    461a:	08db      	lsrs	r3, r3, #3
		LOG_WRN("Ring buffer full, drop %d bytes", len - wrote);
    461c:	019b      	lsls	r3, r3, #6
    461e:	1a29      	subs	r1, r5, r0
    4620:	f043 0202 	orr.w	r2, r3, #2
    4624:	4807      	ldr	r0, [pc, #28]	; (4644 <cdc_acm_fifo_fill+0x68>)
    4626:	f010 fe1d 	bl	15264 <log_1>
    462a:	f106 0018 	add.w	r0, r6, #24
    462e:	f7ff feed 	bl	440c <k_work_submit_to_queue.constprop.0>
	return wrote;
    4632:	4620      	mov	r0, r4
    4634:	e7e4      	b.n	4600 <cdc_acm_fifo_fill+0x24>
    4636:	bf00      	nop
    4638:	0001956c 	.word	0x0001956c
    463c:	00019664 	.word	0x00019664
    4640:	0001a647 	.word	0x0001a647
    4644:	0001a5b0 	.word	0x0001a5b0

00004648 <cdc_acm_poll_out>:
 * The UART poll method for USB UART is simulated by waiting till
 * we get the next BULK In upcall from the USB device controller or 100 ms.
 */
static void cdc_acm_poll_out(struct device *dev,
				      unsigned char c)
{
    4648:	b507      	push	{r0, r1, r2, lr}
	cdc_acm_fifo_fill(dev, &c, 1);
    464a:	2201      	movs	r2, #1
{
    464c:	f88d 1007 	strb.w	r1, [sp, #7]
	cdc_acm_fifo_fill(dev, &c, 1);
    4650:	f10d 0107 	add.w	r1, sp, #7
    4654:	f7ff ffc2 	bl	45dc <cdc_acm_fifo_fill>
	return z_impl_k_sem_take(sem, timeout);
    4658:	2164      	movs	r1, #100	; 0x64
    465a:	4803      	ldr	r0, [pc, #12]	; (4668 <cdc_acm_poll_out+0x20>)
    465c:	f00f fe6c 	bl	14338 <z_impl_k_sem_take>
	k_sem_take(&poll_wait_sem, K_MSEC(100));
}
    4660:	b003      	add	sp, #12
    4662:	f85d fb04 	ldr.w	pc, [sp], #4
    4666:	bf00      	nop
    4668:	2000149c 	.word	0x2000149c

0000466c <cdc_acm_write_cb>:
	dev_data->tx_ready = true;
    466c:	2301      	movs	r3, #1
{
    466e:	b510      	push	{r4, lr}
    4670:	4614      	mov	r4, r2
	dev_data->tx_ready = true;
    4672:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
	z_impl_k_sem_give(sem);
    4676:	480c      	ldr	r0, [pc, #48]	; (46a8 <cdc_acm_write_cb+0x3c>)
    4678:	f00f fe38 	bl	142ec <z_impl_k_sem_give>
	if (dev_data->cb && dev_data->tx_irq_ena) {
    467c:	6863      	ldr	r3, [r4, #4]
    467e:	b133      	cbz	r3, 468e <cdc_acm_write_cb+0x22>
    4680:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
    4684:	b11b      	cbz	r3, 468e <cdc_acm_write_cb+0x22>
    4686:	f104 000c 	add.w	r0, r4, #12
    468a:	f7ff febf 	bl	440c <k_work_submit_to_queue.constprop.0>
	if (ring_buf_is_empty(dev_data->tx_ringbuf)) {
    468e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    4690:	e9d3 2300 	ldrd	r2, r3, [r3]
    4694:	429a      	cmp	r2, r3
    4696:	d005      	beq.n	46a4 <cdc_acm_write_cb+0x38>
    4698:	f104 0018 	add.w	r0, r4, #24
}
    469c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    46a0:	f7ff beb4 	b.w	440c <k_work_submit_to_queue.constprop.0>
    46a4:	bd10      	pop	{r4, pc}
    46a6:	bf00      	nop
    46a8:	2000149c 	.word	0x2000149c

000046ac <get_flash_area_from_id>:
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
    46ac:	4b09      	ldr	r3, [pc, #36]	; (46d4 <get_flash_area_from_id+0x28>)
{
    46ae:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < flash_map_entries; i++) {
    46b0:	681d      	ldr	r5, [r3, #0]
		if (flash_map[i].fa_id == idx) {
    46b2:	4b09      	ldr	r3, [pc, #36]	; (46d8 <get_flash_area_from_id+0x2c>)
{
    46b4:	4602      	mov	r2, r0
		if (flash_map[i].fa_id == idx) {
    46b6:	681c      	ldr	r4, [r3, #0]
	for (int i = 0; i < flash_map_entries; i++) {
    46b8:	2300      	movs	r3, #0
    46ba:	429d      	cmp	r5, r3
    46bc:	dc01      	bgt.n	46c2 <get_flash_area_from_id+0x16>
			return &flash_map[i];
		}
	}

	return NULL;
    46be:	2000      	movs	r0, #0
}
    46c0:	bd30      	pop	{r4, r5, pc}
		if (flash_map[i].fa_id == idx) {
    46c2:	0119      	lsls	r1, r3, #4
    46c4:	eb04 1003 	add.w	r0, r4, r3, lsl #4
    46c8:	5c61      	ldrb	r1, [r4, r1]
    46ca:	4291      	cmp	r1, r2
    46cc:	d0f8      	beq.n	46c0 <get_flash_area_from_id+0x14>
	for (int i = 0; i < flash_map_entries; i++) {
    46ce:	3301      	adds	r3, #1
    46d0:	e7f3      	b.n	46ba <get_flash_area_from_id+0xe>
    46d2:	bf00      	nop
    46d4:	00019844 	.word	0x00019844
    46d8:	2000bd8c 	.word	0x2000bd8c

000046dc <flash_area_open>:

int flash_area_open(u8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
    46dc:	4b08      	ldr	r3, [pc, #32]	; (4700 <flash_area_open+0x24>)
    46de:	681b      	ldr	r3, [r3, #0]
{
    46e0:	b510      	push	{r4, lr}
    46e2:	460c      	mov	r4, r1
	if (flash_map == NULL) {
    46e4:	b12b      	cbz	r3, 46f2 <flash_area_open+0x16>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
    46e6:	f7ff ffe1 	bl	46ac <get_flash_area_from_id>
	if (area == NULL) {
    46ea:	b128      	cbz	r0, 46f8 <flash_area_open+0x1c>
		return -ENOENT;
	}

	*fap = area;
    46ec:	6020      	str	r0, [r4, #0]
	return 0;
    46ee:	2000      	movs	r0, #0
}
    46f0:	bd10      	pop	{r4, pc}
		return -EACCES;
    46f2:	f06f 000c 	mvn.w	r0, #12
    46f6:	e7fb      	b.n	46f0 <flash_area_open+0x14>
		return -ENOENT;
    46f8:	f06f 0001 	mvn.w	r0, #1
    46fc:	e7f8      	b.n	46f0 <flash_area_open+0x14>
    46fe:	bf00      	nop
    4700:	2000bd8c 	.word	0x2000bd8c

00004704 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    4704:	b510      	push	{r4, lr}
    4706:	4807      	ldr	r0, [pc, #28]	; (4724 <uart_console_init+0x20>)
	__stdout_hook_install(console_out);
    4708:	4c07      	ldr	r4, [pc, #28]	; (4728 <uart_console_init+0x24>)
    470a:	f00e ffaf 	bl	1366c <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    470e:	4b07      	ldr	r3, [pc, #28]	; (472c <uart_console_init+0x28>)
    4710:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
    4712:	4620      	mov	r0, r4
    4714:	f002 fb1e 	bl	6d54 <__stdout_hook_install>
	__printk_hook_install(console_out);
    4718:	4620      	mov	r0, r4
    471a:	f7fd ff35 	bl	2588 <__printk_hook_install>
#endif

	uart_console_hook_install();

	return 0;
}
    471e:	2000      	movs	r0, #0
    4720:	bd10      	pop	{r4, pc}
    4722:	bf00      	nop
    4724:	0001a2de 	.word	0x0001a2de
    4728:	00004731 	.word	0x00004731
    472c:	200014b4 	.word	0x200014b4

00004730 <console_out>:
	if ('\n' == c) {
    4730:	280a      	cmp	r0, #10
{
    4732:	b538      	push	{r3, r4, r5, lr}
    4734:	4d07      	ldr	r5, [pc, #28]	; (4754 <console_out+0x24>)
    4736:	4604      	mov	r4, r0
	if ('\n' == c) {
    4738:	d104      	bne.n	4744 <console_out+0x14>
    473a:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
    473c:	6843      	ldr	r3, [r0, #4]
    473e:	210d      	movs	r1, #13
    4740:	685b      	ldr	r3, [r3, #4]
    4742:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    4744:	6828      	ldr	r0, [r5, #0]
    4746:	6843      	ldr	r3, [r0, #4]
    4748:	b2e1      	uxtb	r1, r4
    474a:	685b      	ldr	r3, [r3, #4]
    474c:	4798      	blx	r3
}
    474e:	4620      	mov	r0, r4
    4750:	bd38      	pop	{r3, r4, r5, pc}
    4752:	bf00      	nop
    4754:	200014b4 	.word	0x200014b4

00004758 <rtt_console_init>:

	return character;
}

static int rtt_console_init(struct device *d)
{
    4758:	b510      	push	{r4, lr}
	ARG_UNUSED(d);

	__printk_hook_install(rtt_console_out);
    475a:	4c04      	ldr	r4, [pc, #16]	; (476c <rtt_console_init+0x14>)
    475c:	4620      	mov	r0, r4
    475e:	f7fd ff13 	bl	2588 <__printk_hook_install>
	__stdout_hook_install(rtt_console_out);
    4762:	4620      	mov	r0, r4
    4764:	f002 faf6 	bl	6d54 <__stdout_hook_install>

	return 0;
}
    4768:	2000      	movs	r0, #0
    476a:	bd10      	pop	{r4, pc}
    476c:	00004771 	.word	0x00004771

00004770 <rtt_console_out>:
{
    4770:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return z_impl_k_mutex_lock(mutex, timeout);
    4774:	f8df 8058 	ldr.w	r8, [pc, #88]	; 47d0 <rtt_console_out+0x60>
    4778:	4e14      	ldr	r6, [pc, #80]	; (47cc <rtt_console_out+0x5c>)
	char c = (char)character;
    477a:	f88d 0007 	strb.w	r0, [sp, #7]
{
    477e:	4604      	mov	r4, r0
	char c = (char)character;
    4780:	2503      	movs	r5, #3
    4782:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4786:	4640      	mov	r0, r8
    4788:	f00f f9a2 	bl	13ad0 <z_impl_k_mutex_lock>
		cnt = SEGGER_RTT_WriteNoLock(0, &c, 1);
    478c:	2201      	movs	r2, #1
    478e:	f10d 0107 	add.w	r1, sp, #7
    4792:	2000      	movs	r0, #0
    4794:	f001 f914 	bl	59c0 <SEGGER_RTT_WriteNoLock>
    4798:	4607      	mov	r7, r0
	return z_impl_k_mutex_unlock(mutex);
    479a:	4640      	mov	r0, r8
    479c:	f00f fa0a 	bl	13bb4 <z_impl_k_mutex_unlock>
		if (cnt) {
    47a0:	b12f      	cbz	r7, 47ae <rtt_console_out+0x3e>
			host_present = true;
    47a2:	2301      	movs	r3, #1
    47a4:	7033      	strb	r3, [r6, #0]
}
    47a6:	4620      	mov	r0, r4
    47a8:	b002      	add	sp, #8
    47aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (host_present) {
    47ae:	7833      	ldrb	r3, [r6, #0]
    47b0:	2b00      	cmp	r3, #0
    47b2:	d0f8      	beq.n	47a6 <rtt_console_out+0x36>
			if (max_cnt) {
    47b4:	3d01      	subs	r5, #1
    47b6:	d007      	beq.n	47c8 <rtt_console_out+0x58>
	if (k_is_in_isr()) {
    47b8:	f014 fbb7 	bl	18f2a <k_is_in_isr>
    47bc:	2800      	cmp	r0, #0
    47be:	d1e0      	bne.n	4782 <rtt_console_out+0x12>
	return z_impl_k_sleep(timeout);
    47c0:	2002      	movs	r0, #2
    47c2:	f00f fd65 	bl	14290 <z_impl_k_sleep>
		SEGGER_RTT_LOCK();
    47c6:	e7dc      	b.n	4782 <rtt_console_out+0x12>
				host_present = false;
    47c8:	7035      	strb	r5, [r6, #0]
    47ca:	e7ec      	b.n	47a6 <rtt_console_out+0x36>
    47cc:	2000825f 	.word	0x2000825f
    47d0:	2000c39c 	.word	0x2000c39c

000047d4 <clkstarted_handle.constprop.0>:
DEVICE_AND_API_INIT(clock_nrf, DT_INST_LABEL(0),
		    clk_init, &data, &config, PRE_KERNEL_1,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &clock_control_api);

static void clkstarted_handle(struct device *dev,
    47d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			      enum clock_control_nrf_type type)
{
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    47d6:	4e12      	ldr	r6, [pc, #72]	; (4820 <clkstarted_handle.constprop.0+0x4c>)
    47d8:	68b3      	ldr	r3, [r6, #8]
	struct clock_control_async_data *async_data;

	DBG(dev, type, "Clock started");
	sub_data->started = true;
    47da:	240c      	movs	r4, #12
    47dc:	fb04 3400 	mla	r4, r4, r0, r3
    47e0:	2301      	movs	r3, #1
static void clkstarted_handle(struct device *dev,
    47e2:	4605      	mov	r5, r0
	sub_data->started = true;
    47e4:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
    47e6:	f04f 0320 	mov.w	r3, #32
    47ea:	f3ef 8111 	mrs	r1, BASEPRI
    47ee:	f383 8811 	msr	BASEPRI, r3
    47f2:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
    47f6:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    47f8:	b12b      	cbz	r3, 4806 <clkstarted_handle.constprop.0+0x32>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    47fa:	6860      	ldr	r0, [r4, #4]
    47fc:	681a      	ldr	r2, [r3, #0]
	list->head = node;
    47fe:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4800:	4283      	cmp	r3, r0
	list->tail = node;
    4802:	bf08      	it	eq
    4804:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
    4806:	f381 8811 	msr	BASEPRI, r1
    480a:	f3bf 8f6f 	isb	sy

	while ((async_data = list_get(&sub_data->list)) != NULL) {
    480e:	b903      	cbnz	r3, 4812 <clkstarted_handle.constprop.0+0x3e>
		async_data->cb(dev, (clock_control_subsys_t)type,
				async_data->user_data);
	}
}
    4810:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		async_data->cb(dev, (clock_control_subsys_t)type,
    4812:	e9d3 7201 	ldrd	r7, r2, [r3, #4]
    4816:	4629      	mov	r1, r5
    4818:	4630      	mov	r0, r6
    481a:	47b8      	blx	r7
    481c:	e7e3      	b.n	47e6 <clkstarted_handle.constprop.0+0x12>
    481e:	bf00      	nop
    4820:	2000c1a8 	.word	0x2000c1a8

00004824 <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4824:	4b25      	ldr	r3, [pc, #148]	; (48bc <nrf_power_clock_isr+0x98>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    4826:	b507      	push	{r0, r1, r2, lr}
    4828:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    482a:	b182      	cbz	r2, 484e <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
    482c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4830:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    4834:	07d1      	lsls	r1, r2, #31
    4836:	d50a      	bpl.n	484e <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4838:	2200      	movs	r2, #0
    483a:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    483c:	681b      	ldr	r3, [r3, #0]
    483e:	9300      	str	r3, [sp, #0]
    (void)dummy;
    4840:	9b00      	ldr	r3, [sp, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    4842:	4b1f      	ldr	r3, [pc, #124]	; (48c0 <nrf_power_clock_isr+0x9c>)

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    4844:	689b      	ldr	r3, [r3, #8]
    4846:	7a58      	ldrb	r0, [r3, #9]
    4848:	b908      	cbnz	r0, 484e <nrf_power_clock_isr+0x2a>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    484a:	f7ff ffc3 	bl	47d4 <clkstarted_handle.constprop.0>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    484e:	4b1d      	ldr	r3, [pc, #116]	; (48c4 <nrf_power_clock_isr+0xa0>)
    4850:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    4852:	b16a      	cbz	r2, 4870 <nrf_power_clock_isr+0x4c>
    return p_reg->INTENSET & mask;
    4854:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4858:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    485c:	0792      	lsls	r2, r2, #30
    485e:	d507      	bpl.n	4870 <nrf_power_clock_isr+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4860:	2200      	movs	r2, #0
    4862:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    4864:	681b      	ldr	r3, [r3, #0]
    4866:	9301      	str	r3, [sp, #4]
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    4868:	2001      	movs	r0, #1
    (void)dummy;
    486a:	9b01      	ldr	r3, [sp, #4]
    486c:	f7ff ffb2 	bl	47d4 <clkstarted_handle.constprop.0>
	if (power_event_check_and_clean(NRF_POWER_EVENT_USBDETECTED,
    4870:	2180      	movs	r1, #128	; 0x80
    4872:	f44f 708e 	mov.w	r0, #284	; 0x11c
    4876:	f011 faa3 	bl	15dc0 <power_event_check_and_clean>
    487a:	b118      	cbz	r0, 4884 <nrf_power_clock_isr+0x60>
		usb_dc_nrfx_power_event_callback(NRF_POWER_EVENT_USBDETECTED);
    487c:	f44f 708e 	mov.w	r0, #284	; 0x11c
    4880:	f000 fc40 	bl	5104 <usb_dc_nrfx_power_event_callback>
	if (power_event_check_and_clean(NRF_POWER_EVENT_USBPWRRDY,
    4884:	f44f 7100 	mov.w	r1, #512	; 0x200
    4888:	f44f 7092 	mov.w	r0, #292	; 0x124
    488c:	f011 fa98 	bl	15dc0 <power_event_check_and_clean>
    4890:	b118      	cbz	r0, 489a <nrf_power_clock_isr+0x76>
		usb_dc_nrfx_power_event_callback(NRF_POWER_EVENT_USBPWRRDY);
    4892:	f44f 7092 	mov.w	r0, #292	; 0x124
    4896:	f000 fc35 	bl	5104 <usb_dc_nrfx_power_event_callback>
	if (power_event_check_and_clean(NRF_POWER_EVENT_USBREMOVED,
    489a:	f44f 7180 	mov.w	r1, #256	; 0x100
    489e:	f44f 7090 	mov.w	r0, #288	; 0x120
    48a2:	f011 fa8d 	bl	15dc0 <power_event_check_and_clean>
    48a6:	b130      	cbz	r0, 48b6 <nrf_power_clock_isr+0x92>
		usb_dc_nrfx_power_event_callback(NRF_POWER_EVENT_USBREMOVED);
    48a8:	f44f 7090 	mov.w	r0, #288	; 0x120
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    48ac:	b003      	add	sp, #12
    48ae:	f85d eb04 	ldr.w	lr, [sp], #4
		usb_dc_nrfx_power_event_callback(NRF_POWER_EVENT_USBREMOVED);
    48b2:	f000 bc27 	b.w	5104 <usb_dc_nrfx_power_event_callback>
}
    48b6:	b003      	add	sp, #12
    48b8:	f85d fb04 	ldr.w	pc, [sp], #4
    48bc:	40000100 	.word	0x40000100
    48c0:	2000c1a8 	.word	0x2000c1a8
    48c4:	40000104 	.word	0x40000104

000048c8 <usbd_evt_put>:
 * @brief Enqueue USBD event.
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
    48c8:	4601      	mov	r1, r0
	k_fifo_put(&usbd_evt_fifo, ev);
    48ca:	4801      	ldr	r0, [pc, #4]	; (48d0 <usbd_evt_put+0x8>)
    48cc:	f014 b96b 	b.w	18ba6 <k_queue_append>
    48d0:	2000c3b0 	.word	0x2000c3b0

000048d4 <endpoint_ctx>:
	u8_t ep_num = ep & ~USB_EP_DIR_MASK;
    48d4:	f000 037f 	and.w	r3, r0, #127	; 0x7f
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
    48d8:	2b08      	cmp	r3, #8
	if (NRF_USBD_EPIN_CHECK(ep)) {
    48da:	b242      	sxtb	r2, r0
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
    48dc:	d004      	beq.n	48e8 <endpoint_ctx+0x14>
			if (ep_num >= CFG_EPIN_CNT) {
    48de:	f010 0f78 	tst.w	r0, #120	; 0x78
    48e2:	d001      	beq.n	48e8 <endpoint_ctx+0x14>
		return NULL;
    48e4:	2000      	movs	r0, #0
    48e6:	4770      	bx	lr
	if (NRF_USBD_EPIN_CHECK(ep)) {
    48e8:	2a00      	cmp	r2, #0
	ep_num = NRF_USBD_EP_NR_GET(ep);
    48ea:	f000 030f 	and.w	r3, r0, #15
	if (NRF_USBD_EPIN_CHECK(ep)) {
    48ee:	f000 0008 	and.w	r0, r0, #8
    48f2:	da06      	bge.n	4902 <endpoint_ctx+0x2e>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
    48f4:	b968      	cbnz	r0, 4912 <endpoint_ctx+0x3e>
			return &ctx->ep_ctx[ep_num];
    48f6:	4809      	ldr	r0, [pc, #36]	; (491c <endpoint_ctx+0x48>)
    48f8:	2224      	movs	r2, #36	; 0x24
    48fa:	fb02 0003 	mla	r0, r2, r3, r0
			return &ctx->ep_ctx[CFG_EPIN_CNT +
    48fe:	3028      	adds	r0, #40	; 0x28
    4900:	4770      	bx	lr
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
    4902:	b940      	cbnz	r0, 4916 <endpoint_ctx+0x42>
					    CFG_EP_ISOIN_CNT +
    4904:	f103 0009 	add.w	r0, r3, #9
			return &ctx->ep_ctx[CFG_EPIN_CNT +
    4908:	4b04      	ldr	r3, [pc, #16]	; (491c <endpoint_ctx+0x48>)
    490a:	2224      	movs	r2, #36	; 0x24
    490c:	fb02 3000 	mla	r0, r2, r0, r3
    4910:	e7f5      	b.n	48fe <endpoint_ctx+0x2a>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
    4912:	4803      	ldr	r0, [pc, #12]	; (4920 <endpoint_ctx+0x4c>)
    4914:	4770      	bx	lr
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
    4916:	4803      	ldr	r0, [pc, #12]	; (4924 <endpoint_ctx+0x50>)
}
    4918:	4770      	bx	lr
    491a:	bf00      	nop
    491c:	20002710 	.word	0x20002710
    4920:	20002858 	.word	0x20002858
    4924:	2000299c 	.word	0x2000299c

00004928 <hf_clock_enable.constprop.0>:
 * @param on		Set true to enable the HF clock, false to disable.
 * @param blocking	Set true to block wait till HF clock stabilizes.
 *
 * @return 0 on success, error number otherwise
 */
static int hf_clock_enable(bool on, bool blocking)
    4928:	b570      	push	{r4, r5, r6, lr}
    492a:	4605      	mov	r5, r0
    492c:	481c      	ldr	r0, [pc, #112]	; (49a0 <hf_clock_enable.constprop.0+0x78>)
    492e:	f00e fe9d 	bl	1366c <z_impl_device_get_binding>
	int ret = -ENODEV;
	struct device *clock;
	static bool clock_requested;

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
    4932:	b968      	cbnz	r0, 4950 <hf_clock_enable.constprop.0+0x28>
    4934:	4b1b      	ldr	r3, [pc, #108]	; (49a4 <hf_clock_enable.constprop.0+0x7c>)
    4936:	491c      	ldr	r1, [pc, #112]	; (49a8 <hf_clock_enable.constprop.0+0x80>)
		LOG_ERR("NRF HF Clock device not found!");
    4938:	481c      	ldr	r0, [pc, #112]	; (49ac <hf_clock_enable.constprop.0+0x84>)
    493a:	1ac9      	subs	r1, r1, r3
    493c:	08c9      	lsrs	r1, r1, #3
    493e:	0189      	lsls	r1, r1, #6
    4940:	f041 0101 	orr.w	r1, r1, #1
    4944:	f010 fc81 	bl	1524a <log_0>
		return ret;
    4948:	f06f 0412 	mvn.w	r4, #18
	/* NOTE: Non-blocking HF clock enable can return -EINPROGRESS
	 * if HF clock start was already requested. Such error code
	 * does not need to be propagated, hence returned value is 0.
	 */
	return 0;
}
    494c:	4620      	mov	r0, r4
    494e:	bd70      	pop	{r4, r5, r6, pc}
	if (on) {
    4950:	4e17      	ldr	r6, [pc, #92]	; (49b0 <hf_clock_enable.constprop.0+0x88>)
    4952:	7831      	ldrb	r1, [r6, #0]
    4954:	b1cd      	cbz	r5, 498a <hf_clock_enable.constprop.0+0x62>
		if (clock_requested) {
    4956:	b9f1      	cbnz	r1, 4996 <hf_clock_enable.constprop.0+0x6e>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    4958:	6843      	ldr	r3, [r0, #4]
    495a:	681b      	ldr	r3, [r3, #0]
				    clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->off(dev, sys);
    495c:	4798      	blx	r3
    495e:	4604      	mov	r4, r0
	if (ret && (blocking || (ret != -EINPROGRESS))) {
    4960:	b1c0      	cbz	r0, 4994 <hf_clock_enable.constprop.0+0x6c>
    4962:	f110 0f44 	cmn.w	r0, #68	; 0x44
    4966:	d015      	beq.n	4994 <hf_clock_enable.constprop.0+0x6c>
    4968:	4a0e      	ldr	r2, [pc, #56]	; (49a4 <hf_clock_enable.constprop.0+0x7c>)
    496a:	4b0f      	ldr	r3, [pc, #60]	; (49a8 <hf_clock_enable.constprop.0+0x80>)
		LOG_ERR("HF clock %s fail: %d",
    496c:	4911      	ldr	r1, [pc, #68]	; (49b4 <hf_clock_enable.constprop.0+0x8c>)
    496e:	1a9b      	subs	r3, r3, r2
    4970:	08db      	lsrs	r3, r3, #3
    4972:	4602      	mov	r2, r0
    4974:	4810      	ldr	r0, [pc, #64]	; (49b8 <hf_clock_enable.constprop.0+0x90>)
    4976:	019b      	lsls	r3, r3, #6
    4978:	2d00      	cmp	r5, #0
    497a:	bf08      	it	eq
    497c:	4601      	moveq	r1, r0
    497e:	f043 0301 	orr.w	r3, r3, #1
    4982:	480e      	ldr	r0, [pc, #56]	; (49bc <hf_clock_enable.constprop.0+0x94>)
    4984:	f010 fc82 	bl	1528c <log_2>
		return ret;
    4988:	e7e0      	b.n	494c <hf_clock_enable.constprop.0+0x24>
		if (!clock_requested) {
    498a:	b131      	cbz	r1, 499a <hf_clock_enable.constprop.0+0x72>
    498c:	6843      	ldr	r3, [r0, #4]
    498e:	4629      	mov	r1, r5
    4990:	685b      	ldr	r3, [r3, #4]
    4992:	e7e3      	b.n	495c <hf_clock_enable.constprop.0+0x34>
	clock_requested = on;
    4994:	7035      	strb	r5, [r6, #0]
			return 0;
    4996:	2400      	movs	r4, #0
    4998:	e7d8      	b.n	494c <hf_clock_enable.constprop.0+0x24>
    499a:	460c      	mov	r4, r1
    499c:	e7d6      	b.n	494c <hf_clock_enable.constprop.0+0x24>
    499e:	bf00      	nop
    49a0:	0001a699 	.word	0x0001a699
    49a4:	0001956c 	.word	0x0001956c
    49a8:	0001967c 	.word	0x0001967c
    49ac:	0001a6b9 	.word	0x0001a6b9
    49b0:	20008260 	.word	0x20008260
    49b4:	0001a6d8 	.word	0x0001a6d8
    49b8:	0001a6de 	.word	0x0001a6de
    49bc:	0001a6e3 	.word	0x0001a6e3

000049c0 <usbd_work_schedule>:
    49c0:	4909      	ldr	r1, [pc, #36]	; (49e8 <usbd_work_schedule+0x28>)
    49c2:	f3bf 8f5b 	dmb	ish
    49c6:	e851 3f00 	ldrex	r3, [r1]
    49ca:	f043 0201 	orr.w	r2, r3, #1
    49ce:	e841 2000 	strex	r0, r2, [r1]
    49d2:	2800      	cmp	r0, #0
    49d4:	d1f7      	bne.n	49c6 <usbd_work_schedule+0x6>
    49d6:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    49da:	07db      	lsls	r3, r3, #31
    49dc:	d403      	bmi.n	49e6 <usbd_work_schedule+0x26>
		k_queue_append(&work_q->queue, work);
    49de:	4803      	ldr	r0, [pc, #12]	; (49ec <usbd_work_schedule+0x2c>)
    49e0:	3908      	subs	r1, #8
    49e2:	f014 b8e0 	b.w	18ba6 <k_queue_append>
}
    49e6:	4770      	bx	lr
    49e8:	20002720 	.word	0x20002720
    49ec:	200029c4 	.word	0x200029c4

000049f0 <usbd_evt_flush>:
{
    49f0:	b510      	push	{r4, lr}
	return z_impl_k_queue_get(queue, timeout);
    49f2:	4c05      	ldr	r4, [pc, #20]	; (4a08 <usbd_evt_flush+0x18>)
    49f4:	2100      	movs	r1, #0
    49f6:	4620      	mov	r0, r4
    49f8:	f014 f904 	bl	18c04 <z_impl_k_queue_get>
		if (ev) {
    49fc:	b118      	cbz	r0, 4a06 <usbd_evt_flush+0x16>
	k_mem_pool_free(&ev->block);
    49fe:	3004      	adds	r0, #4
    4a00:	f014 f84a 	bl	18a98 <k_mem_pool_free>
	} while (ev != NULL);
    4a04:	e7f6      	b.n	49f4 <usbd_evt_flush+0x4>
}
    4a06:	bd10      	pop	{r4, pc}
    4a08:	2000c3b0 	.word	0x2000c3b0

00004a0c <usbd_evt_alloc>:
{
    4a0c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ret = k_mem_pool_alloc(&fifo_elem_pool, &block,
    4a0e:	466d      	mov	r5, sp
    4a10:	481c      	ldr	r0, [pc, #112]	; (4a84 <usbd_evt_alloc+0x78>)
    4a12:	2300      	movs	r3, #0
    4a14:	2218      	movs	r2, #24
    4a16:	4629      	mov	r1, r5
    4a18:	f014 f809 	bl	18a2e <k_mem_pool_alloc>
	if (ret < 0) {
    4a1c:	2800      	cmp	r0, #0
    4a1e:	da2a      	bge.n	4a76 <usbd_evt_alloc+0x6a>
    4a20:	4b19      	ldr	r3, [pc, #100]	; (4a88 <usbd_evt_alloc+0x7c>)
    4a22:	4c1a      	ldr	r4, [pc, #104]	; (4a8c <usbd_evt_alloc+0x80>)
		LOG_ERR("USBD event allocation failed!");
    4a24:	481a      	ldr	r0, [pc, #104]	; (4a90 <usbd_evt_alloc+0x84>)
    4a26:	1ae4      	subs	r4, r4, r3
    4a28:	08e4      	lsrs	r4, r4, #3
    4a2a:	01a4      	lsls	r4, r4, #6
    4a2c:	f044 0401 	orr.w	r4, r4, #1
    4a30:	4621      	mov	r1, r4
    4a32:	f010 fc0a 	bl	1524a <log_0>
		usbd_evt_flush();
    4a36:	f7ff ffdb 	bl	49f0 <usbd_evt_flush>
		ret = k_mem_pool_alloc(&fifo_elem_pool, &block,
    4a3a:	4812      	ldr	r0, [pc, #72]	; (4a84 <usbd_evt_alloc+0x78>)
    4a3c:	2300      	movs	r3, #0
    4a3e:	2218      	movs	r2, #24
    4a40:	4629      	mov	r1, r5
    4a42:	f013 fff4 	bl	18a2e <k_mem_pool_alloc>
		if (ret < 0) {
    4a46:	2800      	cmp	r0, #0
    4a48:	da07      	bge.n	4a5a <usbd_evt_alloc+0x4e>
			LOG_ERR("USBD event memory corrupted");
    4a4a:	4812      	ldr	r0, [pc, #72]	; (4a94 <usbd_evt_alloc+0x88>)
    4a4c:	4621      	mov	r1, r4
    4a4e:	f010 fbfc 	bl	1524a <log_0>
		return NULL;
    4a52:	2300      	movs	r3, #0
}
    4a54:	4618      	mov	r0, r3
    4a56:	b003      	add	sp, #12
    4a58:	bd30      	pop	{r4, r5, pc}
		ev = (struct usbd_event *)block.data;
    4a5a:	9b00      	ldr	r3, [sp, #0]
		ev->block = block;
    4a5c:	e895 0003 	ldmia.w	r5, {r0, r1}
    4a60:	1d1a      	adds	r2, r3, #4
    4a62:	e882 0003 	stmia.w	r2, {r0, r1}
		ev->evt_type = USBD_EVT_REINIT;
    4a66:	2204      	movs	r2, #4
    4a68:	751a      	strb	r2, [r3, #20]
		usbd_evt_put(ev);
    4a6a:	4618      	mov	r0, r3
    4a6c:	f7ff ff2c 	bl	48c8 <usbd_evt_put>
		usbd_work_schedule();
    4a70:	f7ff ffa6 	bl	49c0 <usbd_work_schedule>
    4a74:	e7ed      	b.n	4a52 <usbd_evt_alloc+0x46>
	ev->block = block;
    4a76:	e895 0003 	ldmia.w	r5, {r0, r1}
	ev = (struct usbd_event *)block.data;
    4a7a:	9b00      	ldr	r3, [sp, #0]
	ev->block = block;
    4a7c:	1d1a      	adds	r2, r3, #4
    4a7e:	e882 0003 	stmia.w	r2, {r0, r1}
	return ev;
    4a82:	e7e7      	b.n	4a54 <usbd_evt_alloc+0x48>
    4a84:	2000bd94 	.word	0x2000bd94
    4a88:	0001956c 	.word	0x0001956c
    4a8c:	0001967c 	.word	0x0001967c
    4a90:	0001a6f8 	.word	0x0001a6f8
    4a94:	0001a716 	.word	0x0001a716

00004a98 <usbd_event_transfer_data>:
}

static void usbd_event_transfer_data(nrfx_usbd_evt_t const *const p_event)
{
	struct nrf_usbd_ep_ctx *ep_ctx =
		endpoint_ctx(p_event->data.eptransfer.ep);
    4a98:	7881      	ldrb	r1, [r0, #2]
{
    4a9a:	b570      	push	{r4, r5, r6, lr}
    4a9c:	4606      	mov	r6, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
    4a9e:	4608      	mov	r0, r1
    4aa0:	f7ff ff18 	bl	48d4 <endpoint_ctx>

	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    4aa4:	060b      	lsls	r3, r1, #24
    4aa6:	78f4      	ldrb	r4, [r6, #3]
		endpoint_ctx(p_event->data.eptransfer.ep);
    4aa8:	4605      	mov	r5, r0
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    4aaa:	d513      	bpl.n	4ad4 <usbd_event_transfer_data+0x3c>
		switch (p_event->data.eptransfer.status) {
    4aac:	2c00      	cmp	r4, #0
    4aae:	d146      	bne.n	4b3e <usbd_event_transfer_data+0xa6>
		case NRFX_USBD_EP_OK: {
			struct usbd_event *ev = usbd_evt_alloc();
    4ab0:	f7ff ffac 	bl	4a0c <usbd_evt_alloc>

			if (!ev) {
    4ab4:	4603      	mov	r3, r0
    4ab6:	2800      	cmp	r0, #0
    4ab8:	d04f      	beq.n	4b5a <usbd_event_transfer_data+0xc2>

			LOG_DBG("write complete, ep 0x%02x",
				(u32_t)p_event->data.eptransfer.ep);

			ep_ctx->write_in_progress = false;
			ev->evt_type = USBD_EVT_EP;
    4aba:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
    4abc:	f885 4022 	strb.w	r4, [r5, #34]	; 0x22
			ev->evt_type = USBD_EVT_EP;
    4ac0:	7502      	strb	r2, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
    4ac2:	2203      	movs	r2, #3
    4ac4:	7402      	strb	r2, [r0, #16]
				(u32_t)p_event->data.eptransfer.ep);

			ep_ctx->read_pending = true;
			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
			ev->evt.ep_evt.ep = ep_ctx;
    4ac6:	60dd      	str	r5, [r3, #12]

			usbd_evt_put(ev);
    4ac8:	f7ff fefe 	bl	48c8 <usbd_evt_put>
				p_event->data.eptransfer.ep);
		}
		break;
		}
	}
}
    4acc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			usbd_work_schedule();
    4ad0:	f7ff bf76 	b.w	49c0 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
    4ad4:	b15c      	cbz	r4, 4aee <usbd_event_transfer_data+0x56>
    4ad6:	2c01      	cmp	r4, #1
    4ad8:	d131      	bne.n	4b3e <usbd_event_transfer_data+0xa6>
			struct usbd_event *ev = usbd_evt_alloc();
    4ada:	f7ff ff97 	bl	4a0c <usbd_evt_alloc>
			if (!ev) {
    4ade:	4603      	mov	r3, r0
    4ae0:	2800      	cmp	r0, #0
    4ae2:	d03a      	beq.n	4b5a <usbd_event_transfer_data+0xc2>
			ep_ctx->read_pending = true;
    4ae4:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
			ev->evt_type = USBD_EVT_EP;
    4ae8:	7504      	strb	r4, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    4aea:	7404      	strb	r4, [r0, #16]
    4aec:	e7eb      	b.n	4ac6 <usbd_event_transfer_data+0x2e>
			struct usbd_event *ev = usbd_evt_alloc();
    4aee:	f7ff ff8d 	bl	4a0c <usbd_evt_alloc>
			if (!ev) {
    4af2:	b390      	cbz	r0, 4b5a <usbd_event_transfer_data+0xc2>
				p_event->data.eptransfer.ep);
    4af4:	78b3      	ldrb	r3, [r6, #2]

NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get(NRF_USBD_Type const * p_reg, uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
    4af6:	4a19      	ldr	r2, [pc, #100]	; (4b5c <usbd_event_transfer_data+0xc4>)
    4af8:	f013 0f80 	tst.w	r3, #128	; 0x80
    4afc:	f003 0108 	and.w	r1, r3, #8
    4b00:	d011      	beq.n	4b26 <usbd_event_transfer_data+0x8e>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    4b02:	b141      	cbz	r1, 4b16 <usbd_event_transfer_data+0x7e>
        {
            ret = p_reg->ISOIN.AMOUNT;
    4b04:	f8d2 36a8 	ldr.w	r3, [r2, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(NRF_USBD,
    4b08:	60eb      	str	r3, [r5, #12]
			ev->evt_type = USBD_EVT_EP;
    4b0a:	2301      	movs	r3, #1
    4b0c:	7503      	strb	r3, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
    4b0e:	2302      	movs	r3, #2
    4b10:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    4b12:	60c5      	str	r5, [r0, #12]
			usbd_evt_put(ev);
    4b14:	e7d8      	b.n	4ac8 <usbd_event_transfer_data+0x30>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPIN[epnr].AMOUNT;
    4b16:	f003 030f 	and.w	r3, r3, #15
    4b1a:	2114      	movs	r1, #20
    4b1c:	fb01 2303 	mla	r3, r1, r3, r2
    4b20:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4b24:	e7f0      	b.n	4b08 <usbd_event_transfer_data+0x70>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    4b26:	b111      	cbz	r1, 4b2e <usbd_event_transfer_data+0x96>
        {
            ret = p_reg->ISOOUT.AMOUNT;
    4b28:	f8d2 37a8 	ldr.w	r3, [r2, #1960]	; 0x7a8
    4b2c:	e7ec      	b.n	4b08 <usbd_event_transfer_data+0x70>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPOUT[epnr].AMOUNT;
    4b2e:	f003 030f 	and.w	r3, r3, #15
    4b32:	2114      	movs	r1, #20
    4b34:	fb01 2303 	mla	r3, r1, r3, r2
    4b38:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
    4b3c:	e7e4      	b.n	4b08 <usbd_event_transfer_data+0x70>
    4b3e:	4a08      	ldr	r2, [pc, #32]	; (4b60 <usbd_event_transfer_data+0xc8>)
    4b40:	4b08      	ldr	r3, [pc, #32]	; (4b64 <usbd_event_transfer_data+0xcc>)
			LOG_ERR("Unexpected event (nrfx_usbd): %d, ep 0x%02x",
    4b42:	4809      	ldr	r0, [pc, #36]	; (4b68 <usbd_event_transfer_data+0xd0>)
    4b44:	1a9b      	subs	r3, r3, r2
    4b46:	08db      	lsrs	r3, r3, #3
    4b48:	019b      	lsls	r3, r3, #6
    4b4a:	460a      	mov	r2, r1
    4b4c:	f043 0301 	orr.w	r3, r3, #1
    4b50:	4621      	mov	r1, r4
}
    4b52:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			LOG_ERR("Unexpected event (nrfx_usbd): %d, ep 0x%02x",
    4b56:	f010 bb99 	b.w	1528c <log_2>
}
    4b5a:	bd70      	pop	{r4, r5, r6, pc}
    4b5c:	40027000 	.word	0x40027000
    4b60:	0001956c 	.word	0x0001956c
    4b64:	0001967c 	.word	0x0001967c
    4b68:	0001a732 	.word	0x0001a732

00004b6c <usbd_event_handler>:

/**
 * @brief nRFx USBD driver event handler function.
 */
static void usbd_event_handler(nrfx_usbd_evt_t const *const p_event)
{
    4b6c:	b570      	push	{r4, r5, r6, lr}
    4b6e:	4606      	mov	r6, r0
    4b70:	b088      	sub	sp, #32
	struct nrf_usbd_ep_ctx *ep_ctx;
	struct usbd_event evt = {0};
    4b72:	2218      	movs	r2, #24
    4b74:	2100      	movs	r1, #0
    4b76:	a802      	add	r0, sp, #8
    4b78:	f011 fa8a 	bl	16090 <memset>
	bool put_evt = false;

	switch (p_event->type) {
    4b7c:	7833      	ldrb	r3, [r6, #0]
    4b7e:	3b01      	subs	r3, #1
    4b80:	2b05      	cmp	r3, #5
    4b82:	d824      	bhi.n	4bce <usbd_event_handler+0x62>
    4b84:	e8df f003 	tbb	[pc, r3]
    4b88:	23170395 	.word	0x23170395
    4b8c:	1985      	.short	0x1985
	case NRFX_USBD_EVT_SUSPEND:
		LOG_DBG("SUSPEND state detected");
		evt.evt_type = USBD_EVT_POWER;
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
    4b8e:	2303      	movs	r3, #3
		put_evt = true;
		break;
	case NRFX_USBD_EVT_RESUME:
		LOG_DBG("RESUMING from suspend");
		evt.evt_type = USBD_EVT_POWER;
		evt.evt.pwr_evt.state = USBD_RESUMED;
    4b90:	f88d 3014 	strb.w	r3, [sp, #20]
		evt.evt_type = USBD_EVT_POWER;
    4b94:	2400      	movs	r4, #0
	}

	if (put_evt) {
		struct usbd_event *ev;

		ev = usbd_evt_alloc();
    4b96:	f7ff ff39 	bl	4a0c <usbd_evt_alloc>
		if (!ev) {
    4b9a:	4603      	mov	r3, r0
    4b9c:	b1b8      	cbz	r0, 4bce <usbd_event_handler+0x62>
			return;
		}
		ev->evt_type = evt.evt_type;
		ev->evt = evt.evt;
    4b9e:	2200      	movs	r2, #0
    4ba0:	f88d 2018 	strb.w	r2, [sp, #24]
		ev->evt_type = evt.evt_type;
    4ba4:	7504      	strb	r4, [r0, #20]
		ev->evt = evt.evt;
    4ba6:	f100 020c 	add.w	r2, r0, #12
    4baa:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
    4bae:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
    4bb2:	4618      	mov	r0, r3
    4bb4:	e01e      	b.n	4bf4 <usbd_event_handler+0x88>
		evt.evt.pwr_evt.state = USBD_RESUMED;
    4bb6:	2304      	movs	r3, #4
    4bb8:	e7ea      	b.n	4b90 <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
    4bba:	78b1      	ldrb	r1, [r6, #2]
    4bbc:	4608      	mov	r0, r1
    4bbe:	f7ff fe89 	bl	48d4 <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
    4bc2:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
    4bc4:	4604      	mov	r4, r0
		switch (ep_ctx->cfg.type) {
    4bc6:	b123      	cbz	r3, 4bd2 <usbd_event_handler+0x66>
    4bc8:	3b01      	subs	r3, #1
    4bca:	2b02      	cmp	r3, #2
    4bcc:	d95d      	bls.n	4c8a <usbd_event_handler+0x11e>
		usbd_work_schedule();
	}
}
    4bce:	b008      	add	sp, #32
    4bd0:	bd70      	pop	{r4, r5, r6, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    4bd2:	060b      	lsls	r3, r1, #24
    4bd4:	78f5      	ldrb	r5, [r6, #3]
    4bd6:	d512      	bpl.n	4bfe <usbd_event_handler+0x92>
		switch (p_event->data.eptransfer.status) {
    4bd8:	2d00      	cmp	r5, #0
    4bda:	d149      	bne.n	4c70 <usbd_event_handler+0x104>
			struct usbd_event *ev = usbd_evt_alloc();
    4bdc:	f7ff ff16 	bl	4a0c <usbd_evt_alloc>
			if (!ev) {
    4be0:	4603      	mov	r3, r0
    4be2:	2800      	cmp	r0, #0
    4be4:	d0f3      	beq.n	4bce <usbd_event_handler+0x62>
			ev->evt_type = USBD_EVT_EP;
    4be6:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
    4be8:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
			ev->evt_type = USBD_EVT_EP;
    4bec:	7502      	strb	r2, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
    4bee:	2203      	movs	r2, #3
    4bf0:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    4bf2:	60dc      	str	r4, [r3, #12]
		usbd_evt_put(ev);
    4bf4:	f7ff fe68 	bl	48c8 <usbd_evt_put>
		usbd_work_schedule();
    4bf8:	f7ff fee2 	bl	49c0 <usbd_work_schedule>
    4bfc:	e7e7      	b.n	4bce <usbd_event_handler+0x62>
		switch (p_event->data.eptransfer.status) {
    4bfe:	b15d      	cbz	r5, 4c18 <usbd_event_handler+0xac>
    4c00:	2d01      	cmp	r5, #1
    4c02:	d135      	bne.n	4c70 <usbd_event_handler+0x104>
			struct usbd_event *ev = usbd_evt_alloc();
    4c04:	f7ff ff02 	bl	4a0c <usbd_evt_alloc>
			if (!ev) {
    4c08:	4603      	mov	r3, r0
    4c0a:	2800      	cmp	r0, #0
    4c0c:	d0df      	beq.n	4bce <usbd_event_handler+0x62>
			ep_ctx->read_pending = true;
    4c0e:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21
			ev->evt_type = USBD_EVT_EP;
    4c12:	7505      	strb	r5, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    4c14:	7405      	strb	r5, [r0, #16]
    4c16:	e7ec      	b.n	4bf2 <usbd_event_handler+0x86>
			struct usbd_event *ev = usbd_evt_alloc();
    4c18:	f7ff fef8 	bl	4a0c <usbd_evt_alloc>
			if (!ev) {
    4c1c:	4605      	mov	r5, r0
    4c1e:	2800      	cmp	r0, #0
    4c20:	d0d5      	beq.n	4bce <usbd_event_handler+0x62>
			ev->evt_type = USBD_EVT_EP;
    4c22:	2301      	movs	r3, #1
    4c24:	7503      	strb	r3, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
    4c26:	2302      	movs	r3, #2
    4c28:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    4c2a:	60c4      	str	r4, [r0, #12]
			err_code = nrfx_usbd_ep_status_get(
    4c2c:	f104 010c 	add.w	r1, r4, #12
    4c30:	78b0      	ldrb	r0, [r6, #2]
    4c32:	f012 fe89 	bl	17948 <nrfx_usbd_ep_status_get>
			if (err_code != NRFX_USBD_EP_OK) {
    4c36:	4601      	mov	r1, r0
    4c38:	b148      	cbz	r0, 4c4e <usbd_event_handler+0xe2>
    4c3a:	4a1f      	ldr	r2, [pc, #124]	; (4cb8 <usbd_event_handler+0x14c>)
    4c3c:	4b1f      	ldr	r3, [pc, #124]	; (4cbc <usbd_event_handler+0x150>)
				LOG_ERR("_ep_status_get failed! Code: %d",
    4c3e:	4820      	ldr	r0, [pc, #128]	; (4cc0 <usbd_event_handler+0x154>)
    4c40:	1ad2      	subs	r2, r2, r3
    4c42:	08d2      	lsrs	r2, r2, #3
    4c44:	0192      	lsls	r2, r2, #6
    4c46:	f042 0201 	orr.w	r2, r2, #1
    4c4a:	f010 fb0b 	bl	15264 <log_1>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
    4c4e:	4a1d      	ldr	r2, [pc, #116]	; (4cc4 <usbd_event_handler+0x158>)
    4c50:	68e1      	ldr	r1, [r4, #12]
    4c52:	f8b2 32b0 	ldrh.w	r3, [r2, #688]	; 0x2b0
    4c56:	428b      	cmp	r3, r1
    4c58:	d906      	bls.n	4c68 <usbd_event_handler+0xfc>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
    4c5a:	1a5b      	subs	r3, r3, r1
    4c5c:	f8a2 32b0 	strh.w	r3, [r2, #688]	; 0x2b0
				nrfx_usbd_setup_data_clear();
    4c60:	f00b fffa 	bl	10c58 <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
    4c64:	4628      	mov	r0, r5
    4c66:	e7c5      	b.n	4bf4 <usbd_event_handler+0x88>
				ctx->ctrl_read_len = 0U;
    4c68:	2300      	movs	r3, #0
    4c6a:	f8a2 32b0 	strh.w	r3, [r2, #688]	; 0x2b0
    4c6e:	e7f9      	b.n	4c64 <usbd_event_handler+0xf8>
    4c70:	4a12      	ldr	r2, [pc, #72]	; (4cbc <usbd_event_handler+0x150>)
    4c72:	4b11      	ldr	r3, [pc, #68]	; (4cb8 <usbd_event_handler+0x14c>)
			LOG_ERR("Unexpected event (nrfx_usbd): %d, ep 0x%02x",
    4c74:	4814      	ldr	r0, [pc, #80]	; (4cc8 <usbd_event_handler+0x15c>)
    4c76:	1a9b      	subs	r3, r3, r2
    4c78:	08db      	lsrs	r3, r3, #3
    4c7a:	019b      	lsls	r3, r3, #6
    4c7c:	460a      	mov	r2, r1
    4c7e:	f043 0301 	orr.w	r3, r3, #1
    4c82:	4629      	mov	r1, r5
    4c84:	f010 fb02 	bl	1528c <log_2>
    4c88:	e7a1      	b.n	4bce <usbd_event_handler+0x62>
			usbd_event_transfer_data(p_event);
    4c8a:	4630      	mov	r0, r6
    4c8c:	f7ff ff04 	bl	4a98 <usbd_event_transfer_data>
	if (put_evt) {
    4c90:	e79d      	b.n	4bce <usbd_event_handler+0x62>
		nrfx_usbd_setup_get(&drv_setup);
    4c92:	4668      	mov	r0, sp
    4c94:	f00b ffba 	bl	10c0c <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != REQ_SET_ADDRESS)
    4c98:	f89d 3001 	ldrb.w	r3, [sp, #1]
    4c9c:	2b05      	cmp	r3, #5
    4c9e:	d104      	bne.n	4caa <usbd_event_handler+0x13e>
		    || (REQTYPE_GET_TYPE(drv_setup.bmRequestType)
    4ca0:	f89d 3000 	ldrb.w	r3, [sp]
    4ca4:	f013 0f60 	tst.w	r3, #96	; 0x60
    4ca8:	d091      	beq.n	4bce <usbd_event_handler+0x62>
			evt.evt.ep_evt.ep = ep_ctx;
    4caa:	4b08      	ldr	r3, [pc, #32]	; (4ccc <usbd_event_handler+0x160>)
    4cac:	9305      	str	r3, [sp, #20]
			evt.evt_type = USBD_EVT_EP;
    4cae:	2401      	movs	r4, #1
    4cb0:	e771      	b.n	4b96 <usbd_event_handler+0x2a>
	switch (p_event->type) {
    4cb2:	2402      	movs	r4, #2
    4cb4:	e76f      	b.n	4b96 <usbd_event_handler+0x2a>
    4cb6:	bf00      	nop
    4cb8:	0001967c 	.word	0x0001967c
    4cbc:	0001956c 	.word	0x0001956c
    4cc0:	0001a75e 	.word	0x0001a75e
    4cc4:	20002710 	.word	0x20002710
    4cc8:	0001a732 	.word	0x0001a732
    4ccc:	2000287c 	.word	0x2000287c

00004cd0 <eps_ctx_init>:
{
    4cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    4cd2:	2500      	movs	r5, #0
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    4cd4:	4f4b      	ldr	r7, [pc, #300]	; (4e04 <eps_ctx_init+0x134>)
    4cd6:	462e      	mov	r6, r5
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    4cd8:	f065 007f 	orn	r0, r5, #127	; 0x7f
    4cdc:	b2c0      	uxtb	r0, r0
    4cde:	f7ff fdf9 	bl	48d4 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
    4ce2:	6903      	ldr	r3, [r0, #16]
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    4ce4:	4604      	mov	r4, r0
		if (!ep_ctx->buf.block.data) {
    4ce6:	b9ab      	cbnz	r3, 4d14 <eps_ctx_init+0x44>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    4ce8:	f100 0110 	add.w	r1, r0, #16
    4cec:	2240      	movs	r2, #64	; 0x40
    4cee:	4638      	mov	r0, r7
    4cf0:	f013 fe9d 	bl	18a2e <k_mem_pool_alloc>
			if (err < 0) {
    4cf4:	2800      	cmp	r0, #0
    4cf6:	da0d      	bge.n	4d14 <eps_ctx_init+0x44>
    4cf8:	4a43      	ldr	r2, [pc, #268]	; (4e08 <eps_ctx_init+0x138>)
    4cfa:	4b44      	ldr	r3, [pc, #272]	; (4e0c <eps_ctx_init+0x13c>)
				LOG_ERR("Buffer alloc failed for EP 0x%02x", i);
    4cfc:	4844      	ldr	r0, [pc, #272]	; (4e10 <eps_ctx_init+0x140>)
    4cfe:	1ad2      	subs	r2, r2, r3
    4d00:	08d2      	lsrs	r2, r2, #3
    4d02:	0192      	lsls	r2, r2, #6
    4d04:	f042 0201 	orr.w	r2, r2, #1
    4d08:	4629      	mov	r1, r5
    4d0a:	f010 faab 	bl	15264 <log_1>
				return -ENOMEM;
    4d0e:	f06f 000b 	mvn.w	r0, #11
}
    4d12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    4d14:	6923      	ldr	r3, [r4, #16]
	ep_ctx->buf.len  = 0U;
    4d16:	60e6      	str	r6, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
    4d18:	e9c4 3306 	strd	r3, r3, [r4, #24]
	ep_ctx->read_complete = true;
    4d1c:	2301      	movs	r3, #1
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    4d1e:	441d      	add	r5, r3
    4d20:	2d08      	cmp	r5, #8
	ep_ctx->read_complete = true;
    4d22:	f884 3020 	strb.w	r3, [r4, #32]
	ep_ctx->read_pending = false;
    4d26:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
	ep_ctx->write_in_progress = false;
    4d2a:	f884 6022 	strb.w	r6, [r4, #34]	; 0x22
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    4d2e:	d1d3      	bne.n	4cd8 <eps_ctx_init+0x8>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    4d30:	2500      	movs	r5, #0
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    4d32:	4f34      	ldr	r7, [pc, #208]	; (4e04 <eps_ctx_init+0x134>)
    4d34:	462e      	mov	r6, r5
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    4d36:	b2e8      	uxtb	r0, r5
    4d38:	f7ff fdcc 	bl	48d4 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
    4d3c:	6903      	ldr	r3, [r0, #16]
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    4d3e:	4604      	mov	r4, r0
		if (!ep_ctx->buf.block.data) {
    4d40:	b93b      	cbnz	r3, 4d52 <eps_ctx_init+0x82>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    4d42:	f100 0110 	add.w	r1, r0, #16
    4d46:	2240      	movs	r2, #64	; 0x40
    4d48:	4638      	mov	r0, r7
    4d4a:	f013 fe70 	bl	18a2e <k_mem_pool_alloc>
			if (err < 0) {
    4d4e:	2800      	cmp	r0, #0
    4d50:	dbd2      	blt.n	4cf8 <eps_ctx_init+0x28>
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    4d52:	6923      	ldr	r3, [r4, #16]
	ep_ctx->buf.len  = 0U;
    4d54:	60e6      	str	r6, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
    4d56:	e9c4 3306 	strd	r3, r3, [r4, #24]
	ep_ctx->read_complete = true;
    4d5a:	2301      	movs	r3, #1
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    4d5c:	441d      	add	r5, r3
    4d5e:	2d08      	cmp	r5, #8
	ep_ctx->read_complete = true;
    4d60:	f884 3020 	strb.w	r3, [r4, #32]
	ep_ctx->read_pending = false;
    4d64:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
	ep_ctx->write_in_progress = false;
    4d68:	f884 6022 	strb.w	r6, [r4, #34]	; 0x22
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    4d6c:	d1e3      	bne.n	4d36 <eps_ctx_init+0x66>
		if (!ep_ctx->buf.block.data) {
    4d6e:	4929      	ldr	r1, [pc, #164]	; (4e14 <eps_ctx_init+0x144>)
    4d70:	f8d1 3158 	ldr.w	r3, [r1, #344]	; 0x158
    4d74:	460c      	mov	r4, r1
    4d76:	b99b      	cbnz	r3, 4da0 <eps_ctx_init+0xd0>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    4d78:	4822      	ldr	r0, [pc, #136]	; (4e04 <eps_ctx_init+0x134>)
    4d7a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    4d7e:	f501 71ac 	add.w	r1, r1, #344	; 0x158
    4d82:	f013 fe54 	bl	18a2e <k_mem_pool_alloc>
			if (err < 0) {
    4d86:	2800      	cmp	r0, #0
    4d88:	da0a      	bge.n	4da0 <eps_ctx_init+0xd0>
    4d8a:	491f      	ldr	r1, [pc, #124]	; (4e08 <eps_ctx_init+0x138>)
    4d8c:	4b1f      	ldr	r3, [pc, #124]	; (4e0c <eps_ctx_init+0x13c>)
				LOG_ERR("EP buffer alloc failed for ISOIN");
    4d8e:	4822      	ldr	r0, [pc, #136]	; (4e18 <eps_ctx_init+0x148>)
    4d90:	1ac9      	subs	r1, r1, r3
    4d92:	08c9      	lsrs	r1, r1, #3
    4d94:	0189      	lsls	r1, r1, #6
    4d96:	f041 0101 	orr.w	r1, r1, #1
				LOG_ERR("EP buffer alloc failed for ISOOUT");
    4d9a:	f010 fa56 	bl	1524a <log_0>
    4d9e:	e7b6      	b.n	4d0e <eps_ctx_init+0x3e>
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    4da0:	f8d4 3158 	ldr.w	r3, [r4, #344]	; 0x158
	ep_ctx->read_complete = true;
    4da4:	2201      	movs	r2, #1
	ep_ctx->buf.curr = ep_ctx->buf.data;
    4da6:	e9c4 3358 	strd	r3, r3, [r4, #352]	; 0x160
	ep_ctx->buf.len  = 0U;
    4daa:	2300      	movs	r3, #0
	ep_ctx->read_complete = true;
    4dac:	f884 2168 	strb.w	r2, [r4, #360]	; 0x168
	ep_ctx->buf.len  = 0U;
    4db0:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
	ep_ctx->read_pending = false;
    4db4:	f884 3169 	strb.w	r3, [r4, #361]	; 0x169
	ep_ctx->write_in_progress = false;
    4db8:	f884 316a 	strb.w	r3, [r4, #362]	; 0x16a
		if (!ep_ctx->buf.block.data) {
    4dbc:	f8d4 329c 	ldr.w	r3, [r4, #668]	; 0x29c
    4dc0:	b983      	cbnz	r3, 4de4 <eps_ctx_init+0x114>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    4dc2:	4916      	ldr	r1, [pc, #88]	; (4e1c <eps_ctx_init+0x14c>)
    4dc4:	480f      	ldr	r0, [pc, #60]	; (4e04 <eps_ctx_init+0x134>)
    4dc6:	f44f 6280 	mov.w	r2, #1024	; 0x400
    4dca:	f013 fe30 	bl	18a2e <k_mem_pool_alloc>
			if (err < 0) {
    4dce:	2800      	cmp	r0, #0
    4dd0:	da08      	bge.n	4de4 <eps_ctx_init+0x114>
    4dd2:	490d      	ldr	r1, [pc, #52]	; (4e08 <eps_ctx_init+0x138>)
    4dd4:	4b0d      	ldr	r3, [pc, #52]	; (4e0c <eps_ctx_init+0x13c>)
				LOG_ERR("EP buffer alloc failed for ISOOUT");
    4dd6:	4812      	ldr	r0, [pc, #72]	; (4e20 <eps_ctx_init+0x150>)
    4dd8:	1ac9      	subs	r1, r1, r3
    4dda:	08c9      	lsrs	r1, r1, #3
    4ddc:	0189      	lsls	r1, r1, #6
    4dde:	f041 0101 	orr.w	r1, r1, #1
    4de2:	e7da      	b.n	4d9a <eps_ctx_init+0xca>
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    4de4:	f8d4 329c 	ldr.w	r3, [r4, #668]	; 0x29c
	ep_ctx->buf.len  = 0U;
    4de8:	2000      	movs	r0, #0
	ep_ctx->buf.curr = ep_ctx->buf.data;
    4dea:	e9c4 33a9 	strd	r3, r3, [r4, #676]	; 0x2a4
	ep_ctx->read_complete = true;
    4dee:	2301      	movs	r3, #1
    4df0:	f884 32ac 	strb.w	r3, [r4, #684]	; 0x2ac
	ep_ctx->buf.len  = 0U;
    4df4:	f8c4 0298 	str.w	r0, [r4, #664]	; 0x298
	ep_ctx->read_pending = false;
    4df8:	f884 02ad 	strb.w	r0, [r4, #685]	; 0x2ad
	ep_ctx->write_in_progress = false;
    4dfc:	f884 02ae 	strb.w	r0, [r4, #686]	; 0x2ae
}
    4e00:	e787      	b.n	4d12 <eps_ctx_init+0x42>
    4e02:	bf00      	nop
    4e04:	2000bd90 	.word	0x2000bd90
    4e08:	0001967c 	.word	0x0001967c
    4e0c:	0001956c 	.word	0x0001956c
    4e10:	0001a77e 	.word	0x0001a77e
    4e14:	20002710 	.word	0x20002710
    4e18:	0001a7a0 	.word	0x0001a7a0
    4e1c:	200029ac 	.word	0x200029ac
    4e20:	0001a7c1 	.word	0x0001a7c1

00004e24 <usbd_work_handler>:
}


/* Work handler */
static void usbd_work_handler(struct k_work *item)
{
    4e24:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    4e28:	4faa      	ldr	r7, [pc, #680]	; (50d4 <usbd_work_handler+0x2b0>)
    4e2a:	4bab      	ldr	r3, [pc, #684]	; (50d8 <usbd_work_handler+0x2b4>)
    4e2c:	f8df a2d0 	ldr.w	sl, [pc, #720]	; 5100 <usbd_work_handler+0x2dc>
	return get_usbd_ctx()->ready;
    4e30:	4daa      	ldr	r5, [pc, #680]	; (50dc <usbd_work_handler+0x2b8>)
    4e32:	1aff      	subs	r7, r7, r3
{
    4e34:	4680      	mov	r8, r0
    4e36:	08ff      	lsrs	r7, r7, #3
    4e38:	2100      	movs	r1, #0
    4e3a:	4650      	mov	r0, sl
    4e3c:	f013 fee2 	bl	18c04 <z_impl_k_queue_get>
	struct nrf_usbd_ctx *ctx;
	struct usbd_event *ev;

	ctx = CONTAINER_OF(item, struct nrf_usbd_ctx, usb_work);

	while ((ev = usbd_evt_get()) != NULL) {
    4e40:	4606      	mov	r6, r0
    4e42:	b910      	cbnz	r0, 4e4a <usbd_work_handler+0x26>
			LOG_ERR("Unknown USBD event: %"PRId16, ev->evt_type);
			break;
		}
		usbd_evt_free(ev);
	}
}
    4e44:	b004      	add	sp, #16
    4e46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return get_usbd_ctx()->ready;
    4e4a:	796b      	ldrb	r3, [r5, #5]
    4e4c:	7d31      	ldrb	r1, [r6, #20]
    4e4e:	f106 0904 	add.w	r9, r6, #4
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
    4e52:	b933      	cbnz	r3, 4e62 <usbd_work_handler+0x3e>
    4e54:	2900      	cmp	r1, #0
    4e56:	f000 8096 	beq.w	4f86 <usbd_work_handler+0x162>
	k_mem_pool_free(&ev->block);
    4e5a:	4648      	mov	r0, r9
    4e5c:	f013 fe1c 	bl	18a98 <k_mem_pool_free>
}
    4e60:	e7ea      	b.n	4e38 <usbd_work_handler+0x14>
		switch (ev->evt_type) {
    4e62:	2904      	cmp	r1, #4
    4e64:	f200 812f 	bhi.w	50c6 <usbd_work_handler+0x2a2>
    4e68:	e8df f011 	tbh	[pc, r1, lsl #1]
    4e6c:	0005008d 	.word	0x0005008d
    4e70:	010d00fb 	.word	0x010d00fb
    4e74:	0115      	.short	0x0115
			if (!ctx->attached) {
    4e76:	f818 3c04 	ldrb.w	r3, [r8, #-4]
    4e7a:	b93b      	cbnz	r3, 4e8c <usbd_work_handler+0x68>
    4e7c:	68f3      	ldr	r3, [r6, #12]
				LOG_ERR("not attached, EP 0x%02x event dropped",
    4e7e:	4898      	ldr	r0, [pc, #608]	; (50e0 <usbd_work_handler+0x2bc>)
    4e80:	7a59      	ldrb	r1, [r3, #9]
    4e82:	01ba      	lsls	r2, r7, #6
    4e84:	f042 0201 	orr.w	r2, r2, #1
    4e88:	f010 f9ec 	bl	15264 <log_1>
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
    4e8c:	7c33      	ldrb	r3, [r6, #16]
    4e8e:	68f4      	ldr	r4, [r6, #12]
	switch (ep_evt->evt_type) {
    4e90:	2b03      	cmp	r3, #3
    4e92:	d8e2      	bhi.n	4e5a <usbd_work_handler+0x36>
    4e94:	e8df f003 	tbb	[pc, r3]
    4e98:	67623b02 	.word	0x67623b02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
    4e9c:	69a6      	ldr	r6, [r4, #24]
	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
    4e9e:	2208      	movs	r2, #8
    4ea0:	2100      	movs	r1, #0
    4ea2:	4630      	mov	r0, r6
    4ea4:	f011 f8f4 	bl	16090 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
    4ea8:	4a8e      	ldr	r2, [pc, #568]	; (50e4 <usbd_work_handler+0x2c0>)
    4eaa:	f8d2 3480 	ldr.w	r3, [r2, #1152]	; 0x480
    4eae:	7033      	strb	r3, [r6, #0]
    return (uint8_t)(p_reg->BREQUEST);
    4eb0:	f8d2 3484 	ldr.w	r3, [r2, #1156]	; 0x484
    4eb4:	7073      	strb	r3, [r6, #1]
    const uint16_t val = p_reg->WVALUEL;
    4eb6:	f8d2 3488 	ldr.w	r3, [r2, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
    4eba:	f8d2 148c 	ldr.w	r1, [r2, #1164]	; 0x48c
    4ebe:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
    4ec2:	8073      	strh	r3, [r6, #2]
    const uint16_t val = p_reg->WINDEXL;
    4ec4:	f8d2 3490 	ldr.w	r3, [r2, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
    4ec8:	f8d2 1494 	ldr.w	r1, [r2, #1172]	; 0x494
    4ecc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get(NRF_USBD);
    4ed0:	80b3      	strh	r3, [r6, #4]
    const uint16_t val = p_reg->WLENGTHL;
    4ed2:	f8d2 3498 	ldr.w	r3, [r2, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
    4ed6:	f8d2 249c 	ldr.w	r2, [r2, #1180]	; 0x49c
    4eda:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	usbd_setup->wLength = nrf_usbd_setup_wlength_get(NRF_USBD);
    4ede:	80f3      	strh	r3, [r6, #6]
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
    4ee0:	2308      	movs	r3, #8
    4ee2:	60e3      	str	r3, [r4, #12]
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
    4ee4:	7a60      	ldrb	r0, [r4, #9]
    4ee6:	6823      	ldr	r3, [r4, #0]
    4ee8:	2100      	movs	r1, #0
    4eea:	4798      	blx	r3
	if ((REQTYPE_GET_DIR(usbd_setup->bmRequestType)
    4eec:	7833      	ldrb	r3, [r6, #0]
    4eee:	09db      	lsrs	r3, r3, #7
    4ef0:	d109      	bne.n	4f06 <usbd_work_handler+0xe2>
	    && (usbd_setup->wLength)) {
    4ef2:	88f2      	ldrh	r2, [r6, #6]
    4ef4:	b13a      	cbz	r2, 4f06 <usbd_work_handler+0xe2>
		ctx->ctrl_read_len -= usbd_setup->wLength;
    4ef6:	f8b5 32b0 	ldrh.w	r3, [r5, #688]	; 0x2b0
    4efa:	1a9b      	subs	r3, r3, r2
    4efc:	f8a5 32b0 	strh.w	r3, [r5, #688]	; 0x2b0
		nrfx_usbd_setup_data_clear();
    4f00:	f00b feaa 	bl	10c58 <nrfx_usbd_setup_data_clear>
	    && (usbd_setup->wLength)) {
    4f04:	e7a9      	b.n	4e5a <usbd_work_handler+0x36>
		ctx->ctrl_read_len = 0U;
    4f06:	2300      	movs	r3, #0
    4f08:	f8a5 32b0 	strh.w	r3, [r5, #688]	; 0x2b0
    4f0c:	e7a5      	b.n	4e5a <usbd_work_handler+0x36>
	if (!ep_ctx->read_pending) {
    4f0e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    4f12:	2b00      	cmp	r3, #0
    4f14:	d0a1      	beq.n	4e5a <usbd_work_handler+0x36>
	if (!ep_ctx->read_complete) {
    4f16:	f894 3020 	ldrb.w	r3, [r4, #32]
    4f1a:	2b00      	cmp	r3, #0
    4f1c:	d09d      	beq.n	4e5a <usbd_work_handler+0x36>
	ep_ctx->read_pending = false;
    4f1e:	2600      	movs	r6, #0
    4f20:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    4f24:	4870      	ldr	r0, [pc, #448]	; (50e8 <usbd_work_handler+0x2c4>)
	ep_ctx->read_complete = false;
    4f26:	f884 6020 	strb.w	r6, [r4, #32]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    4f2a:	f010 ff6b 	bl	15e04 <k_mutex_lock.constprop.0>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
    4f2e:	69a3      	ldr	r3, [r4, #24]
    4f30:	9301      	str	r3, [sp, #4]
    4f32:	6863      	ldr	r3, [r4, #4]
    4f34:	e9cd 3602 	strd	r3, r6, [sp, #8]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
    4f38:	a901      	add	r1, sp, #4
    4f3a:	7a60      	ldrb	r0, [r4, #9]
    4f3c:	f00b fc3c 	bl	107b8 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
    4f40:	4b6a      	ldr	r3, [pc, #424]	; (50ec <usbd_work_handler+0x2c8>)
    4f42:	4298      	cmp	r0, r3
	nrfx_err_t err = nrfx_usbd_ep_transfer(
    4f44:	4601      	mov	r1, r0
	if (err != NRFX_SUCCESS) {
    4f46:	d005      	beq.n	4f54 <usbd_work_handler+0x130>
		LOG_ERR("nRF USBD transfer error (OUT): 0x%02x", err);
    4f48:	01ba      	lsls	r2, r7, #6
    4f4a:	4869      	ldr	r0, [pc, #420]	; (50f0 <usbd_work_handler+0x2cc>)
    4f4c:	f042 0201 	orr.w	r2, r2, #1
    4f50:	f010 f988 	bl	15264 <log_1>
	k_mutex_unlock(&ctx->drv_lock);
    4f54:	4864      	ldr	r0, [pc, #400]	; (50e8 <usbd_work_handler+0x2c4>)
    4f56:	f010 ff53 	bl	15e00 <k_mutex_unlock>
    4f5a:	e77e      	b.n	4e5a <usbd_work_handler+0x36>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    4f5c:	6823      	ldr	r3, [r4, #0]
    4f5e:	2101      	movs	r1, #1
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    4f60:	7a60      	ldrb	r0, [r4, #9]
    4f62:	4798      	blx	r3
		break;
    4f64:	e779      	b.n	4e5a <usbd_work_handler+0x36>
		if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
    4f66:	7aa3      	ldrb	r3, [r4, #10]
    4f68:	b953      	cbnz	r3, 4f80 <usbd_work_handler+0x15c>
		    && (!ep_ctx->write_fragmented)) {
    4f6a:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    4f6e:	b93b      	cbnz	r3, 4f80 <usbd_work_handler+0x15c>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    4f70:	485d      	ldr	r0, [pc, #372]	; (50e8 <usbd_work_handler+0x2c4>)
    4f72:	f010 ff47 	bl	15e04 <k_mutex_lock.constprop.0>
			nrfx_usbd_setup_clear();
    4f76:	f00b fea9 	bl	10ccc <nrfx_usbd_setup_clear>
			k_mutex_unlock(&ctx->drv_lock);
    4f7a:	485b      	ldr	r0, [pc, #364]	; (50e8 <usbd_work_handler+0x2c4>)
    4f7c:	f010 ff40 	bl	15e00 <k_mutex_unlock>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    4f80:	6823      	ldr	r3, [r4, #0]
    4f82:	2102      	movs	r1, #2
    4f84:	e7ec      	b.n	4f60 <usbd_work_handler+0x13c>
	switch (pwr_evt->state) {
    4f86:	7b32      	ldrb	r2, [r6, #12]
    4f88:	2a04      	cmp	r2, #4
    4f8a:	f63f af66 	bhi.w	4e5a <usbd_work_handler+0x36>
    4f8e:	e8df f002 	tbb	[pc, r2]
    4f92:	0343      	.short	0x0343
    4f94:	510e      	.short	0x510e
    4f96:	5d          	.byte	0x5d
    4f97:	00          	.byte	0x00
		if (!nrfx_usbd_is_enabled()) {
    4f98:	f00b fbc2 	bl	10720 <nrfx_usbd_is_enabled>
    4f9c:	2800      	cmp	r0, #0
    4f9e:	f47f af5c 	bne.w	4e5a <usbd_work_handler+0x36>
			nrfx_usbd_enable();
    4fa2:	f00b fac7 	bl	10534 <nrfx_usbd_enable>
			(void) hf_clock_enable(true, false);
    4fa6:	2001      	movs	r0, #1
    4fa8:	f7ff fcbe 	bl	4928 <hf_clock_enable.constprop.0>
    4fac:	e755      	b.n	4e5a <usbd_work_handler+0x36>
			usbd_work_process_pwr_events(&ev->evt.pwr_evt);
    4fae:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    4fb0:	f064 007f 	orn	r0, r4, #127	; 0x7f
    4fb4:	b2c0      	uxtb	r0, r0
    4fb6:	f7ff fc8d 	bl	48d4 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
    4fba:	7a03      	ldrb	r3, [r0, #8]
    4fbc:	b113      	cbz	r3, 4fc4 <usbd_work_handler+0x1a0>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    4fbe:	7a40      	ldrb	r0, [r0, #9]
    4fc0:	f00c f902 	bl	111c8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
    4fc4:	3401      	adds	r4, #1
    4fc6:	2c08      	cmp	r4, #8
    4fc8:	d1f2      	bne.n	4fb0 <usbd_work_handler+0x18c>
		if (ep_ctx->cfg.en) {
    4fca:	f895 3150 	ldrb.w	r3, [r5, #336]	; 0x150
    4fce:	b11b      	cbz	r3, 4fd8 <usbd_work_handler+0x1b4>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    4fd0:	f895 0151 	ldrb.w	r0, [r5, #337]	; 0x151
    4fd4:	f00c f8f8 	bl	111c8 <nrfx_usbd_ep_enable>
			usbd_work_process_pwr_events(&ev->evt.pwr_evt);
    4fd8:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    4fda:	b2e0      	uxtb	r0, r4
    4fdc:	f7ff fc7a 	bl	48d4 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
    4fe0:	7a03      	ldrb	r3, [r0, #8]
    4fe2:	b113      	cbz	r3, 4fea <usbd_work_handler+0x1c6>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    4fe4:	7a40      	ldrb	r0, [r0, #9]
    4fe6:	f00c f8ef 	bl	111c8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
    4fea:	3401      	adds	r4, #1
    4fec:	2c08      	cmp	r4, #8
    4fee:	d1f4      	bne.n	4fda <usbd_work_handler+0x1b6>
		if (ep_ctx->cfg.en) {
    4ff0:	f895 3294 	ldrb.w	r3, [r5, #660]	; 0x294
    4ff4:	b11b      	cbz	r3, 4ffe <usbd_work_handler+0x1da>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    4ff6:	f895 0295 	ldrb.w	r0, [r5, #661]	; 0x295
    4ffa:	f00c f8e5 	bl	111c8 <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
    4ffe:	2001      	movs	r0, #1
    5000:	f00b fb6a 	bl	106d8 <nrfx_usbd_start>
		ctx->ready = true;
    5004:	2301      	movs	r3, #1
    5006:	716b      	strb	r3, [r5, #5]
		if (ctx->status_cb) {
    5008:	682b      	ldr	r3, [r5, #0]
    500a:	2b00      	cmp	r3, #0
    500c:	f43f af25 	beq.w	4e5a <usbd_work_handler+0x36>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
    5010:	2100      	movs	r1, #0
    5012:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
    5014:	4798      	blx	r3
    5016:	e720      	b.n	4e5a <usbd_work_handler+0x36>
		ctx->ready = false;
    5018:	2400      	movs	r4, #0
    501a:	716c      	strb	r4, [r5, #5]
		nrfx_usbd_disable();
    501c:	f00c f860 	bl	110e0 <nrfx_usbd_disable>
		(void) hf_clock_enable(false, false);
    5020:	4620      	mov	r0, r4
    5022:	f7ff fc81 	bl	4928 <hf_clock_enable.constprop.0>
		if (ctx->status_cb) {
    5026:	682b      	ldr	r3, [r5, #0]
    5028:	2b00      	cmp	r3, #0
    502a:	f43f af16 	beq.w	4e5a <usbd_work_handler+0x36>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
    502e:	4621      	mov	r1, r4
    5030:	2004      	movs	r0, #4
    5032:	e7ef      	b.n	5014 <usbd_work_handler+0x1f0>
		if (dev_ready()) {
    5034:	2b00      	cmp	r3, #0
    5036:	f43f af10 	beq.w	4e5a <usbd_work_handler+0x36>
			nrfx_usbd_suspend();
    503a:	f00c f869 	bl	11110 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
    503e:	682b      	ldr	r3, [r5, #0]
    5040:	2b00      	cmp	r3, #0
    5042:	f43f af0a 	beq.w	4e5a <usbd_work_handler+0x36>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
    5046:	2100      	movs	r1, #0
    5048:	2005      	movs	r0, #5
    504a:	e7e3      	b.n	5014 <usbd_work_handler+0x1f0>
		if (ctx->status_cb && dev_ready()) {
    504c:	682a      	ldr	r2, [r5, #0]
    504e:	2a00      	cmp	r2, #0
    5050:	f43f af03 	beq.w	4e5a <usbd_work_handler+0x36>
    5054:	2b00      	cmp	r3, #0
    5056:	f43f af00 	beq.w	4e5a <usbd_work_handler+0x36>
			ctx->status_cb(USB_DC_RESUME, NULL);
    505a:	2100      	movs	r1, #0
    505c:	2006      	movs	r0, #6
    505e:	4790      	blx	r2
    5060:	e6fb      	b.n	4e5a <usbd_work_handler+0x36>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    5062:	f108 040c 	add.w	r4, r8, #12
    5066:	4620      	mov	r0, r4
    5068:	f010 fecc 	bl	15e04 <k_mutex_lock.constprop.0>
			eps_ctx_init();
    506c:	f7ff fe30 	bl	4cd0 <eps_ctx_init>
			k_mutex_unlock(&ctx->drv_lock);
    5070:	4620      	mov	r0, r4
    5072:	f010 fec5 	bl	15e00 <k_mutex_unlock>
			if (ctx->status_cb) {
    5076:	f858 3c08 	ldr.w	r3, [r8, #-8]
    507a:	2b00      	cmp	r3, #0
    507c:	f43f aeed 	beq.w	4e5a <usbd_work_handler+0x36>
				ctx->status_cb(USB_DC_RESET, NULL);
    5080:	2100      	movs	r1, #0
    5082:	2001      	movs	r0, #1
    5084:	e7c6      	b.n	5014 <usbd_work_handler+0x1f0>
			if (ctx->status_cb) {
    5086:	f858 3c08 	ldr.w	r3, [r8, #-8]
    508a:	2b00      	cmp	r3, #0
    508c:	f43f aee5 	beq.w	4e5a <usbd_work_handler+0x36>
				ctx->status_cb(USB_DC_SOF, NULL);
    5090:	2100      	movs	r1, #0
    5092:	200a      	movs	r0, #10
    5094:	e7be      	b.n	5014 <usbd_work_handler+0x1f0>
				LOG_ERR("USBD event queue full!");
    5096:	01b9      	lsls	r1, r7, #6
    5098:	f041 0101 	orr.w	r1, r1, #1
    509c:	4815      	ldr	r0, [pc, #84]	; (50f4 <usbd_work_handler+0x2d0>)
    509e:	f010 f8d4 	bl	1524a <log_0>
	nrf5_power_usb_power_int_enable(false);
    50a2:	2000      	movs	r0, #0
    50a4:	f010 fe9f 	bl	15de6 <nrf5_power_usb_power_int_enable>
	nrfx_usbd_disable();
    50a8:	f00c f81a 	bl	110e0 <nrfx_usbd_disable>
	nrfx_usbd_uninit();
    50ac:	f00b fa38 	bl	10520 <nrfx_usbd_uninit>
	usbd_evt_flush();
    50b0:	f7ff fc9e 	bl	49f0 <usbd_evt_flush>
	ret = eps_ctx_init();
    50b4:	f7ff fe0c 	bl	4cd0 <eps_ctx_init>
	nrf5_power_usb_power_int_enable(true);
    50b8:	2001      	movs	r0, #1
    50ba:	f010 fe94 	bl	15de6 <nrf5_power_usb_power_int_enable>
	err = nrfx_usbd_init(usbd_event_handler);
    50be:	480e      	ldr	r0, [pc, #56]	; (50f8 <usbd_work_handler+0x2d4>)
    50c0:	f00b fb38 	bl	10734 <nrfx_usbd_init>
}
    50c4:	e6c9      	b.n	4e5a <usbd_work_handler+0x36>
			LOG_ERR("Unknown USBD event: %"PRId16, ev->evt_type);
    50c6:	01ba      	lsls	r2, r7, #6
    50c8:	480c      	ldr	r0, [pc, #48]	; (50fc <usbd_work_handler+0x2d8>)
    50ca:	f042 0201 	orr.w	r2, r2, #1
    50ce:	f010 f8c9 	bl	15264 <log_1>
    50d2:	e6c2      	b.n	4e5a <usbd_work_handler+0x36>
    50d4:	0001967c 	.word	0x0001967c
    50d8:	0001956c 	.word	0x0001956c
    50dc:	20002710 	.word	0x20002710
    50e0:	0001a7e3 	.word	0x0001a7e3
    50e4:	40027000 	.word	0x40027000
    50e8:	20002724 	.word	0x20002724
    50ec:	0bad0000 	.word	0x0bad0000
    50f0:	0001a809 	.word	0x0001a809
    50f4:	0001a82f 	.word	0x0001a82f
    50f8:	00004b6d 	.word	0x00004b6d
    50fc:	0001a846 	.word	0x0001a846
    5100:	2000c3b0 	.word	0x2000c3b0

00005104 <usb_dc_nrfx_power_event_callback>:
	switch (event) {
    5104:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
{
    5108:	b510      	push	{r4, lr}
	switch (event) {
    510a:	d011      	beq.n	5130 <usb_dc_nrfx_power_event_callback+0x2c>
    510c:	f5b0 7f92 	cmp.w	r0, #292	; 0x124
    5110:	d01e      	beq.n	5150 <usb_dc_nrfx_power_event_callback+0x4c>
    5112:	f5b0 7f8e 	cmp.w	r0, #284	; 0x11c
    5116:	d01d      	beq.n	5154 <usb_dc_nrfx_power_event_callback+0x50>
    5118:	4910      	ldr	r1, [pc, #64]	; (515c <usb_dc_nrfx_power_event_callback+0x58>)
    511a:	4b11      	ldr	r3, [pc, #68]	; (5160 <usb_dc_nrfx_power_event_callback+0x5c>)
		LOG_ERR("Unknown USB power event");
    511c:	4811      	ldr	r0, [pc, #68]	; (5164 <usb_dc_nrfx_power_event_callback+0x60>)
    511e:	1ac9      	subs	r1, r1, r3
    5120:	08c9      	lsrs	r1, r1, #3
    5122:	0189      	lsls	r1, r1, #6
}
    5124:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LOG_ERR("Unknown USB power event");
    5128:	f041 0101 	orr.w	r1, r1, #1
    512c:	f010 b88d 	b.w	1524a <log_0>
		new_state = USBD_DETACHED;
    5130:	2400      	movs	r4, #0
	struct usbd_event *ev = usbd_evt_alloc();
    5132:	f7ff fc6b 	bl	4a0c <usbd_evt_alloc>
	if (!ev) {
    5136:	b178      	cbz	r0, 5158 <usb_dc_nrfx_power_event_callback+0x54>
	ev->evt_type = USBD_EVT_POWER;
    5138:	2200      	movs	r2, #0
    513a:	7502      	strb	r2, [r0, #20]
	ev->evt.pwr_evt.state = new_state;
    513c:	7304      	strb	r4, [r0, #12]
	usbd_evt_put(ev);
    513e:	f7ff fbc3 	bl	48c8 <usbd_evt_put>
	if (usbd_ctx.attached) {
    5142:	4b09      	ldr	r3, [pc, #36]	; (5168 <usb_dc_nrfx_power_event_callback+0x64>)
    5144:	791b      	ldrb	r3, [r3, #4]
    5146:	b13b      	cbz	r3, 5158 <usb_dc_nrfx_power_event_callback+0x54>
}
    5148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
    514c:	f7ff bc38 	b.w	49c0 <usbd_work_schedule>
	switch (event) {
    5150:	2402      	movs	r4, #2
    5152:	e7ee      	b.n	5132 <usb_dc_nrfx_power_event_callback+0x2e>
		new_state = USBD_ATTACHED;
    5154:	2401      	movs	r4, #1
    5156:	e7ec      	b.n	5132 <usb_dc_nrfx_power_event_callback+0x2e>
}
    5158:	bd10      	pop	{r4, pc}
    515a:	bf00      	nop
    515c:	0001967c 	.word	0x0001967c
    5160:	0001956c 	.word	0x0001956c
    5164:	0001a85d 	.word	0x0001a85d
    5168:	20002710 	.word	0x20002710

0000516c <usb_dc_attach>:

int usb_dc_attach(void)
{
    516c:	b538      	push	{r3, r4, r5, lr}
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();
	nrfx_err_t err;
	int ret;

	if (ctx->attached) {
    516e:	4d1e      	ldr	r5, [pc, #120]	; (51e8 <usb_dc_attach+0x7c>)
    5170:	792c      	ldrb	r4, [r5, #4]
    5172:	bba4      	cbnz	r4, 51de <usb_dc_attach+0x72>
		return 0;
	}

	k_work_q_start(&usbd_work_queue,
    5174:	491d      	ldr	r1, [pc, #116]	; (51ec <usb_dc_attach+0x80>)
    5176:	481e      	ldr	r0, [pc, #120]	; (51f0 <usb_dc_attach+0x84>)
    5178:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    517c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    5180:	f00f f9c4 	bl	1450c <k_work_q_start>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    5184:	4b1b      	ldr	r3, [pc, #108]	; (51f4 <usb_dc_attach+0x88>)
    5186:	60ac      	str	r4, [r5, #8]
    5188:	e9c5 3403 	strd	r3, r4, [r5, #12]
	return z_impl_k_mutex_init(mutex);
    518c:	f105 0014 	add.w	r0, r5, #20
    5190:	f013 fc9d 	bl	18ace <z_impl_k_mutex_init>
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);

	k_work_init(&ctx->usb_work, usbd_work_handler);
	k_mutex_init(&ctx->drv_lock);

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    5194:	4622      	mov	r2, r4
    5196:	2101      	movs	r1, #1
    5198:	2027      	movs	r0, #39	; 0x27
    519a:	f000 fccf 	bl	5b3c <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_usbd_irq_handler, 0);

	err = nrfx_usbd_init(usbd_event_handler);
    519e:	4816      	ldr	r0, [pc, #88]	; (51f8 <usb_dc_attach+0x8c>)
    51a0:	f00b fac8 	bl	10734 <nrfx_usbd_init>

	if (err != NRFX_SUCCESS) {
    51a4:	4b15      	ldr	r3, [pc, #84]	; (51fc <usb_dc_attach+0x90>)
    51a6:	4298      	cmp	r0, r3
    51a8:	d11b      	bne.n	51e2 <usb_dc_attach+0x76>
		LOG_DBG("nRF USBD driver init failed. Code: %d", (u32_t)err);
		return -EIO;
	}
	nrf5_power_usb_power_int_enable(true);
    51aa:	2001      	movs	r0, #1
    51ac:	f010 fe1b 	bl	15de6 <nrf5_power_usb_power_int_enable>

	ret = eps_ctx_init();
    51b0:	f7ff fd8e 	bl	4cd0 <eps_ctx_init>
	if (ret == 0) {
    51b4:	4604      	mov	r4, r0
    51b6:	b908      	cbnz	r0, 51bc <usb_dc_attach+0x50>
		ctx->attached = true;
    51b8:	2301      	movs	r3, #1
    51ba:	712b      	strb	r3, [r5, #4]
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
    51bc:	4b10      	ldr	r3, [pc, #64]	; (5200 <usb_dc_attach+0x94>)
	}

	if (!k_fifo_is_empty(&usbd_evt_fifo)) {
    51be:	681b      	ldr	r3, [r3, #0]
    51c0:	b10b      	cbz	r3, 51c6 <usb_dc_attach+0x5a>
		usbd_work_schedule();
    51c2:	f7ff fbfd 	bl	49c0 <usbd_work_schedule>
#endif // NRF_POWER_HAS_MAINREGSTATUS

#if NRF_POWER_HAS_USBREG
NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg)
{
    return p_reg->USBREGSTATUS;
    51c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    51ca:	f8d3 3438 	ldr.w	r3, [r3, #1080]	; 0x438
	}

	if (nrf_power_usbregstatus_vbusdet_get(NRF_POWER)) {
    51ce:	07db      	lsls	r3, r3, #31
    51d0:	d503      	bpl.n	51da <usb_dc_attach+0x6e>
		 * the peripheral is re-enabled.
		 * When USB-enabled bootloader is used, target application
		 * will not receive this event and it needs to be generated
		 * again here.
		 */
		usb_dc_nrfx_power_event_callback(NRF_POWER_EVENT_USBDETECTED);
    51d2:	f44f 708e 	mov.w	r0, #284	; 0x11c
    51d6:	f7ff ff95 	bl	5104 <usb_dc_nrfx_power_event_callback>
	}

	return ret;
}
    51da:	4620      	mov	r0, r4
    51dc:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
    51de:	2400      	movs	r4, #0
    51e0:	e7fb      	b.n	51da <usb_dc_attach+0x6e>
		return -EIO;
    51e2:	f06f 0404 	mvn.w	r4, #4
    51e6:	e7f8      	b.n	51da <usb_dc_attach+0x6e>
    51e8:	20002710 	.word	0x20002710
    51ec:	20008ee0 	.word	0x20008ee0
    51f0:	200029c4 	.word	0x200029c4
    51f4:	00004e25 	.word	0x00004e25
    51f8:	00004b6d 	.word	0x00004b6d
    51fc:	0bad0000 	.word	0x0bad0000
    5200:	2000c3b0 	.word	0x2000c3b0

00005204 <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
    5204:	4b06      	ldr	r3, [pc, #24]	; (5220 <usb_dc_set_address+0x1c>)

int usb_dc_set_address(const u8_t addr)
{
	struct nrf_usbd_ctx *ctx;

	if (!dev_attached() || !dev_ready()) {
    5206:	791a      	ldrb	r2, [r3, #4]
    5208:	b132      	cbz	r2, 5218 <usb_dc_set_address+0x14>
    520a:	795b      	ldrb	r3, [r3, #5]
    520c:	2b00      	cmp	r3, #0

	ctx = get_usbd_ctx();

	LOG_DBG("Address set to: %d", addr);

	return 0;
    520e:	bf0c      	ite	eq
    5210:	f06f 0012 	mvneq.w	r0, #18
    5214:	2000      	movne	r0, #0
    5216:	4770      	bx	lr
		return -ENODEV;
    5218:	f06f 0012 	mvn.w	r0, #18
}
    521c:	4770      	bx	lr
    521e:	bf00      	nop
    5220:	20002710 	.word	0x20002710

00005224 <usb_dc_ep_check_cap>:


int usb_dc_ep_check_cap(const struct usb_dc_ep_cfg_data *const ep_cfg)
{
    5224:	b508      	push	{r3, lr}
    5226:	4602      	mov	r2, r0
	u8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
    5228:	7803      	ldrb	r3, [r0, #0]

	LOG_DBG("ep 0x%02x, mps %d, type %d", ep_cfg->ep_addr, ep_cfg->ep_mps,
		ep_cfg->ep_type);

	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
    522a:	7912      	ldrb	r2, [r2, #4]
	u8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
    522c:	f003 000f 	and.w	r0, r3, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
    5230:	b96a      	cbnz	r2, 524e <usb_dc_ep_check_cap+0x2a>
    5232:	b158      	cbz	r0, 524c <usb_dc_ep_check_cap+0x28>
    5234:	490f      	ldr	r1, [pc, #60]	; (5274 <usb_dc_ep_check_cap+0x50>)
    5236:	4b10      	ldr	r3, [pc, #64]	; (5278 <usb_dc_ep_check_cap+0x54>)
		LOG_ERR("invalid endpoint configuration");
    5238:	4810      	ldr	r0, [pc, #64]	; (527c <usb_dc_ep_check_cap+0x58>)
    523a:	1ac9      	subs	r1, r1, r3
    523c:	08c9      	lsrs	r1, r1, #3
    523e:	0189      	lsls	r1, r1, #6
    5240:	f041 0101 	orr.w	r1, r1, #1
		return -1;
	}

	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
		LOG_ERR("invalid endpoint index/address");
    5244:	f010 f801 	bl	1524a <log_0>
		return -1;
    5248:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		LOG_WRN("invalid endpoint type");
		return -1;
	}

	return 0;
}
    524c:	bd08      	pop	{r3, pc}
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
    524e:	2808      	cmp	r0, #8
    5250:	d908      	bls.n	5264 <usb_dc_ep_check_cap+0x40>
    5252:	4908      	ldr	r1, [pc, #32]	; (5274 <usb_dc_ep_check_cap+0x50>)
    5254:	4b08      	ldr	r3, [pc, #32]	; (5278 <usb_dc_ep_check_cap+0x54>)
		LOG_ERR("invalid endpoint index/address");
    5256:	480a      	ldr	r0, [pc, #40]	; (5280 <usb_dc_ep_check_cap+0x5c>)
    5258:	1ac9      	subs	r1, r1, r3
    525a:	08c9      	lsrs	r1, r1, #3
    525c:	0189      	lsls	r1, r1, #6
    525e:	f041 0101 	orr.w	r1, r1, #1
    5262:	e7ef      	b.n	5244 <usb_dc_ep_check_cap+0x20>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
    5264:	2a01      	cmp	r2, #1
    5266:	bf06      	itte	eq
    5268:	f083 0008 	eoreq.w	r0, r3, #8
    526c:	f340 00c0 	sbfxeq	r0, r0, #3, #1
	return 0;
    5270:	2000      	movne	r0, #0
    5272:	e7eb      	b.n	524c <usb_dc_ep_check_cap+0x28>
    5274:	0001967c 	.word	0x0001967c
    5278:	0001956c 	.word	0x0001956c
    527c:	0001a875 	.word	0x0001a875
    5280:	0001a894 	.word	0x0001a894

00005284 <usb_dc_ep_configure>:

int usb_dc_ep_configure(const struct usb_dc_ep_cfg_data *const ep_cfg)
{
    5284:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    5286:	4b13      	ldr	r3, [pc, #76]	; (52d4 <usb_dc_ep_configure+0x50>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    5288:	791b      	ldrb	r3, [r3, #4]
{
    528a:	4601      	mov	r1, r0
	if (!dev_attached()) {
    528c:	b1f3      	cbz	r3, 52cc <usb_dc_ep_configure+0x48>
	 * accordingly. So either this needs to be chosen in the
	 * menuconfig in application area or perhaps in device tree
	 * at compile time or introduce a new API to read the endpoint
	 * configuration at runtime before configuring them.
	 */
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
    528e:	7805      	ldrb	r5, [r0, #0]
    5290:	4628      	mov	r0, r5
    5292:	f7ff fb1f 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    5296:	b188      	cbz	r0, 52bc <usb_dc_ep_configure+0x38>
		return -EINVAL;
	}

	ep_ctx->cfg.addr = ep_cfg->ep_addr;
    5298:	7245      	strb	r5, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
    529a:	790b      	ldrb	r3, [r1, #4]
    529c:	7283      	strb	r3, [r0, #10]
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
    529e:	8849      	ldrh	r1, [r1, #2]
    52a0:	6041      	str	r1, [r0, #4]

	if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
    52a2:	1e4c      	subs	r4, r1, #1
    52a4:	400c      	ands	r4, r1
    52a6:	d00c      	beq.n	52c2 <usb_dc_ep_configure+0x3e>
    52a8:	490b      	ldr	r1, [pc, #44]	; (52d8 <usb_dc_ep_configure+0x54>)
    52aa:	4b0c      	ldr	r3, [pc, #48]	; (52dc <usb_dc_ep_configure+0x58>)
		LOG_ERR("EP max packet size must be a power of 2");
    52ac:	480c      	ldr	r0, [pc, #48]	; (52e0 <usb_dc_ep_configure+0x5c>)
    52ae:	1ac9      	subs	r1, r1, r3
    52b0:	08c9      	lsrs	r1, r1, #3
    52b2:	0189      	lsls	r1, r1, #6
    52b4:	f041 0101 	orr.w	r1, r1, #1
    52b8:	f00f ffc7 	bl	1524a <log_0>
		return -EINVAL;
    52bc:	f06f 0415 	mvn.w	r4, #21
    52c0:	e002      	b.n	52c8 <usb_dc_ep_configure+0x44>
		return -EINVAL;
	}
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
    52c2:	4628      	mov	r0, r5
    52c4:	f012 fb3b 	bl	1793e <nrfx_usbd_ep_max_packet_size_set>
					 ep_cfg->ep_mps);

	return 0;
}
    52c8:	4620      	mov	r0, r4
    52ca:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    52cc:	f06f 0412 	mvn.w	r4, #18
    52d0:	e7fa      	b.n	52c8 <usb_dc_ep_configure+0x44>
    52d2:	bf00      	nop
    52d4:	20002710 	.word	0x20002710
    52d8:	0001967c 	.word	0x0001967c
    52dc:	0001956c 	.word	0x0001956c
    52e0:	0001a8b3 	.word	0x0001a8b3

000052e4 <usb_dc_ep_set_stall>:
	return get_usbd_ctx()->attached;
    52e4:	4b16      	ldr	r3, [pc, #88]	; (5340 <usb_dc_ep_set_stall+0x5c>)

int usb_dc_ep_set_stall(const u8_t ep)
{
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    52e6:	791a      	ldrb	r2, [r3, #4]
{
    52e8:	b510      	push	{r4, lr}
    52ea:	4601      	mov	r1, r0
	if (!dev_attached() || !dev_ready()) {
    52ec:	b32a      	cbz	r2, 533a <usb_dc_ep_set_stall+0x56>
    52ee:	795b      	ldrb	r3, [r3, #5]
    52f0:	b31b      	cbz	r3, 533a <usb_dc_ep_set_stall+0x56>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    52f2:	f7ff faef 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    52f6:	4604      	mov	r4, r0
    52f8:	b1e0      	cbz	r0, 5334 <usb_dc_ep_set_stall+0x50>
		return -EINVAL;
	}

	switch (ep_ctx->cfg.type) {
    52fa:	7a83      	ldrb	r3, [r0, #10]
    52fc:	2b01      	cmp	r3, #1
    52fe:	d00f      	beq.n	5320 <usb_dc_ep_set_stall+0x3c>
    5300:	d907      	bls.n	5312 <usb_dc_ep_set_stall+0x2e>
    5302:	3b02      	subs	r3, #2
    5304:	2b01      	cmp	r3, #1
    5306:	d907      	bls.n	5318 <usb_dc_ep_set_stall+0x34>
		LOG_ERR("STALL unsupported on ISO endpoint");
		return -EINVAL;
	}

	ep_ctx->buf.len = 0U;
	ep_ctx->buf.curr = ep_ctx->buf.data;
    5308:	69a3      	ldr	r3, [r4, #24]
    530a:	61e3      	str	r3, [r4, #28]
	ep_ctx->buf.len = 0U;
    530c:	2000      	movs	r0, #0
    530e:	60e0      	str	r0, [r4, #12]

	LOG_DBG("STALL on EP 0x%02x", ep);

	return 0;
}
    5310:	bd10      	pop	{r4, pc}
		nrfx_usbd_setup_stall();
    5312:	f00b fce3 	bl	10cdc <nrfx_usbd_setup_stall>
		break;
    5316:	e7f7      	b.n	5308 <usb_dc_ep_set_stall+0x24>
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
    5318:	4608      	mov	r0, r1
    531a:	f00b fc49 	bl	10bb0 <nrfx_usbd_ep_stall>
		break;
    531e:	e7f3      	b.n	5308 <usb_dc_ep_set_stall+0x24>
    5320:	4908      	ldr	r1, [pc, #32]	; (5344 <usb_dc_ep_set_stall+0x60>)
    5322:	4b09      	ldr	r3, [pc, #36]	; (5348 <usb_dc_ep_set_stall+0x64>)
		LOG_ERR("STALL unsupported on ISO endpoint");
    5324:	4809      	ldr	r0, [pc, #36]	; (534c <usb_dc_ep_set_stall+0x68>)
    5326:	1ac9      	subs	r1, r1, r3
    5328:	08c9      	lsrs	r1, r1, #3
    532a:	0189      	lsls	r1, r1, #6
    532c:	f041 0101 	orr.w	r1, r1, #1
    5330:	f00f ff8b 	bl	1524a <log_0>
		return -EINVAL;
    5334:	f06f 0015 	mvn.w	r0, #21
    5338:	e7ea      	b.n	5310 <usb_dc_ep_set_stall+0x2c>
		return -ENODEV;
    533a:	f06f 0012 	mvn.w	r0, #18
    533e:	e7e7      	b.n	5310 <usb_dc_ep_set_stall+0x2c>
    5340:	20002710 	.word	0x20002710
    5344:	0001967c 	.word	0x0001967c
    5348:	0001956c 	.word	0x0001956c
    534c:	0001a8db 	.word	0x0001a8db

00005350 <usb_dc_ep_clear_stall>:
	return get_usbd_ctx()->attached;
    5350:	4b0b      	ldr	r3, [pc, #44]	; (5380 <usb_dc_ep_clear_stall+0x30>)
int usb_dc_ep_clear_stall(const u8_t ep)
{

	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    5352:	791a      	ldrb	r2, [r3, #4]
{
    5354:	b510      	push	{r4, lr}
    5356:	4604      	mov	r4, r0
	if (!dev_attached() || !dev_ready()) {
    5358:	b162      	cbz	r2, 5374 <usb_dc_ep_clear_stall+0x24>
    535a:	795b      	ldrb	r3, [r3, #5]
    535c:	b153      	cbz	r3, 5374 <usb_dc_ep_clear_stall+0x24>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    535e:	f7ff fab9 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    5362:	b150      	cbz	r0, 537a <usb_dc_ep_clear_stall+0x2a>
		return -EINVAL;
	}

	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
    5364:	4620      	mov	r0, r4
    5366:	f00b fc45 	bl	10bf4 <nrfx_usbd_ep_dtoggle_clear>
	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
    536a:	4620      	mov	r0, r4
    536c:	f00b ff7e 	bl	1126c <nrfx_usbd_ep_stall_clear>
	LOG_DBG("Unstall on EP 0x%02x", ep);

	return 0;
    5370:	2000      	movs	r0, #0
}
    5372:	bd10      	pop	{r4, pc}
		return -ENODEV;
    5374:	f06f 0012 	mvn.w	r0, #18
    5378:	e7fb      	b.n	5372 <usb_dc_ep_clear_stall+0x22>
		return -EINVAL;
    537a:	f06f 0015 	mvn.w	r0, #21
    537e:	e7f8      	b.n	5372 <usb_dc_ep_clear_stall+0x22>
    5380:	20002710 	.word	0x20002710

00005384 <usb_dc_ep_is_stalled>:
{
	return usb_dc_ep_set_stall(ep);
}

int usb_dc_ep_is_stalled(const u8_t ep, u8_t *const stalled)
{
    5384:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    5386:	4b0b      	ldr	r3, [pc, #44]	; (53b4 <usb_dc_ep_is_stalled+0x30>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    5388:	791a      	ldrb	r2, [r3, #4]
{
    538a:	4605      	mov	r5, r0
    538c:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
    538e:	b15a      	cbz	r2, 53a8 <usb_dc_ep_is_stalled+0x24>
    5390:	795b      	ldrb	r3, [r3, #5]
    5392:	b14b      	cbz	r3, 53a8 <usb_dc_ep_is_stalled+0x24>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    5394:	f7ff fa9e 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    5398:	b148      	cbz	r0, 53ae <usb_dc_ep_is_stalled+0x2a>
		return -EINVAL;
	}

	if (!stalled) {
    539a:	b141      	cbz	r1, 53ae <usb_dc_ep_is_stalled+0x2a>
		return -EINVAL;
	}

	*stalled = (u8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
    539c:	4628      	mov	r0, r5
    539e:	f00b fc0f 	bl	10bc0 <nrfx_usbd_ep_stall_check>
    53a2:	7020      	strb	r0, [r4, #0]

	return 0;
    53a4:	2000      	movs	r0, #0
}
    53a6:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    53a8:	f06f 0012 	mvn.w	r0, #18
    53ac:	e7fb      	b.n	53a6 <usb_dc_ep_is_stalled+0x22>
		return -EINVAL;
    53ae:	f06f 0015 	mvn.w	r0, #21
    53b2:	e7f8      	b.n	53a6 <usb_dc_ep_is_stalled+0x22>
    53b4:	20002710 	.word	0x20002710

000053b8 <usb_dc_ep_enable>:

int usb_dc_ep_enable(const u8_t ep)
{
    53b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return get_usbd_ctx()->attached;
    53ba:	4f0f      	ldr	r7, [pc, #60]	; (53f8 <usb_dc_ep_enable+0x40>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    53bc:	793b      	ldrb	r3, [r7, #4]
{
    53be:	4605      	mov	r5, r0
	if (!dev_attached()) {
    53c0:	b18b      	cbz	r3, 53e6 <usb_dc_ep_enable+0x2e>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    53c2:	f7ff fa87 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    53c6:	4604      	mov	r4, r0
    53c8:	b180      	cbz	r0, 53ec <usb_dc_ep_enable+0x34>
		return -EINVAL;
	}

	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
    53ca:	4628      	mov	r0, r5
    53cc:	f00b fc12 	bl	10bf4 <nrfx_usbd_ep_dtoggle_clear>
	if (ep_ctx->cfg.en) {
    53d0:	7a26      	ldrb	r6, [r4, #8]
    53d2:	b976      	cbnz	r6, 53f2 <usb_dc_ep_enable+0x3a>
	LOG_DBG("EP enable: 0x%02x", ep);

	ep_ctx->cfg.en = true;

	/* Defer the endpoint enable if USBD is not ready yet. */
	if (dev_ready()) {
    53d4:	7978      	ldrb	r0, [r7, #5]
	ep_ctx->cfg.en = true;
    53d6:	2301      	movs	r3, #1
    53d8:	7223      	strb	r3, [r4, #8]
	if (dev_ready()) {
    53da:	b118      	cbz	r0, 53e4 <usb_dc_ep_enable+0x2c>
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
    53dc:	4628      	mov	r0, r5
    53de:	f00b fef3 	bl	111c8 <nrfx_usbd_ep_enable>
	}

	return 0;
    53e2:	4630      	mov	r0, r6
}
    53e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENODEV;
    53e6:	f06f 0012 	mvn.w	r0, #18
    53ea:	e7fb      	b.n	53e4 <usb_dc_ep_enable+0x2c>
		return -EINVAL;
    53ec:	f06f 0015 	mvn.w	r0, #21
    53f0:	e7f8      	b.n	53e4 <usb_dc_ep_enable+0x2c>
		return -EALREADY;
    53f2:	f06f 0044 	mvn.w	r0, #68	; 0x44
    53f6:	e7f5      	b.n	53e4 <usb_dc_ep_enable+0x2c>
    53f8:	20002710 	.word	0x20002710

000053fc <usb_dc_ep_disable>:
	return get_usbd_ctx()->attached;
    53fc:	4b0d      	ldr	r3, [pc, #52]	; (5434 <usb_dc_ep_disable+0x38>)

int usb_dc_ep_disable(const u8_t ep)
{
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    53fe:	791a      	ldrb	r2, [r3, #4]
{
    5400:	b510      	push	{r4, lr}
    5402:	4601      	mov	r1, r0
	if (!dev_attached() || !dev_ready()) {
    5404:	b16a      	cbz	r2, 5422 <usb_dc_ep_disable+0x26>
    5406:	795b      	ldrb	r3, [r3, #5]
    5408:	b15b      	cbz	r3, 5422 <usb_dc_ep_disable+0x26>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    540a:	f7ff fa63 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    540e:	4604      	mov	r4, r0
    5410:	b150      	cbz	r0, 5428 <usb_dc_ep_disable+0x2c>
		return -EINVAL;
	}

	if (!ep_ctx->cfg.en) {
    5412:	7a03      	ldrb	r3, [r0, #8]
    5414:	b15b      	cbz	r3, 542e <usb_dc_ep_disable+0x32>
		return -EALREADY;
	}

	LOG_DBG("EP disable: 0x%02x", ep);

	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
    5416:	4608      	mov	r0, r1
    5418:	f00b feaa 	bl	11170 <nrfx_usbd_ep_disable>
	ep_ctx->cfg.en = false;
    541c:	2000      	movs	r0, #0
    541e:	7220      	strb	r0, [r4, #8]

	return 0;
}
    5420:	bd10      	pop	{r4, pc}
		return -ENODEV;
    5422:	f06f 0012 	mvn.w	r0, #18
    5426:	e7fb      	b.n	5420 <usb_dc_ep_disable+0x24>
		return -EINVAL;
    5428:	f06f 0015 	mvn.w	r0, #21
    542c:	e7f8      	b.n	5420 <usb_dc_ep_disable+0x24>
		return -EALREADY;
    542e:	f06f 0044 	mvn.w	r0, #68	; 0x44
    5432:	e7f5      	b.n	5420 <usb_dc_ep_disable+0x24>
    5434:	20002710 	.word	0x20002710

00005438 <usb_dc_ep_write>:
	return 0;
}

int usb_dc_ep_write(const u8_t ep, const u8_t *const data,
		    const u32_t data_len, u32_t *const ret_bytes)
{
    5438:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	return get_usbd_ctx()->attached;
    543c:	f8df 8104 	ldr.w	r8, [pc, #260]	; 5544 <usb_dc_ep_write+0x10c>
{
    5440:	461f      	mov	r7, r3
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();
	struct nrf_usbd_ep_ctx *ep_ctx;
	u32_t bytes_to_copy;
	int result = 0;

	if (!dev_attached() || !dev_ready()) {
    5442:	f898 3004 	ldrb.w	r3, [r8, #4]
{
    5446:	4606      	mov	r6, r0
    5448:	4689      	mov	r9, r1
    544a:	4614      	mov	r4, r2
	if (!dev_attached() || !dev_ready()) {
    544c:	2b00      	cmp	r3, #0
    544e:	d06a      	beq.n	5526 <usb_dc_ep_write+0xee>
    5450:	f898 3005 	ldrb.w	r3, [r8, #5]
    5454:	2b00      	cmp	r3, #0
    5456:	d066      	beq.n	5526 <usb_dc_ep_write+0xee>
		return -ENODEV;
	}

	if (NRF_USBD_EPOUT_CHECK(ep)) {
    5458:	0603      	lsls	r3, r0, #24
    545a:	d513      	bpl.n	5484 <usb_dc_ep_write+0x4c>
		return -EINVAL;
	}

	ep_ctx = endpoint_ctx(ep);
    545c:	f7ff fa3a 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    5460:	4605      	mov	r5, r0
    5462:	b178      	cbz	r0, 5484 <usb_dc_ep_write+0x4c>
		return -EINVAL;
	}

	if (!ep_ctx->cfg.en) {
    5464:	f890 a008 	ldrb.w	sl, [r0, #8]
    5468:	f1ba 0f00 	cmp.w	sl, #0
    546c:	d10d      	bne.n	548a <usb_dc_ep_write+0x52>
    546e:	4a2f      	ldr	r2, [pc, #188]	; (552c <usb_dc_ep_write+0xf4>)
    5470:	4b2f      	ldr	r3, [pc, #188]	; (5530 <usb_dc_ep_write+0xf8>)
		LOG_ERR("Endpoint 0x%02x is not enabled", ep);
    5472:	4830      	ldr	r0, [pc, #192]	; (5534 <usb_dc_ep_write+0xfc>)
    5474:	1ad2      	subs	r2, r2, r3
    5476:	08d2      	lsrs	r2, r2, #3
    5478:	0192      	lsls	r2, r2, #6
    547a:	f042 0201 	orr.w	r2, r2, #1
    547e:	4631      	mov	r1, r6
    5480:	f00f fef0 	bl	15264 <log_1>
		return -EINVAL;
    5484:	f06f 0415 	mvn.w	r4, #21
    5488:	e00e      	b.n	54a8 <usb_dc_ep_write+0x70>
		return -EINVAL;
	}

	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    548a:	f108 0014 	add.w	r0, r8, #20
    548e:	f010 fcb9 	bl	15e04 <k_mutex_lock.constprop.0>

	/* USBD driver does not allow scheduling multiple DMA transfers
	 * for one EP at a time. Next USB transfer on this endpoint can be
	 * triggered after the completion of previous one.
	 */
	if (ep_ctx->write_in_progress) {
    5492:	f895 2022 	ldrb.w	r2, [r5, #34]	; 0x22
    5496:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    549a:	b14a      	cbz	r2, 54b0 <usb_dc_ep_write+0x78>
		k_mutex_unlock(&ctx->drv_lock);
    549c:	f108 0014 	add.w	r0, r8, #20
    54a0:	f010 fcae 	bl	15e00 <k_mutex_unlock>
		return -EAGAIN;
    54a4:	f06f 040a 	mvn.w	r4, #10
		LOG_ERR("nRF USBD write error: %d", (u32_t)err);
	}

	k_mutex_unlock(&ctx->drv_lock);
	return result;
}
    54a8:	4620      	mov	r0, r4
    54aa:	b004      	add	sp, #16
    54ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (data_len > ep_ctx->cfg.max_sz) {
    54b0:	686a      	ldr	r2, [r5, #4]
	memcpy(ep_ctx->buf.data, data, bytes_to_copy);
    54b2:	69a8      	ldr	r0, [r5, #24]
	if (data_len > ep_ctx->cfg.max_sz) {
    54b4:	4294      	cmp	r4, r2
    54b6:	bf84      	itt	hi
    54b8:	4614      	movhi	r4, r2
		ep_ctx->write_fragmented = true;
    54ba:	4653      	movhi	r3, sl
    54bc:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	memcpy(ep_ctx->buf.data, data, bytes_to_copy);
    54c0:	4622      	mov	r2, r4
    54c2:	4649      	mov	r1, r9
    54c4:	f010 fdb9 	bl	1603a <memcpy>
	ep_ctx->buf.len = bytes_to_copy;
    54c8:	60ec      	str	r4, [r5, #12]
	if (ret_bytes) {
    54ca:	b107      	cbz	r7, 54ce <usb_dc_ep_write+0x96>
		*ret_bytes = bytes_to_copy;
    54cc:	603c      	str	r4, [r7, #0]
	if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
    54ce:	7aac      	ldrb	r4, [r5, #10]
    54d0:	b94c      	cbnz	r4, 54e6 <usb_dc_ep_write+0xae>
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
    54d2:	f00b fc0b 	bl	10cec <nrfx_usbd_last_setup_dir_get>
    54d6:	4286      	cmp	r6, r0
    54d8:	d005      	beq.n	54e6 <usb_dc_ep_write+0xae>
		nrfx_usbd_setup_clear();
    54da:	f00b fbf7 	bl	10ccc <nrfx_usbd_setup_clear>
	k_mutex_unlock(&ctx->drv_lock);
    54de:	4816      	ldr	r0, [pc, #88]	; (5538 <usb_dc_ep_write+0x100>)
    54e0:	f010 fc8e 	bl	15e00 <k_mutex_unlock>
	return result;
    54e4:	e7e0      	b.n	54a8 <usb_dc_ep_write+0x70>
	ep_ctx->write_in_progress = true;
    54e6:	2301      	movs	r3, #1
    54e8:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	NRFX_USBD_TRANSFER_IN(transfer, ep_ctx->buf.data, ep_ctx->buf.len, 0);
    54ec:	69ab      	ldr	r3, [r5, #24]
    54ee:	9301      	str	r3, [sp, #4]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    54f0:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_IN(transfer, ep_ctx->buf.data, ep_ctx->buf.len, 0);
    54f2:	68eb      	ldr	r3, [r5, #12]
    54f4:	9302      	str	r3, [sp, #8]
    54f6:	2400      	movs	r4, #0
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    54f8:	4630      	mov	r0, r6
	NRFX_USBD_TRANSFER_IN(transfer, ep_ctx->buf.data, ep_ctx->buf.len, 0);
    54fa:	9403      	str	r4, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    54fc:	f00b f95c 	bl	107b8 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
    5500:	4b0e      	ldr	r3, [pc, #56]	; (553c <usb_dc_ep_write+0x104>)
    5502:	4298      	cmp	r0, r3
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    5504:	4601      	mov	r1, r0
	if (err != NRFX_SUCCESS) {
    5506:	d0ea      	beq.n	54de <usb_dc_ep_write+0xa6>
    5508:	4b09      	ldr	r3, [pc, #36]	; (5530 <usb_dc_ep_write+0xf8>)
    550a:	4a08      	ldr	r2, [pc, #32]	; (552c <usb_dc_ep_write+0xf4>)
		ep_ctx->write_in_progress = false;
    550c:	f885 4022 	strb.w	r4, [r5, #34]	; 0x22
    5510:	1ad2      	subs	r2, r2, r3
    5512:	08d2      	lsrs	r2, r2, #3
		LOG_ERR("nRF USBD write error: %d", (u32_t)err);
    5514:	0192      	lsls	r2, r2, #6
    5516:	480a      	ldr	r0, [pc, #40]	; (5540 <usb_dc_ep_write+0x108>)
    5518:	f042 0201 	orr.w	r2, r2, #1
    551c:	f00f fea2 	bl	15264 <log_1>
		result = -EIO;
    5520:	f06f 0404 	mvn.w	r4, #4
    5524:	e7db      	b.n	54de <usb_dc_ep_write+0xa6>
		return -ENODEV;
    5526:	f06f 0412 	mvn.w	r4, #18
    552a:	e7bd      	b.n	54a8 <usb_dc_ep_write+0x70>
    552c:	0001967c 	.word	0x0001967c
    5530:	0001956c 	.word	0x0001956c
    5534:	0001a8fd 	.word	0x0001a8fd
    5538:	20002724 	.word	0x20002724
    553c:	0bad0000 	.word	0x0bad0000
    5540:	0001a91c 	.word	0x0001a91c
    5544:	20002710 	.word	0x20002710

00005548 <usb_dc_ep_read_wait>:

int usb_dc_ep_read_wait(u8_t ep, u8_t *data, u32_t max_data_len,
			u32_t *read_bytes)
{
    5548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    554c:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
    554e:	4b25      	ldr	r3, [pc, #148]	; (55e4 <usb_dc_ep_read_wait+0x9c>)
{
    5550:	4690      	mov	r8, r2
	struct nrf_usbd_ep_ctx *ep_ctx;
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();
	u32_t bytes_to_copy;

	if (!dev_attached() || !dev_ready()) {
    5552:	791a      	ldrb	r2, [r3, #4]
{
    5554:	4607      	mov	r7, r0
    5556:	460e      	mov	r6, r1
	if (!dev_attached() || !dev_ready()) {
    5558:	2a00      	cmp	r2, #0
    555a:	d040      	beq.n	55de <usb_dc_ep_read_wait+0x96>
    555c:	795b      	ldrb	r3, [r3, #5]
    555e:	2b00      	cmp	r3, #0
    5560:	d03d      	beq.n	55de <usb_dc_ep_read_wait+0x96>
		return -ENODEV;
	}

	if (NRF_USBD_EPIN_CHECK(ep)) {
    5562:	0603      	lsls	r3, r0, #24
    5564:	d415      	bmi.n	5592 <usb_dc_ep_read_wait+0x4a>
		return -EINVAL;
	}

	if (!data && max_data_len) {
    5566:	b911      	cbnz	r1, 556e <usb_dc_ep_read_wait+0x26>
    5568:	f1b8 0f00 	cmp.w	r8, #0
    556c:	d111      	bne.n	5592 <usb_dc_ep_read_wait+0x4a>
		return -EINVAL;
	}

	ep_ctx = endpoint_ctx(ep);
    556e:	4638      	mov	r0, r7
    5570:	f7ff f9b0 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    5574:	4604      	mov	r4, r0
    5576:	b160      	cbz	r0, 5592 <usb_dc_ep_read_wait+0x4a>
		return -EINVAL;
	}

	if (!ep_ctx->cfg.en) {
    5578:	7a03      	ldrb	r3, [r0, #8]
    557a:	b96b      	cbnz	r3, 5598 <usb_dc_ep_read_wait+0x50>
    557c:	4a1a      	ldr	r2, [pc, #104]	; (55e8 <usb_dc_ep_read_wait+0xa0>)
    557e:	4b1b      	ldr	r3, [pc, #108]	; (55ec <usb_dc_ep_read_wait+0xa4>)
		LOG_ERR("Endpoint 0x%02x is not enabled", ep);
    5580:	481b      	ldr	r0, [pc, #108]	; (55f0 <usb_dc_ep_read_wait+0xa8>)
    5582:	1ad2      	subs	r2, r2, r3
    5584:	08d2      	lsrs	r2, r2, #3
    5586:	0192      	lsls	r2, r2, #6
    5588:	f042 0201 	orr.w	r2, r2, #1
    558c:	4639      	mov	r1, r7
    558e:	f00f fe69 	bl	15264 <log_1>
		return -EINVAL;
    5592:	f06f 0015 	mvn.w	r0, #21
    5596:	e011      	b.n	55bc <usb_dc_ep_read_wait+0x74>
		return -EINVAL;
	}

	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    5598:	4816      	ldr	r0, [pc, #88]	; (55f4 <usb_dc_ep_read_wait+0xac>)
    559a:	f010 fc33 	bl	15e04 <k_mutex_lock.constprop.0>

	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
    559e:	68e3      	ldr	r3, [r4, #12]
    55a0:	4543      	cmp	r3, r8
    55a2:	461f      	mov	r7, r3
    55a4:	bf28      	it	cs
    55a6:	4647      	movcs	r7, r8

	if (!data && !max_data_len) {
    55a8:	b956      	cbnz	r6, 55c0 <usb_dc_ep_read_wait+0x78>
    55aa:	f1b8 0f00 	cmp.w	r8, #0
    55ae:	d107      	bne.n	55c0 <usb_dc_ep_read_wait+0x78>
		if (read_bytes) {
    55b0:	b105      	cbz	r5, 55b4 <usb_dc_ep_read_wait+0x6c>
			*read_bytes = ep_ctx->buf.len;
    55b2:	602b      	str	r3, [r5, #0]
		}
		k_mutex_unlock(&ctx->drv_lock);
    55b4:	480f      	ldr	r0, [pc, #60]	; (55f4 <usb_dc_ep_read_wait+0xac>)
    55b6:	f010 fc23 	bl	15e00 <k_mutex_unlock>
		return 0;
    55ba:	2000      	movs	r0, #0
		*read_bytes = bytes_to_copy;
	}

	k_mutex_unlock(&ctx->drv_lock);
	return 0;
}
    55bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
    55c0:	69e1      	ldr	r1, [r4, #28]
    55c2:	463a      	mov	r2, r7
    55c4:	4630      	mov	r0, r6
    55c6:	f010 fd38 	bl	1603a <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
    55ca:	69e3      	ldr	r3, [r4, #28]
    55cc:	443b      	add	r3, r7
    55ce:	61e3      	str	r3, [r4, #28]
	ep_ctx->buf.len -= bytes_to_copy;
    55d0:	68e3      	ldr	r3, [r4, #12]
    55d2:	1bdb      	subs	r3, r3, r7
    55d4:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
    55d6:	2d00      	cmp	r5, #0
    55d8:	d0ec      	beq.n	55b4 <usb_dc_ep_read_wait+0x6c>
		*read_bytes = bytes_to_copy;
    55da:	602f      	str	r7, [r5, #0]
    55dc:	e7ea      	b.n	55b4 <usb_dc_ep_read_wait+0x6c>
		return -ENODEV;
    55de:	f06f 0012 	mvn.w	r0, #18
    55e2:	e7eb      	b.n	55bc <usb_dc_ep_read_wait+0x74>
    55e4:	20002710 	.word	0x20002710
    55e8:	0001967c 	.word	0x0001967c
    55ec:	0001956c 	.word	0x0001956c
    55f0:	0001a8fd 	.word	0x0001a8fd
    55f4:	20002724 	.word	0x20002724

000055f8 <usb_dc_ep_read_continue>:

int usb_dc_ep_read_continue(u8_t ep)
{
    55f8:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    55fa:	4d1f      	ldr	r5, [pc, #124]	; (5678 <usb_dc_ep_read_continue+0x80>)
	struct nrf_usbd_ep_ctx *ep_ctx;
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();

	if (!dev_attached() || !dev_ready()) {
    55fc:	792b      	ldrb	r3, [r5, #4]
{
    55fe:	4601      	mov	r1, r0
	if (!dev_attached() || !dev_ready()) {
    5600:	b39b      	cbz	r3, 566a <usb_dc_ep_read_continue+0x72>
    5602:	796b      	ldrb	r3, [r5, #5]
    5604:	b38b      	cbz	r3, 566a <usb_dc_ep_read_continue+0x72>
		return -ENODEV;
	}

	if (NRF_USBD_EPIN_CHECK(ep)) {
    5606:	0603      	lsls	r3, r0, #24
    5608:	d40f      	bmi.n	562a <usb_dc_ep_read_continue+0x32>
		return -EINVAL;
	}

	ep_ctx = endpoint_ctx(ep);
    560a:	f7ff f963 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    560e:	4604      	mov	r4, r0
    5610:	b158      	cbz	r0, 562a <usb_dc_ep_read_continue+0x32>
		return -EINVAL;
	}

	if (!ep_ctx->cfg.en) {
    5612:	7a03      	ldrb	r3, [r0, #8]
    5614:	b963      	cbnz	r3, 5630 <usb_dc_ep_read_continue+0x38>
    5616:	4a19      	ldr	r2, [pc, #100]	; (567c <usb_dc_ep_read_continue+0x84>)
    5618:	4b19      	ldr	r3, [pc, #100]	; (5680 <usb_dc_ep_read_continue+0x88>)
		LOG_ERR("Endpoint 0x%02x is not enabled", ep);
    561a:	481a      	ldr	r0, [pc, #104]	; (5684 <usb_dc_ep_read_continue+0x8c>)
    561c:	1ad2      	subs	r2, r2, r3
    561e:	08d2      	lsrs	r2, r2, #3
    5620:	0192      	lsls	r2, r2, #6
    5622:	f042 0201 	orr.w	r2, r2, #1
    5626:	f00f fe1d 	bl	15264 <log_1>
		return -EINVAL;
    562a:	f06f 0015 	mvn.w	r0, #21
    562e:	e01b      	b.n	5668 <usb_dc_ep_read_continue+0x70>
		return -EINVAL;
	}

	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    5630:	f105 0014 	add.w	r0, r5, #20
    5634:	f010 fbe6 	bl	15e04 <k_mutex_lock.constprop.0>
	if (!ep_ctx->buf.len) {
    5638:	68e3      	ldr	r3, [r4, #12]
    563a:	b98b      	cbnz	r3, 5660 <usb_dc_ep_read_continue+0x68>
		ep_ctx->buf.curr = ep_ctx->buf.data;
		ep_ctx->read_complete = true;
    563c:	2501      	movs	r5, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
    563e:	69a3      	ldr	r3, [r4, #24]
		ep_ctx->read_complete = true;
    5640:	f884 5020 	strb.w	r5, [r4, #32]
		ep_ctx->buf.curr = ep_ctx->buf.data;
    5644:	61e3      	str	r3, [r4, #28]

		if (ep_ctx->read_pending) {
    5646:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    564a:	b14b      	cbz	r3, 5660 <usb_dc_ep_read_continue+0x68>
			struct usbd_event *ev = usbd_evt_alloc();
    564c:	f7ff f9de 	bl	4a0c <usbd_evt_alloc>

			if (!ev) {
    5650:	b170      	cbz	r0, 5670 <usb_dc_ep_read_continue+0x78>
				return -ENOMEM;
			}

			ev->evt_type = USBD_EVT_EP;
    5652:	7505      	strb	r5, [r0, #20]
			ev->evt.ep_evt.ep = ep_ctx;
    5654:	60c4      	str	r4, [r0, #12]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    5656:	7405      	strb	r5, [r0, #16]
			usbd_evt_put(ev);
    5658:	f7ff f936 	bl	48c8 <usbd_evt_put>
			usbd_work_schedule();
    565c:	f7ff f9b0 	bl	49c0 <usbd_work_schedule>
		}
	}
	k_mutex_unlock(&ctx->drv_lock);
    5660:	4809      	ldr	r0, [pc, #36]	; (5688 <usb_dc_ep_read_continue+0x90>)
    5662:	f010 fbcd 	bl	15e00 <k_mutex_unlock>

	return 0;
    5666:	2000      	movs	r0, #0
}
    5668:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    566a:	f06f 0012 	mvn.w	r0, #18
    566e:	e7fb      	b.n	5668 <usb_dc_ep_read_continue+0x70>
				return -ENOMEM;
    5670:	f06f 000b 	mvn.w	r0, #11
    5674:	e7f8      	b.n	5668 <usb_dc_ep_read_continue+0x70>
    5676:	bf00      	nop
    5678:	20002710 	.word	0x20002710
    567c:	0001967c 	.word	0x0001967c
    5680:	0001956c 	.word	0x0001956c
    5684:	0001a8fd 	.word	0x0001a8fd
    5688:	20002724 	.word	0x20002724

0000568c <usb_dc_ep_set_callback>:
	ret = usb_dc_ep_read_continue(ep);
	return ret;
}

int usb_dc_ep_set_callback(const u8_t ep, const usb_dc_ep_callback cb)
{
    568c:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
    568e:	4b07      	ldr	r3, [pc, #28]	; (56ac <usb_dc_ep_set_callback+0x20>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    5690:	791b      	ldrb	r3, [r3, #4]
    5692:	b12b      	cbz	r3, 56a0 <usb_dc_ep_set_callback+0x14>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    5694:	f7ff f91e 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    5698:	b128      	cbz	r0, 56a6 <usb_dc_ep_set_callback+0x1a>
		return -EINVAL;
	}

	ep_ctx->cfg.cb = cb;
    569a:	6001      	str	r1, [r0, #0]

	return 0;
    569c:	2000      	movs	r0, #0
}
    569e:	bd08      	pop	{r3, pc}
		return -ENODEV;
    56a0:	f06f 0012 	mvn.w	r0, #18
    56a4:	e7fb      	b.n	569e <usb_dc_ep_set_callback+0x12>
		return -EINVAL;
    56a6:	f06f 0015 	mvn.w	r0, #21
    56aa:	e7f8      	b.n	569e <usb_dc_ep_set_callback+0x12>
    56ac:	20002710 	.word	0x20002710

000056b0 <usb_dc_set_status_callback>:

void usb_dc_set_status_callback(const usb_dc_status_callback cb)
{
	get_usbd_ctx()->status_cb = cb;
    56b0:	4b01      	ldr	r3, [pc, #4]	; (56b8 <usb_dc_set_status_callback+0x8>)
    56b2:	6018      	str	r0, [r3, #0]
}
    56b4:	4770      	bx	lr
    56b6:	bf00      	nop
    56b8:	20002710 	.word	0x20002710

000056bc <usb_dc_ep_mps>:

int usb_dc_ep_mps(const u8_t ep)
{
    56bc:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
    56be:	4b07      	ldr	r3, [pc, #28]	; (56dc <usb_dc_ep_mps+0x20>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    56c0:	791b      	ldrb	r3, [r3, #4]
    56c2:	b123      	cbz	r3, 56ce <usb_dc_ep_mps+0x12>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    56c4:	f7ff f906 	bl	48d4 <endpoint_ctx>
	if (!ep_ctx) {
    56c8:	b120      	cbz	r0, 56d4 <usb_dc_ep_mps+0x18>
		return -EINVAL;
	}

	return ep_ctx->cfg.max_sz;
    56ca:	6840      	ldr	r0, [r0, #4]
}
    56cc:	bd08      	pop	{r3, pc}
		return -ENODEV;
    56ce:	f06f 0012 	mvn.w	r0, #18
    56d2:	e7fb      	b.n	56cc <usb_dc_ep_mps+0x10>
		return -EINVAL;
    56d4:	f06f 0015 	mvn.w	r0, #21
    56d8:	e7f8      	b.n	56cc <usb_dc_ep_mps+0x10>
    56da:	bf00      	nop
    56dc:	20002710 	.word	0x20002710

000056e0 <handle_next_tick_case>:
 * counter progresses during that time it means that 1 tick elapsed and
 * interrupt is set pending.
 */
static void handle_next_tick_case(u32_t t)
{
	set_comparator(t + 2);
    56e0:	1c82      	adds	r2, r0, #2

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    56e2:	4b08      	ldr	r3, [pc, #32]	; (5704 <handle_next_tick_case+0x24>)
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    56e4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    56e8:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    56ec:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	while (t != counter()) {
    56f0:	4290      	cmp	r0, r2
    56f2:	d100      	bne.n	56f6 <handle_next_tick_case+0x16>
		 * generated. Trigger interrupt.
		 */
		t = counter();
		set_comparator(t + 2);
	}
}
    56f4:	4770      	bx	lr
    56f6:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		set_comparator(t + 2);
    56fa:	1c82      	adds	r2, r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    56fc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    5700:	e7f2      	b.n	56e8 <handle_next_tick_case+0x8>
    5702:	bf00      	nop
    5704:	40011000 	.word	0x40011000

00005708 <event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    5708:	4b04      	ldr	r3, [pc, #16]	; (571c <event_clear+0x14>)
    570a:	2200      	movs	r2, #0
{
    570c:	b082      	sub	sp, #8
    570e:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    5710:	681b      	ldr	r3, [r3, #0]
    5712:	9301      	str	r3, [sp, #4]
    (void)dummy;
    5714:	9b01      	ldr	r3, [sp, #4]
}
    5716:	b002      	add	sp, #8
    5718:	4770      	bx	lr
    571a:	bf00      	nop
    571c:	40011140 	.word	0x40011140

00005720 <rtc1_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
    5720:	b508      	push	{r3, lr}
	ARG_UNUSED(arg);
	event_clear();
    5722:	f7ff fff1 	bl	5708 <event_clear>
    return p_reg->CC[ch];
    5726:	4b07      	ldr	r3, [pc, #28]	; (5744 <rtc1_nrf_isr+0x24>)

	u32_t t = get_comparator();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    5728:	4a07      	ldr	r2, [pc, #28]	; (5748 <rtc1_nrf_isr+0x28>)
    572a:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
    572e:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    5730:	1ac0      	subs	r0, r0, r3
    5732:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    5736:	4403      	add	r3, r0
    5738:	6013      	str	r3, [r2, #0]
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
    573a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    573e:	f00e bf87 	b.w	14650 <z_clock_announce>
    5742:	bf00      	nop
    5744:	40011000 	.word	0x40011000
    5748:	20002a48 	.word	0x20002a48

0000574c <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
    574c:	b538      	push	{r3, r4, r5, lr}
    574e:	4814      	ldr	r0, [pc, #80]	; (57a0 <z_clock_driver_init+0x54>)
    5750:	f00d ff8c 	bl	1366c <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
    5754:	b300      	cbz	r0, 5798 <z_clock_driver_init+0x4c>
	return api->on(dev, sys);
    5756:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    5758:	4d12      	ldr	r5, [pc, #72]	; (57a4 <z_clock_driver_init+0x58>)
    575a:	681b      	ldr	r3, [r3, #0]
    575c:	2101      	movs	r1, #1
    575e:	2400      	movs	r4, #0
    5760:	4798      	blx	r3
    5762:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508

	clock_control_on(clock, CLOCK_CONTROL_NRF_SUBSYS_LF);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	event_clear();
    5766:	f7ff ffcf 	bl	5708 <event_clear>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    576a:	4b0f      	ldr	r3, [pc, #60]	; (57a8 <z_clock_driver_init+0x5c>)
    576c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    5770:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    p_reg->INTENSET = mask;
    5774:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    5778:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
	NVIC_ClearPendingIRQ(RTC1_IRQn);
	int_enable();

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    577c:	4622      	mov	r2, r4
    577e:	2101      	movs	r1, #1
    5780:	2011      	movs	r0, #17
    5782:	f000 f9db 	bl	5b3c <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    5786:	2011      	movs	r0, #17
    5788:	f000 f9a6 	bl	5ad8 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    578c:	4a07      	ldr	r2, [pc, #28]	; (57ac <z_clock_driver_init+0x60>)
    578e:	2301      	movs	r3, #1
    5790:	6013      	str	r3, [r2, #0]

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    5792:	4620      	mov	r0, r4
    5794:	602b      	str	r3, [r5, #0]
}
    5796:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    5798:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    579c:	e7fb      	b.n	5796 <z_clock_driver_init+0x4a>
    579e:	bf00      	nop
    57a0:	0001a699 	.word	0x0001a699
    57a4:	40011000 	.word	0x40011000
    57a8:	e000e100 	.word	0xe000e100
    57ac:	40011008 	.word	0x40011008

000057b0 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    57b0:	b570      	push	{r4, r5, r6, lr}
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	u32_t unannounced = counter_sub(counter(), last_count);
    57b2:	4b28      	ldr	r3, [pc, #160]	; (5854 <z_clock_set_timeout+0xa4>)
     return p_reg->COUNTER;
    57b4:	4c28      	ldr	r4, [pc, #160]	; (5858 <z_clock_set_timeout+0xa8>)
    57b6:	6819      	ldr	r1, [r3, #0]
    57b8:	f8d4 2504 	ldr.w	r2, [r4, #1284]	; 0x504
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    57bc:	4d27      	ldr	r5, [pc, #156]	; (585c <z_clock_set_timeout+0xac>)
	return (a - b) & COUNTER_MAX;
    57be:	1a52      	subs	r2, r2, r1
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    57c0:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    57c4:	bf08      	it	eq
    57c6:	4628      	moveq	r0, r5
	return (a - b) & COUNTER_MAX;
    57c8:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    57cc:	0212      	lsls	r2, r2, #8
    57ce:	d42f      	bmi.n	5830 <z_clock_set_timeout+0x80>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    57d0:	3801      	subs	r0, #1
    57d2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    57d6:	42a8      	cmp	r0, r5
    57d8:	bfa8      	it	ge
    57da:	4628      	movge	r0, r5
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    57dc:	3301      	adds	r3, #1
    p_reg->INTENCLR = mask;
    57de:	f44f 3680 	mov.w	r6, #65536	; 0x10000
    57e2:	4418      	add	r0, r3
    57e4:	f8c4 6308 	str.w	r6, [r4, #776]	; 0x308
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    57e8:	42a8      	cmp	r0, r5
    57ea:	bf94      	ite	ls
    57ec:	180d      	addls	r5, r1, r0
    57ee:	194d      	addhi	r5, r1, r5
     return p_reg->COUNTER;
    57f0:	f8d4 0504 	ldr.w	r0, [r4, #1284]	; 0x504
    return p_reg->CC[ch];
    57f4:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
	event_clear();
    57f8:	f7ff ff86 	bl	5708 <event_clear>
	return (a - b) & COUNTER_MAX;
    57fc:	1a09      	subs	r1, r1, r0
    57fe:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    5802:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	if (counter_sub(prev_val, now) == 1) {
    5806:	2901      	cmp	r1, #1
    p_reg->CC[ch] = cc_val;
    5808:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    580c:	f8c4 6344 	str.w	r6, [r4, #836]	; 0x344
    5810:	d104      	bne.n	581c <z_clock_set_timeout+0x6c>
	z_impl_k_busy_wait(usec_to_wait);
    5812:	200f      	movs	r0, #15
    5814:	f013 fb8f 	bl	18f36 <z_impl_k_busy_wait>
		event_clear();
    5818:	f7ff ff76 	bl	5708 <event_clear>
     return p_reg->COUNTER;
    581c:	f8d4 0504 	ldr.w	r0, [r4, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    5820:	1a2b      	subs	r3, r5, r0
    5822:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (diff == 1) {
    5826:	2b01      	cmp	r3, #1
    5828:	d104      	bne.n	5834 <z_clock_set_timeout+0x84>
		handle_next_tick_case(t);
    582a:	f7ff ff59 	bl	56e0 <handle_next_tick_case>
    582e:	e00b      	b.n	5848 <z_clock_set_timeout+0x98>
		ticks = 0;
    5830:	2000      	movs	r0, #0
    5832:	e7d3      	b.n	57dc <z_clock_set_timeout+0x2c>
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    5834:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    5838:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
     return p_reg->COUNTER;
    583c:	f8d4 0504 	ldr.w	r0, [r4, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    5840:	1a2d      	subs	r5, r5, r0
    5842:	3d02      	subs	r5, #2
	if (diff > MAX_TICKS) {
    5844:	022b      	lsls	r3, r5, #8
    5846:	d4f0      	bmi.n	582a <z_clock_set_timeout+0x7a>
    p_reg->INTENSET = mask;
    5848:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    584c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
	set_protected_absolute_ticks(cyc);
}
    5850:	bd70      	pop	{r4, r5, r6, pc}
    5852:	bf00      	nop
    5854:	20002a48 	.word	0x20002a48
    5858:	40011000 	.word	0x40011000
    585c:	007fffff 	.word	0x007fffff

00005860 <z_clock_elapsed>:
	__asm__ volatile(
    5860:	f04f 0220 	mov.w	r2, #32
    5864:	f3ef 8311 	mrs	r3, BASEPRI
    5868:	f382 8811 	msr	BASEPRI, r2
    586c:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    5870:	4a06      	ldr	r2, [pc, #24]	; (588c <z_clock_elapsed+0x2c>)
    5872:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    5876:	4a06      	ldr	r2, [pc, #24]	; (5890 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    5878:	6812      	ldr	r2, [r2, #0]
    587a:	1a80      	subs	r0, r0, r2
    587c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    5880:	f383 8811 	msr	BASEPRI, r3
    5884:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    5888:	4770      	bx	lr
    588a:	bf00      	nop
    588c:	40011000 	.word	0x40011000
    5890:	20002a48 	.word	0x20002a48

00005894 <z_timer_cycle_get_32>:
	__asm__ volatile(
    5894:	f04f 0320 	mov.w	r3, #32
    5898:	f3ef 8211 	mrs	r2, BASEPRI
    589c:	f383 8811 	msr	BASEPRI, r3
    58a0:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    58a4:	4906      	ldr	r1, [pc, #24]	; (58c0 <z_timer_cycle_get_32+0x2c>)
    58a6:	4b07      	ldr	r3, [pc, #28]	; (58c4 <z_timer_cycle_get_32+0x30>)
    58a8:	6808      	ldr	r0, [r1, #0]
    58aa:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    58ae:	f382 8811 	msr	BASEPRI, r2
    58b2:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    58b6:	1a1b      	subs	r3, r3, r0
    58b8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    58bc:	4418      	add	r0, r3
    58be:	4770      	bx	lr
    58c0:	20002a48 	.word	0x20002a48
    58c4:	40011000 	.word	0x40011000

000058c8 <_DoInit>:
*
*/
#define INIT()  do {                                            \
                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
                } while (0)
static void _DoInit(void) {
    58c8:	b510      	push	{r4, lr}
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    58ca:	4c11      	ldr	r4, [pc, #68]	; (5910 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    58cc:	4a11      	ldr	r2, [pc, #68]	; (5914 <_DoInit+0x4c>)
    58ce:	61a2      	str	r2, [r4, #24]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    58d0:	2303      	movs	r3, #3
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    58d2:	e9c4 3304 	strd	r3, r3, [r4, #16]
  p->aUp[0].pBuffer       = _acUpBuffer;
    58d6:	4b10      	ldr	r3, [pc, #64]	; (5918 <_DoInit+0x50>)
    58d8:	61e3      	str	r3, [r4, #28]
  p->aUp[0].WrOff         = 0u;
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    58da:	6622      	str	r2, [r4, #96]	; 0x60
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    58dc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  p->aDown[0].pBuffer       = _acDownBuffer;
    58e0:	4a0e      	ldr	r2, [pc, #56]	; (591c <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
    58e2:	490f      	ldr	r1, [pc, #60]	; (5920 <_DoInit+0x58>)
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    58e4:	6223      	str	r3, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
    58e6:	6662      	str	r2, [r4, #100]	; 0x64
  p->aUp[0].RdOff         = 0u;
    58e8:	2300      	movs	r3, #0
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    58ea:	2210      	movs	r2, #16
  strcpy(&p->acID[7], "RTT");
    58ec:	1de0      	adds	r0, r4, #7
  p->aUp[0].RdOff         = 0u;
    58ee:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    58f0:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    58f2:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    58f4:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    58f6:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    58f8:	6763      	str	r3, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    58fa:	66a2      	str	r2, [r4, #104]	; 0x68
  strcpy(&p->acID[7], "RTT");
    58fc:	f010 fb40 	bl	15f80 <strcpy>
  strcpy(&p->acID[0], "SEGGER");
    5900:	4908      	ldr	r1, [pc, #32]	; (5924 <_DoInit+0x5c>)
    5902:	4620      	mov	r0, r4
    5904:	f010 fb3c 	bl	15f80 <strcpy>
  p->acID[6] = ' ';
    5908:	2320      	movs	r3, #32
    590a:	71a3      	strb	r3, [r4, #6]
}
    590c:	bd10      	pop	{r4, pc}
    590e:	bf00      	nop
    5910:	20002a4c 	.word	0x20002a4c
    5914:	0001a948 	.word	0x0001a948
    5918:	20008271 	.word	0x20008271
    591c:	20008261 	.word	0x20008261
    5920:	0001a951 	.word	0x0001a951
    5924:	0001a955 	.word	0x0001a955

00005928 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    5928:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
    592c:	4f23      	ldr	r7, [pc, #140]	; (59bc <SEGGER_RTT_WriteSkipNoLock+0x94>)
    592e:	f04f 0b18 	mov.w	fp, #24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    5932:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
    5934:	fb0b 7200 	mla	r2, fp, r0, r7
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    5938:	4606      	mov	r6, r0
  RdOff = pRing->RdOff;
    593a:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    593c:	6a55      	ldr	r5, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    593e:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    5940:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    5942:	d834      	bhi.n	59ae <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    5944:	f8d2 a020 	ldr.w	sl, [r2, #32]
    5948:	ebaa 0905 	sub.w	r9, sl, r5
    594c:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
    5950:	4294      	cmp	r4, r2
    5952:	d811      	bhi.n	5978 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    5954:	f04f 0918 	mov.w	r9, #24
    5958:	fb06 9309 	mla	r3, r6, r9, r9
    595c:	443b      	add	r3, r7
    595e:	4622      	mov	r2, r4
    5960:	6858      	ldr	r0, [r3, #4]
    5962:	4641      	mov	r1, r8
    5964:	4428      	add	r0, r5
    5966:	f010 fb68 	bl	1603a <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    596a:	fb09 7606 	mla	r6, r9, r6, r7
    596e:	442c      	add	r4, r5
      // Therefore, check if 2nd memcpy is necessary at all
      //
      if (NumBytes) {
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
      }
      pRing->WrOff = NumBytes;
    5970:	6274      	str	r4, [r6, #36]	; 0x24
      return 1;
    5972:	2001      	movs	r0, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
    5974:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
    5978:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    597a:	429c      	cmp	r4, r3
    597c:	d81b      	bhi.n	59b6 <SEGGER_RTT_WriteSkipNoLock+0x8e>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
    597e:	fb00 bb0b 	mla	fp, r0, fp, fp
    5982:	44bb      	add	fp, r7
    5984:	464a      	mov	r2, r9
    5986:	f8db 0004 	ldr.w	r0, [fp, #4]
    598a:	442c      	add	r4, r5
    598c:	4428      	add	r0, r5
    598e:	f010 fb54 	bl	1603a <memcpy>
      if (NumBytes) {
    5992:	ebb4 040a 	subs.w	r4, r4, sl
    5996:	d006      	beq.n	59a6 <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
    5998:	f8db 0004 	ldr.w	r0, [fp, #4]
    599c:	4622      	mov	r2, r4
    599e:	eb08 0109 	add.w	r1, r8, r9
    59a2:	f010 fb4a 	bl	1603a <memcpy>
      pRing->WrOff = NumBytes;
    59a6:	2018      	movs	r0, #24
    59a8:	fb00 7606 	mla	r6, r0, r6, r7
    59ac:	e7e0      	b.n	5970 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
    59ae:	3b01      	subs	r3, #1
    59b0:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    59b2:	42a3      	cmp	r3, r4
    59b4:	d2ce      	bcs.n	5954 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
    59b6:	2000      	movs	r0, #0
    59b8:	e7dc      	b.n	5974 <SEGGER_RTT_WriteSkipNoLock+0x4c>
    59ba:	bf00      	nop
    59bc:	20002a4c 	.word	0x20002a4c

000059c0 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    59c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  pData = (const char *)pBuffer;
  //
  // Get "to-host" ring buffer.
  //
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
    59c2:	4c18      	ldr	r4, [pc, #96]	; (5a24 <SEGGER_RTT_WriteNoLock+0x64>)
    59c4:	2318      	movs	r3, #24
    59c6:	fb00 3503 	mla	r5, r0, r3, r3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    59ca:	fb03 4000 	mla	r0, r3, r0, r4
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
    59ce:	4425      	add	r5, r4
  switch (pRing->Flags) {
    59d0:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    59d2:	2c01      	cmp	r4, #1
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    59d4:	460f      	mov	r7, r1
    59d6:	4616      	mov	r6, r2
  switch (pRing->Flags) {
    59d8:	d00f      	beq.n	59fa <SEGGER_RTT_WriteNoLock+0x3a>
    59da:	2c02      	cmp	r4, #2
    59dc:	d01a      	beq.n	5a14 <SEGGER_RTT_WriteNoLock+0x54>
    59de:	b9f4      	cbnz	r4, 5a1e <SEGGER_RTT_WriteNoLock+0x5e>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
    59e0:	4628      	mov	r0, r5
    59e2:	f010 fa5b 	bl	15e9c <_GetAvailWriteSpace>
    if (Avail < NumBytes) {
    59e6:	4286      	cmp	r6, r0
    59e8:	d805      	bhi.n	59f6 <SEGGER_RTT_WriteNoLock+0x36>
      Status = 0u;
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    59ea:	4632      	mov	r2, r6
    59ec:	4639      	mov	r1, r7
    59ee:	4628      	mov	r0, r5
    59f0:	f010 fa62 	bl	15eb8 <_WriteNoCheck>
    59f4:	4634      	mov	r4, r6
  }
  //
  // Finish up.
  //
  return Status;
}
    59f6:	4620      	mov	r0, r4
    59f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Avail = _GetAvailWriteSpace(pRing);
    59fa:	4628      	mov	r0, r5
    59fc:	f010 fa4e 	bl	15e9c <_GetAvailWriteSpace>
    Status = Avail < NumBytes ? Avail : NumBytes;
    5a00:	4286      	cmp	r6, r0
    5a02:	4634      	mov	r4, r6
    5a04:	bf28      	it	cs
    5a06:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
    5a08:	4622      	mov	r2, r4
    5a0a:	4639      	mov	r1, r7
    5a0c:	4628      	mov	r0, r5
    5a0e:	f010 fa53 	bl	15eb8 <_WriteNoCheck>
    break;
    5a12:	e7f0      	b.n	59f6 <SEGGER_RTT_WriteNoLock+0x36>
    Status = _WriteBlocking(pRing, pData, NumBytes);
    5a14:	4628      	mov	r0, r5
}
    5a16:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    Status = _WriteBlocking(pRing, pData, NumBytes);
    5a1a:	f010 ba69 	b.w	15ef0 <_WriteBlocking>
  switch (pRing->Flags) {
    5a1e:	2400      	movs	r4, #0
  return Status;
    5a20:	e7e9      	b.n	59f6 <SEGGER_RTT_WriteNoLock+0x36>
    5a22:	bf00      	nop
    5a24:	20002a4c 	.word	0x20002a4c

00005a28 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
    5a28:	4b03      	ldr	r3, [pc, #12]	; (5a38 <SEGGER_RTT_HasDataUp+0x10>)
    5a2a:	2218      	movs	r2, #24
    5a2c:	fb02 3300 	mla	r3, r2, r0, r3
    5a30:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
    5a32:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
    5a34:	1a80      	subs	r0, r0, r2
    5a36:	4770      	bx	lr
    5a38:	20002a4c 	.word	0x20002a4c

00005a3c <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    5a3c:	4a09      	ldr	r2, [pc, #36]	; (5a64 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    5a3e:	490a      	ldr	r1, [pc, #40]	; (5a68 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    5a40:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    5a42:	6809      	ldr	r1, [r1, #0]
    5a44:	6719      	str	r1, [r3, #112]	; 0x70

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    5a46:	4909      	ldr	r1, [pc, #36]	; (5a6c <arch_swap+0x30>)
	_current->arch.basepri = key;
    5a48:	66d8      	str	r0, [r3, #108]	; 0x6c
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    5a4a:	684b      	ldr	r3, [r1, #4]
    5a4c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    5a50:	604b      	str	r3, [r1, #4]
    5a52:	2300      	movs	r3, #0
    5a54:	f383 8811 	msr	BASEPRI, r3
    5a58:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    5a5c:	6893      	ldr	r3, [r2, #8]
}
    5a5e:	6f18      	ldr	r0, [r3, #112]	; 0x70
    5a60:	4770      	bx	lr
    5a62:	bf00      	nop
    5a64:	200040e8 	.word	0x200040e8
    5a68:	00019b40 	.word	0x00019b40
    5a6c:	e000ed00 	.word	0xe000ed00

00005a70 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    5a70:	490f      	ldr	r1, [pc, #60]	; (5ab0 <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
    5a72:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    5a74:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    5a78:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    5a7a:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    5a7e:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    5a82:	2020      	movs	r0, #32
    msr BASEPRI, r0
    5a84:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    5a88:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    5a8c:	4f09      	ldr	r7, [pc, #36]	; (5ab4 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    5a8e:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    5a92:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    5a94:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    5a96:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    5a98:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    movs r3, #0
    5a9a:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    5a9c:	66d3      	str	r3, [r2, #108]	; 0x6c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    5a9e:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    5aa2:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    5aa6:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    5aaa:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    5aae:	4770      	bx	lr
    ldr r1, =_kernel
    5ab0:	200040e8 	.word	0x200040e8
    ldr v4, =_SCS_ICSR
    5ab4:	e000ed04 	.word	0xe000ed04

00005ab8 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    5ab8:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    5abc:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    5abe:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    5ac2:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    5ac6:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    5ac8:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    5acc:	2902      	cmp	r1, #2
    beq _oops
    5ace:	d0ff      	beq.n	5ad0 <_oops>

00005ad0 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    5ad0:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    5ad2:	f010 fa41 	bl	15f58 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    5ad6:	bd01      	pop	{r0, pc}

00005ad8 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    5ad8:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    5ada:	2b00      	cmp	r3, #0
    5adc:	db08      	blt.n	5af0 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    5ade:	2201      	movs	r2, #1
    5ae0:	f000 001f 	and.w	r0, r0, #31
    5ae4:	fa02 f000 	lsl.w	r0, r2, r0
    5ae8:	095b      	lsrs	r3, r3, #5
    5aea:	4a02      	ldr	r2, [pc, #8]	; (5af4 <arch_irq_enable+0x1c>)
    5aec:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    5af0:	4770      	bx	lr
    5af2:	bf00      	nop
    5af4:	e000e100 	.word	0xe000e100

00005af8 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    5af8:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    5afa:	2b00      	cmp	r3, #0
    5afc:	db0d      	blt.n	5b1a <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    5afe:	2201      	movs	r2, #1
    5b00:	095b      	lsrs	r3, r3, #5
    5b02:	f000 001f 	and.w	r0, r0, #31
    5b06:	fa02 f000 	lsl.w	r0, r2, r0
    5b0a:	3320      	adds	r3, #32
    5b0c:	4a03      	ldr	r2, [pc, #12]	; (5b1c <arch_irq_disable+0x24>)
    5b0e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5b12:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    5b16:	f3bf 8f6f 	isb	sy
}
    5b1a:	4770      	bx	lr
    5b1c:	e000e100 	.word	0xe000e100

00005b20 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    5b20:	4b05      	ldr	r3, [pc, #20]	; (5b38 <arch_irq_is_enabled+0x18>)
    5b22:	0942      	lsrs	r2, r0, #5
    5b24:	f000 001f 	and.w	r0, r0, #31
    5b28:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    5b2c:	2301      	movs	r3, #1
    5b2e:	fa03 f000 	lsl.w	r0, r3, r0
}
    5b32:	4010      	ands	r0, r2
    5b34:	4770      	bx	lr
    5b36:	bf00      	nop
    5b38:	e000e100 	.word	0xe000e100

00005b3c <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    5b3c:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    5b3e:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    5b40:	bfa8      	it	ge
    5b42:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
    5b46:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    5b4a:	bfb8      	it	lt
    5b4c:	4b06      	ldrlt	r3, [pc, #24]	; (5b68 <z_arm_irq_priority_set+0x2c>)
    5b4e:	ea4f 1141 	mov.w	r1, r1, lsl #5
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    5b52:	bfac      	ite	ge
    5b54:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    5b58:	f000 000f 	andlt.w	r0, r0, #15
    5b5c:	b2c9      	uxtb	r1, r1
    5b5e:	bfb4      	ite	lt
    5b60:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    5b62:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
}
    5b66:	4770      	bx	lr
    5b68:	e000ed14 	.word	0xe000ed14

00005b6c <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
    5b6c:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    5b6e:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    5b70:	4b04      	ldr	r3, [pc, #16]	; (5b84 <_arch_isr_direct_pm+0x18>)
    5b72:	6a18      	ldr	r0, [r3, #32]
    5b74:	b118      	cbz	r0, 5b7e <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
    5b76:	2200      	movs	r2, #0
    5b78:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
    5b7a:	f012 fee4 	bl	18946 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    5b7e:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    5b80:	bd08      	pop	{r3, pc}
    5b82:	bf00      	nop
    5b84:	200040e8 	.word	0x200040e8

00005b88 <arch_new_thread>:
#ifdef CONFIG_INIT_STACKS
	memset(stack, 0xaa, stack_size);
#endif
#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)stack;
	thread->stack_info.size = stack_size;
    5b88:	e9c0 1218 	strd	r1, r2, [r0, #96]	; 0x60
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
    5b8c:	440a      	add	r2, r1
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(Z_STACK_PTR_ALIGN(stackEnd -
    5b8e:	3a20      	subs	r2, #32
    5b90:	f022 0207 	bic.w	r2, r2, #7
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    5b94:	4908      	ldr	r1, [pc, #32]	; (5bb8 <arch_new_thread+0x30>)
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
    5b96:	6013      	str	r3, [r2, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
    5b98:	9b00      	ldr	r3, [sp, #0]
    5b9a:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    5b9c:	9b01      	ldr	r3, [sp, #4]
    5b9e:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    5ba0:	9b02      	ldr	r3, [sp, #8]
    5ba2:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	pInitCtx->basic.xpsr =
    5ba4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    5ba8:	61d3      	str	r3, [r2, #28]
	pInitCtx->basic.pc &= 0xfffffffe;
    5baa:	f021 0101 	bic.w	r1, r1, #1
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (u32_t)pInitCtx;

	thread->arch.basepri = 0;
    5bae:	2300      	movs	r3, #0
	pInitCtx->basic.pc &= 0xfffffffe;
    5bb0:	6191      	str	r1, [r2, #24]
	thread->callee_saved.psp = (u32_t)pInitCtx;
    5bb2:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    5bb4:	66c3      	str	r3, [r0, #108]	; 0x6c

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    5bb6:	4770      	bx	lr
    5bb8:	00014b5f 	.word	0x00014b5f

00005bbc <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    5bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5bbe:	4606      	mov	r6, r0
    5bc0:	460c      	mov	r4, r1
    5bc2:	4617      	mov	r7, r2
    5bc4:	461d      	mov	r5, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    5bc6:	f000 fb0d 	bl	61e4 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);

	_current = main_thread;
    5bca:	4b09      	ldr	r3, [pc, #36]	; (5bf0 <arch_switch_to_main_thread+0x34>)
	start_of_main_stack =
    5bcc:	443c      	add	r4, r7
	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);
    5bce:	f024 0407 	bic.w	r4, r4, #7
	_current = main_thread;
    5bd2:	609e      	str	r6, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    5bd4:	4628      	mov	r0, r5
    5bd6:	f384 8809 	msr	PSP, r4
    5bda:	2100      	movs	r1, #0
    5bdc:	b663      	cpsie	if
    5bde:	f381 8811 	msr	BASEPRI, r1
    5be2:	f3bf 8f6f 	isb	sy
    5be6:	2200      	movs	r2, #0
    5be8:	2300      	movs	r3, #0
    5bea:	f00e ffb8 	bl	14b5e <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    5bee:	bf00      	nop
    5bf0:	200040e8 	.word	0x200040e8

00005bf4 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    5bf4:	4901      	ldr	r1, [pc, #4]	; (5bfc <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    5bf6:	2210      	movs	r2, #16
	str	r2, [r1]
    5bf8:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    5bfa:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    5bfc:	e000ed10 	.word	0xe000ed10

00005c00 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    5c00:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    5c02:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    5c04:	f380 8811 	msr	BASEPRI, r0
	isb
    5c08:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    5c0c:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    5c10:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    5c12:	b662      	cpsie	i
	isb
    5c14:	f3bf 8f6f 	isb	sy

	bx	lr
    5c18:	4770      	bx	lr
    5c1a:	bf00      	nop

00005c1c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    5c1c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5c1e:	4606      	mov	r6, r0

	if (esf != NULL) {
    5c20:	460c      	mov	r4, r1
    5c22:	b301      	cbz	r1, 5c66 <z_arm_fatal_error+0x4a>
    5c24:	4b13      	ldr	r3, [pc, #76]	; (5c74 <z_arm_fatal_error+0x58>)
    5c26:	4d14      	ldr	r5, [pc, #80]	; (5c78 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    5c28:	4814      	ldr	r0, [pc, #80]	; (5c7c <z_arm_fatal_error+0x60>)
    5c2a:	1aed      	subs	r5, r5, r3
    5c2c:	08ed      	lsrs	r5, r5, #3
    5c2e:	01ad      	lsls	r5, r5, #6
    5c30:	f045 0501 	orr.w	r5, r5, #1
    5c34:	f8ad 5000 	strh.w	r5, [sp]
    5c38:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
    5c3c:	6809      	ldr	r1, [r1, #0]
    5c3e:	f00f fb3e 	bl	152be <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    5c42:	f8ad 5000 	strh.w	r5, [sp]
    5c46:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    5c4a:	68e1      	ldr	r1, [r4, #12]
    5c4c:	480c      	ldr	r0, [pc, #48]	; (5c80 <z_arm_fatal_error+0x64>)
    5c4e:	f00f fb36 	bl	152be <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    5c52:	69e1      	ldr	r1, [r4, #28]
    5c54:	480b      	ldr	r0, [pc, #44]	; (5c84 <z_arm_fatal_error+0x68>)
    5c56:	462a      	mov	r2, r5
    5c58:	f00f fb04 	bl	15264 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    5c5c:	69a1      	ldr	r1, [r4, #24]
    5c5e:	480a      	ldr	r0, [pc, #40]	; (5c88 <z_arm_fatal_error+0x6c>)
    5c60:	462a      	mov	r2, r5
    5c62:	f00f faff 	bl	15264 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    5c66:	4621      	mov	r1, r4
    5c68:	4630      	mov	r0, r6
}
    5c6a:	b002      	add	sp, #8
    5c6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
    5c70:	f00d bd40 	b.w	136f4 <z_fatal_error>
    5c74:	0001956c 	.word	0x0001956c
    5c78:	0001962c 	.word	0x0001962c
    5c7c:	0001a95c 	.word	0x0001a95c
    5c80:	0001a98b 	.word	0x0001a98b
    5c84:	0001a9ba 	.word	0x0001a9ba
    5c88:	0001a9c9 	.word	0x0001a9c9

00005c8c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    5c8c:	bf30      	wfi
    b z_SysNmiOnReset
    5c8e:	f7ff bffd 	b.w	5c8c <z_SysNmiOnReset>
    5c92:	bf00      	nop

00005c94 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    5c94:	4a0e      	ldr	r2, [pc, #56]	; (5cd0 <z_arm_prep_c+0x3c>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    5c96:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    5c98:	4b0e      	ldr	r3, [pc, #56]	; (5cd4 <z_arm_prep_c+0x40>)
    5c9a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    5c9e:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    5ca0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    5ca4:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    5ca8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    5cac:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    5cb0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    5cb4:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    5cb8:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    5cbc:	f383 8814 	msr	CONTROL, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    5cc0:	f00d fd94 	bl	137ec <z_bss_zero>
	z_data_copy();
    5cc4:	f00d fd9c 	bl	13800 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    5cc8:	f000 fa5a 	bl	6180 <z_arm_interrupt_init>
	z_cstart();
    5ccc:	f00d fdd6 	bl	1387c <z_cstart>
    5cd0:	00000000 	.word	0x00000000
    5cd4:	e000ed00 	.word	0xe000ed00

00005cd8 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    5cd8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    5cda:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    5cdc:	4a0b      	ldr	r2, [pc, #44]	; (5d0c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    5cde:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    5ce0:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    5ce2:	bf1e      	ittt	ne
	movne	r1, #0
    5ce4:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    5ce6:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    5ce8:	f012 fe2d 	blne	18946 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    5cec:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    5cee:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    5cf2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    5cf6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    5cfa:	4905      	ldr	r1, [pc, #20]	; (5d10 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    5cfc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    5cfe:	c909      	ldmia	r1!, {r0, r3}
#ifdef CONFIG_EXECUTION_BENCHMARKING
	push {r0, r3}	/* Save r0 and r3 into stack */
	bl read_timer_end_of_isr
	pop {r0, r3}	/* Restore r0 and r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    5d00:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    5d02:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    5d06:	4903      	ldr	r1, [pc, #12]	; (5d14 <_isr_wrapper+0x3c>)
	bx r1
    5d08:	4708      	bx	r1
    5d0a:	0000      	.short	0x0000
	ldr r2, =_kernel
    5d0c:	200040e8 	.word	0x200040e8
	ldr r1, =_sw_isr_table
    5d10:	000192c0 	.word	0x000192c0
	ldr r1, =z_arm_int_exit
    5d14:	00006165 	.word	0x00006165

00005d18 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    5d18:	f010 fa83 	bl	16222 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    5d1c:	2020      	movs	r0, #32
    msr BASEPRI, r0
    5d1e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    5d22:	4808      	ldr	r0, [pc, #32]	; (5d44 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    5d24:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    5d28:	1840      	adds	r0, r0, r1
    msr PSP, r0
    5d2a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    5d2e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    5d32:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    5d34:	4308      	orrs	r0, r1
    msr CONTROL, r0
    5d36:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    5d3a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    5d3e:	f7ff ffa9 	bl	5c94 <z_arm_prep_c>
    5d42:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    5d44:	2000a460 	.word	0x2000a460

00005d48 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    5d48:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    5d4c:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    5d50:	4672      	mov	r2, lr

	push {r0, lr}
    5d52:	b501      	push	{r0, lr}

	bl z_arm_fault
    5d54:	f000 f932 	bl	5fbc <z_arm_fault>

	pop {r0, pc}
    5d58:	bd01      	pop	{r0, pc}
    5d5a:	bf00      	nop

00005d5c <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
    5d5c:	b570      	push	{r4, r5, r6, lr}
    5d5e:	4b23      	ldr	r3, [pc, #140]	; (5dec <usage_fault.isra.0+0x90>)
    5d60:	4c23      	ldr	r4, [pc, #140]	; (5df0 <usage_fault.isra.0+0x94>)
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    5d62:	4d24      	ldr	r5, [pc, #144]	; (5df4 <usage_fault.isra.0+0x98>)
	PR_FAULT_INFO("***** USAGE FAULT *****");
    5d64:	4824      	ldr	r0, [pc, #144]	; (5df8 <usage_fault.isra.0+0x9c>)
    5d66:	1ae4      	subs	r4, r4, r3
    5d68:	08e4      	lsrs	r4, r4, #3
    5d6a:	01a4      	lsls	r4, r4, #6
    5d6c:	f044 0601 	orr.w	r6, r4, #1
    5d70:	4631      	mov	r1, r6
    5d72:	f00f fa6a 	bl	1524a <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    5d76:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5d78:	0193      	lsls	r3, r2, #6
    5d7a:	d503      	bpl.n	5d84 <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
    5d7c:	481f      	ldr	r0, [pc, #124]	; (5dfc <usage_fault.isra.0+0xa0>)
    5d7e:	4631      	mov	r1, r6
    5d80:	f00f fa63 	bl	1524a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    5d84:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5d86:	01dd      	lsls	r5, r3, #7
    5d88:	d504      	bpl.n	5d94 <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
    5d8a:	481d      	ldr	r0, [pc, #116]	; (5e00 <usage_fault.isra.0+0xa4>)
    5d8c:	f044 0101 	orr.w	r1, r4, #1
    5d90:	f00f fa5b 	bl	1524a <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    5d94:	4d17      	ldr	r5, [pc, #92]	; (5df4 <usage_fault.isra.0+0x98>)
    5d96:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5d98:	0310      	lsls	r0, r2, #12
    5d9a:	d504      	bpl.n	5da6 <usage_fault.isra.0+0x4a>
		PR_FAULT_INFO("  No coprocessor instructions");
    5d9c:	4819      	ldr	r0, [pc, #100]	; (5e04 <usage_fault.isra.0+0xa8>)
    5d9e:	f044 0101 	orr.w	r1, r4, #1
    5da2:	f00f fa52 	bl	1524a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    5da6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5da8:	0359      	lsls	r1, r3, #13
    5daa:	d504      	bpl.n	5db6 <usage_fault.isra.0+0x5a>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    5dac:	4816      	ldr	r0, [pc, #88]	; (5e08 <usage_fault.isra.0+0xac>)
    5dae:	f044 0101 	orr.w	r1, r4, #1
    5db2:	f00f fa4a 	bl	1524a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    5db6:	4d0f      	ldr	r5, [pc, #60]	; (5df4 <usage_fault.isra.0+0x98>)
    5db8:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5dba:	0392      	lsls	r2, r2, #14
    5dbc:	d504      	bpl.n	5dc8 <usage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    5dbe:	4813      	ldr	r0, [pc, #76]	; (5e0c <usage_fault.isra.0+0xb0>)
    5dc0:	f044 0101 	orr.w	r1, r4, #1
    5dc4:	f00f fa41 	bl	1524a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    5dc8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5dca:	03db      	lsls	r3, r3, #15
    5dcc:	d504      	bpl.n	5dd8 <usage_fault.isra.0+0x7c>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    5dce:	4810      	ldr	r0, [pc, #64]	; (5e10 <usage_fault.isra.0+0xb4>)
    5dd0:	f044 0101 	orr.w	r1, r4, #1
    5dd4:	f00f fa39 	bl	1524a <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    5dd8:	4a06      	ldr	r2, [pc, #24]	; (5df4 <usage_fault.isra.0+0x98>)
    5dda:	6a93      	ldr	r3, [r2, #40]	; 0x28
    5ddc:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    5de0:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    5de4:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    5de6:	2000      	movs	r0, #0
    5de8:	bd70      	pop	{r4, r5, r6, pc}
    5dea:	bf00      	nop
    5dec:	0001956c 	.word	0x0001956c
    5df0:	0001962c 	.word	0x0001962c
    5df4:	e000ed00 	.word	0xe000ed00
    5df8:	0001a9f7 	.word	0x0001a9f7
    5dfc:	0001aa0f 	.word	0x0001aa0f
    5e00:	0001aa22 	.word	0x0001aa22
    5e04:	0001aa3c 	.word	0x0001aa3c
    5e08:	0001aa5a 	.word	0x0001aa5a
    5e0c:	0001aa7f 	.word	0x0001aa7f
    5e10:	0001aa99 	.word	0x0001aa99

00005e14 <mem_manage_fault.isra.0>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    5e14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5e18:	4b27      	ldr	r3, [pc, #156]	; (5eb8 <mem_manage_fault.isra.0+0xa4>)
    5e1a:	4c28      	ldr	r4, [pc, #160]	; (5ebc <mem_manage_fault.isra.0+0xa8>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    5e1c:	4d28      	ldr	r5, [pc, #160]	; (5ec0 <mem_manage_fault.isra.0+0xac>)
    5e1e:	1ae4      	subs	r4, r4, r3
    5e20:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
    5e22:	01a4      	lsls	r4, r4, #6
    5e24:	f044 0801 	orr.w	r8, r4, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
    5e28:	4607      	mov	r7, r0
    5e2a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    5e2c:	4825      	ldr	r0, [pc, #148]	; (5ec4 <mem_manage_fault.isra.0+0xb0>)
    5e2e:	4641      	mov	r1, r8
    5e30:	f00f fa0b 	bl	1524a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    5e34:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5e36:	06d1      	lsls	r1, r2, #27
    5e38:	d503      	bpl.n	5e42 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
    5e3a:	4823      	ldr	r0, [pc, #140]	; (5ec8 <mem_manage_fault.isra.0+0xb4>)
    5e3c:	4641      	mov	r1, r8
    5e3e:	f00f fa04 	bl	1524a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    5e42:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5e44:	071a      	lsls	r2, r3, #28
    5e46:	d504      	bpl.n	5e52 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
    5e48:	4820      	ldr	r0, [pc, #128]	; (5ecc <mem_manage_fault.isra.0+0xb8>)
    5e4a:	f044 0101 	orr.w	r1, r4, #1
    5e4e:	f00f f9fc 	bl	1524a <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    5e52:	4d1b      	ldr	r5, [pc, #108]	; (5ec0 <mem_manage_fault.isra.0+0xac>)
    5e54:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5e56:	079b      	lsls	r3, r3, #30
    5e58:	d512      	bpl.n	5e80 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
    5e5a:	f044 0801 	orr.w	r8, r4, #1
    5e5e:	481c      	ldr	r0, [pc, #112]	; (5ed0 <mem_manage_fault.isra.0+0xbc>)
    5e60:	4641      	mov	r1, r8
    5e62:	f00f f9f2 	bl	1524a <log_0>
		mmfar = SCB->MMFAR;
    5e66:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    5e68:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5e6a:	0618      	lsls	r0, r3, #24
    5e6c:	d508      	bpl.n	5e80 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    5e6e:	4819      	ldr	r0, [pc, #100]	; (5ed4 <mem_manage_fault.isra.0+0xc0>)
    5e70:	4642      	mov	r2, r8
    5e72:	f00f f9f7 	bl	15264 <log_1>
			if (from_hard_fault) {
    5e76:	b11f      	cbz	r7, 5e80 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    5e78:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5e7a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    5e7e:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    5e80:	4d0f      	ldr	r5, [pc, #60]	; (5ec0 <mem_manage_fault.isra.0+0xac>)
    5e82:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5e84:	07d2      	lsls	r2, r2, #31
    5e86:	d504      	bpl.n	5e92 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
    5e88:	4813      	ldr	r0, [pc, #76]	; (5ed8 <mem_manage_fault.isra.0+0xc4>)
    5e8a:	f044 0101 	orr.w	r1, r4, #1
    5e8e:	f00f f9dc 	bl	1524a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    5e92:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5e94:	069b      	lsls	r3, r3, #26
    5e96:	d504      	bpl.n	5ea2 <mem_manage_fault.isra.0+0x8e>
		PR_FAULT_INFO(
    5e98:	4810      	ldr	r0, [pc, #64]	; (5edc <mem_manage_fault.isra.0+0xc8>)
    5e9a:	f044 0101 	orr.w	r1, r4, #1
    5e9e:	f00f f9d4 	bl	1524a <log_0>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    5ea2:	4b07      	ldr	r3, [pc, #28]	; (5ec0 <mem_manage_fault.isra.0+0xac>)
    5ea4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    5ea6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    5ea8:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    5eaa:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    5eae:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    5eb0:	7030      	strb	r0, [r6, #0]
}
    5eb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5eb6:	bf00      	nop
    5eb8:	0001956c 	.word	0x0001956c
    5ebc:	0001962c 	.word	0x0001962c
    5ec0:	e000ed00 	.word	0xe000ed00
    5ec4:	0001aac4 	.word	0x0001aac4
    5ec8:	0001aada 	.word	0x0001aada
    5ecc:	0001ab0d 	.word	0x0001ab0d
    5ed0:	0001ab20 	.word	0x0001ab20
    5ed4:	0001ab38 	.word	0x0001ab38
    5ed8:	0001ab4e 	.word	0x0001ab4e
    5edc:	0001ab6d 	.word	0x0001ab6d

00005ee0 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    5ee0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5ee4:	4b2a      	ldr	r3, [pc, #168]	; (5f90 <bus_fault.isra.0+0xb0>)
    5ee6:	4c2b      	ldr	r4, [pc, #172]	; (5f94 <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    5ee8:	4d2b      	ldr	r5, [pc, #172]	; (5f98 <bus_fault.isra.0+0xb8>)
    5eea:	1ae4      	subs	r4, r4, r3
    5eec:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
    5eee:	01a4      	lsls	r4, r4, #6
    5ef0:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    5ef4:	4607      	mov	r7, r0
    5ef6:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    5ef8:	4828      	ldr	r0, [pc, #160]	; (5f9c <bus_fault.isra.0+0xbc>)
    5efa:	4641      	mov	r1, r8
    5efc:	f00f f9a5 	bl	1524a <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    5f00:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5f02:	04d1      	lsls	r1, r2, #19
    5f04:	d503      	bpl.n	5f0e <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
    5f06:	4826      	ldr	r0, [pc, #152]	; (5fa0 <bus_fault.isra.0+0xc0>)
    5f08:	4641      	mov	r1, r8
    5f0a:	f00f f99e 	bl	1524a <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    5f0e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f10:	051a      	lsls	r2, r3, #20
    5f12:	d504      	bpl.n	5f1e <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
    5f14:	4823      	ldr	r0, [pc, #140]	; (5fa4 <bus_fault.isra.0+0xc4>)
    5f16:	f044 0101 	orr.w	r1, r4, #1
    5f1a:	f00f f996 	bl	1524a <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    5f1e:	4d1e      	ldr	r5, [pc, #120]	; (5f98 <bus_fault.isra.0+0xb8>)
    5f20:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f22:	059b      	lsls	r3, r3, #22
    5f24:	d512      	bpl.n	5f4c <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
    5f26:	f044 0801 	orr.w	r8, r4, #1
    5f2a:	481f      	ldr	r0, [pc, #124]	; (5fa8 <bus_fault.isra.0+0xc8>)
    5f2c:	4641      	mov	r1, r8
    5f2e:	f00f f98c 	bl	1524a <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    5f32:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    5f34:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f36:	0418      	lsls	r0, r3, #16
    5f38:	d508      	bpl.n	5f4c <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    5f3a:	481c      	ldr	r0, [pc, #112]	; (5fac <bus_fault.isra.0+0xcc>)
    5f3c:	4642      	mov	r2, r8
    5f3e:	f00f f991 	bl	15264 <log_1>
			if (from_hard_fault) {
    5f42:	b11f      	cbz	r7, 5f4c <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    5f44:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f46:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    5f4a:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    5f4c:	4d12      	ldr	r5, [pc, #72]	; (5f98 <bus_fault.isra.0+0xb8>)
    5f4e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f50:	0559      	lsls	r1, r3, #21
    5f52:	d504      	bpl.n	5f5e <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
    5f54:	4816      	ldr	r0, [pc, #88]	; (5fb0 <bus_fault.isra.0+0xd0>)
    5f56:	f044 0101 	orr.w	r1, r4, #1
    5f5a:	f00f f976 	bl	1524a <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    5f5e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f60:	05da      	lsls	r2, r3, #23
    5f62:	d50d      	bpl.n	5f80 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
    5f64:	4813      	ldr	r0, [pc, #76]	; (5fb4 <bus_fault.isra.0+0xd4>)
    5f66:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    5f6a:	f00f f96e 	bl	1524a <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    5f6e:	4a0a      	ldr	r2, [pc, #40]	; (5f98 <bus_fault.isra.0+0xb8>)
    5f70:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    5f72:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    5f74:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    5f78:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    5f7a:	7030      	strb	r0, [r6, #0]
}
    5f7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    5f80:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5f82:	049b      	lsls	r3, r3, #18
    5f84:	d5f3      	bpl.n	5f6e <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    5f86:	480c      	ldr	r0, [pc, #48]	; (5fb8 <bus_fault.isra.0+0xd8>)
    5f88:	f044 0101 	orr.w	r1, r4, #1
    5f8c:	e7ed      	b.n	5f6a <bus_fault.isra.0+0x8a>
    5f8e:	bf00      	nop
    5f90:	0001956c 	.word	0x0001956c
    5f94:	0001962c 	.word	0x0001962c
    5f98:	e000ed00 	.word	0xe000ed00
    5f9c:	0001ab9c 	.word	0x0001ab9c
    5fa0:	0001abb2 	.word	0x0001abb2
    5fa4:	0001ab0d 	.word	0x0001ab0d
    5fa8:	0001abc3 	.word	0x0001abc3
    5fac:	0001abdc 	.word	0x0001abdc
    5fb0:	0001abf1 	.word	0x0001abf1
    5fb4:	0001ac0c 	.word	0x0001ac0c
    5fb8:	0001ab6d 	.word	0x0001ab6d

00005fbc <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    5fbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    5fc0:	4b56      	ldr	r3, [pc, #344]	; (611c <z_arm_fault+0x160>)
    5fc2:	685e      	ldr	r6, [r3, #4]
{
    5fc4:	b08a      	sub	sp, #40	; 0x28
    5fc6:	460f      	mov	r7, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    5fc8:	f3c6 0408 	ubfx	r4, r6, #0, #9
    5fcc:	2500      	movs	r5, #0
    5fce:	f385 8811 	msr	BASEPRI, r5
    5fd2:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    5fd6:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    5fda:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    5fde:	d10d      	bne.n	5ffc <z_arm_fault+0x40>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    5fe0:	f002 030c 	and.w	r3, r2, #12
    5fe4:	2b08      	cmp	r3, #8
    5fe6:	d10b      	bne.n	6000 <z_arm_fault+0x44>
    5fe8:	494d      	ldr	r1, [pc, #308]	; (6120 <z_arm_fault+0x164>)
    5fea:	4b4e      	ldr	r3, [pc, #312]	; (6124 <z_arm_fault+0x168>)
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    5fec:	484e      	ldr	r0, [pc, #312]	; (6128 <z_arm_fault+0x16c>)
    5fee:	1ac9      	subs	r1, r1, r3
    5ff0:	08c9      	lsrs	r1, r1, #3
    5ff2:	0189      	lsls	r1, r1, #6
    5ff4:	f041 0101 	orr.w	r1, r1, #1
    5ff8:	f00f f927 	bl	1524a <log_0>
		return NULL;
    5ffc:	462f      	mov	r7, r5
    5ffe:	e003      	b.n	6008 <z_arm_fault+0x4c>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    6000:	0712      	lsls	r2, r2, #28
    6002:	d401      	bmi.n	6008 <z_arm_fault+0x4c>
			ptr_esf = (z_arch_esf_t *)msp;
    6004:	4607      	mov	r7, r0
			*nested_exc = true;
    6006:	2501      	movs	r5, #1
	*recoverable = false;
    6008:	2300      	movs	r3, #0
    600a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
    600e:	1ee3      	subs	r3, r4, #3
    6010:	2b09      	cmp	r3, #9
    6012:	d86a      	bhi.n	60ea <z_arm_fault+0x12e>
    6014:	e8df f003 	tbb	[pc, r3]
    6018:	3c5c5805 	.word	0x3c5c5805
    601c:	69696969 	.word	0x69696969
    6020:	6069      	.short	0x6069
    6022:	4b40      	ldr	r3, [pc, #256]	; (6124 <z_arm_fault+0x168>)
    6024:	4e3e      	ldr	r6, [pc, #248]	; (6120 <z_arm_fault+0x164>)
	PR_FAULT_INFO("***** HARD FAULT *****");
    6026:	4841      	ldr	r0, [pc, #260]	; (612c <z_arm_fault+0x170>)
    6028:	1af6      	subs	r6, r6, r3
    602a:	08f6      	lsrs	r6, r6, #3
    602c:	01b6      	lsls	r6, r6, #6
    602e:	f046 0601 	orr.w	r6, r6, #1
    6032:	4631      	mov	r1, r6
    6034:	f00f f909 	bl	1524a <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    6038:	4b38      	ldr	r3, [pc, #224]	; (611c <z_arm_fault+0x160>)
    603a:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	*recoverable = false;
    603c:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    6040:	f014 0402 	ands.w	r4, r4, #2
	*recoverable = false;
    6044:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    6048:	d005      	beq.n	6056 <z_arm_fault+0x9a>
		PR_EXC("  Bus fault on vector table read");
    604a:	4839      	ldr	r0, [pc, #228]	; (6130 <z_arm_fault+0x174>)
    604c:	4631      	mov	r1, r6
	PR_FAULT_INFO(
    604e:	f00f f8fc 	bl	1524a <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    6052:	2400      	movs	r4, #0
}
    6054:	e01f      	b.n	6096 <z_arm_fault+0xda>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    6056:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6058:	005b      	lsls	r3, r3, #1
    605a:	d51c      	bpl.n	6096 <z_arm_fault+0xda>
		PR_EXC("  Fault escalation (see below)");
    605c:	4835      	ldr	r0, [pc, #212]	; (6134 <z_arm_fault+0x178>)
    605e:	4631      	mov	r1, r6
    6060:	f00f f8f3 	bl	1524a <log_0>
		if (SCB_MMFSR != 0) {
    6064:	4b34      	ldr	r3, [pc, #208]	; (6138 <z_arm_fault+0x17c>)
    6066:	781b      	ldrb	r3, [r3, #0]
    6068:	b12b      	cbz	r3, 6076 <z_arm_fault+0xba>
			reason = mem_manage_fault(esf, 1, recoverable);
    606a:	f10d 0107 	add.w	r1, sp, #7
    606e:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    6070:	f7ff fed0 	bl	5e14 <mem_manage_fault.isra.0>
    6074:	e00e      	b.n	6094 <z_arm_fault+0xd8>
		} else if (SCB_BFSR != 0) {
    6076:	4b31      	ldr	r3, [pc, #196]	; (613c <z_arm_fault+0x180>)
    6078:	781b      	ldrb	r3, [r3, #0]
    607a:	b12b      	cbz	r3, 6088 <z_arm_fault+0xcc>
			reason = bus_fault(esf, 1, recoverable);
    607c:	f10d 0107 	add.w	r1, sp, #7
    6080:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    6082:	f7ff ff2d 	bl	5ee0 <bus_fault.isra.0>
    6086:	e005      	b.n	6094 <z_arm_fault+0xd8>
		} else if (SCB_UFSR != 0) {
    6088:	4b2d      	ldr	r3, [pc, #180]	; (6140 <z_arm_fault+0x184>)
    608a:	881b      	ldrh	r3, [r3, #0]
    608c:	b29b      	uxth	r3, r3
    608e:	b113      	cbz	r3, 6096 <z_arm_fault+0xda>
			reason = usage_fault(esf);
    6090:	f7ff fe64 	bl	5d5c <usage_fault.isra.0>
    6094:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    6096:	f89d 3007 	ldrb.w	r3, [sp, #7]
    609a:	b993      	cbnz	r3, 60c2 <z_arm_fault+0x106>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    609c:	2220      	movs	r2, #32
    609e:	4639      	mov	r1, r7
    60a0:	a802      	add	r0, sp, #8
    60a2:	f00f ffca 	bl	1603a <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    60a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    60a8:	b39d      	cbz	r5, 6112 <z_arm_fault+0x156>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    60aa:	f3c3 0208 	ubfx	r2, r3, #0, #9
    60ae:	b922      	cbnz	r2, 60ba <z_arm_fault+0xfe>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    60b0:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    60b4:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    60b8:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    60ba:	a902      	add	r1, sp, #8
    60bc:	4620      	mov	r0, r4
    60be:	f7ff fdad 	bl	5c1c <z_arm_fatal_error>
}
    60c2:	b00a      	add	sp, #40	; 0x28
    60c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    60c8:	f10d 0107 	add.w	r1, sp, #7
    60cc:	2000      	movs	r0, #0
    60ce:	e7cf      	b.n	6070 <z_arm_fault+0xb4>
		reason = bus_fault(esf, 0, recoverable);
    60d0:	f10d 0107 	add.w	r1, sp, #7
    60d4:	2000      	movs	r0, #0
    60d6:	e7d4      	b.n	6082 <z_arm_fault+0xc6>
    60d8:	4911      	ldr	r1, [pc, #68]	; (6120 <z_arm_fault+0x164>)
    60da:	4b12      	ldr	r3, [pc, #72]	; (6124 <z_arm_fault+0x168>)
	PR_FAULT_INFO(
    60dc:	4819      	ldr	r0, [pc, #100]	; (6144 <z_arm_fault+0x188>)
    60de:	1ac9      	subs	r1, r1, r3
    60e0:	08c9      	lsrs	r1, r1, #3
    60e2:	0189      	lsls	r1, r1, #6
    60e4:	f041 0101 	orr.w	r1, r1, #1
    60e8:	e7b1      	b.n	604e <z_arm_fault+0x92>
    60ea:	4a0e      	ldr	r2, [pc, #56]	; (6124 <z_arm_fault+0x168>)
    60ec:	4b0c      	ldr	r3, [pc, #48]	; (6120 <z_arm_fault+0x164>)
	PR_FAULT_INFO("***** %s %d) *****",
    60ee:	4816      	ldr	r0, [pc, #88]	; (6148 <z_arm_fault+0x18c>)
    60f0:	4916      	ldr	r1, [pc, #88]	; (614c <z_arm_fault+0x190>)
    60f2:	1a9b      	subs	r3, r3, r2
    60f4:	08db      	lsrs	r3, r3, #3
    60f6:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
    60fa:	ea4f 1383 	mov.w	r3, r3, lsl #6
    60fe:	bf18      	it	ne
    6100:	4601      	movne	r1, r0
    6102:	f043 0301 	orr.w	r3, r3, #1
    6106:	4812      	ldr	r0, [pc, #72]	; (6150 <z_arm_fault+0x194>)
    6108:	f1a4 0210 	sub.w	r2, r4, #16
    610c:	f00f f8be 	bl	1528c <log_2>
    6110:	e79f      	b.n	6052 <z_arm_fault+0x96>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    6112:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    6116:	f023 0301 	bic.w	r3, r3, #1
    611a:	e7cd      	b.n	60b8 <z_arm_fault+0xfc>
    611c:	e000ed00 	.word	0xe000ed00
    6120:	0001962c 	.word	0x0001962c
    6124:	0001956c 	.word	0x0001956c
    6128:	0001ac24 	.word	0x0001ac24
    612c:	0001ac4f 	.word	0x0001ac4f
    6130:	0001ac66 	.word	0x0001ac66
    6134:	0001ac87 	.word	0x0001ac87
    6138:	e000ed28 	.word	0xe000ed28
    613c:	e000ed29 	.word	0xe000ed29
    6140:	e000ed2a 	.word	0xe000ed2a
    6144:	0001aca6 	.word	0x0001aca6
    6148:	0001acf1 	.word	0x0001acf1
    614c:	0001acdc 	.word	0x0001acdc
    6150:	0001ad0a 	.word	0x0001ad0a

00006154 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    6154:	4a02      	ldr	r2, [pc, #8]	; (6160 <z_arm_fault_init+0xc>)
    6156:	6953      	ldr	r3, [r2, #20]
    6158:	f043 0310 	orr.w	r3, r3, #16
    615c:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    615e:	4770      	bx	lr
    6160:	e000ed00 	.word	0xe000ed00

00006164 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    6164:	4b04      	ldr	r3, [pc, #16]	; (6178 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    6166:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    6168:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
    616a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    616c:	d003      	beq.n	6176 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    616e:	4903      	ldr	r1, [pc, #12]	; (617c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    6170:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    6174:	600a      	str	r2, [r1, #0]

00006176 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    6176:	4770      	bx	lr
	ldr r3, =_kernel
    6178:	200040e8 	.word	0x200040e8
	ldr r1, =_SCS_ICSR
    617c:	e000ed04 	.word	0xe000ed04

00006180 <z_arm_interrupt_init>:
    6180:	4804      	ldr	r0, [pc, #16]	; (6194 <z_arm_interrupt_init+0x14>)
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    6182:	2300      	movs	r3, #0
    6184:	2120      	movs	r1, #32
    6186:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    6188:	3301      	adds	r3, #1
    618a:	2b30      	cmp	r3, #48	; 0x30
    618c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    6190:	d1f9      	bne.n	6186 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    6192:	4770      	bx	lr
    6194:	e000e100 	.word	0xe000e100

00006198 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    6198:	b538      	push	{r3, r4, r5, lr}
    619a:	4604      	mov	r4, r0
	__asm__ volatile(
    619c:	f04f 0320 	mov.w	r3, #32
    61a0:	f3ef 8511 	mrs	r5, BASEPRI
    61a4:	f383 8811 	msr	BASEPRI, r3
    61a8:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    61ac:	f00d fef6 	bl	13f9c <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    61b0:	4b0a      	ldr	r3, [pc, #40]	; (61dc <z_impl_k_thread_abort+0x44>)
    61b2:	689b      	ldr	r3, [r3, #8]
    61b4:	42a3      	cmp	r3, r4
    61b6:	d10b      	bne.n	61d0 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    61b8:	4b09      	ldr	r3, [pc, #36]	; (61e0 <z_impl_k_thread_abort+0x48>)
    61ba:	685a      	ldr	r2, [r3, #4]
    61bc:	f3c2 0208 	ubfx	r2, r2, #0, #9
    61c0:	b912      	cbnz	r2, 61c8 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    61c2:	4628      	mov	r0, r5
    61c4:	f7ff fc3a 	bl	5a3c <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    61c8:	685a      	ldr	r2, [r3, #4]
    61ca:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    61ce:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    61d0:	4628      	mov	r0, r5
}
    61d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    61d6:	f012 bda8 	b.w	18d2a <z_reschedule_irqlock>
    61da:	bf00      	nop
    61dc:	200040e8 	.word	0x200040e8
    61e0:	e000ed00 	.word	0xe000ed00

000061e4 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    61e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    61e6:	4b08      	ldr	r3, [pc, #32]	; (6208 <z_arm_configure_static_mpu_regions+0x24>)
    61e8:	9301      	str	r3, [sp, #4]
    61ea:	4b08      	ldr	r3, [pc, #32]	; (620c <z_arm_configure_static_mpu_regions+0x28>)
    61ec:	9302      	str	r3, [sp, #8]
    61ee:	4b08      	ldr	r3, [pc, #32]	; (6210 <z_arm_configure_static_mpu_regions+0x2c>)
    61f0:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    61f2:	ab01      	add	r3, sp, #4
    61f4:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    61f6:	4a07      	ldr	r2, [pc, #28]	; (6214 <z_arm_configure_static_mpu_regions+0x30>)
    61f8:	4b07      	ldr	r3, [pc, #28]	; (6218 <z_arm_configure_static_mpu_regions+0x34>)
    61fa:	2101      	movs	r1, #1
    61fc:	4668      	mov	r0, sp
    61fe:	f000 f8af 	bl	6360 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    6202:	b005      	add	sp, #20
    6204:	f85d fb04 	ldr.w	pc, [sp], #4
    6208:	20000000 	.word	0x20000000
    620c:	00000000 	.word	0x00000000
    6210:	060b0000 	.word	0x060b0000
    6214:	20000000 	.word	0x20000000
    6218:	20040000 	.word	0x20040000

0000621c <mpu_configure_regions>:
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    621c:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 62dc <mpu_configure_regions+0xc0>
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    6220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6222:	4606      	mov	r6, r0
    6224:	460f      	mov	r7, r1
	int i;
	int reg_index = start_reg_index;
    6226:	4610      	mov	r0, r2

	for (i = 0; i < regions_num; i++) {
    6228:	2100      	movs	r1, #0
    622a:	42b9      	cmp	r1, r7
    622c:	da1b      	bge.n	6266 <mpu_configure_regions+0x4a>
		if (regions[i]->size == 0U) {
    622e:	f856 e021 	ldr.w	lr, [r6, r1, lsl #2]
    6232:	f8de 4004 	ldr.w	r4, [lr, #4]
    6236:	2c00      	cmp	r4, #0
    6238:	d046      	beq.n	62c8 <mpu_configure_regions+0xac>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    623a:	b1ab      	cbz	r3, 6268 <mpu_configure_regions+0x4c>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
    623c:	1e65      	subs	r5, r4, #1
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    623e:	422c      	tst	r4, r5
    6240:	d105      	bne.n	624e <mpu_configure_regions+0x32>
		&&
    6242:	2c1f      	cmp	r4, #31
    6244:	d903      	bls.n	624e <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    6246:	f8de 2000 	ldr.w	r2, [lr]
		&&
    624a:	4215      	tst	r5, r2
    624c:	d00c      	beq.n	6268 <mpu_configure_regions+0x4c>
    624e:	4a1f      	ldr	r2, [pc, #124]	; (62cc <mpu_configure_regions+0xb0>)
    6250:	4b1f      	ldr	r3, [pc, #124]	; (62d0 <mpu_configure_regions+0xb4>)
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    6252:	4820      	ldr	r0, [pc, #128]	; (62d4 <mpu_configure_regions+0xb8>)
    6254:	1ad2      	subs	r2, r2, r3
    6256:	08d2      	lsrs	r2, r2, #3
    6258:	0192      	lsls	r2, r2, #6
    625a:	f042 0201 	orr.w	r2, r2, #1
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    625e:	f00f f801 	bl	15264 <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    6262:	f06f 0015 	mvn.w	r0, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    6266:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    6268:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    626a:	b2c5      	uxtb	r5, r0
	region_conf.base = new_region->start;
    626c:	f8de 2000 	ldr.w	r2, [lr]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    6270:	f8de 0008 	ldr.w	r0, [lr, #8]
    6274:	d916      	bls.n	62a4 <mpu_configure_regions+0x88>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
    6276:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    627a:	d815      	bhi.n	62a8 <mpu_configure_regions+0x8c>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    627c:	3c01      	subs	r4, #1
    627e:	fab4 f484 	clz	r4, r4
    6282:	f1c4 041f 	rsb	r4, r4, #31
    6286:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    6288:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    628a:	ea44 0400 	orr.w	r4, r4, r0
    628e:	d90d      	bls.n	62ac <mpu_configure_regions+0x90>
    6290:	4a0e      	ldr	r2, [pc, #56]	; (62cc <mpu_configure_regions+0xb0>)
    6292:	4b0f      	ldr	r3, [pc, #60]	; (62d0 <mpu_configure_regions+0xb4>)
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    6294:	4810      	ldr	r0, [pc, #64]	; (62d8 <mpu_configure_regions+0xbc>)
    6296:	1ad2      	subs	r2, r2, r3
    6298:	08d2      	lsrs	r2, r2, #3
    629a:	0192      	lsls	r2, r2, #6
    629c:	f042 0201 	orr.w	r2, r2, #1
    62a0:	4629      	mov	r1, r5
    62a2:	e7dc      	b.n	625e <mpu_configure_regions+0x42>
		return REGION_32B;
    62a4:	2408      	movs	r4, #8
    62a6:	e7ef      	b.n	6288 <mpu_configure_regions+0x6c>
		return REGION_4G;
    62a8:	243e      	movs	r4, #62	; 0x3e
    62aa:	e7ed      	b.n	6288 <mpu_configure_regions+0x6c>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    62ac:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    62b0:	432a      	orrs	r2, r5
    62b2:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    62b6:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    62ba:	f8cc 5008 	str.w	r5, [ip, #8]
		reg_index++;
    62be:	1c68      	adds	r0, r5, #1
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    62c0:	f8cc 200c 	str.w	r2, [ip, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    62c4:	f8cc 4010 	str.w	r4, [ip, #16]
	for (i = 0; i < regions_num; i++) {
    62c8:	3101      	adds	r1, #1
    62ca:	e7ae      	b.n	622a <mpu_configure_regions+0xe>
    62cc:	0001961c 	.word	0x0001961c
    62d0:	0001956c 	.word	0x0001956c
    62d4:	0001ad21 	.word	0x0001ad21
    62d8:	0001ad44 	.word	0x0001ad44
    62dc:	e000ed90 	.word	0xe000ed90

000062e0 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    62e0:	4b03      	ldr	r3, [pc, #12]	; (62f0 <arm_core_mpu_enable+0x10>)
    62e2:	2205      	movs	r2, #5
    62e4:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    62e6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    62ea:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    62ee:	4770      	bx	lr
    62f0:	e000ed90 	.word	0xe000ed90

000062f4 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    62f4:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    62f8:	4b01      	ldr	r3, [pc, #4]	; (6300 <arm_core_mpu_disable+0xc>)
    62fa:	2200      	movs	r2, #0
    62fc:	605a      	str	r2, [r3, #4]
}
    62fe:	4770      	bx	lr
    6300:	e000ed90 	.word	0xe000ed90

00006304 <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    6304:	4913      	ldr	r1, [pc, #76]	; (6354 <arm_mpu_init+0x50>)
    6306:	6808      	ldr	r0, [r1, #0]
    6308:	2808      	cmp	r0, #8
{
    630a:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    630c:	d81e      	bhi.n	634c <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    630e:	f7ff fff1 	bl	62f4 <arm_core_mpu_disable>
	MPU->RNR = index;
    6312:	4c11      	ldr	r4, [pc, #68]	; (6358 <arm_mpu_init+0x54>)
    6314:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    6316:	2200      	movs	r2, #0
    6318:	4290      	cmp	r0, r2
    631a:	f101 010c 	add.w	r1, r1, #12
    631e:	d105      	bne.n	632c <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    6320:	4b0e      	ldr	r3, [pc, #56]	; (635c <arm_mpu_init+0x58>)
    6322:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    6324:	f7ff ffdc 	bl	62e0 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    6328:	2000      	movs	r0, #0
}
    632a:	bd10      	pop	{r4, pc}
    632c:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    632e:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    6332:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    6336:	4313      	orrs	r3, r2
    6338:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    633c:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    633e:	f851 3c04 	ldr.w	r3, [r1, #-4]
    6342:	f043 0301 	orr.w	r3, r3, #1
    6346:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    6348:	3201      	adds	r2, #1
    634a:	e7e5      	b.n	6318 <arm_mpu_init+0x14>
		return -1;
    634c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6350:	e7eb      	b.n	632a <arm_mpu_init+0x26>
    6352:	bf00      	nop
    6354:	0001986c 	.word	0x0001986c
    6358:	e000ed90 	.word	0xe000ed90
    635c:	20008671 	.word	0x20008671

00006360 <arm_core_mpu_configure_static_mpu_regions>:
{
    6360:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    6362:	4c03      	ldr	r4, [pc, #12]	; (6370 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    6364:	2301      	movs	r3, #1
    6366:	7822      	ldrb	r2, [r4, #0]
    6368:	f7ff ff58 	bl	621c <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    636c:	7020      	strb	r0, [r4, #0]
}
    636e:	bd10      	pop	{r4, pc}
    6370:	20008671 	.word	0x20008671

00006374 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
    6374:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6378:	b0a1      	sub	sp, #132	; 0x84
    637a:	461e      	mov	r6, r3
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
    637c:	2300      	movs	r3, #0
{
    637e:	9003      	str	r0, [sp, #12]
    6380:	4689      	mov	r9, r1
	count = 0;
    6382:	9302      	str	r3, [sp, #8]

	while ((c = *format++)) {
    6384:	4613      	mov	r3, r2
    6386:	f813 0b01 	ldrb.w	r0, [r3], #1
    638a:	9306      	str	r3, [sp, #24]
    638c:	b158      	cbz	r0, 63a6 <z_prf+0x32>
		if (c != '%') {
    638e:	2825      	cmp	r0, #37	; 0x25
    6390:	f000 8081 	beq.w	6496 <z_prf+0x122>
			PUTC(c);
    6394:	4649      	mov	r1, r9
    6396:	9b03      	ldr	r3, [sp, #12]
    6398:	4798      	blx	r3
    639a:	3001      	adds	r0, #1
    639c:	f040 844a 	bne.w	6c34 <z_prf+0x8c0>
    63a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    63a4:	9302      	str	r3, [sp, #8]
		}
	}
	return count;

#undef PUTC
}
    63a6:	9802      	ldr	r0, [sp, #8]
    63a8:	b021      	add	sp, #132	; 0x84
    63aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				switch (c) {
    63ae:	2d2b      	cmp	r5, #43	; 0x2b
    63b0:	d065      	beq.n	647e <z_prf+0x10a>
    63b2:	d85c      	bhi.n	646e <z_prf+0xfa>
    63b4:	2d20      	cmp	r5, #32
    63b6:	d065      	beq.n	6484 <z_prf+0x110>
    63b8:	2d23      	cmp	r5, #35	; 0x23
    63ba:	d066      	beq.n	648a <z_prf+0x116>
    63bc:	2d00      	cmp	r5, #0
    63be:	d0f2      	beq.n	63a6 <z_prf+0x32>
					fzero = true;
    63c0:	f8cd 8018 	str.w	r8, [sp, #24]
			while (strchr("-+ #0", (c = *format++)) != NULL) {
    63c4:	f8dd 8018 	ldr.w	r8, [sp, #24]
    63c8:	48a4      	ldr	r0, [pc, #656]	; (665c <z_prf+0x2e8>)
    63ca:	f818 5b01 	ldrb.w	r5, [r8], #1
    63ce:	4629      	mov	r1, r5
    63d0:	f00f fdf3 	bl	15fba <strchr>
    63d4:	2800      	cmp	r0, #0
    63d6:	d1ea      	bne.n	63ae <z_prf+0x3a>
			if (c == '*') {
    63d8:	2d2a      	cmp	r5, #42	; 0x2a
    63da:	d163      	bne.n	64a4 <z_prf+0x130>
				width = va_arg(vargs, int);
    63dc:	f856 3b04 	ldr.w	r3, [r6], #4
    63e0:	9307      	str	r3, [sp, #28]
				if (width < 0) {
    63e2:	2b00      	cmp	r3, #0
					width = -width;
    63e4:	bfbf      	itttt	lt
    63e6:	425b      	neglt	r3, r3
    63e8:	9307      	strlt	r3, [sp, #28]
					fminus = true;
    63ea:	2301      	movlt	r3, #1
    63ec:	930d      	strlt	r3, [sp, #52]	; 0x34
				c = *format++;
    63ee:	9b06      	ldr	r3, [sp, #24]
    63f0:	f898 5000 	ldrb.w	r5, [r8]
    63f4:	f103 0802 	add.w	r8, r3, #2
			if (c == '.') {
    63f8:	2d2e      	cmp	r5, #46	; 0x2e
    63fa:	d178      	bne.n	64ee <z_prf+0x17a>
				if (c == '*') {
    63fc:	f898 3000 	ldrb.w	r3, [r8]
    6400:	2b2a      	cmp	r3, #42	; 0x2a
    6402:	d171      	bne.n	64e8 <z_prf+0x174>
					precision = va_arg(vargs, int);
    6404:	f856 4b04 	ldr.w	r4, [r6], #4
				c = *format++;
    6408:	f108 0801 	add.w	r8, r8, #1
				c = *format++;
    640c:	f818 5b01 	ldrb.w	r5, [r8], #1
			if (strchr("hlz", c) != NULL) {
    6410:	4893      	ldr	r0, [pc, #588]	; (6660 <z_prf+0x2ec>)
    6412:	4629      	mov	r1, r5
    6414:	462f      	mov	r7, r5
    6416:	f00f fdd0 	bl	15fba <strchr>
    641a:	2800      	cmp	r0, #0
    641c:	d06a      	beq.n	64f4 <z_prf+0x180>
				c = *format++;
    641e:	4643      	mov	r3, r8
				} else if (i == 'h' && c == 'h') {
    6420:	2f68      	cmp	r7, #104	; 0x68
				c = *format++;
    6422:	f813 5b01 	ldrb.w	r5, [r3], #1
    6426:	9306      	str	r3, [sp, #24]
				} else if (i == 'h' && c == 'h') {
    6428:	d107      	bne.n	643a <z_prf+0xc6>
    642a:	2d68      	cmp	r5, #104	; 0x68
    642c:	d105      	bne.n	643a <z_prf+0xc6>
					c = *format++;
    642e:	f108 0302 	add.w	r3, r8, #2
    6432:	f898 5001 	ldrb.w	r5, [r8, #1]
    6436:	9306      	str	r3, [sp, #24]
					i = 'H';
    6438:	2748      	movs	r7, #72	; 0x48
			switch (c) {
    643a:	2d78      	cmp	r5, #120	; 0x78
    643c:	d808      	bhi.n	6450 <z_prf+0xdc>
    643e:	2d57      	cmp	r5, #87	; 0x57
    6440:	d85c      	bhi.n	64fc <z_prf+0x188>
    6442:	2d25      	cmp	r5, #37	; 0x25
    6444:	f000 83f2 	beq.w	6c2c <z_prf+0x8b8>
    6448:	f200 80a2 	bhi.w	6590 <z_prf+0x21c>
    644c:	2d00      	cmp	r5, #0
    644e:	d0aa      	beq.n	63a6 <z_prf+0x32>
				PUTC('%');
    6450:	9b03      	ldr	r3, [sp, #12]
    6452:	4649      	mov	r1, r9
    6454:	2025      	movs	r0, #37	; 0x25
    6456:	4798      	blx	r3
    6458:	3001      	adds	r0, #1
    645a:	d0a1      	beq.n	63a0 <z_prf+0x2c>
				PUTC(c);
    645c:	9b03      	ldr	r3, [sp, #12]
    645e:	4649      	mov	r1, r9
    6460:	4628      	mov	r0, r5
    6462:	4798      	blx	r3
    6464:	3001      	adds	r0, #1
    6466:	d09b      	beq.n	63a0 <z_prf+0x2c>
				count += 2;
    6468:	9b02      	ldr	r3, [sp, #8]
    646a:	3302      	adds	r3, #2
    646c:	e3e4      	b.n	6c38 <z_prf+0x8c4>
				switch (c) {
    646e:	2d2d      	cmp	r5, #45	; 0x2d
    6470:	d00e      	beq.n	6490 <z_prf+0x11c>
					fzero = true;
    6472:	2d30      	cmp	r5, #48	; 0x30
    6474:	9b08      	ldr	r3, [sp, #32]
    6476:	bf08      	it	eq
    6478:	2301      	moveq	r3, #1
    647a:	9308      	str	r3, [sp, #32]
    647c:	e7a0      	b.n	63c0 <z_prf+0x4c>
					fplus = true;
    647e:	2301      	movs	r3, #1
    6480:	9309      	str	r3, [sp, #36]	; 0x24
    6482:	e79d      	b.n	63c0 <z_prf+0x4c>
					fspace = true;
    6484:	2301      	movs	r3, #1
    6486:	930c      	str	r3, [sp, #48]	; 0x30
    6488:	e79a      	b.n	63c0 <z_prf+0x4c>
					falt = true;
    648a:	f04f 0a01 	mov.w	sl, #1
    648e:	e797      	b.n	63c0 <z_prf+0x4c>
				switch (c) {
    6490:	2301      	movs	r3, #1
    6492:	930d      	str	r3, [sp, #52]	; 0x34
    6494:	e794      	b.n	63c0 <z_prf+0x4c>
			fminus = fplus = fspace = falt = fzero = false;
    6496:	2300      	movs	r3, #0
    6498:	9308      	str	r3, [sp, #32]
    649a:	930c      	str	r3, [sp, #48]	; 0x30
    649c:	9309      	str	r3, [sp, #36]	; 0x24
    649e:	930d      	str	r3, [sp, #52]	; 0x34
    64a0:	469a      	mov	sl, r3
    64a2:	e78f      	b.n	63c4 <z_prf+0x50>
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    64a4:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
			} else if (!isdigit(c)) {
    64a8:	2b09      	cmp	r3, #9
				width = 0;
    64aa:	9007      	str	r0, [sp, #28]
			} else if (!isdigit(c)) {
    64ac:	d8a4      	bhi.n	63f8 <z_prf+0x84>
		i = 10 * i + *p++ - '0';
    64ae:	220a      	movs	r2, #10
	while (isdigit(*p)) {
    64b0:	f8dd 8018 	ldr.w	r8, [sp, #24]
    64b4:	f818 5b01 	ldrb.w	r5, [r8], #1
    64b8:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
    64bc:	2b09      	cmp	r3, #9
    64be:	d89b      	bhi.n	63f8 <z_prf+0x84>
		i = 10 * i + *p++ - '0';
    64c0:	9b07      	ldr	r3, [sp, #28]
    64c2:	fb02 5503 	mla	r5, r2, r3, r5
    64c6:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
    64ca:	e9cd 8306 	strd	r8, r3, [sp, #24]
    64ce:	e7ef      	b.n	64b0 <z_prf+0x13c>
    64d0:	fb01 3404 	mla	r4, r1, r4, r3
    64d4:	3c30      	subs	r4, #48	; 0x30
    64d6:	4690      	mov	r8, r2
	while (isdigit(*p)) {
    64d8:	4642      	mov	r2, r8
    64da:	f812 3b01 	ldrb.w	r3, [r2], #1
    64de:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    64e2:	2809      	cmp	r0, #9
    64e4:	d9f4      	bls.n	64d0 <z_prf+0x15c>
    64e6:	e791      	b.n	640c <z_prf+0x98>
	int i = 0;
    64e8:	2400      	movs	r4, #0
		i = 10 * i + *p++ - '0';
    64ea:	210a      	movs	r1, #10
    64ec:	e7f4      	b.n	64d8 <z_prf+0x164>
			precision = -1;
    64ee:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    64f2:	e78d      	b.n	6410 <z_prf+0x9c>
    64f4:	f8cd 8018 	str.w	r8, [sp, #24]
			i = 0;
    64f8:	4607      	mov	r7, r0
    64fa:	e79e      	b.n	643a <z_prf+0xc6>
    64fc:	f1a5 0358 	sub.w	r3, r5, #88	; 0x58
    6500:	2b20      	cmp	r3, #32
    6502:	d8a5      	bhi.n	6450 <z_prf+0xdc>
    6504:	a201      	add	r2, pc, #4	; (adr r2, 650c <z_prf+0x198>)
    6506:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    650a:	bf00      	nop
    650c:	00006b91 	.word	0x00006b91
    6510:	00006451 	.word	0x00006451
    6514:	00006451 	.word	0x00006451
    6518:	00006451 	.word	0x00006451
    651c:	00006451 	.word	0x00006451
    6520:	00006451 	.word	0x00006451
    6524:	00006451 	.word	0x00006451
    6528:	00006451 	.word	0x00006451
    652c:	00006451 	.word	0x00006451
    6530:	00006451 	.word	0x00006451
    6534:	00006451 	.word	0x00006451
    6538:	00006665 	.word	0x00006665
    653c:	0000673b 	.word	0x0000673b
    6540:	0000659d 	.word	0x0000659d
    6544:	0000659d 	.word	0x0000659d
    6548:	0000659d 	.word	0x0000659d
    654c:	00006451 	.word	0x00006451
    6550:	0000673b 	.word	0x0000673b
    6554:	00006451 	.word	0x00006451
    6558:	00006451 	.word	0x00006451
    655c:	00006451 	.word	0x00006451
    6560:	00006451 	.word	0x00006451
    6564:	00006b1d 	.word	0x00006b1d
    6568:	00006b91 	.word	0x00006b91
    656c:	00006b47 	.word	0x00006b47
    6570:	00006451 	.word	0x00006451
    6574:	00006451 	.word	0x00006451
    6578:	00006b69 	.word	0x00006b69
    657c:	00006451 	.word	0x00006451
    6580:	00006b91 	.word	0x00006b91
    6584:	00006451 	.word	0x00006451
    6588:	00006451 	.word	0x00006451
    658c:	00006b91 	.word	0x00006b91
			switch (c) {
    6590:	f1a5 0345 	sub.w	r3, r5, #69	; 0x45
    6594:	b2db      	uxtb	r3, r3
    6596:	2b02      	cmp	r3, #2
    6598:	f63f af5a 	bhi.w	6450 <z_prf+0xdc>
				u.d = va_arg(vargs, double);
    659c:	3607      	adds	r6, #7
    659e:	f026 0307 	bic.w	r3, r6, #7
    65a2:	4619      	mov	r1, r3
    65a4:	e8f1 2302 	ldrd	r2, r3, [r1], #8
	fract = (double_temp << 11) & ~HIGHBIT64;
    65a8:	02d8      	lsls	r0, r3, #11
    65aa:	ea40 5052 	orr.w	r0, r0, r2, lsr #21
    65ae:	02d6      	lsls	r6, r2, #11
    65b0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    65b4:	9604      	str	r6, [sp, #16]
    65b6:	9005      	str	r0, [sp, #20]
    65b8:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
	if (sign) {
    65bc:	2a00      	cmp	r2, #0
				u.d = va_arg(vargs, double);
    65be:	9101      	str	r1, [sp, #4]
	exp = double_temp >> 52 & 0x7ff;
    65c0:	f3c3 510a 	ubfx	r1, r3, #20, #11
	if (sign) {
    65c4:	f173 0300 	sbcs.w	r3, r3, #0
	fract = (double_temp << 11) & ~HIGHBIT64;
    65c8:	e9cd 6714 	strd	r6, r7, [sp, #80]	; 0x50
	if (sign) {
    65cc:	f280 80e5 	bge.w	679a <z_prf+0x426>
		*buf++ = '-';
    65d0:	232d      	movs	r3, #45	; 0x2d
		*buf++ = ' ';
    65d2:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    65d6:	f10d 0765 	add.w	r7, sp, #101	; 0x65
	if (exp == 0x7ff) {
    65da:	f240 73ff 	movw	r3, #2047	; 0x7ff
    65de:	4299      	cmp	r1, r3
    65e0:	f040 80f6 	bne.w	67d0 <z_prf+0x45c>
		if (!fract) {
    65e4:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
    65e8:	430a      	orrs	r2, r1
    65ea:	f1a5 0541 	sub.w	r5, r5, #65	; 0x41
    65ee:	f107 0303 	add.w	r3, r7, #3
    65f2:	f040 80e2 	bne.w	67ba <z_prf+0x446>
			if (isupper(c)) {
    65f6:	2d19      	cmp	r5, #25
    65f8:	f200 80d9 	bhi.w	67ae <z_prf+0x43a>
				*buf++ = 'I';
    65fc:	2249      	movs	r2, #73	; 0x49
    65fe:	703a      	strb	r2, [r7, #0]
				*buf++ = 'N';
    6600:	224e      	movs	r2, #78	; 0x4e
    6602:	707a      	strb	r2, [r7, #1]
				*buf++ = 'F';
    6604:	2246      	movs	r2, #70	; 0x46
		*buf = 0;
    6606:	2400      	movs	r4, #0
		return buf - start;
    6608:	ae19      	add	r6, sp, #100	; 0x64
				*buf++ = 'n';
    660a:	70ba      	strb	r2, [r7, #2]
		*buf = 0;
    660c:	70fc      	strb	r4, [r7, #3]
		return buf - start;
    660e:	1b9b      	subs	r3, r3, r6
			zero.predot = zero.postdot = zero.trail = 0;
    6610:	46a2      	mov	sl, r4
    6612:	46a3      	mov	fp, r4
				if (fplus || fspace || (buf[0] == '-')) {
    6614:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6616:	2a00      	cmp	r2, #0
    6618:	f040 827d 	bne.w	6b16 <z_prf+0x7a2>
    661c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    661e:	2a00      	cmp	r2, #0
    6620:	f040 8279 	bne.w	6b16 <z_prf+0x7a2>
    6624:	f89d 8064 	ldrb.w	r8, [sp, #100]	; 0x64
    6628:	f1a8 022d 	sub.w	r2, r8, #45	; 0x2d
    662c:	f1d2 0800 	rsbs	r8, r2, #0
    6630:	eb48 0802 	adc.w	r8, r8, r2
				clen += zero.predot + zero.postdot + zero.trail;
    6634:	eb0b 060a 	add.w	r6, fp, sl
    6638:	4433      	add	r3, r6
    663a:	191e      	adds	r6, r3, r4
				if (!isdigit(buf[prefix])) {
    663c:	ab20      	add	r3, sp, #128	; 0x80
    663e:	4443      	add	r3, r8
    6640:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    6644:	3b30      	subs	r3, #48	; 0x30
    6646:	2b09      	cmp	r3, #9
    6648:	f200 82fe 	bhi.w	6c48 <z_prf+0x8d4>
			} else if (fzero) {
    664c:	9b08      	ldr	r3, [sp, #32]
    664e:	2b00      	cmp	r3, #0
    6650:	f000 82fd 	beq.w	6c4e <z_prf+0x8da>
    6654:	9b07      	ldr	r3, [sp, #28]
    6656:	af19      	add	r7, sp, #100	; 0x64
    6658:	1b9b      	subs	r3, r3, r6
    665a:	e014      	b.n	6686 <z_prf+0x312>
    665c:	0001ad6a 	.word	0x0001ad6a
    6660:	0001ad70 	.word	0x0001ad70
				buf[0] = va_arg(vargs, int);
    6664:	4632      	mov	r2, r6
				break;
    6666:	f04f 0800 	mov.w	r8, #0
				buf[0] = va_arg(vargs, int);
    666a:	f852 3b04 	ldr.w	r3, [r2], #4
    666e:	9201      	str	r2, [sp, #4]
    6670:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
				clen = 1;
    6674:	2601      	movs	r6, #1
				break;
    6676:	4644      	mov	r4, r8
    6678:	af19      	add	r7, sp, #100	; 0x64
				zero_head = precision - clen + prefix;
    667a:	eb04 0308 	add.w	r3, r4, r8
			zero.predot = zero.postdot = zero.trail = 0;
    667e:	2400      	movs	r4, #0
				zero_head = precision - clen + prefix;
    6680:	1b9b      	subs	r3, r3, r6
			zero.predot = zero.postdot = zero.trail = 0;
    6682:	46a2      	mov	sl, r4
    6684:	46a3      	mov	fp, r4
			if (zero_head < 0) {
    6686:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
			width -= clen + zero_head;
    668a:	199a      	adds	r2, r3, r6
    668c:	9208      	str	r2, [sp, #32]
    668e:	9a07      	ldr	r2, [sp, #28]
    6690:	1999      	adds	r1, r3, r6
    6692:	1a55      	subs	r5, r2, r1
			if (!fminus && width > 0) {
    6694:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6696:	b912      	cbnz	r2, 669e <z_prf+0x32a>
    6698:	2d00      	cmp	r5, #0
    669a:	f300 82ed 	bgt.w	6c78 <z_prf+0x904>
			while (prefix-- > 0) {
    669e:	eb07 0208 	add.w	r2, r7, r8
    66a2:	42ba      	cmp	r2, r7
    66a4:	f040 82ea 	bne.w	6c7c <z_prf+0x908>
			while (zero_head-- > 0) {
    66a8:	3b01      	subs	r3, #1
    66aa:	f080 82f5 	bcs.w	6c98 <z_prf+0x924>
			clen -= prefix;
    66ae:	eba6 0608 	sub.w	r6, r6, r8
			if (zero.predot) {
    66b2:	f1bb 0f00 	cmp.w	fp, #0
    66b6:	d010      	beq.n	66da <z_prf+0x366>
				c = *cptr;
    66b8:	7838      	ldrb	r0, [r7, #0]
				while (isdigit(c)) {
    66ba:	eb07 0806 	add.w	r8, r7, r6
    66be:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    66c2:	2b09      	cmp	r3, #9
    66c4:	eba8 0607 	sub.w	r6, r8, r7
    66c8:	f240 82f1 	bls.w	6cae <z_prf+0x93a>
    66cc:	46d8      	mov	r8, fp
				while (zero.predot-- > 0) {
    66ce:	f1b8 0801 	subs.w	r8, r8, #1
    66d2:	f080 82f5 	bcs.w	6cc0 <z_prf+0x94c>
				clen -= zero.predot;
    66d6:	eba6 060b 	sub.w	r6, r6, fp
			if (zero.postdot) {
    66da:	f1ba 0f00 	cmp.w	sl, #0
    66de:	d016      	beq.n	670e <z_prf+0x39a>
    66e0:	eb07 0806 	add.w	r8, r7, r6
					c = *cptr++;
    66e4:	f817 bb01 	ldrb.w	fp, [r7], #1
					PUTC(c);
    66e8:	9b03      	ldr	r3, [sp, #12]
    66ea:	4649      	mov	r1, r9
    66ec:	4658      	mov	r0, fp
    66ee:	4798      	blx	r3
    66f0:	3001      	adds	r0, #1
    66f2:	f43f ae55 	beq.w	63a0 <z_prf+0x2c>
				} while (c != '.');
    66f6:	f1bb 0f2e 	cmp.w	fp, #46	; 0x2e
    66fa:	eba8 0607 	sub.w	r6, r8, r7
    66fe:	d1f1      	bne.n	66e4 <z_prf+0x370>
				while (zero.postdot-- > 0) {
    6700:	46d0      	mov	r8, sl
    6702:	f1b8 0f00 	cmp.w	r8, #0
    6706:	f300 82e4 	bgt.w	6cd2 <z_prf+0x95e>
				clen -= zero.postdot;
    670a:	eba6 060a 	sub.w	r6, r6, sl
			if (zero.trail) {
    670e:	b194      	cbz	r4, 6736 <z_prf+0x3c2>
				c = *cptr;
    6710:	7838      	ldrb	r0, [r7, #0]
				while (isdigit(c) || c == '.') {
    6712:	eb07 0806 	add.w	r8, r7, r6
    6716:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    671a:	2b09      	cmp	r3, #9
    671c:	eba8 0607 	sub.w	r6, r8, r7
    6720:	f240 82e2 	bls.w	6ce8 <z_prf+0x974>
    6724:	282e      	cmp	r0, #46	; 0x2e
    6726:	f000 82df 	beq.w	6ce8 <z_prf+0x974>
				while (zero.trail-- > 0) {
    672a:	46a0      	mov	r8, r4
    672c:	f1b8 0f00 	cmp.w	r8, #0
    6730:	f300 82e3 	bgt.w	6cfa <z_prf+0x986>
				clen -= zero.trail;
    6734:	1b36      	subs	r6, r6, r4
    6736:	443e      	add	r6, r7
    6738:	e2f2      	b.n	6d20 <z_prf+0x9ac>
				switch (i) {
    673a:	6835      	ldr	r5, [r6, #0]
	if (value < 0) {
    673c:	1d33      	adds	r3, r6, #4
    673e:	2d00      	cmp	r5, #0
    6740:	9301      	str	r3, [sp, #4]
    6742:	da1c      	bge.n	677e <z_prf+0x40a>
		*buf++ = '-';
    6744:	232d      	movs	r3, #45	; 0x2d
    6746:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
		value = -value;
    674a:	4269      	negs	r1, r5
		*buf++ = ' ';
    674c:	f10d 0665 	add.w	r6, sp, #101	; 0x65
	return _to_x(buf, value, 10);
    6750:	4630      	mov	r0, r6
    6752:	220a      	movs	r2, #10
    6754:	f00f fcdf 	bl	16116 <_to_x>
				if (fplus || fspace || val < 0) {
    6758:	9b09      	ldr	r3, [sp, #36]	; 0x24
	return (buf + _to_udec(buf, value)) - start;
    675a:	4406      	add	r6, r0
    675c:	a819      	add	r0, sp, #100	; 0x64
    675e:	1a36      	subs	r6, r6, r0
				if (fplus || fspace || val < 0) {
    6760:	2b00      	cmp	r3, #0
    6762:	f040 826c 	bne.w	6c3e <z_prf+0x8ca>
    6766:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6768:	2b00      	cmp	r3, #0
    676a:	f040 8268 	bne.w	6c3e <z_prf+0x8ca>
    676e:	ea4f 78d5 	mov.w	r8, r5, lsr #31
			if (precision >= 0) {
    6772:	2c00      	cmp	r4, #0
    6774:	da80      	bge.n	6678 <z_prf+0x304>
			zero.predot = zero.postdot = zero.trail = 0;
    6776:	2400      	movs	r4, #0
    6778:	46a2      	mov	sl, r4
    677a:	46a3      	mov	fp, r4
    677c:	e766      	b.n	664c <z_prf+0x2d8>
	} else if (fplus) {
    677e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6780:	b123      	cbz	r3, 678c <z_prf+0x418>
		*buf++ = '+';
    6782:	232b      	movs	r3, #43	; 0x2b
		*buf++ = ' ';
    6784:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    6788:	4629      	mov	r1, r5
    678a:	e7df      	b.n	674c <z_prf+0x3d8>
	} else if (fspace) {
    678c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    678e:	b10b      	cbz	r3, 6794 <z_prf+0x420>
		*buf++ = ' ';
    6790:	2320      	movs	r3, #32
    6792:	e7f7      	b.n	6784 <z_prf+0x410>
    6794:	4629      	mov	r1, r5
    6796:	ae19      	add	r6, sp, #100	; 0x64
    6798:	e7da      	b.n	6750 <z_prf+0x3dc>
	} else if (fplus) {
    679a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    679c:	b10b      	cbz	r3, 67a2 <z_prf+0x42e>
		*buf++ = '+';
    679e:	232b      	movs	r3, #43	; 0x2b
    67a0:	e717      	b.n	65d2 <z_prf+0x25e>
	} else if (fspace) {
    67a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    67a4:	b10b      	cbz	r3, 67aa <z_prf+0x436>
		*buf++ = ' ';
    67a6:	2320      	movs	r3, #32
    67a8:	e713      	b.n	65d2 <z_prf+0x25e>
    67aa:	af19      	add	r7, sp, #100	; 0x64
    67ac:	e715      	b.n	65da <z_prf+0x266>
				*buf++ = 'i';
    67ae:	2269      	movs	r2, #105	; 0x69
    67b0:	703a      	strb	r2, [r7, #0]
				*buf++ = 'n';
    67b2:	226e      	movs	r2, #110	; 0x6e
    67b4:	707a      	strb	r2, [r7, #1]
				*buf++ = 'f';
    67b6:	2266      	movs	r2, #102	; 0x66
    67b8:	e725      	b.n	6606 <z_prf+0x292>
			if (isupper(c)) {
    67ba:	2d19      	cmp	r5, #25
				*buf++ = 'N';
    67bc:	bf99      	ittee	ls
    67be:	224e      	movls	r2, #78	; 0x4e
				*buf++ = 'A';
    67c0:	2141      	movls	r1, #65	; 0x41
				*buf++ = 'n';
    67c2:	226e      	movhi	r2, #110	; 0x6e
				*buf++ = 'a';
    67c4:	2161      	movhi	r1, #97	; 0x61
				*buf++ = 'N';
    67c6:	bf94      	ite	ls
    67c8:	703a      	strbls	r2, [r7, #0]
				*buf++ = 'n';
    67ca:	703a      	strbhi	r2, [r7, #0]
				*buf++ = 'a';
    67cc:	7079      	strb	r1, [r7, #1]
    67ce:	e71a      	b.n	6606 <z_prf+0x292>
	if ((exp | fract) != 0) {
    67d0:	9b04      	ldr	r3, [sp, #16]
    67d2:	9805      	ldr	r0, [sp, #20]
    67d4:	430b      	orrs	r3, r1
    67d6:	930e      	str	r3, [sp, #56]	; 0x38
    67d8:	17cb      	asrs	r3, r1, #31
    67da:	4303      	orrs	r3, r0
    67dc:	930f      	str	r3, [sp, #60]	; 0x3c
    67de:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
		c = 'f';
    67e2:	2d46      	cmp	r5, #70	; 0x46
    67e4:	bf08      	it	eq
    67e6:	2566      	moveq	r5, #102	; 0x66
	if ((exp | fract) != 0) {
    67e8:	4313      	orrs	r3, r2
    67ea:	f000 8107 	beq.w	69fc <z_prf+0x688>
		if (exp == 0) {
    67ee:	2900      	cmp	r1, #0
    67f0:	f000 809f 	beq.w	6932 <z_prf+0x5be>
		fract |= HIGHBIT64;
    67f4:	9b15      	ldr	r3, [sp, #84]	; 0x54
    67f6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    67fa:	f2a1 38fe 	subw	r8, r1, #1022	; 0x3fe
		fract |= HIGHBIT64;
    67fe:	9315      	str	r3, [sp, #84]	; 0x54
    6800:	2600      	movs	r6, #0
	while (exp <= -3) {
    6802:	f118 0f02 	cmn.w	r8, #2
    6806:	f2c0 80a8 	blt.w	695a <z_prf+0x5e6>
	while (exp > 0) {
    680a:	f1b8 0f00 	cmp.w	r8, #0
    680e:	f300 80d4 	bgt.w	69ba <z_prf+0x646>
		_rlrshift(&fract);
    6812:	a814      	add	r0, sp, #80	; 0x50
		exp++;
    6814:	f108 0801 	add.w	r8, r8, #1
		_rlrshift(&fract);
    6818:	f00f fca1 	bl	1615e <_rlrshift>
	while (exp < (0 + 4)) {
    681c:	f1b8 0f04 	cmp.w	r8, #4
    6820:	d1f7      	bne.n	6812 <z_prf+0x49e>
		precision = 6;		/* Default precision if none given */
    6822:	2c00      	cmp	r4, #0
	if ((c == 'g') || (c == 'G')) {
    6824:	f005 03df 	and.w	r3, r5, #223	; 0xdf
		precision = 6;		/* Default precision if none given */
    6828:	bfb8      	it	lt
    682a:	2406      	movlt	r4, #6
	if ((c == 'g') || (c == 'G')) {
    682c:	2b47      	cmp	r3, #71	; 0x47
    682e:	f040 80ee 	bne.w	6a0e <z_prf+0x69a>
		if (decexp < (-4 + 1) || decexp > precision) {
    6832:	1cf1      	adds	r1, r6, #3
    6834:	db02      	blt.n	683c <z_prf+0x4c8>
    6836:	42b4      	cmp	r4, r6
    6838:	f280 80e3 	bge.w	6a02 <z_prf+0x68e>
			c += 'e' - 'g';
    683c:	3d02      	subs	r5, #2
    683e:	b2ed      	uxtb	r5, r5
			if (precision > 0) {
    6840:	2c00      	cmp	r4, #0
    6842:	f000 80ea 	beq.w	6a1a <z_prf+0x6a6>
				precision--;
    6846:	3c01      	subs	r4, #1
		if (!falt && (precision > 0)) {
    6848:	f1ba 0f00 	cmp.w	sl, #0
    684c:	f040 80e5 	bne.w	6a1a <z_prf+0x6a6>
    6850:	2c00      	cmp	r4, #0
    6852:	bfd4      	ite	le
    6854:	f04f 0800 	movle.w	r8, #0
    6858:	f04f 0801 	movgt.w	r8, #1
	if (c == 'f') {
    685c:	2d66      	cmp	r5, #102	; 0x66
    685e:	f040 80de 	bne.w	6a1e <z_prf+0x6aa>
		if (exp < 0) {
    6862:	eb14 0b06 	adds.w	fp, r4, r6
    6866:	f04f 0566 	mov.w	r5, #102	; 0x66
    686a:	f100 80db 	bmi.w	6a24 <z_prf+0x6b0>
	if (exp > 16) {
    686e:	f1bb 0f10 	cmp.w	fp, #16
    6872:	bfa8      	it	ge
    6874:	f04f 0b10 	movge.w	fp, #16
    6878:	2310      	movs	r3, #16
    687a:	9313      	str	r3, [sp, #76]	; 0x4c
	ltemp = 0x0800000000000000;
    687c:	2200      	movs	r2, #0
    687e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    6882:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
	while (exp--) {
    6886:	f1bb 0b01 	subs.w	fp, fp, #1
    688a:	f080 80ce 	bcs.w	6a2a <z_prf+0x6b6>
	fract += ltemp;
    688e:	9b14      	ldr	r3, [sp, #80]	; 0x50
    6890:	9a16      	ldr	r2, [sp, #88]	; 0x58
    6892:	9917      	ldr	r1, [sp, #92]	; 0x5c
    6894:	189b      	adds	r3, r3, r2
    6896:	9a15      	ldr	r2, [sp, #84]	; 0x54
    6898:	eb41 0202 	adc.w	r2, r1, r2
    689c:	e9cd 3214 	strd	r3, r2, [sp, #80]	; 0x50
	if ((fract >> 32) & 0xF0000000) {
    68a0:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    68a4:	9310      	str	r3, [sp, #64]	; 0x40
    68a6:	2300      	movs	r3, #0
    68a8:	9311      	str	r3, [sp, #68]	; 0x44
    68aa:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    68ae:	4313      	orrs	r3, r2
    68b0:	d006      	beq.n	68c0 <z_prf+0x54c>
		_ldiv5(&fract);
    68b2:	a814      	add	r0, sp, #80	; 0x50
    68b4:	f00f fc65 	bl	16182 <_ldiv5>
		_rlrshift(&fract);
    68b8:	a814      	add	r0, sp, #80	; 0x50
    68ba:	f00f fc50 	bl	1615e <_rlrshift>
		decexp++;
    68be:	3601      	adds	r6, #1
	if (c == 'f') {
    68c0:	2d66      	cmp	r5, #102	; 0x66
    68c2:	f040 80cf 	bne.w	6a64 <z_prf+0x6f0>
		if (decexp > 0) {
    68c6:	2e00      	cmp	r6, #0
    68c8:	f340 80b6 	ble.w	6a38 <z_prf+0x6c4>
			while (decexp > 0 && digit_count > 0) {
    68cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    68ce:	2b00      	cmp	r3, #0
    68d0:	dd07      	ble.n	68e2 <z_prf+0x56e>
				*buf++ = _get_digit(&fract, &digit_count);
    68d2:	a913      	add	r1, sp, #76	; 0x4c
    68d4:	a814      	add	r0, sp, #80	; 0x50
    68d6:	f00f fc7d 	bl	161d4 <_get_digit>
			while (decexp > 0 && digit_count > 0) {
    68da:	3e01      	subs	r6, #1
				*buf++ = _get_digit(&fract, &digit_count);
    68dc:	f807 0b01 	strb.w	r0, [r7], #1
			while (decexp > 0 && digit_count > 0) {
    68e0:	d1f4      	bne.n	68cc <z_prf+0x558>
			zp->predot = decexp;
    68e2:	46b3      	mov	fp, r6
    68e4:	463b      	mov	r3, r7
			decexp = 0;
    68e6:	2600      	movs	r6, #0
		if (falt || (precision > 0)) {
    68e8:	f1ba 0f00 	cmp.w	sl, #0
    68ec:	d101      	bne.n	68f2 <z_prf+0x57e>
    68ee:	2c00      	cmp	r4, #0
    68f0:	dd15      	ble.n	691e <z_prf+0x5aa>
			*buf++ = '.';
    68f2:	222e      	movs	r2, #46	; 0x2e
    68f4:	f803 2b01 	strb.w	r2, [r3], #1
		if (decexp < 0 && precision > 0) {
    68f8:	2e00      	cmp	r6, #0
    68fa:	f000 80ae 	beq.w	6a5a <z_prf+0x6e6>
    68fe:	2c00      	cmp	r4, #0
    6900:	f340 80ad 	ble.w	6a5e <z_prf+0x6ea>
			zp->postdot = -decexp;
    6904:	f1c6 0a00 	rsb	sl, r6, #0
    6908:	45a2      	cmp	sl, r4
    690a:	bfa8      	it	ge
    690c:	46a2      	movge	sl, r4
			precision -= zp->postdot;
    690e:	eba4 040a 	sub.w	r4, r4, sl
		while (precision > 0 && digit_count > 0) {
    6912:	2c00      	cmp	r4, #0
    6914:	dd03      	ble.n	691e <z_prf+0x5aa>
    6916:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    6918:	2a00      	cmp	r2, #0
    691a:	f300 8094 	bgt.w	6a46 <z_prf+0x6d2>
	if (prune_zero) {
    691e:	f1b8 0f00 	cmp.w	r8, #0
    6922:	f040 80b4 	bne.w	6a8e <z_prf+0x71a>
	*buf = 0;
    6926:	2200      	movs	r2, #0
	return buf - start;
    6928:	ae19      	add	r6, sp, #100	; 0x64
	*buf = 0;
    692a:	701a      	strb	r2, [r3, #0]
	return buf - start;
    692c:	1b9b      	subs	r3, r3, r6
    692e:	e671      	b.n	6614 <z_prf+0x2a0>
				exp--;
    6930:	3901      	subs	r1, #1
			while (((fract <<= 1) & HIGHBIT64) == 0) {
    6932:	9b04      	ldr	r3, [sp, #16]
    6934:	18db      	adds	r3, r3, r3
    6936:	9304      	str	r3, [sp, #16]
    6938:	9b05      	ldr	r3, [sp, #20]
    693a:	415b      	adcs	r3, r3
    693c:	9305      	str	r3, [sp, #20]
    693e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    6942:	2a00      	cmp	r2, #0
    6944:	f173 0300 	sbcs.w	r3, r3, #0
    6948:	daf2      	bge.n	6930 <z_prf+0x5bc>
    694a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    694e:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
    6952:	e74f      	b.n	67f4 <z_prf+0x480>
			_rlrshift(&fract);
    6954:	a814      	add	r0, sp, #80	; 0x50
    6956:	f00f fc02 	bl	1615e <_rlrshift>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    695a:	e9dd 2c14 	ldrd	r2, ip, [sp, #80]	; 0x50
    695e:	2300      	movs	r3, #0
    6960:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    6964:	930b      	str	r3, [sp, #44]	; 0x2c
    6966:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    696a:	2900      	cmp	r1, #0
    696c:	bf08      	it	eq
    696e:	f1b0 3f33 	cmpeq.w	r0, #858993459	; 0x33333333
    6972:	f108 0801 	add.w	r8, r8, #1
    6976:	d2ed      	bcs.n	6954 <z_prf+0x5e0>
		fract *= 5U;
    6978:	2005      	movs	r0, #5
    697a:	fba2 2300 	umull	r2, r3, r2, r0
    697e:	fb00 330c 	mla	r3, r0, ip, r3
    6982:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
		decexp--;
    6986:	3e01      	subs	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    6988:	f04f 0e00 	mov.w	lr, #0
    698c:	2100      	movs	r1, #0
    698e:	f04f 0c00 	mov.w	ip, #0
    6992:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
    6996:	458c      	cmp	ip, r1
    6998:	bf08      	it	eq
    699a:	459b      	cmpeq	fp, r3
    699c:	d206      	bcs.n	69ac <z_prf+0x638>
    699e:	f1be 0f00 	cmp.w	lr, #0
    69a2:	f43f af2e 	beq.w	6802 <z_prf+0x48e>
    69a6:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
    69aa:	e72a      	b.n	6802 <z_prf+0x48e>
			fract <<= 1;
    69ac:	1892      	adds	r2, r2, r2
    69ae:	415b      	adcs	r3, r3
			exp--;
    69b0:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    69b4:	f04f 0e01 	mov.w	lr, #1
    69b8:	e7e8      	b.n	698c <z_prf+0x618>
		_ldiv5(&fract);
    69ba:	a814      	add	r0, sp, #80	; 0x50
    69bc:	f00f fbe1 	bl	16182 <_ldiv5>
		exp--;
    69c0:	e9dd 1014 	ldrd	r1, r0, [sp, #80]	; 0x50
    69c4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		decexp++;
    69c8:	3601      	adds	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    69ca:	f04f 0e00 	mov.w	lr, #0
    69ce:	2300      	movs	r3, #0
    69d0:	f04f 0c00 	mov.w	ip, #0
    69d4:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
    69d8:	459c      	cmp	ip, r3
    69da:	bf08      	it	eq
    69dc:	4583      	cmpeq	fp, r0
    69de:	d206      	bcs.n	69ee <z_prf+0x67a>
    69e0:	f1be 0f00 	cmp.w	lr, #0
    69e4:	f43f af11 	beq.w	680a <z_prf+0x496>
    69e8:	e9cd 1014 	strd	r1, r0, [sp, #80]	; 0x50
    69ec:	e70d      	b.n	680a <z_prf+0x496>
			fract <<= 1;
    69ee:	1849      	adds	r1, r1, r1
    69f0:	4140      	adcs	r0, r0
			exp--;
    69f2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    69f6:	f04f 0e01 	mov.w	lr, #1
    69fa:	e7e8      	b.n	69ce <z_prf+0x65a>
    69fc:	2600      	movs	r6, #0
    69fe:	46b0      	mov	r8, r6
    6a00:	e707      	b.n	6812 <z_prf+0x49e>
			precision -= decexp;
    6a02:	1ba4      	subs	r4, r4, r6
		if (!falt && (precision > 0)) {
    6a04:	f1ba 0f00 	cmp.w	sl, #0
    6a08:	d104      	bne.n	6a14 <z_prf+0x6a0>
			c = 'f';
    6a0a:	2566      	movs	r5, #102	; 0x66
    6a0c:	e720      	b.n	6850 <z_prf+0x4dc>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    6a0e:	f04f 0800 	mov.w	r8, #0
    6a12:	e723      	b.n	685c <z_prf+0x4e8>
    6a14:	f04f 0800 	mov.w	r8, #0
    6a18:	e723      	b.n	6862 <z_prf+0x4ee>
    6a1a:	f04f 0800 	mov.w	r8, #0
		exp = precision + 1;
    6a1e:	f104 0b01 	add.w	fp, r4, #1
    6a22:	e724      	b.n	686e <z_prf+0x4fa>
			exp = 0;
    6a24:	f04f 0b00 	mov.w	fp, #0
    6a28:	e726      	b.n	6878 <z_prf+0x504>
		_ldiv5(&ltemp);
    6a2a:	a816      	add	r0, sp, #88	; 0x58
    6a2c:	f00f fba9 	bl	16182 <_ldiv5>
		_rlrshift(&ltemp);
    6a30:	a816      	add	r0, sp, #88	; 0x58
    6a32:	f00f fb94 	bl	1615e <_rlrshift>
    6a36:	e726      	b.n	6886 <z_prf+0x512>
			*buf++ = '0';
    6a38:	463b      	mov	r3, r7
    6a3a:	2230      	movs	r2, #48	; 0x30
    6a3c:	f803 2b01 	strb.w	r2, [r3], #1
			zero.predot = zero.postdot = zero.trail = 0;
    6a40:	f04f 0b00 	mov.w	fp, #0
    6a44:	e750      	b.n	68e8 <z_prf+0x574>
			*buf++ = _get_digit(&fract, &digit_count);
    6a46:	a913      	add	r1, sp, #76	; 0x4c
    6a48:	a814      	add	r0, sp, #80	; 0x50
    6a4a:	930a      	str	r3, [sp, #40]	; 0x28
    6a4c:	f00f fbc2 	bl	161d4 <_get_digit>
    6a50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			precision--;
    6a52:	3c01      	subs	r4, #1
			*buf++ = _get_digit(&fract, &digit_count);
    6a54:	f803 0b01 	strb.w	r0, [r3], #1
			precision--;
    6a58:	e75b      	b.n	6912 <z_prf+0x59e>
			zero.predot = zero.postdot = zero.trail = 0;
    6a5a:	46b2      	mov	sl, r6
    6a5c:	e759      	b.n	6912 <z_prf+0x59e>
    6a5e:	f04f 0a00 	mov.w	sl, #0
    6a62:	e75c      	b.n	691e <z_prf+0x5aa>
		*buf = _get_digit(&fract, &digit_count);
    6a64:	a913      	add	r1, sp, #76	; 0x4c
    6a66:	a814      	add	r0, sp, #80	; 0x50
    6a68:	f00f fbb4 	bl	161d4 <_get_digit>
		if (*buf++ != '0') {
    6a6c:	2830      	cmp	r0, #48	; 0x30
		*buf = _get_digit(&fract, &digit_count);
    6a6e:	7038      	strb	r0, [r7, #0]
			decexp--;
    6a70:	bf18      	it	ne
    6a72:	f106 36ff 	addne.w	r6, r6, #4294967295	; 0xffffffff
		if (falt || (precision > 0)) {
    6a76:	f1ba 0f00 	cmp.w	sl, #0
    6a7a:	d137      	bne.n	6aec <z_prf+0x778>
    6a7c:	2c00      	cmp	r4, #0
    6a7e:	dc35      	bgt.n	6aec <z_prf+0x778>
		if (*buf++ != '0') {
    6a80:	1c7b      	adds	r3, r7, #1
	if (prune_zero) {
    6a82:	f1b8 0f00 	cmp.w	r8, #0
    6a86:	d043      	beq.n	6b10 <z_prf+0x79c>
			zero.predot = zero.postdot = zero.trail = 0;
    6a88:	f04f 0b00 	mov.w	fp, #0
    6a8c:	46da      	mov	sl, fp
		while (*--buf == '0')
    6a8e:	4619      	mov	r1, r3
    6a90:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    6a94:	2a30      	cmp	r2, #48	; 0x30
    6a96:	d0fa      	beq.n	6a8e <z_prf+0x71a>
		if (*buf != '.') {
    6a98:	2a2e      	cmp	r2, #46	; 0x2e
    6a9a:	bf18      	it	ne
    6a9c:	460b      	movne	r3, r1
    6a9e:	2400      	movs	r4, #0
	if ((c == 'e') || (c == 'E')) {
    6aa0:	f005 02df 	and.w	r2, r5, #223	; 0xdf
    6aa4:	2a45      	cmp	r2, #69	; 0x45
    6aa6:	f47f af3e 	bne.w	6926 <z_prf+0x5b2>
		if (decexp < 0) {
    6aaa:	2e00      	cmp	r6, #0
		*buf++ = c;
    6aac:	4619      	mov	r1, r3
			decexp = -decexp;
    6aae:	bfba      	itte	lt
    6ab0:	4276      	neglt	r6, r6
			*buf++ = '-';
    6ab2:	222d      	movlt	r2, #45	; 0x2d
			*buf++ = '+';
    6ab4:	222b      	movge	r2, #43	; 0x2b
		if (decexp >= 100) {
    6ab6:	2e63      	cmp	r6, #99	; 0x63
		*buf++ = c;
    6ab8:	f801 5b02 	strb.w	r5, [r1], #2
			*buf++ = '-';
    6abc:	705a      	strb	r2, [r3, #1]
		if (decexp >= 100) {
    6abe:	dd08      	ble.n	6ad2 <z_prf+0x75e>
			*buf++ = (decexp / 100) + '0';
    6ac0:	2064      	movs	r0, #100	; 0x64
    6ac2:	fb96 f2f0 	sdiv	r2, r6, r0
    6ac6:	f102 0530 	add.w	r5, r2, #48	; 0x30
    6aca:	1cd9      	adds	r1, r3, #3
    6acc:	709d      	strb	r5, [r3, #2]
			decexp %= 100;
    6ace:	fb00 6612 	mls	r6, r0, r2, r6
		*buf++ = (decexp / 10) + '0';
    6ad2:	200a      	movs	r0, #10
    6ad4:	460b      	mov	r3, r1
    6ad6:	fb96 f2f0 	sdiv	r2, r6, r0
		decexp %= 10;
    6ada:	fb00 6612 	mls	r6, r0, r2, r6
		*buf++ = (decexp / 10) + '0';
    6ade:	f102 0530 	add.w	r5, r2, #48	; 0x30
		*buf++ = decexp + '0';
    6ae2:	3630      	adds	r6, #48	; 0x30
		*buf++ = (decexp / 10) + '0';
    6ae4:	f803 5b02 	strb.w	r5, [r3], #2
		*buf++ = decexp + '0';
    6ae8:	704e      	strb	r6, [r1, #1]
    6aea:	e71c      	b.n	6926 <z_prf+0x5b2>
			*buf++ = '.';
    6aec:	222e      	movs	r2, #46	; 0x2e
    6aee:	1cbb      	adds	r3, r7, #2
    6af0:	707a      	strb	r2, [r7, #1]
		while (precision > 0 && digit_count > 0) {
    6af2:	2c00      	cmp	r4, #0
    6af4:	ddc5      	ble.n	6a82 <z_prf+0x70e>
    6af6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    6af8:	2a00      	cmp	r2, #0
    6afa:	ddc2      	ble.n	6a82 <z_prf+0x70e>
			*buf++ = _get_digit(&fract, &digit_count);
    6afc:	a913      	add	r1, sp, #76	; 0x4c
    6afe:	a814      	add	r0, sp, #80	; 0x50
    6b00:	930a      	str	r3, [sp, #40]	; 0x28
    6b02:	f00f fb67 	bl	161d4 <_get_digit>
    6b06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			precision--;
    6b08:	3c01      	subs	r4, #1
			*buf++ = _get_digit(&fract, &digit_count);
    6b0a:	f803 0b01 	strb.w	r0, [r3], #1
			precision--;
    6b0e:	e7f0      	b.n	6af2 <z_prf+0x77e>
			zero.predot = zero.postdot = zero.trail = 0;
    6b10:	46c3      	mov	fp, r8
    6b12:	46c2      	mov	sl, r8
    6b14:	e7c4      	b.n	6aa0 <z_prf+0x72c>
					prefix = 1;
    6b16:	f04f 0801 	mov.w	r8, #1
    6b1a:	e58b      	b.n	6634 <z_prf+0x2c0>
				switch (i) {
    6b1c:	4632      	mov	r2, r6
    6b1e:	2f68      	cmp	r7, #104	; 0x68
    6b20:	f852 3b04 	ldr.w	r3, [r2], #4
    6b24:	9201      	str	r2, [sp, #4]
    6b26:	d006      	beq.n	6b36 <z_prf+0x7c2>
    6b28:	2f6c      	cmp	r7, #108	; 0x6c
    6b2a:	d009      	beq.n	6b40 <z_prf+0x7cc>
    6b2c:	2f48      	cmp	r7, #72	; 0x48
    6b2e:	d107      	bne.n	6b40 <z_prf+0x7cc>
					*va_arg(vargs, char *) = count;
    6b30:	9a02      	ldr	r2, [sp, #8]
    6b32:	701a      	strb	r2, [r3, #0]
					break;
    6b34:	e001      	b.n	6b3a <z_prf+0x7c6>
					*va_arg(vargs, short *) = count;
    6b36:	9a02      	ldr	r2, [sp, #8]
    6b38:	801a      	strh	r2, [r3, #0]
				continue;
    6b3a:	9e01      	ldr	r6, [sp, #4]
    6b3c:	9a06      	ldr	r2, [sp, #24]
    6b3e:	e421      	b.n	6384 <z_prf+0x10>
					*va_arg(vargs, int *) = count;
    6b40:	9a02      	ldr	r2, [sp, #8]
    6b42:	601a      	str	r2, [r3, #0]
					break;
    6b44:	e7f9      	b.n	6b3a <z_prf+0x7c6>
		*buf++ = '0';
    6b46:	f647 0330 	movw	r3, #30768	; 0x7830
    6b4a:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
	len = _to_x(buf, value, 16);
    6b4e:	4633      	mov	r3, r6
    6b50:	2210      	movs	r2, #16
    6b52:	f853 1b04 	ldr.w	r1, [r3], #4
    6b56:	9301      	str	r3, [sp, #4]
    6b58:	f10d 0066 	add.w	r0, sp, #102	; 0x66
    6b5c:	f00f fadb 	bl	16116 <_to_x>
				prefix = 2;
    6b60:	f04f 0802 	mov.w	r8, #2
	return len + (buf - buf0);
    6b64:	1c86      	adds	r6, r0, #2
				break;
    6b66:	e604      	b.n	6772 <z_prf+0x3fe>
				cptr = va_arg(vargs, char *);
    6b68:	4633      	mov	r3, r6
					precision = INT_MAX;
    6b6a:	2c00      	cmp	r4, #0
				cptr = va_arg(vargs, char *);
    6b6c:	f853 7b04 	ldr.w	r7, [r3], #4
    6b70:	9301      	str	r3, [sp, #4]
					precision = INT_MAX;
    6b72:	bfb8      	it	lt
    6b74:	f06f 4400 	mvnlt.w	r4, #2147483648	; 0x80000000
				for (clen = 0; clen < precision; clen++) {
    6b78:	2600      	movs	r6, #0
    6b7a:	42b4      	cmp	r4, r6
    6b7c:	d103      	bne.n	6b86 <z_prf+0x812>
    6b7e:	4626      	mov	r6, r4
    6b80:	2400      	movs	r4, #0
    6b82:	46a0      	mov	r8, r4
    6b84:	e579      	b.n	667a <z_prf+0x306>
					if (cptr[clen] == '\0') {
    6b86:	5dbb      	ldrb	r3, [r7, r6]
    6b88:	2b00      	cmp	r3, #0
    6b8a:	d05b      	beq.n	6c44 <z_prf+0x8d0>
				for (clen = 0; clen < precision; clen++) {
    6b8c:	3601      	adds	r6, #1
    6b8e:	e7f4      	b.n	6b7a <z_prf+0x806>
				switch (i) {
    6b90:	1d33      	adds	r3, r6, #4
				if (c == 'o') {
    6b92:	2d6f      	cmp	r5, #111	; 0x6f
    6b94:	6831      	ldr	r1, [r6, #0]
    6b96:	9301      	str	r3, [sp, #4]
    6b98:	d119      	bne.n	6bce <z_prf+0x85a>
	if (alt_form) {
    6b9a:	f1ba 0f00 	cmp.w	sl, #0
    6b9e:	d008      	beq.n	6bb2 <z_prf+0x83e>
		*buf++ = '0';
    6ba0:	2330      	movs	r3, #48	; 0x30
    6ba2:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
		if (!value) {
    6ba6:	b979      	cbnz	r1, 6bc8 <z_prf+0x854>
			*buf++ = 0;
    6ba8:	f88d 1065 	strb.w	r1, [sp, #101]	; 0x65
			prefix = 0;
    6bac:	4688      	mov	r8, r1
			return 1;
    6bae:	2601      	movs	r6, #1
    6bb0:	e5df      	b.n	6772 <z_prf+0x3fe>
    6bb2:	ad19      	add	r5, sp, #100	; 0x64
	return (buf - buf0) + _to_x(buf, value, 8);
    6bb4:	4628      	mov	r0, r5
    6bb6:	2208      	movs	r2, #8
    6bb8:	f00f faad 	bl	16116 <_to_x>
    6bbc:	ae19      	add	r6, sp, #100	; 0x64
    6bbe:	1bad      	subs	r5, r5, r6
    6bc0:	182e      	adds	r6, r5, r0
			prefix = 0;
    6bc2:	f04f 0800 	mov.w	r8, #0
    6bc6:	e5d4      	b.n	6772 <z_prf+0x3fe>
		*buf++ = '0';
    6bc8:	f10d 0565 	add.w	r5, sp, #101	; 0x65
    6bcc:	e7f2      	b.n	6bb4 <z_prf+0x840>
				} else if (c == 'u') {
    6bce:	2d75      	cmp	r5, #117	; 0x75
    6bd0:	d105      	bne.n	6bde <z_prf+0x86a>
	return _to_x(buf, value, 10);
    6bd2:	220a      	movs	r2, #10
    6bd4:	a819      	add	r0, sp, #100	; 0x64
    6bd6:	f00f fa9e 	bl	16116 <_to_x>
    6bda:	4606      	mov	r6, r0
    6bdc:	e7f1      	b.n	6bc2 <z_prf+0x84e>
	if (alt_form) {
    6bde:	f1ba 0f00 	cmp.w	sl, #0
    6be2:	d011      	beq.n	6c08 <z_prf+0x894>
		*buf++ = '0';
    6be4:	f647 0330 	movw	r3, #30768	; 0x7830
    6be8:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
		*buf++ = 'x';
    6bec:	f10d 0766 	add.w	r7, sp, #102	; 0x66
	len = _to_x(buf, value, 16);
    6bf0:	2210      	movs	r2, #16
    6bf2:	4638      	mov	r0, r7
    6bf4:	f00f fa8f 	bl	16116 <_to_x>
	if (prefix == 'X') {
    6bf8:	2d58      	cmp	r5, #88	; 0x58
    6bfa:	d007      	beq.n	6c0c <z_prf+0x898>
	return len + (buf - buf0);
    6bfc:	ae19      	add	r6, sp, #100	; 0x64
    6bfe:	1bbf      	subs	r7, r7, r6
    6c00:	183e      	adds	r6, r7, r0
						prefix = 2;
    6c02:	ea4f 084a 	mov.w	r8, sl, lsl #1
    6c06:	e5b4      	b.n	6772 <z_prf+0x3fe>
    6c08:	af19      	add	r7, sp, #100	; 0x64
    6c0a:	e7f1      	b.n	6bf0 <z_prf+0x87c>
    6c0c:	aa19      	add	r2, sp, #100	; 0x64
		if (*buf >= 'a' && *buf <= 'z') {
    6c0e:	f812 3b01 	ldrb.w	r3, [r2], #1
    6c12:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
    6c16:	2919      	cmp	r1, #25
    6c18:	d803      	bhi.n	6c22 <z_prf+0x8ae>
			*buf += 'A' - 'a';
    6c1a:	3b20      	subs	r3, #32
    6c1c:	f802 3c01 	strb.w	r3, [r2, #-1]
	} while (*buf++);
    6c20:	e7f5      	b.n	6c0e <z_prf+0x89a>
    6c22:	f812 3c01 	ldrb.w	r3, [r2, #-1]
    6c26:	2b00      	cmp	r3, #0
    6c28:	d1f1      	bne.n	6c0e <z_prf+0x89a>
    6c2a:	e7e7      	b.n	6bfc <z_prf+0x888>
				PUTC('%');
    6c2c:	4649      	mov	r1, r9
    6c2e:	4628      	mov	r0, r5
    6c30:	f7ff bbb1 	b.w	6396 <z_prf+0x22>
				count++;
    6c34:	9b02      	ldr	r3, [sp, #8]
    6c36:	3301      	adds	r3, #1
				continue;
    6c38:	e9cd 6301 	strd	r6, r3, [sp, #4]
    6c3c:	e77d      	b.n	6b3a <z_prf+0x7c6>
					prefix = 1;
    6c3e:	f04f 0801 	mov.w	r8, #1
    6c42:	e596      	b.n	6772 <z_prf+0x3fe>
    6c44:	461c      	mov	r4, r3
    6c46:	e79c      	b.n	6b82 <z_prf+0x80e>
			cptr = buf;
    6c48:	af19      	add	r7, sp, #100	; 0x64
				zero_head = 0;
    6c4a:	2300      	movs	r3, #0
    6c4c:	e51d      	b.n	668a <z_prf+0x316>
    6c4e:	9b08      	ldr	r3, [sp, #32]
    6c50:	af19      	add	r7, sp, #100	; 0x64
    6c52:	e51a      	b.n	668a <z_prf+0x316>
    6c54:	9309      	str	r3, [sp, #36]	; 0x24
					PUTC(' ');
    6c56:	4649      	mov	r1, r9
    6c58:	9b03      	ldr	r3, [sp, #12]
    6c5a:	9207      	str	r2, [sp, #28]
    6c5c:	2020      	movs	r0, #32
    6c5e:	4798      	blx	r3
    6c60:	3001      	adds	r0, #1
    6c62:	9a07      	ldr	r2, [sp, #28]
    6c64:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6c66:	f43f ab9b 	beq.w	63a0 <z_prf+0x2c>
				while (width-- > 0) {
    6c6a:	3a01      	subs	r2, #1
    6c6c:	d2f2      	bcs.n	6c54 <z_prf+0x8e0>
				count += width;
    6c6e:	9902      	ldr	r1, [sp, #8]
    6c70:	4429      	add	r1, r5
    6c72:	9102      	str	r1, [sp, #8]
				while (width-- > 0) {
    6c74:	4615      	mov	r5, r2
    6c76:	e512      	b.n	669e <z_prf+0x32a>
    6c78:	462a      	mov	r2, r5
    6c7a:	e7f6      	b.n	6c6a <z_prf+0x8f6>
    6c7c:	9309      	str	r3, [sp, #36]	; 0x24
				PUTC(*cptr++);
    6c7e:	f817 0b01 	ldrb.w	r0, [r7], #1
    6c82:	9b03      	ldr	r3, [sp, #12]
    6c84:	9207      	str	r2, [sp, #28]
    6c86:	4649      	mov	r1, r9
    6c88:	4798      	blx	r3
    6c8a:	3001      	adds	r0, #1
    6c8c:	9a07      	ldr	r2, [sp, #28]
    6c8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6c90:	f47f ad07 	bne.w	66a2 <z_prf+0x32e>
    6c94:	f7ff bb84 	b.w	63a0 <z_prf+0x2c>
    6c98:	9307      	str	r3, [sp, #28]
				PUTC('0');
    6c9a:	4649      	mov	r1, r9
    6c9c:	9b03      	ldr	r3, [sp, #12]
    6c9e:	2030      	movs	r0, #48	; 0x30
    6ca0:	4798      	blx	r3
    6ca2:	3001      	adds	r0, #1
    6ca4:	9b07      	ldr	r3, [sp, #28]
    6ca6:	f47f acff 	bne.w	66a8 <z_prf+0x334>
    6caa:	f7ff bb79 	b.w	63a0 <z_prf+0x2c>
					PUTC(c);
    6cae:	9b03      	ldr	r3, [sp, #12]
    6cb0:	4649      	mov	r1, r9
    6cb2:	4798      	blx	r3
    6cb4:	3001      	adds	r0, #1
    6cb6:	f43f ab73 	beq.w	63a0 <z_prf+0x2c>
					c = *++cptr;
    6cba:	f817 0f01 	ldrb.w	r0, [r7, #1]!
    6cbe:	e4fe      	b.n	66be <z_prf+0x34a>
					PUTC('0');
    6cc0:	9b03      	ldr	r3, [sp, #12]
    6cc2:	4649      	mov	r1, r9
    6cc4:	2030      	movs	r0, #48	; 0x30
    6cc6:	4798      	blx	r3
    6cc8:	3001      	adds	r0, #1
    6cca:	f47f ad00 	bne.w	66ce <z_prf+0x35a>
    6cce:	f7ff bb67 	b.w	63a0 <z_prf+0x2c>
					PUTC('0');
    6cd2:	9b03      	ldr	r3, [sp, #12]
    6cd4:	4649      	mov	r1, r9
    6cd6:	2030      	movs	r0, #48	; 0x30
    6cd8:	4798      	blx	r3
    6cda:	3001      	adds	r0, #1
    6cdc:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    6ce0:	f47f ad0f 	bne.w	6702 <z_prf+0x38e>
    6ce4:	f7ff bb5c 	b.w	63a0 <z_prf+0x2c>
					PUTC(c);
    6ce8:	9b03      	ldr	r3, [sp, #12]
    6cea:	4649      	mov	r1, r9
    6cec:	4798      	blx	r3
    6cee:	3001      	adds	r0, #1
    6cf0:	f43f ab56 	beq.w	63a0 <z_prf+0x2c>
					c = *++cptr;
    6cf4:	f817 0f01 	ldrb.w	r0, [r7, #1]!
    6cf8:	e50d      	b.n	6716 <z_prf+0x3a2>
					PUTC('0');
    6cfa:	9b03      	ldr	r3, [sp, #12]
    6cfc:	4649      	mov	r1, r9
    6cfe:	2030      	movs	r0, #48	; 0x30
    6d00:	4798      	blx	r3
    6d02:	3001      	adds	r0, #1
    6d04:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    6d08:	f47f ad10 	bne.w	672c <z_prf+0x3b8>
    6d0c:	f7ff bb48 	b.w	63a0 <z_prf+0x2c>
				PUTC(*cptr++);
    6d10:	f817 0b01 	ldrb.w	r0, [r7], #1
    6d14:	9b03      	ldr	r3, [sp, #12]
    6d16:	4649      	mov	r1, r9
    6d18:	4798      	blx	r3
    6d1a:	3001      	adds	r0, #1
    6d1c:	f43f ab40 	beq.w	63a0 <z_prf+0x2c>
			while (clen-- > 0) {
    6d20:	1bf3      	subs	r3, r6, r7
    6d22:	2b00      	cmp	r3, #0
    6d24:	dcf4      	bgt.n	6d10 <z_prf+0x99c>
			count += clen;
    6d26:	9b02      	ldr	r3, [sp, #8]
    6d28:	9a08      	ldr	r2, [sp, #32]
			if (width > 0) {
    6d2a:	2d00      	cmp	r5, #0
			count += clen;
    6d2c:	4413      	add	r3, r2
    6d2e:	9302      	str	r3, [sp, #8]
			if (width > 0) {
    6d30:	f77f af03 	ble.w	6b3a <z_prf+0x7c6>
    6d34:	462c      	mov	r4, r5
    6d36:	e006      	b.n	6d46 <z_prf+0x9d2>
					PUTC(' ');
    6d38:	9b03      	ldr	r3, [sp, #12]
    6d3a:	4649      	mov	r1, r9
    6d3c:	2020      	movs	r0, #32
    6d3e:	4798      	blx	r3
    6d40:	3001      	adds	r0, #1
    6d42:	f43f ab2d 	beq.w	63a0 <z_prf+0x2c>
				while (width-- > 0) {
    6d46:	3c01      	subs	r4, #1
    6d48:	d2f6      	bcs.n	6d38 <z_prf+0x9c4>
				count += width;
    6d4a:	9b02      	ldr	r3, [sp, #8]
    6d4c:	442b      	add	r3, r5
    6d4e:	9302      	str	r3, [sp, #8]
    6d50:	e6f3      	b.n	6b3a <z_prf+0x7c6>
    6d52:	bf00      	nop

00006d54 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    6d54:	4b01      	ldr	r3, [pc, #4]	; (6d5c <__stdout_hook_install+0x8>)
    6d56:	6018      	str	r0, [r3, #0]
}
    6d58:	4770      	bx	lr
    6d5a:	bf00      	nop
    6d5c:	2000bd98 	.word	0x2000bd98

00006d60 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
    6d60:	b40c      	push	{r2, r3}
    6d62:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    6d64:	b909      	cbnz	r1, 6d6a <snprintf+0xa>
		s = &dummy; /* write final NUL to dummy, can't change *s */
    6d66:	f10d 0003 	add.w	r0, sp, #3
	}

	p.ptr = s;
	p.len = (int) len;
    6d6a:	e9cd 0102 	strd	r0, r1, [sp, #8]

	va_start(vargs, format);
    6d6e:	ab07      	add	r3, sp, #28
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    6d70:	9a06      	ldr	r2, [sp, #24]
    6d72:	4806      	ldr	r0, [pc, #24]	; (6d8c <snprintf+0x2c>)
	va_start(vargs, format);
    6d74:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    6d76:	a902      	add	r1, sp, #8
    6d78:	f7ff fafc 	bl	6374 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    6d7c:	9b02      	ldr	r3, [sp, #8]
    6d7e:	2200      	movs	r2, #0
    6d80:	701a      	strb	r2, [r3, #0]
	return r;
}
    6d82:	b005      	add	sp, #20
    6d84:	f85d eb04 	ldr.w	lr, [sp], #4
    6d88:	b002      	add	sp, #8
    6d8a:	4770      	bx	lr
    6d8c:	00016209 	.word	0x00016209

00006d90 <sprintf>:

int sprintf(char *_MLIBC_RESTRICT s, const char *_MLIBC_RESTRICT format, ...)
{
    6d90:	b40e      	push	{r1, r2, r3}
    6d92:	b50f      	push	{r0, r1, r2, r3, lr}
    6d94:	ab05      	add	r3, sp, #20

	struct emitter p;
	int     r;

	p.ptr = s;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    6d96:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
    6d9a:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = s;
    6d9e:	9002      	str	r0, [sp, #8]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    6da0:	9103      	str	r1, [sp, #12]

	va_start(vargs, format);
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    6da2:	4806      	ldr	r0, [pc, #24]	; (6dbc <sprintf+0x2c>)
	va_start(vargs, format);
    6da4:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    6da6:	a902      	add	r1, sp, #8
    6da8:	f7ff fae4 	bl	6374 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    6dac:	9b02      	ldr	r3, [sp, #8]
    6dae:	2200      	movs	r2, #0
    6db0:	701a      	strb	r2, [r3, #0]
	return r;
}
    6db2:	b004      	add	sp, #16
    6db4:	f85d eb04 	ldr.w	lr, [sp], #4
    6db8:	b003      	add	sp, #12
    6dba:	4770      	bx	lr
    6dbc:	00016209 	.word	0x00016209

00006dc0 <vsnprintf>:

int vsnprintf(char *_MLIBC_RESTRICT s, size_t len,
	      const char *_MLIBC_RESTRICT format, va_list vargs)
{
    6dc0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    6dc2:	b909      	cbnz	r1, 6dc8 <vsnprintf+0x8>
		s = &dummy; /* write final NUL to dummy, can't change * *s */
    6dc4:	f10d 0007 	add.w	r0, sp, #7
	}

	p.ptr = s;
	p.len = (int) len;
    6dc8:	e9cd 0102 	strd	r0, r1, [sp, #8]

	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    6dcc:	a902      	add	r1, sp, #8
    6dce:	4804      	ldr	r0, [pc, #16]	; (6de0 <vsnprintf+0x20>)
    6dd0:	f7ff fad0 	bl	6374 <z_prf>

	*(p.ptr) = 0;
    6dd4:	9b02      	ldr	r3, [sp, #8]
    6dd6:	2200      	movs	r2, #0
    6dd8:	701a      	strb	r2, [r3, #0]
	return r;
}
    6dda:	b005      	add	sp, #20
    6ddc:	f85d fb04 	ldr.w	pc, [sp], #4
    6de0:	00016209 	.word	0x00016209

00006de4 <gmtime_r>:
 * due to time zone, leap seconds, or a different epoch must be
 * applied to @p time before invoking this function.
 */
struct tm *gmtime_r(const time_t *_MLIBC_RESTRICT timep,
		    struct tm *_MLIBC_RESTRICT tp)
{
    6de4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	time_t z = *timep;
    6de8:	e9d0 6700 	ldrd	r6, r7, [r0]
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    6dec:	2e00      	cmp	r6, #0
    6dee:	f177 0300 	sbcs.w	r3, r7, #0
{
    6df2:	468a      	mov	sl, r1
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    6df4:	f280 80ab 	bge.w	6f4e <gmtime_r+0x16a>
    6df8:	4865      	ldr	r0, [pc, #404]	; (6f90 <gmtime_r+0x1ac>)
    6dfa:	4a66      	ldr	r2, [pc, #408]	; (6f94 <gmtime_r+0x1b0>)
    6dfc:	1830      	adds	r0, r6, r0
    6dfe:	f04f 0300 	mov.w	r3, #0
    6e02:	f147 31ff 	adc.w	r1, r7, #4294967295	; 0xffffffff
    6e06:	f7f9 fd2d 	bl	864 <__aeabi_ldivmod>
	unsigned int rem = z - days * 86400;
    6e0a:	4b63      	ldr	r3, [pc, #396]	; (6f98 <gmtime_r+0x1b4>)
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    6e0c:	4604      	mov	r4, r0
	unsigned int rem = z - days * 86400;
    6e0e:	fb03 6600 	mla	r6, r3, r0, r6
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    6e12:	460d      	mov	r5, r1

	*tp = (struct tm){ 0 };
    6e14:	2224      	movs	r2, #36	; 0x24
    6e16:	2100      	movs	r1, #0
    6e18:	4650      	mov	r0, sl
    6e1a:	f00f f939 	bl	16090 <memset>
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
    6e1e:	f06f 0203 	mvn.w	r2, #3
    6e22:	4294      	cmp	r4, r2
    6e24:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6e28:	eb75 0303 	sbcs.w	r3, r5, r3
    6e2c:	f04f 0207 	mov.w	r2, #7
    6e30:	f04f 0300 	mov.w	r3, #0
    6e34:	f2c0 8090 	blt.w	6f58 <gmtime_r+0x174>
    6e38:	1d20      	adds	r0, r4, #4
    6e3a:	f145 0100 	adc.w	r1, r5, #0
    6e3e:	f7f9 fd11 	bl	864 <__aeabi_ldivmod>
	z += 719468;
    6e42:	4b56      	ldr	r3, [pc, #344]	; (6f9c <gmtime_r+0x1b8>)
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
    6e44:	f8ca 2018 	str.w	r2, [sl, #24]
	z += 719468;
    6e48:	eb14 0803 	adds.w	r8, r4, r3
    6e4c:	f04f 0300 	mov.w	r3, #0
    6e50:	eb45 0903 	adc.w	r9, r5, r3
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
    6e54:	f1b8 0f00 	cmp.w	r8, #0
    6e58:	f179 0300 	sbcs.w	r3, r9, #0
    6e5c:	f280 8083 	bge.w	6f66 <gmtime_r+0x182>
    6e60:	484f      	ldr	r0, [pc, #316]	; (6fa0 <gmtime_r+0x1bc>)
    6e62:	4a50      	ldr	r2, [pc, #320]	; (6fa4 <gmtime_r+0x1c0>)
    6e64:	1820      	adds	r0, r4, r0
    6e66:	f04f 0100 	mov.w	r1, #0
    6e6a:	f04f 0300 	mov.w	r3, #0
    6e6e:	eb45 0101 	adc.w	r1, r5, r1
    6e72:	f7f9 fcf7 	bl	864 <__aeabi_ldivmod>
	unsigned int doe = (z - era * (bigint_type)146097);
    6e76:	4b4c      	ldr	r3, [pc, #304]	; (6fa8 <gmtime_r+0x1c4>)
    6e78:	fb03 8800 	mla	r8, r3, r0, r8
	bigint_type y = (time_t)yoe + era * 400;
    6e7c:	f44f 7cc8 	mov.w	ip, #400	; 0x190
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    6e80:	f648 62ac 	movw	r2, #36524	; 0x8eac
    6e84:	fbb8 f2f2 	udiv	r2, r8, r2
    6e88:	4442      	add	r2, r8
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
    6e8a:	460f      	mov	r7, r1
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    6e8c:	f240 55b4 	movw	r5, #1460	; 0x5b4
	bigint_type y = (time_t)yoe + era * 400;
    6e90:	fba0 010c 	umull	r0, r1, r0, ip
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    6e94:	fbb8 f3f5 	udiv	r3, r8, r5
    6e98:	1ad2      	subs	r2, r2, r3
	bigint_type y = (time_t)yoe + era * 400;
    6e9a:	fb0c 1107 	mla	r1, ip, r7, r1
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    6e9e:	4b43      	ldr	r3, [pc, #268]	; (6fac <gmtime_r+0x1c8>)
    6ea0:	fbb8 f3f3 	udiv	r3, r8, r3
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    6ea4:	f04f 0e64 	mov.w	lr, #100	; 0x64
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    6ea8:	1ad2      	subs	r2, r2, r3
    6eaa:	f240 136d 	movw	r3, #365	; 0x16d
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    6eae:	fbb2 f5f5 	udiv	r5, r2, r5
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    6eb2:	fbb2 f4f3 	udiv	r4, r2, r3
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    6eb6:	fbb4 f7fe 	udiv	r7, r4, lr
    6eba:	1b7d      	subs	r5, r7, r5
	bigint_type y = (time_t)yoe + era * 400;
    6ebc:	1900      	adds	r0, r0, r4
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    6ebe:	44a8      	add	r8, r5
	bigint_type y = (time_t)yoe + era * 400;
    6ec0:	f141 0100 	adc.w	r1, r1, #0
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    6ec4:	fb03 8314 	mls	r3, r3, r4, r8
	bigint_type y = (time_t)yoe + era * 400;
    6ec8:	e9cd 0100 	strd	r0, r1, [sp]
	unsigned int mp = (5U * doy + 2U) / 153U;
    6ecc:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
    6ed0:	2199      	movs	r1, #153	; 0x99
    6ed2:	f10c 0c02 	add.w	ip, ip, #2
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
    6ed6:	f103 0801 	add.w	r8, r3, #1
	unsigned int mp = (5U * doy + 2U) / 153U;
    6eda:	fbbc f5f1 	udiv	r5, ip, r1
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
    6ede:	4369      	muls	r1, r5
    6ee0:	3102      	adds	r1, #2
    6ee2:	f04f 0905 	mov.w	r9, #5
    6ee6:	fbb1 f1f9 	udiv	r1, r1, r9
    6eea:	eba8 0101 	sub.w	r1, r8, r1
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
    6eee:	f240 58f9 	movw	r8, #1529	; 0x5f9
    6ef2:	45c4      	cmp	ip, r8
	tp->tm_year = y + (m <= 2) - 1900;
    6ef4:	9800      	ldr	r0, [sp, #0]
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
    6ef6:	bf94      	ite	ls
    6ef8:	f04f 0c03 	movls.w	ip, #3
    6efc:	f06f 0c08 	mvnhi.w	ip, #8
    6f00:	4465      	add	r5, ip
	tp->tm_year = y + (m <= 2) - 1900;
    6f02:	f2a0 706c 	subw	r0, r0, #1900	; 0x76c
    6f06:	2d02      	cmp	r5, #2
    6f08:	bf98      	it	ls
    6f0a:	3001      	addls	r0, #1
	tp->tm_mon = m - 1;
    6f0c:	3d01      	subs	r5, #1
	if (doy >= 306U) {
    6f0e:	f5b3 7f99 	cmp.w	r3, #306	; 0x132
	tp->tm_mday = d;
    6f12:	e9ca 1503 	strd	r1, r5, [sl, #12]
	tp->tm_year = y + (m <= 2) - 1900;
    6f16:	f8ca 0014 	str.w	r0, [sl, #20]
	if (doy >= 306U) {
    6f1a:	d329      	bcc.n	6f70 <gmtime_r+0x18c>
		tp->tm_yday = doy - 306U;
    6f1c:	f5a3 7399 	sub.w	r3, r3, #306	; 0x132

	time_civil_from_days(days, tp);

	tp->tm_hour = rem / 60U / 60U;
    6f20:	f44f 6261 	mov.w	r2, #3600	; 0xe10
		tp->tm_yday = doy + 59U + (((yoe % 4U == 0U) && (yoe % 100U != 0U)) || (yoe == 0U));
    6f24:	f8ca 301c 	str.w	r3, [sl, #28]
	tp->tm_hour = rem / 60U / 60U;
    6f28:	fbb6 f3f2 	udiv	r3, r6, r2
	rem -= tp->tm_hour * 60 * 60;
    6f2c:	fb02 6613 	mls	r6, r2, r3, r6
	tp->tm_min = rem / 60;
    6f30:	223c      	movs	r2, #60	; 0x3c
	tp->tm_hour = rem / 60U / 60U;
    6f32:	f8ca 3008 	str.w	r3, [sl, #8]
	tp->tm_sec = rem - tp->tm_min * 60;

	return tp;
}
    6f36:	4650      	mov	r0, sl
	tp->tm_min = rem / 60;
    6f38:	fbb6 f3f2 	udiv	r3, r6, r2
	tp->tm_sec = rem - tp->tm_min * 60;
    6f3c:	fb02 6613 	mls	r6, r2, r3, r6
	tp->tm_min = rem / 60;
    6f40:	f8ca 3004 	str.w	r3, [sl, #4]
	tp->tm_sec = rem - tp->tm_min * 60;
    6f44:	f8ca 6000 	str.w	r6, [sl]
}
    6f48:	b002      	add	sp, #8
    6f4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    6f4e:	4a11      	ldr	r2, [pc, #68]	; (6f94 <gmtime_r+0x1b0>)
    6f50:	2300      	movs	r3, #0
    6f52:	4630      	mov	r0, r6
    6f54:	4639      	mov	r1, r7
    6f56:	e756      	b.n	6e06 <gmtime_r+0x22>
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
    6f58:	1d60      	adds	r0, r4, #5
    6f5a:	f145 0100 	adc.w	r1, r5, #0
    6f5e:	f7f9 fc81 	bl	864 <__aeabi_ldivmod>
    6f62:	3206      	adds	r2, #6
    6f64:	e76d      	b.n	6e42 <gmtime_r+0x5e>
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
    6f66:	4a0f      	ldr	r2, [pc, #60]	; (6fa4 <gmtime_r+0x1c0>)
    6f68:	2300      	movs	r3, #0
    6f6a:	4640      	mov	r0, r8
    6f6c:	4649      	mov	r1, r9
    6f6e:	e780      	b.n	6e72 <gmtime_r+0x8e>
		tp->tm_yday = doy + 59U + (((yoe % 4U == 0U) && (yoe % 100U != 0U)) || (yoe == 0U));
    6f70:	07a1      	lsls	r1, r4, #30
    6f72:	d102      	bne.n	6f7a <gmtime_r+0x196>
    6f74:	fb0e 4417 	mls	r4, lr, r7, r4
    6f78:	b93c      	cbnz	r4, 6f8a <gmtime_r+0x1a6>
    6f7a:	f5b2 7fb6 	cmp.w	r2, #364	; 0x16c
    6f7e:	bf8c      	ite	hi
    6f80:	2200      	movhi	r2, #0
    6f82:	2201      	movls	r2, #1
    6f84:	333b      	adds	r3, #59	; 0x3b
    6f86:	4413      	add	r3, r2
    6f88:	e7ca      	b.n	6f20 <gmtime_r+0x13c>
    6f8a:	2201      	movs	r2, #1
    6f8c:	e7fa      	b.n	6f84 <gmtime_r+0x1a0>
    6f8e:	bf00      	nop
    6f90:	fffeae81 	.word	0xfffeae81
    6f94:	00015180 	.word	0x00015180
    6f98:	fffeae80 	.word	0xfffeae80
    6f9c:	000afa6c 	.word	0x000afa6c
    6fa0:	0008bfbc 	.word	0x0008bfbc
    6fa4:	00023ab1 	.word	0x00023ab1
    6fa8:	fffdc54f 	.word	0xfffdc54f
    6fac:	00023ab0 	.word	0x00023ab0

00006fb0 <gmtime>:

struct tm *gmtime(const time_t *timep)
{
	static struct tm shared;

	return gmtime_r(timep, &shared);
    6fb0:	4901      	ldr	r1, [pc, #4]	; (6fb8 <gmtime+0x8>)
    6fb2:	f7ff bf17 	b.w	6de4 <gmtime_r>
    6fb6:	bf00      	nop
    6fb8:	20002af4 	.word	0x20002af4

00006fbc <nordicsemi_nrf52_init>:
    6fbc:	f04f 0320 	mov.w	r3, #32
    6fc0:	f3ef 8211 	mrs	r2, BASEPRI
    6fc4:	f383 8811 	msr	BASEPRI, r3
    6fc8:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    6fcc:	4906      	ldr	r1, [pc, #24]	; (6fe8 <nordicsemi_nrf52_init+0x2c>)
    6fce:	2301      	movs	r3, #1
    6fd0:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    6fd4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    6fd8:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    6fdc:	f382 8811 	msr	BASEPRI, r2
    6fe0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    6fe4:	2000      	movs	r0, #0
    6fe6:	4770      	bx	lr
    6fe8:	4001e000 	.word	0x4001e000

00006fec <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    6fec:	b120      	cbz	r0, 6ff8 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    6fee:	4b03      	ldr	r3, [pc, #12]	; (6ffc <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    6ff0:	0180      	lsls	r0, r0, #6
    6ff2:	f043 0301 	orr.w	r3, r3, #1
    6ff6:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    6ff8:	4770      	bx	lr
    6ffa:	bf00      	nop
    6ffc:	00019720 	.word	0x00019720

00007000 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const u8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    7000:	4b0e      	ldr	r3, [pc, #56]	; (703c <bt_hex_real+0x3c>)
    7002:	2940      	cmp	r1, #64	; 0x40
{
    7004:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
    7006:	bf28      	it	cs
    7008:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    700a:	4c0d      	ldr	r4, [pc, #52]	; (7040 <bt_hex_real+0x40>)
    700c:	1846      	adds	r6, r0, r1
    700e:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
    7010:	42b0      	cmp	r0, r6
    7012:	f103 0302 	add.w	r3, r3, #2
    7016:	d104      	bne.n	7022 <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
    7018:	2300      	movs	r3, #0
    701a:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
    701e:	4807      	ldr	r0, [pc, #28]	; (703c <bt_hex_real+0x3c>)
    7020:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
    7022:	7802      	ldrb	r2, [r0, #0]
    7024:	0912      	lsrs	r2, r2, #4
    7026:	5ca2      	ldrb	r2, [r4, r2]
    7028:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    702c:	f810 2b01 	ldrb.w	r2, [r0], #1
    7030:	f002 020f 	and.w	r2, r2, #15
    7034:	5ca2      	ldrb	r2, [r4, r2]
    7036:	f803 2c01 	strb.w	r2, [r3, #-1]
	for (i = 0; i < len; i++) {
    703a:	e7e9      	b.n	7010 <bt_hex_real+0x10>
    703c:	20008672 	.word	0x20008672
    7040:	0001ad87 	.word	0x0001ad87

00007044 <hci_vendor_event>:
	return 0;
}
#endif /* CONFIG_BT_HCI_VS_EVT_USER */

static void hci_vendor_event(struct net_buf *buf)
{
    7044:	b510      	push	{r4, lr}
    7046:	4a0a      	ldr	r2, [pc, #40]	; (7070 <hci_vendor_event+0x2c>)
    7048:	4c0a      	ldr	r4, [pc, #40]	; (7074 <hci_vendor_event+0x30>)
	}
#endif /* CONFIG_BT_HCI_VS_EVT_USER */

	if (IS_ENABLED(CONFIG_BT_HCI_VS_EXT) && !handled) {
		/* do nothing at present time */
		BT_WARN("Unhandled vendor-specific event: %s",
    704a:	8981      	ldrh	r1, [r0, #12]
    704c:	6880      	ldr	r0, [r0, #8]
    704e:	1aa4      	subs	r4, r4, r2
    7050:	f7ff ffd6 	bl	7000 <bt_hex_real>
    7054:	f7fb fd1e 	bl	2a94 <log_strdup>
    7058:	08e4      	lsrs	r4, r4, #3
    705a:	01a4      	lsls	r4, r4, #6
    705c:	f044 0402 	orr.w	r4, r4, #2
    7060:	4601      	mov	r1, r0
    7062:	4622      	mov	r2, r4
    7064:	4804      	ldr	r0, [pc, #16]	; (7078 <hci_vendor_event+0x34>)
			bt_hex(buf->data, buf->len));
	}
}
    7066:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    706a:	f00e b8fb 	b.w	15264 <log_1>
    706e:	bf00      	nop
    7070:	0001956c 	.word	0x0001956c
    7074:	000195f4 	.word	0x000195f4
    7078:	0001ad98 	.word	0x0001ad98

0000707c <handle_event>:
{
    707c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    707e:	4605      	mov	r5, r0
    7080:	4608      	mov	r0, r1
		if (handler->event != event) {
    7082:	7811      	ldrb	r1, [r2, #0]
    7084:	8986      	ldrh	r6, [r0, #12]
    7086:	42a9      	cmp	r1, r5
    7088:	d007      	beq.n	709a <handle_event+0x1e>
	for (i = 0; i < num_handlers; i++) {
    708a:	2b02      	cmp	r3, #2
    708c:	d11c      	bne.n	70c8 <handle_event+0x4c>
		const struct event_handler *handler = &handlers[i];
    708e:	f102 0308 	add.w	r3, r2, #8
		if (handler->event != event) {
    7092:	7a12      	ldrb	r2, [r2, #8]
    7094:	42aa      	cmp	r2, r5
    7096:	d117      	bne.n	70c8 <handle_event+0x4c>
    7098:	461a      	mov	r2, r3
		if (buf->len < handler->min_len) {
    709a:	7853      	ldrb	r3, [r2, #1]
    709c:	42b3      	cmp	r3, r6
    709e:	d90e      	bls.n	70be <handle_event+0x42>
    70a0:	4a15      	ldr	r2, [pc, #84]	; (70f8 <handle_event+0x7c>)
    70a2:	4b16      	ldr	r3, [pc, #88]	; (70fc <handle_event+0x80>)
			BT_ERR("Too small (%u bytes) event 0x%02x",
    70a4:	4816      	ldr	r0, [pc, #88]	; (7100 <handle_event+0x84>)
    70a6:	1a9b      	subs	r3, r3, r2
    70a8:	08db      	lsrs	r3, r3, #3
    70aa:	019b      	lsls	r3, r3, #6
    70ac:	f043 0301 	orr.w	r3, r3, #1
    70b0:	462a      	mov	r2, r5
    70b2:	4631      	mov	r1, r6
}
    70b4:	b002      	add	sp, #8
    70b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			BT_ERR("Too small (%u bytes) event 0x%02x",
    70ba:	f00e b8e7 	b.w	1528c <log_2>
		handler->handler(buf);
    70be:	6853      	ldr	r3, [r2, #4]
}
    70c0:	b002      	add	sp, #8
    70c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		handler->handler(buf);
    70c6:	4718      	bx	r3
    70c8:	4b0b      	ldr	r3, [pc, #44]	; (70f8 <handle_event+0x7c>)
    70ca:	4c0c      	ldr	r4, [pc, #48]	; (70fc <handle_event+0x80>)
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    70cc:	6880      	ldr	r0, [r0, #8]
    70ce:	4631      	mov	r1, r6
    70d0:	1ae4      	subs	r4, r4, r3
    70d2:	f7ff ff95 	bl	7000 <bt_hex_real>
    70d6:	f7fb fcdd 	bl	2a94 <log_strdup>
    70da:	08e4      	lsrs	r4, r4, #3
    70dc:	01a4      	lsls	r4, r4, #6
    70de:	f044 0402 	orr.w	r4, r4, #2
    70e2:	4603      	mov	r3, r0
    70e4:	f8ad 4000 	strh.w	r4, [sp]
    70e8:	4806      	ldr	r0, [pc, #24]	; (7104 <handle_event+0x88>)
    70ea:	4632      	mov	r2, r6
    70ec:	4629      	mov	r1, r5
    70ee:	f00e f8e6 	bl	152be <log_3>
}
    70f2:	b002      	add	sp, #8
    70f4:	bd70      	pop	{r4, r5, r6, pc}
    70f6:	bf00      	nop
    70f8:	0001956c 	.word	0x0001956c
    70fc:	000195f4 	.word	0x000195f4
    7100:	0001adbc 	.word	0x0001adbc
    7104:	0001adde 	.word	0x0001adde

00007108 <hci_le_meta_event>:
#endif /* defined(CONFIG_BT_OBSERVER) */
#endif /* defined(CONFIG_BT_EXT_ADV) */
};

static void hci_le_meta_event(struct net_buf *buf)
{
    7108:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_meta_event *evt;

	evt = net_buf_pull_mem(buf, sizeof(*evt));
    710a:	2101      	movs	r1, #1
{
    710c:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    710e:	3008      	adds	r0, #8
    7110:	f00f ffef 	bl	170f2 <net_buf_simple_pull_mem>

	BT_DBG("subevent 0x%02x", evt->subevent);

	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    7114:	4621      	mov	r1, r4
    7116:	4a03      	ldr	r2, [pc, #12]	; (7124 <hci_le_meta_event+0x1c>)
    7118:	7800      	ldrb	r0, [r0, #0]
}
    711a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    711e:	2301      	movs	r3, #1
    7120:	f7ff bfac 	b.w	707c <handle_event>
    7124:	0001988c 	.word	0x0001988c

00007128 <hci_cmd_done>:
{
    7128:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    712c:	4607      	mov	r7, r0
    712e:	b085      	sub	sp, #20
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    7130:	7990      	ldrb	r0, [r2, #6]
    7132:	4e34      	ldr	r6, [pc, #208]	; (7204 <hci_cmd_done+0xdc>)
{
    7134:	4688      	mov	r8, r1
    7136:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    7138:	f006 fb3c 	bl	d7b4 <net_buf_pool_get>
    713c:	4286      	cmp	r6, r0
    713e:	d016      	beq.n	716e <hci_cmd_done+0x46>
    7140:	4b31      	ldr	r3, [pc, #196]	; (7208 <hci_cmd_done+0xe0>)
    7142:	4d32      	ldr	r5, [pc, #200]	; (720c <hci_cmd_done+0xe4>)
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    7144:	79a0      	ldrb	r0, [r4, #6]
    7146:	9700      	str	r7, [sp, #0]
    7148:	1aed      	subs	r5, r5, r3
    714a:	08ed      	lsrs	r5, r5, #3
    714c:	9001      	str	r0, [sp, #4]
    714e:	f006 fb31 	bl	d7b4 <net_buf_pool_get>
    7152:	01ad      	lsls	r5, r5, #6
    7154:	f045 0502 	orr.w	r5, r5, #2
    7158:	e9cd 0602 	strd	r0, r6, [sp, #8]
    715c:	462b      	mov	r3, r5
    715e:	482c      	ldr	r0, [pc, #176]	; (7210 <hci_cmd_done+0xe8>)
    7160:	2204      	movs	r2, #4
    7162:	4669      	mov	r1, sp
    7164:	f00e f8c7 	bl	152f6 <log_n>
}
    7168:	b005      	add	sp, #20
    716a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (cmd(buf)->opcode != opcode) {
    716e:	4620      	mov	r0, r4
    7170:	f006 fb26 	bl	d7c0 <net_buf_id>
    7174:	4d27      	ldr	r5, [pc, #156]	; (7214 <hci_cmd_done+0xec>)
    7176:	f04f 090c 	mov.w	r9, #12
    717a:	fb09 5300 	mla	r3, r9, r0, r5
    717e:	885b      	ldrh	r3, [r3, #2]
    7180:	42bb      	cmp	r3, r7
    7182:	d011      	beq.n	71a8 <hci_cmd_done+0x80>
    7184:	4b20      	ldr	r3, [pc, #128]	; (7208 <hci_cmd_done+0xe0>)
    7186:	4e21      	ldr	r6, [pc, #132]	; (720c <hci_cmd_done+0xe4>)
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    7188:	4620      	mov	r0, r4
    718a:	1af6      	subs	r6, r6, r3
    718c:	f006 fb18 	bl	d7c0 <net_buf_id>
    7190:	08f6      	lsrs	r6, r6, #3
    7192:	fb09 5000 	mla	r0, r9, r0, r5
    7196:	01b6      	lsls	r6, r6, #6
    7198:	f046 0602 	orr.w	r6, r6, #2
    719c:	8842      	ldrh	r2, [r0, #2]
    719e:	481e      	ldr	r0, [pc, #120]	; (7218 <hci_cmd_done+0xf0>)
    71a0:	4633      	mov	r3, r6
    71a2:	4639      	mov	r1, r7
    71a4:	f00e f872 	bl	1528c <log_2>
	if (cmd(buf)->state && !status) {
    71a8:	4620      	mov	r0, r4
    71aa:	f006 fb09 	bl	d7c0 <net_buf_id>
    71ae:	260c      	movs	r6, #12
    71b0:	fb06 5000 	mla	r0, r6, r0, r5
    71b4:	6843      	ldr	r3, [r0, #4]
    71b6:	b16b      	cbz	r3, 71d4 <hci_cmd_done+0xac>
    71b8:	f1b8 0f00 	cmp.w	r8, #0
    71bc:	d10a      	bne.n	71d4 <hci_cmd_done+0xac>
		struct cmd_state_set *update = cmd(buf)->state;
    71be:	4620      	mov	r0, r4
    71c0:	f006 fafe 	bl	d7c0 <net_buf_id>
    71c4:	fb06 5000 	mla	r0, r6, r0, r5
    71c8:	6843      	ldr	r3, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    71ca:	e9d3 0100 	ldrd	r0, r1, [r3]
    71ce:	7a1a      	ldrb	r2, [r3, #8]
    71d0:	f00f f841 	bl	16256 <atomic_set_bit_to>
	if (cmd(buf)->sync) {
    71d4:	4620      	mov	r0, r4
    71d6:	f006 faf3 	bl	d7c0 <net_buf_id>
    71da:	260c      	movs	r6, #12
    71dc:	fb06 5000 	mla	r0, r6, r0, r5
    71e0:	6883      	ldr	r3, [r0, #8]
    71e2:	2b00      	cmp	r3, #0
    71e4:	d0c0      	beq.n	7168 <hci_cmd_done+0x40>
		cmd(buf)->status = status;
    71e6:	4620      	mov	r0, r4
    71e8:	f006 faea 	bl	d7c0 <net_buf_id>
    71ec:	4370      	muls	r0, r6
    71ee:	f805 8000 	strb.w	r8, [r5, r0]
		k_sem_give(cmd(buf)->sync);
    71f2:	4620      	mov	r0, r4
    71f4:	f006 fae4 	bl	d7c0 <net_buf_id>
    71f8:	fb06 5500 	mla	r5, r6, r0, r5
    71fc:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    71fe:	f00d f875 	bl	142ec <z_impl_k_sem_give>
}
    7202:	e7b1      	b.n	7168 <hci_cmd_done+0x40>
    7204:	2000c3f0 	.word	0x2000c3f0
    7208:	0001956c 	.word	0x0001956c
    720c:	000195f4 	.word	0x000195f4
    7210:	0001ae00 	.word	0x0001ae00
    7214:	20002b18 	.word	0x20002b18
    7218:	0001ae35 	.word	0x0001ae35

0000721c <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
    721c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    721e:	4f0b      	ldr	r7, [pc, #44]	; (724c <id_find+0x30>)
{
    7220:	4606      	mov	r6, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    7222:	2500      	movs	r5, #0
    7224:	79fb      	ldrb	r3, [r7, #7]
    7226:	b2ec      	uxtb	r4, r5
    7228:	42a3      	cmp	r3, r4
    722a:	d802      	bhi.n	7232 <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    722c:	f06f 0401 	mvn.w	r4, #1
    7230:	e009      	b.n	7246 <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    7232:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
}

static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
    7236:	2207      	movs	r2, #7
    7238:	4439      	add	r1, r7
    723a:	4630      	mov	r0, r6
    723c:	f00e feed 	bl	1601a <memcmp>
    7240:	3501      	adds	r5, #1
    7242:	2800      	cmp	r0, #0
    7244:	d1ee      	bne.n	7224 <id_find+0x8>
}
    7246:	4620      	mov	r0, r4
    7248:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    724a:	bf00      	nop
    724c:	2000ba38 	.word	0x2000ba38

00007250 <le_adv_report>:
{
    7250:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t num_reports = net_buf_pull_u8(buf);
    7254:	f100 0708 	add.w	r7, r0, #8
{
    7258:	b08b      	sub	sp, #44	; 0x2c
    725a:	4604      	mov	r4, r0
	u8_t num_reports = net_buf_pull_u8(buf);
    725c:	4638      	mov	r0, r7
    725e:	f00f ff50 	bl	17102 <net_buf_simple_pull_u8>
	if (scan_dev_found_cb) {
    7262:	f8df a154 	ldr.w	sl, [pc, #340]	; 73b8 <le_adv_report+0x168>
	u8_t num_reports = net_buf_pull_u8(buf);
    7266:	9000      	str	r0, [sp, #0]
	while (num_reports--) {
    7268:	9b00      	ldr	r3, [sp, #0]
    726a:	b163      	cbz	r3, 7286 <le_adv_report+0x36>
		if (buf->len < sizeof(*evt)) {
    726c:	89a3      	ldrh	r3, [r4, #12]
    726e:	2b08      	cmp	r3, #8
    7270:	d80c      	bhi.n	728c <le_adv_report+0x3c>
    7272:	494b      	ldr	r1, [pc, #300]	; (73a0 <le_adv_report+0x150>)
    7274:	4b4b      	ldr	r3, [pc, #300]	; (73a4 <le_adv_report+0x154>)
			BT_ERR("Unexpected end of buffer");
    7276:	484c      	ldr	r0, [pc, #304]	; (73a8 <le_adv_report+0x158>)
    7278:	1ac9      	subs	r1, r1, r3
    727a:	08c9      	lsrs	r1, r1, #3
    727c:	0189      	lsls	r1, r1, #6
    727e:	f041 0101 	orr.w	r1, r1, #1
    7282:	f00d ffe2 	bl	1524a <log_0>
}
    7286:	b00b      	add	sp, #44	; 0x2c
    7288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		evt = net_buf_pull_mem(buf, sizeof(*evt));
    728c:	2109      	movs	r1, #9
    728e:	4638      	mov	r0, r7
    7290:	f00f ff2f 	bl	170f2 <net_buf_simple_pull_mem>
		adv_info.rssi = evt->data[evt->length];
    7294:	f890 9008 	ldrb.w	r9, [r0, #8]
    7298:	eb00 0309 	add.w	r3, r0, r9
		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);
    729c:	1c41      	adds	r1, r0, #1
		adv_info.rssi = evt->data[evt->length];
    729e:	7a5b      	ldrb	r3, [r3, #9]
    72a0:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    72a4:	2301      	movs	r3, #1
    72a6:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
    72aa:	237f      	movs	r3, #127	; 0x7f
    72ac:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
		adv_info.sid = BT_GAP_SID_INVALID;
    72b0:	23ff      	movs	r3, #255	; 0xff
    72b2:	f88d 3020 	strb.w	r3, [sp, #32]
		adv_info.adv_type = evt->evt_type;
    72b6:	7803      	ldrb	r3, [r0, #0]
    72b8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    72bc:	2b04      	cmp	r3, #4
    72be:	bf96      	itet	ls
    72c0:	4a3a      	ldrls	r2, [pc, #232]	; (73ac <le_adv_report+0x15c>)
    72c2:	2300      	movhi	r3, #0
    72c4:	5cd3      	ldrbls	r3, [r2, r3]
		adv_info.adv_props = get_adv_props(evt->evt_type);
    72c6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
		evt = net_buf_pull_mem(buf, sizeof(*evt));
    72ca:	4606      	mov	r6, r0
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    72cc:	4838      	ldr	r0, [pc, #224]	; (73b0 <le_adv_report+0x160>)
    72ce:	f00e ffaa 	bl	16226 <atomic_get>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    72d2:	0642      	lsls	r2, r0, #25
    72d4:	d50d      	bpl.n	72f2 <le_adv_report+0xa2>
	    atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN) &&
    72d6:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    72da:	075b      	lsls	r3, r3, #29
    72dc:	d509      	bpl.n	72f2 <le_adv_report+0xa2>
		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
    72de:	7a31      	ldrb	r1, [r6, #8]
    72e0:	4638      	mov	r0, r7
    72e2:	3101      	adds	r1, #1
    72e4:	f00f fefd 	bl	170e2 <net_buf_simple_pull>
    72e8:	9b00      	ldr	r3, [sp, #0]
    72ea:	1e58      	subs	r0, r3, #1
    72ec:	b2c3      	uxtb	r3, r0
    72ee:	9300      	str	r3, [sp, #0]
    72f0:	e7ba      	b.n	7268 <le_adv_report+0x18>
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    72f2:	7873      	ldrb	r3, [r6, #1]
    72f4:	1e9a      	subs	r2, r3, #2
    72f6:	2a01      	cmp	r2, #1
    72f8:	f10d 0b0c 	add.w	fp, sp, #12
    72fc:	d843      	bhi.n	7386 <le_adv_report+0x136>
		bt_addr_le_copy(&id_addr, addr);
    72fe:	4658      	mov	r0, fp
    7300:	f00e ff97 	bl	16232 <bt_addr_le_copy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    7304:	f89d 300c 	ldrb.w	r3, [sp, #12]
    7308:	3b02      	subs	r3, #2
    730a:	f88d 300c 	strb.w	r3, [sp, #12]
	if (scan_dev_found_cb) {
    730e:	f8da 3000 	ldr.w	r3, [sl]
	info->addr = &id_addr;
    7312:	f8cd b01c 	str.w	fp, [sp, #28]
	if (scan_dev_found_cb) {
    7316:	b1b3      	cbz	r3, 7346 <le_adv_report+0xf6>
 * @param state Storage for the state.
 */
static inline void net_buf_simple_save(struct net_buf_simple *buf,
				       struct net_buf_simple_state *state)
{
	state->offset = net_buf_simple_headroom(buf);
    7318:	4638      	mov	r0, r7
    731a:	f00f fefa 	bl	17112 <net_buf_simple_headroom>
	state->len = buf->len;
    731e:	89a3      	ldrh	r3, [r4, #12]
    7320:	9301      	str	r3, [sp, #4]
	state->offset = net_buf_simple_headroom(buf);
    7322:	4680      	mov	r8, r0
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type,
    7324:	463b      	mov	r3, r7
    7326:	4658      	mov	r0, fp
    7328:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    732c:	f99d 1021 	ldrsb.w	r1, [sp, #33]	; 0x21
    7330:	f8da 5000 	ldr.w	r5, [sl]
		buf->len = len;
    7334:	f8a4 900c 	strh.w	r9, [r4, #12]
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type,
    7338:	47a8      	blx	r5
 * @param state Stored state.
 */
static inline void net_buf_simple_restore(struct net_buf_simple *buf,
					  struct net_buf_simple_state *state)
{
	buf->data = buf->__buf + state->offset;
    733a:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    733c:	9b01      	ldr	r3, [sp, #4]
    733e:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf + state->offset;
    7340:	fa10 f088 	uxtah	r0, r0, r8
    7344:	60a0      	str	r0, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&scan_cbs, listener, node) {
    7346:	4b1b      	ldr	r3, [pc, #108]	; (73b4 <le_adv_report+0x164>)
    7348:	681d      	ldr	r5, [r3, #0]
    734a:	2d00      	cmp	r5, #0
    734c:	d0c7      	beq.n	72de <le_adv_report+0x8e>
    734e:	3d08      	subs	r5, #8
    7350:	2d00      	cmp	r5, #0
    7352:	d0c4      	beq.n	72de <le_adv_report+0x8e>
	state->offset = net_buf_simple_headroom(buf);
    7354:	4638      	mov	r0, r7
    7356:	f00f fedc 	bl	17112 <net_buf_simple_headroom>
		listener->recv(info, &buf->b);
    735a:	46ab      	mov	fp, r5
	state->len = buf->len;
    735c:	89a3      	ldrh	r3, [r4, #12]
    735e:	f85b 2b08 	ldr.w	r2, [fp], #8
		buf->len = len;
    7362:	f8a4 900c 	strh.w	r9, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    7366:	4680      	mov	r8, r0
		listener->recv(info, &buf->b);
    7368:	4639      	mov	r1, r7
    736a:	a807      	add	r0, sp, #28
	state->len = buf->len;
    736c:	9301      	str	r3, [sp, #4]
    736e:	4790      	blx	r2
	buf->data = buf->__buf + state->offset;
    7370:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    7372:	9b01      	ldr	r3, [sp, #4]
    7374:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf + state->offset;
    7376:	fa10 f088 	uxtah	r0, r0, r8
    737a:	60a0      	str	r0, [r4, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
    737c:	f1bb 0f00 	cmp.w	fp, #0
    7380:	d0ad      	beq.n	72de <le_adv_report+0x8e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    7382:	68ad      	ldr	r5, [r5, #8]
    7384:	e7e1      	b.n	734a <le_adv_report+0xfa>
	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
    7386:	2bff      	cmp	r3, #255	; 0xff
		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
    7388:	bf04      	itt	eq
    738a:	2300      	moveq	r3, #0
    738c:	a905      	addeq	r1, sp, #20
		bt_addr_le_copy(&id_addr,
    738e:	4658      	mov	r0, fp
		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
    7390:	bf04      	itt	eq
    7392:	9305      	streq	r3, [sp, #20]
    7394:	f8cd 3017 	streq.w	r3, [sp, #23]
		bt_addr_le_copy(&id_addr,
    7398:	f00e ff4b 	bl	16232 <bt_addr_le_copy>
    739c:	e7b7      	b.n	730e <le_adv_report+0xbe>
    739e:	bf00      	nop
    73a0:	000195f4 	.word	0x000195f4
    73a4:	0001956c 	.word	0x0001956c
    73a8:	0001ae68 	.word	0x0001ae68
    73ac:	0001b20b 	.word	0x0001b20b
    73b0:	2000bad0 	.word	0x2000bad0
    73b4:	20002b34 	.word	0x20002b34
    73b8:	20002b3c 	.word	0x20002b3c

000073bc <hci_cmd_status>:
{
    73bc:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    73be:	2104      	movs	r1, #4
{
    73c0:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    73c2:	3008      	adds	r0, #8
    73c4:	f00f fe95 	bl	170f2 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    73c8:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    73ca:	7801      	ldrb	r1, [r0, #0]
    73cc:	8840      	ldrh	r0, [r0, #2]
    73ce:	4622      	mov	r2, r4
    73d0:	f7ff feaa 	bl	7128 <hci_cmd_done>
	if (ncmd) {
    73d4:	b125      	cbz	r5, 73e0 <hci_cmd_status+0x24>
	z_impl_k_sem_give(sem);
    73d6:	4803      	ldr	r0, [pc, #12]	; (73e4 <hci_cmd_status+0x28>)
}
    73d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    73dc:	f00c bf86 	b.w	142ec <z_impl_k_sem_give>
    73e0:	bd38      	pop	{r3, r4, r5, pc}
    73e2:	bf00      	nop
    73e4:	2000bae8 	.word	0x2000bae8

000073e8 <hci_cmd_complete>:
{
    73e8:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    73ea:	2103      	movs	r1, #3
{
    73ec:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    73ee:	3008      	adds	r0, #8
    73f0:	f00f fe7f 	bl	170f2 <net_buf_simple_pull_mem>
	status = buf->data[0];
    73f4:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    73f6:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    73f8:	7819      	ldrb	r1, [r3, #0]
    73fa:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    73fe:	4622      	mov	r2, r4
    7400:	f7ff fe92 	bl	7128 <hci_cmd_done>
	if (ncmd) {
    7404:	b125      	cbz	r5, 7410 <hci_cmd_complete+0x28>
    7406:	4803      	ldr	r0, [pc, #12]	; (7414 <hci_cmd_complete+0x2c>)
}
    7408:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    740c:	f00c bf6e 	b.w	142ec <z_impl_k_sem_give>
    7410:	bd38      	pop	{r3, r4, r5, pc}
    7412:	bf00      	nop
    7414:	2000bae8 	.word	0x2000bae8

00007418 <valid_adv_param>:
	return true;
}

static bool valid_adv_param(const struct bt_le_adv_param *param)
{
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    7418:	6843      	ldr	r3, [r0, #4]
{
    741a:	b537      	push	{r0, r1, r2, r4, r5, lr}
    741c:	4604      	mov	r4, r0
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    741e:	0558      	lsls	r0, r3, #21
    7420:	d408      	bmi.n	7434 <valid_adv_param+0x1c>
		return false;
	}

	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    7422:	6922      	ldr	r2, [r4, #16]
    7424:	b10a      	cbz	r2, 742a <valid_adv_param+0x12>
    7426:	07d9      	lsls	r1, r3, #31
    7428:	d504      	bpl.n	7434 <valid_adv_param+0x1c>
	if (param->id >= bt_dev.id_count ||
    742a:	4d17      	ldr	r5, [pc, #92]	; (7488 <valid_adv_param+0x70>)
    742c:	7820      	ldrb	r0, [r4, #0]
    742e:	79eb      	ldrb	r3, [r5, #7]
    7430:	4283      	cmp	r3, r0
    7432:	d802      	bhi.n	743a <valid_adv_param+0x22>
			return false;
    7434:	2000      	movs	r0, #0
		return false;
	}

	return valid_adv_ext_param(param);
}
    7436:	b003      	add	sp, #12
    7438:	bd30      	pop	{r4, r5, pc}
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    743a:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    743e:	2300      	movs	r3, #0
    7440:	2207      	movs	r2, #7
    7442:	4669      	mov	r1, sp
    7444:	4428      	add	r0, r5
    7446:	9300      	str	r3, [sp, #0]
    7448:	f8cd 3003 	str.w	r3, [sp, #3]
    744c:	f00e fde5 	bl	1601a <memcmp>
	if (param->id >= bt_dev.id_count ||
    7450:	2800      	cmp	r0, #0
    7452:	d0ef      	beq.n	7434 <valid_adv_param+0x1c>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    7454:	6863      	ldr	r3, [r4, #4]
    7456:	07da      	lsls	r2, r3, #31
    7458:	d406      	bmi.n	7468 <valid_adv_param+0x50>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    745a:	f895 2038 	ldrb.w	r2, [r5, #56]	; 0x38
    745e:	2a08      	cmp	r2, #8
    7460:	d802      	bhi.n	7468 <valid_adv_param+0x50>
    7462:	68a2      	ldr	r2, [r4, #8]
    7464:	2a9f      	cmp	r2, #159	; 0x9f
    7466:	d9e5      	bls.n	7434 <valid_adv_param+0x1c>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    7468:	06db      	lsls	r3, r3, #27
    746a:	d401      	bmi.n	7470 <valid_adv_param+0x58>
    746c:	6923      	ldr	r3, [r4, #16]
    746e:	b943      	cbnz	r3, 7482 <valid_adv_param+0x6a>
		if (param->interval_min > param->interval_max ||
    7470:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    7474:	429a      	cmp	r2, r3
    7476:	d8dd      	bhi.n	7434 <valid_adv_param+0x1c>
    7478:	2a1f      	cmp	r2, #31
    747a:	d9db      	bls.n	7434 <valid_adv_param+0x1c>
		    param->interval_min < 0x0020 ||
    747c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    7480:	d8d8      	bhi.n	7434 <valid_adv_param+0x1c>
	return true;
    7482:	2001      	movs	r0, #1
    7484:	e7d7      	b.n	7436 <valid_adv_param+0x1e>
    7486:	bf00      	nop
    7488:	2000ba38 	.word	0x2000ba38

0000748c <bt_hci_cmd_create>:
{
    748c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7490:	4605      	mov	r5, r0
    7492:	460e      	mov	r6, r1
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    7494:	4816      	ldr	r0, [pc, #88]	; (74f0 <bt_hci_cmd_create+0x64>)
	cmd(buf)->opcode = opcode;
    7496:	f8df 805c 	ldr.w	r8, [pc, #92]	; 74f4 <bt_hci_cmd_create+0x68>
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    749a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    749e:	f00f fdd5 	bl	1704c <net_buf_alloc_fixed>
    74a2:	4604      	mov	r4, r0
	net_buf_reserve(buf, BT_BUF_RESERVE);
    74a4:	f100 0b08 	add.w	fp, r0, #8
    74a8:	2100      	movs	r1, #0
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	*(u8_t *)net_buf_user_data(buf) = type;
    74aa:	2700      	movs	r7, #0
    74ac:	4658      	mov	r0, fp
    74ae:	f00f fdec 	bl	1708a <net_buf_simple_reserve>
    74b2:	7527      	strb	r7, [r4, #20]
	cmd(buf)->opcode = opcode;
    74b4:	4620      	mov	r0, r4
    74b6:	f006 f983 	bl	d7c0 <net_buf_id>
    74ba:	f04f 0a0c 	mov.w	sl, #12
    74be:	fb0a 8000 	mla	r0, sl, r0, r8
    74c2:	8045      	strh	r5, [r0, #2]
	cmd(buf)->sync = NULL;
    74c4:	4620      	mov	r0, r4
    74c6:	f006 f97b 	bl	d7c0 <net_buf_id>
    74ca:	fb0a 8000 	mla	r0, sl, r0, r8
    74ce:	6087      	str	r7, [r0, #8]
	cmd(buf)->state = NULL;
    74d0:	4620      	mov	r0, r4
    74d2:	f006 f975 	bl	d7c0 <net_buf_id>
    74d6:	fb0a 8000 	mla	r0, sl, r0, r8
	hdr = net_buf_add(buf, sizeof(*hdr));
    74da:	2103      	movs	r1, #3
	cmd(buf)->state = NULL;
    74dc:	6047      	str	r7, [r0, #4]
	hdr = net_buf_add(buf, sizeof(*hdr));
    74de:	4658      	mov	r0, fp
    74e0:	f00f fde8 	bl	170b4 <net_buf_simple_add>
	hdr->param_len = param_len;
    74e4:	7086      	strb	r6, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    74e6:	8005      	strh	r5, [r0, #0]
}
    74e8:	4620      	mov	r0, r4
    74ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    74ee:	bf00      	nop
    74f0:	2000c3f0 	.word	0x2000c3f0
    74f4:	20002b18 	.word	0x20002b18

000074f8 <bt_hci_cmd_send_sync>:
{
    74f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74fc:	4607      	mov	r7, r0
    74fe:	b086      	sub	sp, #24
    7500:	4615      	mov	r5, r2
	if (!buf) {
    7502:	460c      	mov	r4, r1
    7504:	b921      	cbnz	r1, 7510 <bt_hci_cmd_send_sync+0x18>
		buf = bt_hci_cmd_create(opcode, 0);
    7506:	f7ff ffc1 	bl	748c <bt_hci_cmd_create>
		if (!buf) {
    750a:	4604      	mov	r4, r0
    750c:	2800      	cmp	r0, #0
    750e:	d054      	beq.n	75ba <bt_hci_cmd_send_sync+0xc2>
	return z_impl_k_sem_init(sem, initial_count, limit);
    7510:	2201      	movs	r2, #1
    7512:	2100      	movs	r1, #0
    7514:	4668      	mov	r0, sp
    7516:	f011 fcf8 	bl	18f0a <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    751a:	4620      	mov	r0, r4
    751c:	f006 f950 	bl	d7c0 <net_buf_id>
    7520:	4e27      	ldr	r6, [pc, #156]	; (75c0 <bt_hci_cmd_send_sync+0xc8>)
    7522:	230c      	movs	r3, #12
    7524:	fb03 6000 	mla	r0, r3, r0, r6
    7528:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
    752c:	4620      	mov	r0, r4
    752e:	f00f fdbd 	bl	170ac <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    7532:	4824      	ldr	r0, [pc, #144]	; (75c4 <bt_hci_cmd_send_sync+0xcc>)
    7534:	4621      	mov	r1, r4
    7536:	f00f fdac 	bl	17092 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    753a:	f242 7110 	movw	r1, #10000	; 0x2710
    753e:	4668      	mov	r0, sp
    7540:	f00c fefa 	bl	14338 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    7544:	4680      	mov	r8, r0
    7546:	b180      	cbz	r0, 756a <bt_hci_cmd_send_sync+0x72>
    7548:	4a1f      	ldr	r2, [pc, #124]	; (75c8 <bt_hci_cmd_send_sync+0xd0>)
    754a:	4920      	ldr	r1, [pc, #128]	; (75cc <bt_hci_cmd_send_sync+0xd4>)
    754c:	4820      	ldr	r0, [pc, #128]	; (75d0 <bt_hci_cmd_send_sync+0xd8>)
    754e:	f44f 73b8 	mov.w	r3, #368	; 0x170
    7552:	f00d faea 	bl	14b2a <printk>
    7556:	481f      	ldr	r0, [pc, #124]	; (75d4 <bt_hci_cmd_send_sync+0xdc>)
    7558:	4641      	mov	r1, r8
    755a:	f00d fae6 	bl	14b2a <printk>
    755e:	4040      	eors	r0, r0
    7560:	f380 8811 	msr	BASEPRI, r0
    7564:	f04f 0003 	mov.w	r0, #3
    7568:	df02      	svc	2
	status = cmd(buf)->status;
    756a:	4620      	mov	r0, r4
    756c:	f006 f928 	bl	d7c0 <net_buf_id>
    7570:	230c      	movs	r3, #12
    7572:	4343      	muls	r3, r0
    7574:	5cf6      	ldrb	r6, [r6, r3]
	if (status) {
    7576:	b1be      	cbz	r6, 75a8 <bt_hci_cmd_send_sync+0xb0>
    7578:	4a17      	ldr	r2, [pc, #92]	; (75d8 <bt_hci_cmd_send_sync+0xe0>)
    757a:	4b18      	ldr	r3, [pc, #96]	; (75dc <bt_hci_cmd_send_sync+0xe4>)
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    757c:	4818      	ldr	r0, [pc, #96]	; (75e0 <bt_hci_cmd_send_sync+0xe8>)
    757e:	1a9b      	subs	r3, r3, r2
    7580:	08db      	lsrs	r3, r3, #3
    7582:	019b      	lsls	r3, r3, #6
    7584:	f043 0302 	orr.w	r3, r3, #2
    7588:	4632      	mov	r2, r6
    758a:	4639      	mov	r1, r7
    758c:	f00d fe7e 	bl	1528c <log_2>
		net_buf_unref(buf);
    7590:	4620      	mov	r0, r4
    7592:	f006 f9bd 	bl	d910 <net_buf_unref>
			return -EIO;
    7596:	2e09      	cmp	r6, #9
    7598:	bf0c      	ite	eq
    759a:	f06f 003c 	mvneq.w	r0, #60	; 0x3c
    759e:	f06f 0004 	mvnne.w	r0, #4
}
    75a2:	b006      	add	sp, #24
    75a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (rsp) {
    75a8:	b115      	cbz	r5, 75b0 <bt_hci_cmd_send_sync+0xb8>
		*rsp = buf;
    75aa:	602c      	str	r4, [r5, #0]
	return 0;
    75ac:	4630      	mov	r0, r6
    75ae:	e7f8      	b.n	75a2 <bt_hci_cmd_send_sync+0xaa>
		net_buf_unref(buf);
    75b0:	4620      	mov	r0, r4
    75b2:	f006 f9ad 	bl	d910 <net_buf_unref>
	return 0;
    75b6:	4628      	mov	r0, r5
    75b8:	e7f3      	b.n	75a2 <bt_hci_cmd_send_sync+0xaa>
			return -ENOBUFS;
    75ba:	f06f 0036 	mvn.w	r0, #54	; 0x36
    75be:	e7f0      	b.n	75a2 <bt_hci_cmd_send_sync+0xaa>
    75c0:	20002b18 	.word	0x20002b18
    75c4:	2000bb04 	.word	0x2000bb04
    75c8:	0001ae81 	.word	0x0001ae81
    75cc:	0001aeb5 	.word	0x0001aeb5
    75d0:	0001aebe 	.word	0x0001aebe
    75d4:	0001aedb 	.word	0x0001aedb
    75d8:	0001956c 	.word	0x0001956c
    75dc:	000195f4 	.word	0x000195f4
    75e0:	0001aefb 	.word	0x0001aefb

000075e4 <set_random_address>:
{
    75e4:	b570      	push	{r4, r5, r6, lr}
	return memcmp(a, b, sizeof(*a));
    75e6:	4e15      	ldr	r6, [pc, #84]	; (763c <set_random_address+0x58>)
    75e8:	2206      	movs	r2, #6
    75ea:	f106 0131 	add.w	r1, r6, #49	; 0x31
    75ee:	4605      	mov	r5, r0
    75f0:	f00e fd13 	bl	1601a <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    75f4:	4604      	mov	r4, r0
    75f6:	b1e0      	cbz	r0, 7632 <set_random_address+0x4e>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    75f8:	2106      	movs	r1, #6
    75fa:	f242 0005 	movw	r0, #8197	; 0x2005
    75fe:	f7ff ff45 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    7602:	4604      	mov	r4, r0
    7604:	b1b8      	cbz	r0, 7636 <set_random_address+0x52>
	net_buf_add_mem(buf, addr, sizeof(*addr));
    7606:	2206      	movs	r2, #6
    7608:	4629      	mov	r1, r5
    760a:	3008      	adds	r0, #8
    760c:	f00f fd58 	bl	170c0 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    7610:	4621      	mov	r1, r4
    7612:	2200      	movs	r2, #0
    7614:	f242 0005 	movw	r0, #8197	; 0x2005
    7618:	f7ff ff6e 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    761c:	4604      	mov	r4, r0
    761e:	b940      	cbnz	r0, 7632 <set_random_address+0x4e>
}

static inline void bt_addr_copy(bt_addr_t *dst, const bt_addr_t *src)
{
	memcpy(dst, src, sizeof(*dst));
    7620:	2206      	movs	r2, #6
    7622:	4629      	mov	r1, r5
    7624:	f106 0031 	add.w	r0, r6, #49	; 0x31
    7628:	f00e fd07 	bl	1603a <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    762c:	2301      	movs	r3, #1
    762e:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}
    7632:	4620      	mov	r0, r4
    7634:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
    7636:	f06f 0436 	mvn.w	r4, #54	; 0x36
    763a:	e7fa      	b.n	7632 <set_random_address+0x4e>
    763c:	2000ba38 	.word	0x2000ba38

00007640 <set_le_scan_enable_legacy>:
{
    7640:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    7642:	2102      	movs	r1, #2
{
    7644:	b085      	sub	sp, #20
    7646:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    7648:	f242 000c 	movw	r0, #8204	; 0x200c
    764c:	f7ff ff1e 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    7650:	4605      	mov	r5, r0
    7652:	b348      	cbz	r0, 76a8 <set_le_scan_enable_legacy+0x68>
	cp = net_buf_add(buf, sizeof(*cp));
    7654:	2102      	movs	r1, #2
    7656:	3008      	adds	r0, #8
    7658:	f00f fd2c 	bl	170b4 <net_buf_simple_add>
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    765c:	2c01      	cmp	r4, #1
	cp = net_buf_add(buf, sizeof(*cp));
    765e:	4603      	mov	r3, r0
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    7660:	d11f      	bne.n	76a2 <set_le_scan_enable_legacy+0x62>
    7662:	4813      	ldr	r0, [pc, #76]	; (76b0 <set_le_scan_enable_legacy+0x70>)
    7664:	f00e fddf 	bl	16226 <atomic_get>

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    7668:	f3c0 2000 	ubfx	r0, r0, #8, #1
    766c:	7058      	strb	r0, [r3, #1]
	cp->enable = enable;
    766e:	701c      	strb	r4, [r3, #0]
	state->target = target;
    7670:	4b0f      	ldr	r3, [pc, #60]	; (76b0 <set_le_scan_enable_legacy+0x70>)
    7672:	9301      	str	r3, [sp, #4]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
    7674:	f004 0401 	and.w	r4, r4, #1
	state->bit = bit;
    7678:	2305      	movs	r3, #5
	cmd(buf)->state = &state;
    767a:	4628      	mov	r0, r5
	state->bit = bit;
    767c:	9302      	str	r3, [sp, #8]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
    767e:	f88d 400c 	strb.w	r4, [sp, #12]
	cmd(buf)->state = &state;
    7682:	f006 f89d 	bl	d7c0 <net_buf_id>
    7686:	4b0b      	ldr	r3, [pc, #44]	; (76b4 <set_le_scan_enable_legacy+0x74>)
    7688:	220c      	movs	r2, #12
    768a:	fb02 3000 	mla	r0, r2, r0, r3
    768e:	ab01      	add	r3, sp, #4
    7690:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_ENABLE, buf, NULL);
    7692:	2200      	movs	r2, #0
    7694:	4629      	mov	r1, r5
    7696:	f242 000c 	movw	r0, #8204	; 0x200c
    769a:	f7ff ff2d 	bl	74f8 <bt_hci_cmd_send_sync>
}
    769e:	b005      	add	sp, #20
    76a0:	bd30      	pop	{r4, r5, pc}
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    76a2:	2200      	movs	r2, #0
    76a4:	7042      	strb	r2, [r0, #1]
    76a6:	e7e2      	b.n	766e <set_le_scan_enable_legacy+0x2e>
		return -ENOBUFS;
    76a8:	f06f 0036 	mvn.w	r0, #54	; 0x36
    76ac:	e7f7      	b.n	769e <set_le_scan_enable_legacy+0x5e>
    76ae:	bf00      	nop
    76b0:	2000bad0 	.word	0x2000bad0
    76b4:	20002b18 	.word	0x20002b18

000076b8 <le_adv_set_random_addr.isra.0>:
	} else {
		return BT_LE_ADV_FP_NO_WHITELIST;
	}
}

static int le_adv_set_random_addr(struct bt_le_ext_adv *adv, u32_t options,
    76b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    76bc:	f011 0401 	ands.w	r4, r1, #1
static int le_adv_set_random_addr(struct bt_le_ext_adv *adv, u32_t options,
    76c0:	4605      	mov	r5, r0
    76c2:	4616      	mov	r6, r2
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    76c4:	d019      	beq.n	76fa <le_adv_set_random_addr.isra.0+0x42>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    76c6:	4f26      	ldr	r7, [pc, #152]	; (7760 <le_adv_set_random_addr.isra.0+0xa8>)
    76c8:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
    76cc:	ea4f 08c0 	mov.w	r8, r0, lsl #3
    76d0:	5cfb      	ldrb	r3, [r7, r3]
    76d2:	2b01      	cmp	r3, #1
    76d4:	d007      	beq.n	76e6 <le_adv_set_random_addr.isra.0+0x2e>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
    76d6:	eba8 0505 	sub.w	r5, r8, r5
		if (err) {
			return err;
		}
	}

	return 0;
    76da:	2400      	movs	r4, #0
			*own_addr_type = id_addr->type;
    76dc:	5d7b      	ldrb	r3, [r7, r5]
    76de:	7033      	strb	r3, [r6, #0]
}
    76e0:	4620      	mov	r0, r4
    76e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				err = set_adv_random_address(adv, &id_addr->a);
    76e6:	2007      	movs	r0, #7
    76e8:	fb10 3005 	smlabb	r0, r0, r5, r3
		return set_random_address(addr);
    76ec:	4438      	add	r0, r7
    76ee:	f7ff ff79 	bl	75e4 <set_random_address>
				if (err) {
    76f2:	4604      	mov	r4, r0
    76f4:	2800      	cmp	r0, #0
    76f6:	d0ee      	beq.n	76d6 <le_adv_set_random_addr.isra.0+0x1e>
    76f8:	e7f2      	b.n	76e0 <le_adv_set_random_addr.isra.0+0x28>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    76fa:	f011 0104 	ands.w	r1, r1, #4
    76fe:	d013      	beq.n	7728 <le_adv_set_random_addr.isra.0+0x70>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    7700:	4f17      	ldr	r7, [pc, #92]	; (7760 <le_adv_set_random_addr.isra.0+0xa8>)
    7702:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
    7706:	ea4f 08c0 	mov.w	r8, r0, lsl #3
    770a:	5cfb      	ldrb	r3, [r7, r3]
    770c:	2b01      	cmp	r3, #1
    770e:	d106      	bne.n	771e <le_adv_set_random_addr.isra.0+0x66>
				err = set_adv_random_address(adv, &id_addr->a);
    7710:	2007      	movs	r0, #7
    7712:	fb10 3005 	smlabb	r0, r0, r5, r3
		return set_random_address(addr);
    7716:	4438      	add	r0, r7
    7718:	f7ff ff64 	bl	75e4 <set_random_address>
    771c:	4604      	mov	r4, r0
			*own_addr_type = id_addr->type;
    771e:	eba8 0505 	sub.w	r5, r8, r5
    7722:	5d7b      	ldrb	r3, [r7, r5]
    7724:	7033      	strb	r3, [r6, #0]
    7726:	e7db      	b.n	76e0 <le_adv_set_random_addr.isra.0+0x28>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    7728:	480e      	ldr	r0, [pc, #56]	; (7764 <le_adv_set_random_addr.isra.0+0xac>)
    772a:	f00e fd7c 	bl	16226 <atomic_get>
			if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    772e:	0682      	lsls	r2, r0, #26
    7730:	d40a      	bmi.n	7748 <le_adv_set_random_addr.isra.0+0x90>
			bool scan_enabled = false;
    7732:	2500      	movs	r5, #0
			err = le_adv_set_private_addr(adv);
    7734:	f00e fda9 	bl	1628a <le_adv_set_private_addr.isra.0>
    7738:	4604      	mov	r4, r0
			*own_addr_type = BT_ADDR_LE_RANDOM;
    773a:	2001      	movs	r0, #1
    773c:	7030      	strb	r0, [r6, #0]
			if (scan_enabled) {
    773e:	2d00      	cmp	r5, #0
    7740:	d0ce      	beq.n	76e0 <le_adv_set_random_addr.isra.0+0x28>
	return set_le_scan_enable_legacy(enable);
    7742:	f7ff ff7d 	bl	7640 <set_le_scan_enable_legacy>
		if (err) {
    7746:	e7cb      	b.n	76e0 <le_adv_set_random_addr.isra.0+0x28>
    7748:	4806      	ldr	r0, [pc, #24]	; (7764 <le_adv_set_random_addr.isra.0+0xac>)
    774a:	f00e fd6c 	bl	16226 <atomic_get>
			    atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
    774e:	0603      	lsls	r3, r0, #24
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    7750:	f3c0 15c0 	ubfx	r5, r0, #7, #1
    7754:	d5ed      	bpl.n	7732 <le_adv_set_random_addr.isra.0+0x7a>
	return set_le_scan_enable_legacy(enable);
    7756:	4608      	mov	r0, r1
    7758:	f7ff ff72 	bl	7640 <set_le_scan_enable_legacy>
    775c:	e7ea      	b.n	7734 <le_adv_set_random_addr.isra.0+0x7c>
    775e:	bf00      	nop
    7760:	2000ba38 	.word	0x2000ba38
    7764:	2000bad0 	.word	0x2000bad0

00007768 <hci_set_ad>:
{
    7768:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    776c:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    776e:	2120      	movs	r1, #32
{
    7770:	4682      	mov	sl, r0
    7772:	4615      	mov	r5, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    7774:	f7ff fe8a 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    7778:	4606      	mov	r6, r0
    777a:	2800      	cmp	r0, #0
    777c:	d05b      	beq.n	7836 <hci_set_ad+0xce>
	set_data = net_buf_add(buf, sizeof(*set_data));
    777e:	2120      	movs	r1, #32
    7780:	3008      	adds	r0, #8
    7782:	f00f fc97 	bl	170b4 <net_buf_simple_add>
	(void)memset(set_data, 0, sizeof(*set_data));
    7786:	2220      	movs	r2, #32
    7788:	2100      	movs	r1, #0
	set_data = net_buf_add(buf, sizeof(*set_data));
    778a:	4681      	mov	r9, r0
	(void)memset(set_data, 0, sizeof(*set_data));
    778c:	f00e fc80 	bl	16090 <memset>
	err = set_data_add(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
    7790:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    7794:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
    7798:	9300      	str	r3, [sp, #0]
	u8_t set_data_len = 0;
    779a:	2500      	movs	r5, #0
		for (size_t j = 0; j < ad[i].len; j++) {
    779c:	f8d4 8000 	ldr.w	r8, [r4]
    77a0:	2300      	movs	r3, #0
    77a2:	6862      	ldr	r2, [r4, #4]
    77a4:	4293      	cmp	r3, r2
    77a6:	d30d      	bcc.n	77c4 <hci_set_ad+0x5c>
	for (size_t i = 0; i < ad_len; i++) {
    77a8:	9b00      	ldr	r3, [sp, #0]
    77aa:	3408      	adds	r4, #8
    77ac:	429c      	cmp	r4, r3
    77ae:	d1f5      	bne.n	779c <hci_set_ad+0x34>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    77b0:	2200      	movs	r2, #0
    77b2:	4631      	mov	r1, r6
    77b4:	4650      	mov	r0, sl
	*data_len = set_data_len;
    77b6:	f889 5000 	strb.w	r5, [r9]
}
    77ba:	b003      	add	sp, #12
    77bc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    77c0:	f7ff be9a 	b.w	74f8 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
    77c4:	f898 2001 	ldrb.w	r2, [r8, #1]
			u8_t type = data[j].type;
    77c8:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
    77cc:	1ca8      	adds	r0, r5, #2
    77ce:	1881      	adds	r1, r0, r2
    77d0:	291f      	cmp	r1, #31
    77d2:	d919      	bls.n	7808 <hci_set_ad+0xa0>
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    77d4:	f1bc 0f09 	cmp.w	ip, #9
				len = set_data_len_max - (set_data_len + 2);
    77d8:	f1c5 021d 	rsb	r2, r5, #29
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    77dc:	d100      	bne.n	77e0 <hci_set_ad+0x78>
    77de:	b98a      	cbnz	r2, 7804 <hci_set_ad+0x9c>
    77e0:	4b16      	ldr	r3, [pc, #88]	; (783c <hci_set_ad+0xd4>)
    77e2:	4917      	ldr	r1, [pc, #92]	; (7840 <hci_set_ad+0xd8>)
					BT_ERR("Too big advertising data");
    77e4:	4817      	ldr	r0, [pc, #92]	; (7844 <hci_set_ad+0xdc>)
    77e6:	1ac9      	subs	r1, r1, r3
    77e8:	08c9      	lsrs	r1, r1, #3
    77ea:	0189      	lsls	r1, r1, #6
    77ec:	f041 0101 	orr.w	r1, r1, #1
    77f0:	f00d fd2b 	bl	1524a <log_0>
		net_buf_unref(buf);
    77f4:	4630      	mov	r0, r6
    77f6:	f006 f88b 	bl	d910 <net_buf_unref>
					return -EINVAL;
    77fa:	f06f 0015 	mvn.w	r0, #21
}
    77fe:	b003      	add	sp, #12
    7800:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
    7804:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
    7808:	b2d7      	uxtb	r7, r2
    780a:	1c79      	adds	r1, r7, #1
    780c:	f80b 1005 	strb.w	r1, [fp, r5]
    7810:	1c69      	adds	r1, r5, #1
			set_data[set_data_len++] = type;
    7812:	b2c9      	uxtb	r1, r1
			memcpy(&set_data[set_data_len], data[j].data, len);
    7814:	fa5b f080 	uxtab	r0, fp, r0
			set_data[set_data_len++] = type;
    7818:	f80b c001 	strb.w	ip, [fp, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
    781c:	f8d8 1004 	ldr.w	r1, [r8, #4]
    7820:	9301      	str	r3, [sp, #4]
			set_data_len += len;
    7822:	3702      	adds	r7, #2
			memcpy(&set_data[set_data_len], data[j].data, len);
    7824:	f00e fc09 	bl	1603a <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
    7828:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
    782a:	443d      	add	r5, r7
    782c:	b2ed      	uxtb	r5, r5
		for (size_t j = 0; j < ad[i].len; j++) {
    782e:	3301      	adds	r3, #1
    7830:	f108 0808 	add.w	r8, r8, #8
    7834:	e7b5      	b.n	77a2 <hci_set_ad+0x3a>
		return -ENOBUFS;
    7836:	f06f 0036 	mvn.w	r0, #54	; 0x36
    783a:	e7e0      	b.n	77fe <hci_set_ad+0x96>
    783c:	0001956c 	.word	0x0001956c
    7840:	000195f4 	.word	0x000195f4
    7844:	0001af17 	.word	0x0001af17

00007848 <le_adv_update.isra.0>:
static int le_adv_update(struct bt_le_ext_adv *adv,
    7848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    784c:	b086      	sub	sp, #24
	d[0].len = ad_len;
    784e:	e9cd 0102 	strd	r0, r1, [sp, #8]
static int le_adv_update(struct bt_le_ext_adv *adv,
    7852:	4615      	mov	r5, r2
    7854:	461e      	mov	r6, r3
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    7856:	2201      	movs	r2, #1
	struct bt_ad d[2] = {};
    7858:	2300      	movs	r3, #0
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    785a:	a902      	add	r1, sp, #8
    785c:	f242 0008 	movw	r0, #8200	; 0x2008
	struct bt_ad d[2] = {};
    7860:	e9cd 3304 	strd	r3, r3, [sp, #16]
static int le_adv_update(struct bt_le_ext_adv *adv,
    7864:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
    7868:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    786c:	f7ff ff7c 	bl	7768 <hci_set_ad>
	if (err) {
    7870:	4604      	mov	r4, r0
    7872:	b9f8      	cbnz	r0, 78b4 <le_adv_update.isra.0+0x6c>
	d[0].len = sd_len;
    7874:	e9cd 5602 	strd	r5, r6, [sp, #8]
	if (use_name) {
    7878:	f1b8 0f00 	cmp.w	r8, #0
    787c:	d00e      	beq.n	789c <le_adv_update.isra.0+0x54>
		if (sd) {
    787e:	bb35      	cbnz	r5, 78ce <le_adv_update.isra.0+0x86>
		data = (struct bt_data)BT_DATA(
    7880:	4d15      	ldr	r5, [pc, #84]	; (78d8 <le_adv_update.isra.0+0x90>)
    7882:	4628      	mov	r0, r5
    7884:	f00e fba7 	bl	15fd6 <strlen>
    7888:	2309      	movs	r3, #9
    788a:	f88d 3000 	strb.w	r3, [sp]
		d[1].len = 1;
    788e:	2301      	movs	r3, #1
		data = (struct bt_data)BT_DATA(
    7890:	f88d 0001 	strb.w	r0, [sp, #1]
    7894:	9501      	str	r5, [sp, #4]
		d[1].data = &data;
    7896:	f8cd d010 	str.w	sp, [sp, #16]
		d[1].len = 1;
    789a:	9305      	str	r3, [sp, #20]
	if (d[0].data || d[1].data || connectable) {
    789c:	9b02      	ldr	r3, [sp, #8]
    789e:	b913      	cbnz	r3, 78a6 <le_adv_update.isra.0+0x5e>
    78a0:	9b04      	ldr	r3, [sp, #16]
    78a2:	b903      	cbnz	r3, 78a6 <le_adv_update.isra.0+0x5e>
    78a4:	b137      	cbz	r7, 78b4 <le_adv_update.isra.0+0x6c>
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    78a6:	2202      	movs	r2, #2
    78a8:	a902      	add	r1, sp, #8
    78aa:	f242 0009 	movw	r0, #8201	; 0x2009
    78ae:	f7ff ff5b 	bl	7768 <hci_set_ad>
    78b2:	4604      	mov	r4, r0
}
    78b4:	4620      	mov	r0, r4
    78b6:	b006      	add	sp, #24
    78b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    78bc:	f815 3032 	ldrb.w	r3, [r5, r2, lsl #3]
    78c0:	3b08      	subs	r3, #8
    78c2:	2b01      	cmp	r3, #1
    78c4:	d905      	bls.n	78d2 <le_adv_update.isra.0+0x8a>
	for (i = 0; i < ad_len; i++) {
    78c6:	3201      	adds	r2, #1
    78c8:	4296      	cmp	r6, r2
    78ca:	d1f7      	bne.n	78bc <le_adv_update.isra.0+0x74>
    78cc:	e7d8      	b.n	7880 <le_adv_update.isra.0+0x38>
    78ce:	4602      	mov	r2, r0
    78d0:	e7fa      	b.n	78c8 <le_adv_update.isra.0+0x80>
				return -EINVAL;
    78d2:	f06f 0415 	mvn.w	r4, #21
    78d6:	e7ed      	b.n	78b4 <le_adv_update.isra.0+0x6c>
    78d8:	0001af30 	.word	0x0001af30

000078dc <set_le_adv_enable_legacy.constprop.0>:
static int set_le_adv_enable_legacy(struct bt_le_ext_adv *adv, bool enable)
    78dc:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    78de:	2101      	movs	r1, #1
static int set_le_adv_enable_legacy(struct bt_le_ext_adv *adv, bool enable)
    78e0:	b085      	sub	sp, #20
    78e2:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    78e4:	f242 000a 	movw	r0, #8202	; 0x200a
    78e8:	f7ff fdd0 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    78ec:	4604      	mov	r4, r0
    78ee:	b1e8      	cbz	r0, 792c <set_le_adv_enable_legacy.constprop.0+0x50>
	if (enable) {
    78f0:	3008      	adds	r0, #8
    78f2:	b1cd      	cbz	r5, 7928 <set_le_adv_enable_legacy.constprop.0+0x4c>
		net_buf_add_u8(buf, BT_HCI_LE_ADV_ENABLE);
    78f4:	2101      	movs	r1, #1
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    78f6:	f00f fbec 	bl	170d2 <net_buf_simple_add_u8>
	state->target = target;
    78fa:	4b0e      	ldr	r3, [pc, #56]	; (7934 <set_le_adv_enable_legacy.constprop.0+0x58>)
    78fc:	9301      	str	r3, [sp, #4]
	cmd(buf)->state = &state;
    78fe:	4620      	mov	r0, r4
	state->bit = bit;
    7900:	2305      	movs	r3, #5
    7902:	9302      	str	r3, [sp, #8]
	state->val = val;
    7904:	f88d 500c 	strb.w	r5, [sp, #12]
	cmd(buf)->state = &state;
    7908:	f005 ff5a 	bl	d7c0 <net_buf_id>
    790c:	4b0a      	ldr	r3, [pc, #40]	; (7938 <set_le_adv_enable_legacy.constprop.0+0x5c>)
    790e:	220c      	movs	r2, #12
    7910:	fb02 3000 	mla	r0, r2, r0, r3
    7914:	ab01      	add	r3, sp, #4
    7916:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    7918:	2200      	movs	r2, #0
    791a:	4621      	mov	r1, r4
    791c:	f242 000a 	movw	r0, #8202	; 0x200a
    7920:	f7ff fdea 	bl	74f8 <bt_hci_cmd_send_sync>
}
    7924:	b005      	add	sp, #20
    7926:	bd30      	pop	{r4, r5, pc}
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    7928:	4629      	mov	r1, r5
    792a:	e7e4      	b.n	78f6 <set_le_adv_enable_legacy.constprop.0+0x1a>
		return -ENOBUFS;
    792c:	f06f 0036 	mvn.w	r0, #54	; 0x36
    7930:	e7f8      	b.n	7924 <set_le_adv_enable_legacy.constprop.0+0x48>
    7932:	bf00      	nop
    7934:	2000ba64 	.word	0x2000ba64
    7938:	20002b18 	.word	0x20002b18

0000793c <bt_le_scan_random_addr_check>:
{
    793c:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    793e:	4802      	ldr	r0, [pc, #8]	; (7948 <bt_le_scan_random_addr_check+0xc>)
    7940:	f00e fc71 	bl	16226 <atomic_get>
}
    7944:	2001      	movs	r0, #1
    7946:	bd08      	pop	{r3, pc}
    7948:	2000ba64 	.word	0x2000ba64

0000794c <bt_le_scan_update>:
{
    794c:	b508      	push	{r3, lr}
    794e:	4809      	ldr	r0, [pc, #36]	; (7974 <bt_le_scan_update+0x28>)
    7950:	f00e fc69 	bl	16226 <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    7954:	0641      	lsls	r1, r0, #25
    7956:	f3c0 1380 	ubfx	r3, r0, #6, #1
    795a:	d409      	bmi.n	7970 <bt_le_scan_update+0x24>
    795c:	4805      	ldr	r0, [pc, #20]	; (7974 <bt_le_scan_update+0x28>)
    795e:	f00e fc62 	bl	16226 <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    7962:	0682      	lsls	r2, r0, #26
    7964:	d504      	bpl.n	7970 <bt_le_scan_update+0x24>
	return set_le_scan_enable_legacy(enable);
    7966:	4618      	mov	r0, r3
}
    7968:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return set_le_scan_enable_legacy(enable);
    796c:	f7ff be68 	b.w	7640 <set_le_scan_enable_legacy>
}
    7970:	2000      	movs	r0, #0
    7972:	bd08      	pop	{r3, pc}
    7974:	2000bad0 	.word	0x2000bad0

00007978 <bt_data_parse>:
{
    7978:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    797a:	4604      	mov	r4, r0
    797c:	460e      	mov	r6, r1
    797e:	4617      	mov	r7, r2
	while (ad->len > 1) {
    7980:	88a3      	ldrh	r3, [r4, #4]
    7982:	2b01      	cmp	r3, #1
    7984:	d912      	bls.n	79ac <bt_data_parse+0x34>
		len = net_buf_simple_pull_u8(ad);
    7986:	4620      	mov	r0, r4
    7988:	f00f fbbb 	bl	17102 <net_buf_simple_pull_u8>
		if (len == 0U) {
    798c:	4605      	mov	r5, r0
    798e:	b168      	cbz	r0, 79ac <bt_data_parse+0x34>
		if (len > ad->len) {
    7990:	88a2      	ldrh	r2, [r4, #4]
    7992:	b283      	uxth	r3, r0
    7994:	429a      	cmp	r2, r3
    7996:	d20b      	bcs.n	79b0 <bt_data_parse+0x38>
    7998:	490f      	ldr	r1, [pc, #60]	; (79d8 <bt_data_parse+0x60>)
    799a:	4b10      	ldr	r3, [pc, #64]	; (79dc <bt_data_parse+0x64>)
			BT_WARN("Malformed data");
    799c:	4810      	ldr	r0, [pc, #64]	; (79e0 <bt_data_parse+0x68>)
    799e:	1ac9      	subs	r1, r1, r3
    79a0:	08c9      	lsrs	r1, r1, #3
    79a2:	0189      	lsls	r1, r1, #6
    79a4:	f041 0102 	orr.w	r1, r1, #2
    79a8:	f00d fc4f 	bl	1524a <log_0>
}
    79ac:	b003      	add	sp, #12
    79ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data.type = net_buf_simple_pull_u8(ad);
    79b0:	4620      	mov	r0, r4
    79b2:	f00f fba6 	bl	17102 <net_buf_simple_pull_u8>
		data.data_len = len - 1;
    79b6:	3d01      	subs	r5, #1
		data.data = ad->data;
    79b8:	6823      	ldr	r3, [r4, #0]
		data.type = net_buf_simple_pull_u8(ad);
    79ba:	f88d 0000 	strb.w	r0, [sp]
		if (!func(&data, user_data)) {
    79be:	4639      	mov	r1, r7
    79c0:	4668      	mov	r0, sp
		data.data_len = len - 1;
    79c2:	f88d 5001 	strb.w	r5, [sp, #1]
		data.data = ad->data;
    79c6:	9301      	str	r3, [sp, #4]
		if (!func(&data, user_data)) {
    79c8:	47b0      	blx	r6
    79ca:	2800      	cmp	r0, #0
    79cc:	d0ee      	beq.n	79ac <bt_data_parse+0x34>
		net_buf_simple_pull(ad, len - 1);
    79ce:	4629      	mov	r1, r5
    79d0:	4620      	mov	r0, r4
    79d2:	f00f fb86 	bl	170e2 <net_buf_simple_pull>
    79d6:	e7d3      	b.n	7980 <bt_data_parse+0x8>
    79d8:	000195f4 	.word	0x000195f4
    79dc:	0001956c 	.word	0x0001956c
    79e0:	0001af37 	.word	0x0001af37

000079e4 <id_create.isra.0>:
static void id_create(u8_t id, bt_addr_le_t *addr, u8_t *irk)
    79e4:	b530      	push	{r4, r5, lr}
    79e6:	4d14      	ldr	r5, [pc, #80]	; (7a38 <id_create.isra.0+0x54>)
    79e8:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    79ec:	b085      	sub	sp, #20
    79ee:	4405      	add	r5, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    79f0:	460c      	mov	r4, r1
    79f2:	b179      	cbz	r1, 7a14 <id_create.isra.0+0x30>
    79f4:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    79f6:	2207      	movs	r2, #7
    79f8:	4669      	mov	r1, sp
    79fa:	4620      	mov	r0, r4
    79fc:	9300      	str	r3, [sp, #0]
    79fe:	f8cd 3003 	str.w	r3, [sp, #3]
    7a02:	f00e fb0a 	bl	1601a <memcmp>
    7a06:	b128      	cbz	r0, 7a14 <id_create.isra.0+0x30>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    7a08:	4621      	mov	r1, r4
    7a0a:	4628      	mov	r0, r5
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    7a0c:	f00e fc11 	bl	16232 <bt_addr_le_copy>
}
    7a10:	b005      	add	sp, #20
    7a12:	bd30      	pop	{r4, r5, pc}
			bt_addr_le_create_static(&new_addr);
    7a14:	a802      	add	r0, sp, #8
    7a16:	f00e fc4a 	bl	162ae <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
    7a1a:	a802      	add	r0, sp, #8
    7a1c:	f7ff fbfe 	bl	721c <id_find>
    7a20:	2800      	cmp	r0, #0
    7a22:	daf7      	bge.n	7a14 <id_create.isra.0+0x30>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    7a24:	a902      	add	r1, sp, #8
    7a26:	4628      	mov	r0, r5
    7a28:	f00e fc03 	bl	16232 <bt_addr_le_copy>
		if (addr) {
    7a2c:	2c00      	cmp	r4, #0
    7a2e:	d0ef      	beq.n	7a10 <id_create.isra.0+0x2c>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    7a30:	4629      	mov	r1, r5
    7a32:	4620      	mov	r0, r4
    7a34:	e7ea      	b.n	7a0c <id_create.isra.0+0x28>
    7a36:	bf00      	nop
    7a38:	2000ba38 	.word	0x2000ba38

00007a3c <bt_send>:
	return bt_dev.drv->send(buf);
    7a3c:	4b02      	ldr	r3, [pc, #8]	; (7a48 <bt_send+0xc>)
    7a3e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    7a42:	691b      	ldr	r3, [r3, #16]
    7a44:	4718      	bx	r3
    7a46:	bf00      	nop
    7a48:	2000ba38 	.word	0x2000ba38

00007a4c <hci_tx_thread>:
{
    7a4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7a50:	4b43      	ldr	r3, [pc, #268]	; (7b60 <hci_tx_thread+0x114>)
    7a52:	4c44      	ldr	r4, [pc, #272]	; (7b64 <hci_tx_thread+0x118>)
    7a54:	4d44      	ldr	r5, [pc, #272]	; (7b68 <hci_tx_thread+0x11c>)
		events[0].state = K_POLL_STATE_NOT_READY;
    7a56:	4f45      	ldr	r7, [pc, #276]	; (7b6c <hci_tx_thread+0x120>)
    7a58:	1ae4      	subs	r4, r4, r3
    7a5a:	08e4      	lsrs	r4, r4, #3
    7a5c:	f105 08b0 	add.w	r8, r5, #176	; 0xb0
    7a60:	68fb      	ldr	r3, [r7, #12]
    7a62:	f36f 3310 	bfc	r3, #12, #5
    7a66:	60fb      	str	r3, [r7, #12]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    7a68:	4840      	ldr	r0, [pc, #256]	; (7b6c <hci_tx_thread+0x120>)
    7a6a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7a6e:	2101      	movs	r1, #1
    7a70:	f00c feac 	bl	147cc <z_impl_k_poll>
		BT_ASSERT(err == 0);
    7a74:	b160      	cbz	r0, 7a90 <hci_tx_thread+0x44>
    7a76:	4a3e      	ldr	r2, [pc, #248]	; (7b70 <hci_tx_thread+0x124>)
    7a78:	493e      	ldr	r1, [pc, #248]	; (7b74 <hci_tx_thread+0x128>)
    7a7a:	483f      	ldr	r0, [pc, #252]	; (7b78 <hci_tx_thread+0x12c>)
    7a7c:	f241 437b 	movw	r3, #5243	; 0x147b
    7a80:	f00d f853 	bl	14b2a <printk>
    7a84:	4040      	eors	r0, r0
    7a86:	f380 8811 	msr	BASEPRI, r0
    7a8a:	f04f 0003 	mov.w	r0, #3
    7a8e:	df02      	svc	2
		switch (ev->state) {
    7a90:	68f9      	ldr	r1, [r7, #12]
    7a92:	f3c1 3104 	ubfx	r1, r1, #12, #5
    7a96:	2901      	cmp	r1, #1
    7a98:	d907      	bls.n	7aaa <hci_tx_thread+0x5e>
    7a9a:	2904      	cmp	r1, #4
    7a9c:	d008      	beq.n	7ab0 <hci_tx_thread+0x64>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    7a9e:	01a2      	lsls	r2, r4, #6
    7aa0:	4836      	ldr	r0, [pc, #216]	; (7b7c <hci_tx_thread+0x130>)
    7aa2:	f042 0202 	orr.w	r2, r2, #2
    7aa6:	f00d fbdd 	bl	15264 <log_1>
	z_impl_k_yield();
    7aaa:	f00c fba3 	bl	141f4 <z_impl_k_yield>
}
    7aae:	e7d7      	b.n	7a60 <hci_tx_thread+0x14>
			if (ev->tag == BT_EVENT_CMD_TX) {
    7ab0:	7b39      	ldrb	r1, [r7, #12]
    7ab2:	2900      	cmp	r1, #0
    7ab4:	d1f9      	bne.n	7aaa <hci_tx_thread+0x5e>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    7ab6:	4832      	ldr	r0, [pc, #200]	; (7b80 <hci_tx_thread+0x134>)
    7ab8:	f00f face 	bl	17058 <net_buf_get>
	BT_ASSERT(buf);
    7abc:	4606      	mov	r6, r0
    7abe:	2800      	cmp	r0, #0
    7ac0:	d040      	beq.n	7b44 <hci_tx_thread+0xf8>
	return z_impl_k_sem_take(sem, timeout);
    7ac2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    7ac6:	4640      	mov	r0, r8
    7ac8:	f00c fc36 	bl	14338 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    7acc:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
    7ad0:	bb53      	cbnz	r3, 7b28 <hci_tx_thread+0xdc>
	bt_dev.sent_cmd = net_buf_ref(buf);
    7ad2:	4630      	mov	r0, r6
    7ad4:	f00f faea 	bl	170ac <net_buf_ref>
    7ad8:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
	err = bt_send(buf);
    7adc:	4630      	mov	r0, r6
    7ade:	f7ff ffad 	bl	7a3c <bt_send>
	if (err) {
    7ae2:	4601      	mov	r1, r0
    7ae4:	2800      	cmp	r0, #0
    7ae6:	d0e0      	beq.n	7aaa <hci_tx_thread+0x5e>
		BT_ERR("Unable to send to driver (err %d)", err);
    7ae8:	01a2      	lsls	r2, r4, #6
    7aea:	4826      	ldr	r0, [pc, #152]	; (7b84 <hci_tx_thread+0x138>)
    7aec:	f042 0201 	orr.w	r2, r2, #1
    7af0:	f00d fbb8 	bl	15264 <log_1>
	z_impl_k_sem_give(sem);
    7af4:	4824      	ldr	r0, [pc, #144]	; (7b88 <hci_tx_thread+0x13c>)
    7af6:	f00c fbf9 	bl	142ec <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED,
    7afa:	4630      	mov	r0, r6
    7afc:	f005 fe60 	bl	d7c0 <net_buf_id>
    7b00:	4b22      	ldr	r3, [pc, #136]	; (7b8c <hci_tx_thread+0x140>)
    7b02:	220c      	movs	r2, #12
    7b04:	fb02 3000 	mla	r0, r2, r0, r3
    7b08:	211f      	movs	r1, #31
    7b0a:	2200      	movs	r2, #0
    7b0c:	8840      	ldrh	r0, [r0, #2]
    7b0e:	f7ff fb0b 	bl	7128 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    7b12:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
    7b16:	f005 fefb 	bl	d910 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    7b1a:	2300      	movs	r3, #0
		net_buf_unref(buf);
    7b1c:	4630      	mov	r0, r6
		bt_dev.sent_cmd = NULL;
    7b1e:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
		net_buf_unref(buf);
    7b22:	f005 fef5 	bl	d910 <net_buf_unref>
    7b26:	e7c0      	b.n	7aaa <hci_tx_thread+0x5e>
		BT_ERR("Uncleared pending sent_cmd");
    7b28:	01a1      	lsls	r1, r4, #6
    7b2a:	4819      	ldr	r0, [pc, #100]	; (7b90 <hci_tx_thread+0x144>)
    7b2c:	f041 0101 	orr.w	r1, r1, #1
    7b30:	f00d fb8b 	bl	1524a <log_0>
		net_buf_unref(bt_dev.sent_cmd);
    7b34:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
    7b38:	f005 feea 	bl	d910 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    7b3c:	2300      	movs	r3, #0
    7b3e:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
    7b42:	e7c6      	b.n	7ad2 <hci_tx_thread+0x86>
	BT_ASSERT(buf);
    7b44:	4a0a      	ldr	r2, [pc, #40]	; (7b70 <hci_tx_thread+0x124>)
    7b46:	4913      	ldr	r1, [pc, #76]	; (7b94 <hci_tx_thread+0x148>)
    7b48:	480b      	ldr	r0, [pc, #44]	; (7b78 <hci_tx_thread+0x12c>)
    7b4a:	f241 431c 	movw	r3, #5148	; 0x141c
    7b4e:	f00c ffec 	bl	14b2a <printk>
    7b52:	4040      	eors	r0, r0
    7b54:	f380 8811 	msr	BASEPRI, r0
    7b58:	f04f 0003 	mov.w	r0, #3
    7b5c:	df02      	svc	2
    7b5e:	e7b0      	b.n	7ac2 <hci_tx_thread+0x76>
    7b60:	0001956c 	.word	0x0001956c
    7b64:	000195f4 	.word	0x000195f4
    7b68:	2000ba38 	.word	0x2000ba38
    7b6c:	2000bd9c 	.word	0x2000bd9c
    7b70:	0001ae81 	.word	0x0001ae81
    7b74:	0001aeb5 	.word	0x0001aeb5
    7b78:	0001aebe 	.word	0x0001aebe
    7b7c:	0001af68 	.word	0x0001af68
    7b80:	2000bb04 	.word	0x2000bb04
    7b84:	0001af46 	.word	0x0001af46
    7b88:	2000bae8 	.word	0x2000bae8
    7b8c:	20002b18 	.word	0x20002b18
    7b90:	0001af89 	.word	0x0001af89
    7b94:	0001bd75 	.word	0x0001bd75

00007b98 <bt_recv>:
{
    7b98:	b538      	push	{r3, r4, r5, lr}
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    7b9a:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    7b9c:	2901      	cmp	r1, #1
{
    7b9e:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
    7ba0:	d131      	bne.n	7c06 <bt_recv+0x6e>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    7ba2:	8983      	ldrh	r3, [r0, #12]
    7ba4:	2b01      	cmp	r3, #1
    7ba6:	d80c      	bhi.n	7bc2 <bt_recv+0x2a>
    7ba8:	4a1f      	ldr	r2, [pc, #124]	; (7c28 <bt_recv+0x90>)
    7baa:	4920      	ldr	r1, [pc, #128]	; (7c2c <bt_recv+0x94>)
    7bac:	4820      	ldr	r0, [pc, #128]	; (7c30 <bt_recv+0x98>)
    7bae:	f241 4309 	movw	r3, #5129	; 0x1409
    7bb2:	f00c ffba 	bl	14b2a <printk>
    7bb6:	4040      	eors	r0, r0
    7bb8:	f380 8811 	msr	BASEPRI, r0
    7bbc:	f04f 0003 	mov.w	r0, #3
    7bc0:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    7bc2:	2102      	movs	r1, #2
    7bc4:	f104 0008 	add.w	r0, r4, #8
    7bc8:	f00f fa93 	bl	170f2 <net_buf_simple_pull_mem>
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
    7bcc:	7803      	ldrb	r3, [r0, #0]
    7bce:	3b0e      	subs	r3, #14
    7bd0:	2b01      	cmp	r3, #1
    7bd2:	4605      	mov	r5, r0
    7bd4:	d80c      	bhi.n	7bf0 <bt_recv+0x58>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    7bd6:	4a14      	ldr	r2, [pc, #80]	; (7c28 <bt_recv+0x90>)
    7bd8:	4916      	ldr	r1, [pc, #88]	; (7c34 <bt_recv+0x9c>)
    7bda:	4815      	ldr	r0, [pc, #84]	; (7c30 <bt_recv+0x98>)
    7bdc:	f241 430d 	movw	r3, #5133	; 0x140d
    7be0:	f00c ffa3 	bl	14b2a <printk>
    7be4:	4040      	eors	r0, r0
    7be6:	f380 8811 	msr	BASEPRI, r0
    7bea:	f04f 0003 	mov.w	r0, #3
    7bee:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    7bf0:	4a11      	ldr	r2, [pc, #68]	; (7c38 <bt_recv+0xa0>)
    7bf2:	7828      	ldrb	r0, [r5, #0]
    7bf4:	2302      	movs	r3, #2
    7bf6:	4621      	mov	r1, r4
    7bf8:	f7ff fa40 	bl	707c <handle_event>
	net_buf_unref(buf);
    7bfc:	4620      	mov	r0, r4
    7bfe:	f005 fe87 	bl	d910 <net_buf_unref>
		return 0;
    7c02:	2000      	movs	r0, #0
}
    7c04:	bd38      	pop	{r3, r4, r5, pc}
    7c06:	4b0d      	ldr	r3, [pc, #52]	; (7c3c <bt_recv+0xa4>)
    7c08:	4a0d      	ldr	r2, [pc, #52]	; (7c40 <bt_recv+0xa8>)
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    7c0a:	480e      	ldr	r0, [pc, #56]	; (7c44 <bt_recv+0xac>)
    7c0c:	1ad2      	subs	r2, r2, r3
    7c0e:	08d2      	lsrs	r2, r2, #3
    7c10:	0192      	lsls	r2, r2, #6
    7c12:	f042 0201 	orr.w	r2, r2, #1
    7c16:	f00d fb25 	bl	15264 <log_1>
		net_buf_unref(buf);
    7c1a:	4620      	mov	r0, r4
    7c1c:	f005 fe78 	bl	d910 <net_buf_unref>
		return -EINVAL;
    7c20:	f06f 0015 	mvn.w	r0, #21
    7c24:	e7ee      	b.n	7c04 <bt_recv+0x6c>
    7c26:	bf00      	nop
    7c28:	0001ae81 	.word	0x0001ae81
    7c2c:	0001afa4 	.word	0x0001afa4
    7c30:	0001aebe 	.word	0x0001aebe
    7c34:	0001afbd 	.word	0x0001afbd
    7c38:	000198c4 	.word	0x000198c4
    7c3c:	0001956c 	.word	0x0001956c
    7c40:	000195f4 	.word	0x000195f4
    7c44:	0001afdb 	.word	0x0001afdb

00007c48 <bt_recv_prio>:
{
    7c48:	b538      	push	{r3, r4, r5, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    7c4a:	7d03      	ldrb	r3, [r0, #20]
    7c4c:	2b01      	cmp	r3, #1
{
    7c4e:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    7c50:	d00c      	beq.n	7c6c <bt_recv_prio+0x24>
    7c52:	4a1f      	ldr	r2, [pc, #124]	; (7cd0 <bt_recv_prio+0x88>)
    7c54:	491f      	ldr	r1, [pc, #124]	; (7cd4 <bt_recv_prio+0x8c>)
    7c56:	4820      	ldr	r0, [pc, #128]	; (7cd8 <bt_recv_prio+0x90>)
    7c58:	f641 0395 	movw	r3, #6293	; 0x1895
    7c5c:	f00c ff65 	bl	14b2a <printk>
    7c60:	4040      	eors	r0, r0
    7c62:	f380 8811 	msr	BASEPRI, r0
    7c66:	f04f 0003 	mov.w	r0, #3
    7c6a:	df02      	svc	2
	BT_ASSERT(buf->len >= sizeof(*hdr));
    7c6c:	89a3      	ldrh	r3, [r4, #12]
    7c6e:	2b01      	cmp	r3, #1
    7c70:	d80c      	bhi.n	7c8c <bt_recv_prio+0x44>
    7c72:	4a17      	ldr	r2, [pc, #92]	; (7cd0 <bt_recv_prio+0x88>)
    7c74:	4919      	ldr	r1, [pc, #100]	; (7cdc <bt_recv_prio+0x94>)
    7c76:	4818      	ldr	r0, [pc, #96]	; (7cd8 <bt_recv_prio+0x90>)
    7c78:	f641 0396 	movw	r3, #6294	; 0x1896
    7c7c:	f00c ff55 	bl	14b2a <printk>
    7c80:	4040      	eors	r0, r0
    7c82:	f380 8811 	msr	BASEPRI, r0
    7c86:	f04f 0003 	mov.w	r0, #3
    7c8a:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    7c8c:	2102      	movs	r1, #2
    7c8e:	f104 0008 	add.w	r0, r4, #8
    7c92:	f00f fa2e 	bl	170f2 <net_buf_simple_pull_mem>
    7c96:	7803      	ldrb	r3, [r0, #0]
    7c98:	3b0e      	subs	r3, #14
    7c9a:	2b01      	cmp	r3, #1
    7c9c:	4605      	mov	r5, r0
    7c9e:	d90c      	bls.n	7cba <bt_recv_prio+0x72>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    7ca0:	4a0b      	ldr	r2, [pc, #44]	; (7cd0 <bt_recv_prio+0x88>)
    7ca2:	490f      	ldr	r1, [pc, #60]	; (7ce0 <bt_recv_prio+0x98>)
    7ca4:	480c      	ldr	r0, [pc, #48]	; (7cd8 <bt_recv_prio+0x90>)
    7ca6:	f641 0399 	movw	r3, #6297	; 0x1899
    7caa:	f00c ff3e 	bl	14b2a <printk>
    7cae:	4040      	eors	r0, r0
    7cb0:	f380 8811 	msr	BASEPRI, r0
    7cb4:	f04f 0003 	mov.w	r0, #3
    7cb8:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    7cba:	4a0a      	ldr	r2, [pc, #40]	; (7ce4 <bt_recv_prio+0x9c>)
    7cbc:	7828      	ldrb	r0, [r5, #0]
    7cbe:	2302      	movs	r3, #2
    7cc0:	4621      	mov	r1, r4
    7cc2:	f7ff f9db 	bl	707c <handle_event>
	net_buf_unref(buf);
    7cc6:	4620      	mov	r0, r4
    7cc8:	f005 fe22 	bl	d910 <net_buf_unref>
}
    7ccc:	2000      	movs	r0, #0
    7cce:	bd38      	pop	{r3, r4, r5, pc}
    7cd0:	0001ae81 	.word	0x0001ae81
    7cd4:	0001afef 	.word	0x0001afef
    7cd8:	0001aebe 	.word	0x0001aebe
    7cdc:	0001afa4 	.word	0x0001afa4
    7ce0:	0001afbe 	.word	0x0001afbe
    7ce4:	000198d4 	.word	0x000198d4

00007ce8 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    7ce8:	4a08      	ldr	r2, [pc, #32]	; (7d0c <bt_hci_driver_register+0x24>)
{
    7cea:	4603      	mov	r3, r0
	if (bt_dev.drv) {
    7cec:	f8d2 00dc 	ldr.w	r0, [r2, #220]	; 0xdc
    7cf0:	b930      	cbnz	r0, 7d00 <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
    7cf2:	68d9      	ldr	r1, [r3, #12]
    7cf4:	b139      	cbz	r1, 7d06 <bt_hci_driver_register+0x1e>
    7cf6:	6919      	ldr	r1, [r3, #16]
    7cf8:	b129      	cbz	r1, 7d06 <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
    7cfa:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
	return 0;
    7cfe:	4770      	bx	lr
		return -EALREADY;
    7d00:	f06f 0044 	mvn.w	r0, #68	; 0x44
    7d04:	4770      	bx	lr
		return -EINVAL;
    7d06:	f06f 0015 	mvn.w	r0, #21
}
    7d0a:	4770      	bx	lr
    7d0c:	2000ba38 	.word	0x2000ba38

00007d10 <bt_finalize_init>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7d10:	4b07      	ldr	r3, [pc, #28]	; (7d30 <bt_finalize_init+0x20>)
    7d12:	f3bf 8f5b 	dmb	ish
    7d16:	e853 2f00 	ldrex	r2, [r3]
    7d1a:	f042 0202 	orr.w	r2, r2, #2
    7d1e:	e843 2100 	strex	r1, r2, [r3]
    7d22:	2900      	cmp	r1, #0
    7d24:	d1f7      	bne.n	7d16 <bt_finalize_init+0x6>
    7d26:	f3bf 8f5b 	dmb	ish
		bt_le_scan_update(false);
    7d2a:	2000      	movs	r0, #0
    7d2c:	f7ff be0e 	b.w	794c <bt_le_scan_update>
    7d30:	2000bad0 	.word	0x2000bad0

00007d34 <bt_get_name>:
}
    7d34:	4800      	ldr	r0, [pc, #0]	; (7d38 <bt_get_name+0x4>)
    7d36:	4770      	bx	lr
    7d38:	0001af30 	.word	0x0001af30

00007d3c <bt_id_get>:
{
    7d3c:	b538      	push	{r3, r4, r5, lr}
    7d3e:	460d      	mov	r5, r1
	size_t to_copy = MIN(*count, bt_dev.id_count);
    7d40:	4905      	ldr	r1, [pc, #20]	; (7d58 <bt_id_get+0x1c>)
    7d42:	682b      	ldr	r3, [r5, #0]
    7d44:	79cc      	ldrb	r4, [r1, #7]
    7d46:	429c      	cmp	r4, r3
    7d48:	bf28      	it	cs
    7d4a:	461c      	movcs	r4, r3
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
    7d4c:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
    7d50:	f00e f973 	bl	1603a <memcpy>
	*count = to_copy;
    7d54:	602c      	str	r4, [r5, #0]
}
    7d56:	bd38      	pop	{r3, r4, r5, pc}
    7d58:	2000ba38 	.word	0x2000ba38

00007d5c <bt_id_create>:
{
    7d5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7d5e:	460c      	mov	r4, r1
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    7d60:	4605      	mov	r5, r0
    7d62:	b918      	cbnz	r0, 7d6c <bt_id_create+0x10>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    7d64:	b34c      	cbz	r4, 7dba <bt_id_create+0x5e>
		return -EINVAL;
    7d66:	f06f 0415 	mvn.w	r4, #21
    7d6a:	e023      	b.n	7db4 <bt_id_create+0x58>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    7d6c:	2300      	movs	r3, #0
    7d6e:	2207      	movs	r2, #7
    7d70:	4669      	mov	r1, sp
    7d72:	9300      	str	r3, [sp, #0]
    7d74:	f8cd 3003 	str.w	r3, [sp, #3]
    7d78:	f00e f94f 	bl	1601a <memcmp>
    7d7c:	2800      	cmp	r0, #0
    7d7e:	d0f1      	beq.n	7d64 <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    7d80:	782b      	ldrb	r3, [r5, #0]
    7d82:	2b01      	cmp	r3, #1
    7d84:	d104      	bne.n	7d90 <bt_id_create+0x34>
    7d86:	79ab      	ldrb	r3, [r5, #6]
    7d88:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    7d8c:	2bc0      	cmp	r3, #192	; 0xc0
    7d8e:	d00a      	beq.n	7da6 <bt_id_create+0x4a>
    7d90:	4b11      	ldr	r3, [pc, #68]	; (7dd8 <bt_id_create+0x7c>)
    7d92:	4912      	ldr	r1, [pc, #72]	; (7ddc <bt_id_create+0x80>)
			BT_ERR("Only static random identity address supported");
    7d94:	4812      	ldr	r0, [pc, #72]	; (7de0 <bt_id_create+0x84>)
    7d96:	1ac9      	subs	r1, r1, r3
    7d98:	08c9      	lsrs	r1, r1, #3
    7d9a:	0189      	lsls	r1, r1, #6
    7d9c:	f041 0101 	orr.w	r1, r1, #1
    7da0:	f00d fa53 	bl	1524a <log_0>
			return -EINVAL;
    7da4:	e7df      	b.n	7d66 <bt_id_create+0xa>
		if (id_find(addr) >= 0) {
    7da6:	4628      	mov	r0, r5
    7da8:	f7ff fa38 	bl	721c <id_find>
    7dac:	2800      	cmp	r0, #0
    7dae:	dbd9      	blt.n	7d64 <bt_id_create+0x8>
			return -EALREADY;
    7db0:	f06f 0444 	mvn.w	r4, #68	; 0x44
}
    7db4:	4620      	mov	r0, r4
    7db6:	b003      	add	sp, #12
    7db8:	bd30      	pop	{r4, r5, pc}
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    7dba:	4b0a      	ldr	r3, [pc, #40]	; (7de4 <bt_id_create+0x88>)
    7dbc:	79dc      	ldrb	r4, [r3, #7]
    7dbe:	2c01      	cmp	r4, #1
    7dc0:	d006      	beq.n	7dd0 <bt_id_create+0x74>
	new_id = bt_dev.id_count++;
    7dc2:	1c62      	adds	r2, r4, #1
	id_create(new_id, addr, irk);
    7dc4:	4629      	mov	r1, r5
    7dc6:	4620      	mov	r0, r4
	new_id = bt_dev.id_count++;
    7dc8:	71da      	strb	r2, [r3, #7]
	id_create(new_id, addr, irk);
    7dca:	f7ff fe0b 	bl	79e4 <id_create.isra.0>
	return new_id;
    7dce:	e7f1      	b.n	7db4 <bt_id_create+0x58>
		return -ENOMEM;
    7dd0:	f06f 040b 	mvn.w	r4, #11
    7dd4:	e7ee      	b.n	7db4 <bt_id_create+0x58>
    7dd6:	bf00      	nop
    7dd8:	0001956c 	.word	0x0001956c
    7ddc:	000195f4 	.word	0x000195f4
    7de0:	0001b012 	.word	0x0001b012
    7de4:	2000ba38 	.word	0x2000ba38

00007de8 <bt_setup_public_id_addr>:
{
    7de8:	b570      	push	{r4, r5, r6, lr}
    7dea:	b086      	sub	sp, #24
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    7dec:	aa01      	add	r2, sp, #4
    7dee:	2100      	movs	r1, #0
    7df0:	f241 0009 	movw	r0, #4105	; 0x1009
    7df4:	f7ff fb80 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    7df8:	4e1f      	ldr	r6, [pc, #124]	; (7e78 <bt_setup_public_id_addr+0x90>)
    7dfa:	4604      	mov	r4, r0
    7dfc:	b168      	cbz	r0, 7e1a <bt_setup_public_id_addr+0x32>
    7dfe:	491f      	ldr	r1, [pc, #124]	; (7e7c <bt_setup_public_id_addr+0x94>)
    7e00:	4b1f      	ldr	r3, [pc, #124]	; (7e80 <bt_setup_public_id_addr+0x98>)
		BT_WARN("Failed to read public address");
    7e02:	4820      	ldr	r0, [pc, #128]	; (7e84 <bt_setup_public_id_addr+0x9c>)
    7e04:	1ac9      	subs	r1, r1, r3
    7e06:	08c9      	lsrs	r1, r1, #3
    7e08:	0189      	lsls	r1, r1, #6
    7e0a:	f041 0102 	orr.w	r1, r1, #2
    7e0e:	f00d fa1c 	bl	1524a <log_0>
	bt_dev.id_count = bt_read_public_addr(&addr);
    7e12:	2300      	movs	r3, #0
    7e14:	71f3      	strb	r3, [r6, #7]
}
    7e16:	b006      	add	sp, #24
    7e18:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    7e1a:	9b01      	ldr	r3, [sp, #4]
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    7e1c:	689d      	ldr	r5, [r3, #8]
    7e1e:	9004      	str	r0, [sp, #16]
    7e20:	3501      	adds	r5, #1
    7e22:	f8ad 0014 	strh.w	r0, [sp, #20]
	return memcmp(a, b, sizeof(*a));
    7e26:	2206      	movs	r2, #6
    7e28:	a904      	add	r1, sp, #16
    7e2a:	4628      	mov	r0, r5
    7e2c:	f00e f8f5 	bl	1601a <memcmp>
    7e30:	b918      	cbnz	r0, 7e3a <bt_setup_public_id_addr+0x52>
		net_buf_unref(rsp);
    7e32:	9801      	ldr	r0, [sp, #4]
    7e34:	f005 fd6c 	bl	d910 <net_buf_unref>
    7e38:	e7eb      	b.n	7e12 <bt_setup_public_id_addr+0x2a>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    7e3a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7e3e:	2206      	movs	r2, #6
    7e40:	a902      	add	r1, sp, #8
    7e42:	4628      	mov	r0, r5
    7e44:	9302      	str	r3, [sp, #8]
    7e46:	f8ad 300c 	strh.w	r3, [sp, #12]
    7e4a:	f00e f8e6 	bl	1601a <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    7e4e:	2800      	cmp	r0, #0
    7e50:	d0ef      	beq.n	7e32 <bt_setup_public_id_addr+0x4a>
	memcpy(dst, src, sizeof(*dst));
    7e52:	4629      	mov	r1, r5
    7e54:	2206      	movs	r2, #6
    7e56:	f10d 0011 	add.w	r0, sp, #17
    7e5a:	f00e f8ee 	bl	1603a <memcpy>
	net_buf_unref(rsp);
    7e5e:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
    7e60:	f88d 4010 	strb.w	r4, [sp, #16]
	net_buf_unref(rsp);
    7e64:	f005 fd54 	bl	d910 <net_buf_unref>
	bt_dev.id_count = bt_read_public_addr(&addr);
    7e68:	2301      	movs	r3, #1
	id_create(BT_ID_DEFAULT, &addr, irk);
    7e6a:	a904      	add	r1, sp, #16
    7e6c:	4620      	mov	r0, r4
	bt_dev.id_count = bt_read_public_addr(&addr);
    7e6e:	71f3      	strb	r3, [r6, #7]
	id_create(BT_ID_DEFAULT, &addr, irk);
    7e70:	f7ff fdb8 	bl	79e4 <id_create.isra.0>
    7e74:	e7cf      	b.n	7e16 <bt_setup_public_id_addr+0x2e>
    7e76:	bf00      	nop
    7e78:	2000ba38 	.word	0x2000ba38
    7e7c:	000195f4 	.word	0x000195f4
    7e80:	0001956c 	.word	0x0001956c
    7e84:	0001b040 	.word	0x0001b040

00007e88 <bt_read_static_addr>:
{
    7e88:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    7e8c:	4b25      	ldr	r3, [pc, #148]	; (7f24 <bt_read_static_addr+0x9c>)
    7e8e:	f893 408a 	ldrb.w	r4, [r3, #138]	; 0x8a
    7e92:	f014 0401 	ands.w	r4, r4, #1
{
    7e96:	4607      	mov	r7, r0
    7e98:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    7e9a:	d10a      	bne.n	7eb2 <bt_read_static_addr+0x2a>
    7e9c:	4922      	ldr	r1, [pc, #136]	; (7f28 <bt_read_static_addr+0xa0>)
    7e9e:	4b23      	ldr	r3, [pc, #140]	; (7f2c <bt_read_static_addr+0xa4>)
		BT_WARN("Read Static Addresses command not available");
    7ea0:	4823      	ldr	r0, [pc, #140]	; (7f30 <bt_read_static_addr+0xa8>)
    7ea2:	1ac9      	subs	r1, r1, r3
    7ea4:	08c9      	lsrs	r1, r1, #3
    7ea6:	0189      	lsls	r1, r1, #6
    7ea8:	f041 0102 	orr.w	r1, r1, #2
		BT_WARN("No static addresses stored in controller");
    7eac:	f00d f9cd 	bl	1524a <log_0>
    7eb0:	e012      	b.n	7ed8 <bt_read_static_addr+0x50>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    7eb2:	aa01      	add	r2, sp, #4
    7eb4:	2100      	movs	r1, #0
    7eb6:	f64f 4009 	movw	r0, #64521	; 0xfc09
    7eba:	f7ff fb1d 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    7ebe:	4605      	mov	r5, r0
    7ec0:	b170      	cbz	r0, 7ee0 <bt_read_static_addr+0x58>
    7ec2:	4b1a      	ldr	r3, [pc, #104]	; (7f2c <bt_read_static_addr+0xa4>)
    7ec4:	4918      	ldr	r1, [pc, #96]	; (7f28 <bt_read_static_addr+0xa0>)
		BT_WARN("Failed to read static addresses");
    7ec6:	481b      	ldr	r0, [pc, #108]	; (7f34 <bt_read_static_addr+0xac>)
    7ec8:	1ac9      	subs	r1, r1, r3
    7eca:	08c9      	lsrs	r1, r1, #3
    7ecc:	0189      	lsls	r1, r1, #6
    7ece:	f041 0102 	orr.w	r1, r1, #2
    7ed2:	f00d f9ba 	bl	1524a <log_0>
		return 0;
    7ed6:	2400      	movs	r4, #0
}
    7ed8:	4620      	mov	r0, r4
    7eda:	b002      	add	sp, #8
    7edc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	rp = (void *)rsp->data;
    7ee0:	9b01      	ldr	r3, [sp, #4]
    7ee2:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    7ee4:	785c      	ldrb	r4, [r3, #1]
    7ee6:	42b4      	cmp	r4, r6
    7ee8:	bf28      	it	cs
    7eea:	4634      	movcs	r4, r6
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    7eec:	f04f 0816 	mov.w	r8, #22
    7ef0:	1c9e      	adds	r6, r3, #2
	for (i = 0; i < cnt; i++) {
    7ef2:	42a5      	cmp	r5, r4
    7ef4:	db0d      	blt.n	7f12 <bt_read_static_addr+0x8a>
	net_buf_unref(rsp);
    7ef6:	9801      	ldr	r0, [sp, #4]
    7ef8:	f005 fd0a 	bl	d910 <net_buf_unref>
	if (!cnt) {
    7efc:	2c00      	cmp	r4, #0
    7efe:	d1eb      	bne.n	7ed8 <bt_read_static_addr+0x50>
    7f00:	4909      	ldr	r1, [pc, #36]	; (7f28 <bt_read_static_addr+0xa0>)
    7f02:	4b0a      	ldr	r3, [pc, #40]	; (7f2c <bt_read_static_addr+0xa4>)
		BT_WARN("No static addresses stored in controller");
    7f04:	480c      	ldr	r0, [pc, #48]	; (7f38 <bt_read_static_addr+0xb0>)
    7f06:	1ac9      	subs	r1, r1, r3
    7f08:	08c9      	lsrs	r1, r1, #3
    7f0a:	0189      	lsls	r1, r1, #6
    7f0c:	f041 0102 	orr.w	r1, r1, #2
    7f10:	e7cc      	b.n	7eac <bt_read_static_addr+0x24>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    7f12:	fb08 7005 	mla	r0, r8, r5, r7
    7f16:	2216      	movs	r2, #22
    7f18:	4631      	mov	r1, r6
    7f1a:	f00e f88e 	bl	1603a <memcpy>
	for (i = 0; i < cnt; i++) {
    7f1e:	3501      	adds	r5, #1
    7f20:	e7e7      	b.n	7ef2 <bt_read_static_addr+0x6a>
    7f22:	bf00      	nop
    7f24:	2000ba38 	.word	0x2000ba38
    7f28:	000195f4 	.word	0x000195f4
    7f2c:	0001956c 	.word	0x0001956c
    7f30:	0001b05e 	.word	0x0001b05e
    7f34:	0001b08a 	.word	0x0001b08a
    7f38:	0001b0aa 	.word	0x0001b0aa

00007f3c <bt_setup_random_id_addr>:
{
    7f3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!bt_dev.id_count) {
    7f3e:	4d14      	ldr	r5, [pc, #80]	; (7f90 <bt_setup_random_id_addr+0x54>)
    7f40:	79ec      	ldrb	r4, [r5, #7]
{
    7f42:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.id_count) {
    7f44:	b9f4      	cbnz	r4, 7f84 <bt_setup_random_id_addr+0x48>
		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    7f46:	2101      	movs	r1, #1
    7f48:	a802      	add	r0, sp, #8
    7f4a:	f7ff ff9d 	bl	7e88 <bt_read_static_addr>
    7f4e:	71e8      	strb	r0, [r5, #7]
		if (bt_dev.id_count) {
    7f50:	b1c0      	cbz	r0, 7f84 <bt_setup_random_id_addr+0x48>
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    7f52:	2716      	movs	r7, #22
    7f54:	e00f      	b.n	7f76 <bt_setup_random_id_addr+0x3a>
    7f56:	ab02      	add	r3, sp, #8
    7f58:	fb07 3106 	mla	r1, r7, r6, r3
    7f5c:	2206      	movs	r2, #6
    7f5e:	f10d 0001 	add.w	r0, sp, #1
    7f62:	f00e f86a 	bl	1603a <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
    7f66:	2301      	movs	r3, #1
				id_create(i, &addr, irk);
    7f68:	4669      	mov	r1, sp
    7f6a:	4630      	mov	r0, r6
				addr.type = BT_ADDR_LE_RANDOM;
    7f6c:	f88d 3000 	strb.w	r3, [sp]
				id_create(i, &addr, irk);
    7f70:	f7ff fd38 	bl	79e4 <id_create.isra.0>
			for (u8_t i = 0; i < bt_dev.id_count; i++) {
    7f74:	3401      	adds	r4, #1
    7f76:	79eb      	ldrb	r3, [r5, #7]
    7f78:	b2e6      	uxtb	r6, r4
    7f7a:	42b3      	cmp	r3, r6
    7f7c:	d8eb      	bhi.n	7f56 <bt_setup_random_id_addr+0x1a>
			return 0;
    7f7e:	2000      	movs	r0, #0
}
    7f80:	b009      	add	sp, #36	; 0x24
    7f82:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return bt_id_create(NULL, NULL);
    7f84:	2100      	movs	r1, #0
    7f86:	4608      	mov	r0, r1
    7f88:	f7ff fee8 	bl	7d5c <bt_id_create>
    7f8c:	e7f8      	b.n	7f80 <bt_setup_random_id_addr+0x44>
    7f8e:	bf00      	nop
    7f90:	2000ba38 	.word	0x2000ba38

00007f94 <hci_init>:
{
    7f94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    7f96:	4db9      	ldr	r5, [pc, #740]	; (827c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x27c>)
    7f98:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
    7f9c:	6899      	ldr	r1, [r3, #8]
    7f9e:	f011 0101 	ands.w	r1, r1, #1
    7fa2:	d121      	bne.n	7fe8 <hci_init+0x54>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    7fa4:	aa01      	add	r2, sp, #4
    7fa6:	f640 4003 	movw	r0, #3075	; 0xc03
    7faa:	f7ff faa5 	bl	74f8 <bt_hci_cmd_send_sync>
		if (err) {
    7fae:	4604      	mov	r4, r0
    7fb0:	2800      	cmp	r0, #0
    7fb2:	d170      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		hci_reset_complete(rsp);
    7fb4:	9b01      	ldr	r3, [sp, #4]
	u8_t status = buf->data[0];
    7fb6:	689b      	ldr	r3, [r3, #8]
	if (status) {
    7fb8:	781b      	ldrb	r3, [r3, #0]
    7fba:	b993      	cbnz	r3, 7fe2 <hci_init+0x4e>
	scan_dev_found_cb = NULL;
    7fbc:	4ab0      	ldr	r2, [pc, #704]	; (8280 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x280>)
    7fbe:	6013      	str	r3, [r2, #0]
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    7fc0:	f105 0398 	add.w	r3, r5, #152	; 0x98
    7fc4:	4618      	mov	r0, r3
    7fc6:	f00e f92e 	bl	16226 <atomic_get>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    7fca:	f3bf 8f5b 	dmb	ish
    7fce:	f000 0005 	and.w	r0, r0, #5
    7fd2:	e853 2f00 	ldrex	r2, [r3]
    7fd6:	e843 0100 	strex	r1, r0, [r3]
    7fda:	2900      	cmp	r1, #0
    7fdc:	d1f9      	bne.n	7fd2 <hci_init+0x3e>
    7fde:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
    7fe2:	9801      	ldr	r0, [sp, #4]
    7fe4:	f005 fc94 	bl	d910 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    7fe8:	aa01      	add	r2, sp, #4
    7fea:	2100      	movs	r1, #0
    7fec:	f241 0003 	movw	r0, #4099	; 0x1003
    7ff0:	f7ff fa82 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    7ff4:	4604      	mov	r4, r0
    7ff6:	2800      	cmp	r0, #0
    7ff8:	d14d      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
	read_local_features_complete(rsp);
    7ffa:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    7ffc:	48a1      	ldr	r0, [pc, #644]	; (8284 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x284>)
    7ffe:	6899      	ldr	r1, [r3, #8]
    8000:	2208      	movs	r2, #8
    8002:	3101      	adds	r1, #1
    8004:	f00e f819 	bl	1603a <memcpy>
	net_buf_unref(rsp);
    8008:	9801      	ldr	r0, [sp, #4]
    800a:	f005 fc81 	bl	d910 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    800e:	4621      	mov	r1, r4
    8010:	aa01      	add	r2, sp, #4
    8012:	f241 0001 	movw	r0, #4097	; 0x1001
    8016:	f7ff fa6f 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    801a:	4604      	mov	r4, r0
    801c:	2800      	cmp	r0, #0
    801e:	d13a      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
	read_local_ver_complete(rsp);
    8020:	9801      	ldr	r0, [sp, #4]
    8022:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    8024:	785a      	ldrb	r2, [r3, #1]
    8026:	f885 2038 	strb.w	r2, [r5, #56]	; 0x38
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    802a:	78d9      	ldrb	r1, [r3, #3]
    802c:	789a      	ldrb	r2, [r3, #2]
    802e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    8032:	876a      	strh	r2, [r5, #58]	; 0x3a
	bt_dev.lmp_version = rp->lmp_version;
    8034:	791a      	ldrb	r2, [r3, #4]
    8036:	f885 2039 	strb.w	r2, [r5, #57]	; 0x39
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    803a:	7a19      	ldrb	r1, [r3, #8]
    803c:	79da      	ldrb	r2, [r3, #7]
    803e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    8042:	87aa      	strh	r2, [r5, #60]	; 0x3c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    8044:	795a      	ldrb	r2, [r3, #5]
    8046:	799b      	ldrb	r3, [r3, #6]
    8048:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    804c:	87eb      	strh	r3, [r5, #62]	; 0x3e
	net_buf_unref(rsp);
    804e:	f005 fc5f 	bl	d910 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    8052:	4621      	mov	r1, r4
    8054:	aa01      	add	r2, sp, #4
    8056:	f241 0002 	movw	r0, #4098	; 0x1002
    805a:	f7ff fa4d 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    805e:	4604      	mov	r4, r0
    8060:	b9c8      	cbnz	r0, 8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
	read_supported_commands_complete(rsp);
    8062:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.supported_commands, rp->commands,
    8064:	4888      	ldr	r0, [pc, #544]	; (8288 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x288>)
    8066:	6899      	ldr	r1, [r3, #8]
    8068:	2240      	movs	r2, #64	; 0x40
    806a:	3101      	adds	r1, #1
    806c:	f00d ffe5 	bl	1603a <memcpy>
	net_buf_unref(rsp);
    8070:	9801      	ldr	r0, [sp, #4]
    8072:	f005 fc4d 	bl	d910 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
    8076:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
    807a:	0658      	lsls	r0, r3, #25
    807c:	d40e      	bmi.n	809c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x9c>
    807e:	4b83      	ldr	r3, [pc, #524]	; (828c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28c>)
    8080:	4983      	ldr	r1, [pc, #524]	; (8290 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x290>)
		BT_ERR("Non-LE capable controller detected!");
    8082:	4884      	ldr	r0, [pc, #528]	; (8294 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x294>)
    8084:	1ac9      	subs	r1, r1, r3
    8086:	08c9      	lsrs	r1, r1, #3
    8088:	0189      	lsls	r1, r1, #6
    808a:	f041 0101 	orr.w	r1, r1, #1
    808e:	f00d f8dc 	bl	1524a <log_0>
		return -ENODEV;
    8092:	f06f 0412 	mvn.w	r4, #18
}
    8096:	4620      	mov	r0, r4
    8098:	b003      	add	sp, #12
    809a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    809c:	4621      	mov	r1, r4
    809e:	aa01      	add	r2, sp, #4
    80a0:	f242 0003 	movw	r0, #8195	; 0x2003
    80a4:	f7ff fa28 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    80a8:	4604      	mov	r4, r0
    80aa:	2800      	cmp	r0, #0
    80ac:	d1f3      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
	read_le_features_complete(rsp);
    80ae:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    80b0:	4879      	ldr	r0, [pc, #484]	; (8298 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x298>)
    80b2:	6899      	ldr	r1, [r3, #8]
    80b4:	2208      	movs	r2, #8
    80b6:	3101      	adds	r1, #1
    80b8:	f00d ffbf 	bl	1603a <memcpy>
	net_buf_unref(rsp);
    80bc:	9801      	ldr	r0, [sp, #4]
    80be:	f005 fc27 	bl	d910 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    80c2:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
    80c6:	0699      	lsls	r1, r3, #26
    80c8:	d56b      	bpl.n	81a2 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a2>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    80ca:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
    80ce:	071a      	lsls	r2, r3, #28
    80d0:	f100 8083 	bmi.w	81da <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1da>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    80d4:	2108      	movs	r1, #8
    80d6:	f242 0001 	movw	r0, #8193	; 0x2001
    80da:	f7ff f9d7 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    80de:	4604      	mov	r4, r0
    80e0:	2800      	cmp	r0, #0
    80e2:	d065      	beq.n	81b0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b0>
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
    80e4:	2108      	movs	r1, #8
    80e6:	4408      	add	r0, r1
    80e8:	f00e ffe4 	bl	170b4 <net_buf_simple_add>
	dst[0] = val;
    80ec:	2702      	movs	r7, #2
	dst[1] = val >> 8;
    80ee:	2200      	movs	r2, #0
	dst[0] = val;
    80f0:	7007      	strb	r7, [r0, #0]
	dst[1] = val >> 8;
    80f2:	7042      	strb	r2, [r0, #1]
	dst[0] = val;
    80f4:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    80f6:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    80f8:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    80fa:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    80fc:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    80fe:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    8100:	4621      	mov	r1, r4
    8102:	f242 0001 	movw	r0, #8193	; 0x2001
    8106:	f7ff f9f7 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    810a:	4604      	mov	r4, r0
    810c:	2800      	cmp	r0, #0
    810e:	d1c2      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    8110:	2108      	movs	r1, #8
    8112:	f640 4001 	movw	r0, #3073	; 0xc01
    8116:	f7ff f9b9 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    811a:	4606      	mov	r6, r0
    811c:	2800      	cmp	r0, #0
    811e:	d047      	beq.n	81b0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b0>
	ev = net_buf_add(buf, sizeof(*ev));
    8120:	2108      	movs	r1, #8
    8122:	4408      	add	r0, r1
    8124:	f00e ffc6 	bl	170b4 <net_buf_simple_add>
    8128:	2380      	movs	r3, #128	; 0x80
    812a:	7043      	strb	r3, [r0, #1]
    812c:	2320      	movs	r3, #32
	dst[0] = val;
    812e:	7004      	strb	r4, [r0, #0]
    8130:	7084      	strb	r4, [r0, #2]
    8132:	7104      	strb	r4, [r0, #4]
	dst[1] = val >> 8;
    8134:	7144      	strb	r4, [r0, #5]
	dst[0] = val;
    8136:	7184      	strb	r4, [r0, #6]
	dst[1] = val >> 8;
    8138:	70c7      	strb	r7, [r0, #3]
    813a:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    813c:	4622      	mov	r2, r4
    813e:	4631      	mov	r1, r6
    8140:	f640 4001 	movw	r0, #3073	; 0xc01
    8144:	f7ff f9d8 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    8148:	4604      	mov	r4, r0
    814a:	2800      	cmp	r0, #0
    814c:	d1a3      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    814e:	4601      	mov	r1, r0
    8150:	aa01      	add	r2, sp, #4
    8152:	f64f 4001 	movw	r0, #64513	; 0xfc01
    8156:	f7ff f9cf 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    815a:	2800      	cmp	r0, #0
    815c:	d051      	beq.n	8202 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x202>
    815e:	494c      	ldr	r1, [pc, #304]	; (8290 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x290>)
    8160:	4b4a      	ldr	r3, [pc, #296]	; (828c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28c>)
		BT_WARN("Vendor HCI extensions not available");
    8162:	484e      	ldr	r0, [pc, #312]	; (829c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x29c>)
    8164:	1ac9      	subs	r1, r1, r3
    8166:	08c9      	lsrs	r1, r1, #3
    8168:	0189      	lsls	r1, r1, #6
    816a:	4339      	orrs	r1, r7
			BT_WARN("Failed to read supported vendor features");
    816c:	f00d f86d 	bl	1524a <log_0>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    8170:	79eb      	ldrb	r3, [r5, #7]
    8172:	2b00      	cmp	r3, #0
    8174:	d18f      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		bt_setup_public_id_addr();
    8176:	f7ff fe37 	bl	7de8 <bt_setup_public_id_addr>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    817a:	79eb      	ldrb	r3, [r5, #7]
    817c:	2b00      	cmp	r3, #0
    817e:	d18a      	bne.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		err = bt_setup_random_id_addr();
    8180:	f7ff fedc 	bl	7f3c <bt_setup_random_id_addr>
		if (err) {
    8184:	4604      	mov	r4, r0
    8186:	2800      	cmp	r0, #0
    8188:	f000 8094 	beq.w	82b4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2b4>
    818c:	4940      	ldr	r1, [pc, #256]	; (8290 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x290>)
    818e:	4b3f      	ldr	r3, [pc, #252]	; (828c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28c>)
			BT_ERR("Unable to set identity address");
    8190:	4843      	ldr	r0, [pc, #268]	; (82a0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2a0>)
    8192:	1ac9      	subs	r1, r1, r3
    8194:	08c9      	lsrs	r1, r1, #3
    8196:	0189      	lsls	r1, r1, #6
    8198:	f041 0101 	orr.w	r1, r1, #1
			BT_ERR("Unable to set random address");
    819c:	f00d f855 	bl	1524a <log_0>
			return err;
    81a0:	e779      	b.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    81a2:	2102      	movs	r1, #2
    81a4:	f640 406d 	movw	r0, #3181	; 0xc6d
    81a8:	f7ff f970 	bl	748c <bt_hci_cmd_create>
		if (!buf) {
    81ac:	4606      	mov	r6, r0
    81ae:	b910      	cbnz	r0, 81b6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b6>
		return -ENOBUFS;
    81b0:	f06f 0436 	mvn.w	r4, #54	; 0x36
    81b4:	e76f      	b.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		cp_le = net_buf_add(buf, sizeof(*cp_le));
    81b6:	2102      	movs	r1, #2
    81b8:	3008      	adds	r0, #8
    81ba:	f00e ff7b 	bl	170b4 <net_buf_simple_add>
		cp_le->le = 0x01;
    81be:	2301      	movs	r3, #1
		cp_le->simul = 0x00;
    81c0:	7044      	strb	r4, [r0, #1]
		cp_le->le = 0x01;
    81c2:	7003      	strb	r3, [r0, #0]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    81c4:	4622      	mov	r2, r4
    81c6:	4631      	mov	r1, r6
    81c8:	f640 406d 	movw	r0, #3181	; 0xc6d
    81cc:	f7ff f994 	bl	74f8 <bt_hci_cmd_send_sync>
		if (err) {
    81d0:	4604      	mov	r4, r0
    81d2:	2800      	cmp	r0, #0
    81d4:	f43f af79 	beq.w	80ca <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xca>
    81d8:	e75d      	b.n	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    81da:	aa01      	add	r2, sp, #4
    81dc:	2100      	movs	r1, #0
    81de:	f242 001c 	movw	r0, #8220	; 0x201c
    81e2:	f7ff f989 	bl	74f8 <bt_hci_cmd_send_sync>
		if (err) {
    81e6:	4604      	mov	r4, r0
    81e8:	2800      	cmp	r0, #0
    81ea:	f47f af54 	bne.w	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
		le_read_supp_states_complete(rsp);
    81ee:	9801      	ldr	r0, [sp, #4]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline u64_t sys_get_le64(const u8_t src[8])
{
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    81f0:	6883      	ldr	r3, [r0, #8]
    81f2:	f853 2f01 	ldr.w	r2, [r3, #1]!
    81f6:	685b      	ldr	r3, [r3, #4]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    81f8:	e9c5 232a 	strd	r2, r3, [r5, #168]	; 0xa8
		net_buf_unref(rsp);
    81fc:	f005 fb88 	bl	d910 <net_buf_unref>
    8200:	e768      	b.n	80d4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xd4>
	net_buf_unref(rsp);
    8202:	9801      	ldr	r0, [sp, #4]
    8204:	f005 fb84 	bl	d910 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    8208:	aa01      	add	r2, sp, #4
    820a:	4621      	mov	r1, r4
    820c:	f64f 4002 	movw	r0, #64514	; 0xfc02
    8210:	f7ff f972 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    8214:	b140      	cbz	r0, 8228 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x228>
    8216:	491e      	ldr	r1, [pc, #120]	; (8290 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x290>)
    8218:	4b1c      	ldr	r3, [pc, #112]	; (828c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28c>)
		BT_WARN("Failed to read supported vendor commands");
    821a:	4822      	ldr	r0, [pc, #136]	; (82a4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2a4>)
    821c:	1ac9      	subs	r1, r1, r3
    821e:	08c9      	lsrs	r1, r1, #3
    8220:	0189      	lsls	r1, r1, #6
    8222:	f041 0102 	orr.w	r1, r1, #2
    8226:	e7a1      	b.n	816c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x16c>
	rp.cmds = (void *)rsp->data;
    8228:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    822a:	481f      	ldr	r0, [pc, #124]	; (82a8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2a8>)
    822c:	6899      	ldr	r1, [r3, #8]
    822e:	463a      	mov	r2, r7
    8230:	3101      	adds	r1, #1
    8232:	f00d ff02 	bl	1603a <memcpy>
	net_buf_unref(rsp);
    8236:	9801      	ldr	r0, [sp, #4]
    8238:	f005 fb6a 	bl	d910 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    823c:	f895 3089 	ldrb.w	r3, [r5, #137]	; 0x89
    8240:	075b      	lsls	r3, r3, #29
    8242:	d595      	bpl.n	8170 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x170>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    8244:	aa01      	add	r2, sp, #4
    8246:	4621      	mov	r1, r4
    8248:	f64f 4003 	movw	r0, #64515	; 0xfc03
    824c:	f7ff f954 	bl	74f8 <bt_hci_cmd_send_sync>
		if (err) {
    8250:	b140      	cbz	r0, 8264 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x264>
    8252:	490f      	ldr	r1, [pc, #60]	; (8290 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x290>)
    8254:	4b0d      	ldr	r3, [pc, #52]	; (828c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28c>)
			BT_WARN("Failed to read supported vendor features");
    8256:	4815      	ldr	r0, [pc, #84]	; (82ac <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2ac>)
    8258:	1ac9      	subs	r1, r1, r3
    825a:	08c9      	lsrs	r1, r1, #3
    825c:	0189      	lsls	r1, r1, #6
    825e:	f041 0102 	orr.w	r1, r1, #2
    8262:	e783      	b.n	816c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x16c>
		rp.feat = (void *)rsp->data;
    8264:	9b01      	ldr	r3, [sp, #4]
		memcpy(bt_dev.vs_features, rp.feat->features,
    8266:	4812      	ldr	r0, [pc, #72]	; (82b0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2b0>)
    8268:	6899      	ldr	r1, [r3, #8]
    826a:	2201      	movs	r2, #1
    826c:	4411      	add	r1, r2
    826e:	f00d fee4 	bl	1603a <memcpy>
		net_buf_unref(rsp);
    8272:	9801      	ldr	r0, [sp, #4]
    8274:	f005 fb4c 	bl	d910 <net_buf_unref>
    8278:	e77a      	b.n	8170 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x170>
    827a:	bf00      	nop
    827c:	2000ba38 	.word	0x2000ba38
    8280:	20002b3c 	.word	0x20002b3c
    8284:	2000ba78 	.word	0x2000ba78
    8288:	2000ba80 	.word	0x2000ba80
    828c:	0001956c 	.word	0x0001956c
    8290:	000195f4 	.word	0x000195f4
    8294:	0001b0d3 	.word	0x0001b0d3
    8298:	2000bad8 	.word	0x2000bad8
    829c:	0001b0f7 	.word	0x0001b0f7
    82a0:	0001b16d 	.word	0x0001b16d
    82a4:	0001b11b 	.word	0x0001b11b
    82a8:	2000bac1 	.word	0x2000bac1
    82ac:	0001b144 	.word	0x0001b144
    82b0:	2000bac0 	.word	0x2000bac0
		err = set_random_address(&bt_dev.id_addr[0].a);
    82b4:	4807      	ldr	r0, [pc, #28]	; (82d4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2d4>)
    82b6:	f7ff f995 	bl	75e4 <set_random_address>
		if (err) {
    82ba:	4604      	mov	r4, r0
    82bc:	2800      	cmp	r0, #0
    82be:	f43f aeea 	beq.w	8096 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x96>
    82c2:	4905      	ldr	r1, [pc, #20]	; (82d8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2d8>)
    82c4:	4b05      	ldr	r3, [pc, #20]	; (82dc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2dc>)
			BT_ERR("Unable to set random address");
    82c6:	4806      	ldr	r0, [pc, #24]	; (82e0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2e0>)
    82c8:	1ac9      	subs	r1, r1, r3
    82ca:	08c9      	lsrs	r1, r1, #3
    82cc:	0189      	lsls	r1, r1, #6
    82ce:	f041 0101 	orr.w	r1, r1, #1
    82d2:	e763      	b.n	819c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x19c>
    82d4:	2000ba39 	.word	0x2000ba39
    82d8:	000195f4 	.word	0x000195f4
    82dc:	0001956c 	.word	0x0001956c
    82e0:	0001b18c 	.word	0x0001b18c

000082e4 <bt_enable>:
{
    82e4:	b570      	push	{r4, r5, r6, lr}
	if (!bt_dev.drv) {
    82e6:	4d37      	ldr	r5, [pc, #220]	; (83c4 <bt_enable+0xe0>)
    82e8:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
{
    82ec:	b086      	sub	sp, #24
    82ee:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    82f0:	b973      	cbnz	r3, 8310 <bt_enable+0x2c>
    82f2:	4b35      	ldr	r3, [pc, #212]	; (83c8 <bt_enable+0xe4>)
    82f4:	4935      	ldr	r1, [pc, #212]	; (83cc <bt_enable+0xe8>)
		BT_ERR("No HCI driver registered");
    82f6:	4836      	ldr	r0, [pc, #216]	; (83d0 <bt_enable+0xec>)
    82f8:	1ac9      	subs	r1, r1, r3
    82fa:	08c9      	lsrs	r1, r1, #3
    82fc:	0189      	lsls	r1, r1, #6
    82fe:	f041 0101 	orr.w	r1, r1, #1
    8302:	f00c ffa2 	bl	1524a <log_0>
		return -ENODEV;
    8306:	f06f 0412 	mvn.w	r4, #18
}
    830a:	4620      	mov	r0, r4
    830c:	b006      	add	sp, #24
    830e:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8310:	f105 0298 	add.w	r2, r5, #152	; 0x98
    8314:	f3bf 8f5b 	dmb	ish
    8318:	e852 3f00 	ldrex	r3, [r2]
    831c:	f043 0101 	orr.w	r1, r3, #1
    8320:	e842 1000 	strex	r0, r1, [r2]
    8324:	2800      	cmp	r0, #0
    8326:	d1f7      	bne.n	8318 <bt_enable+0x34>
    8328:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    832c:	f013 0301 	ands.w	r3, r3, #1
    8330:	d145      	bne.n	83be <bt_enable+0xda>
	ready_cb = cb;
    8332:	4a28      	ldr	r2, [pc, #160]	; (83d4 <bt_enable+0xf0>)
    8334:	6016      	str	r6, [r2, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    8336:	f06f 0208 	mvn.w	r2, #8
    833a:	e9cd 3202 	strd	r3, r2, [sp, #8]
    833e:	e9cd 3304 	strd	r3, r3, [sp, #16]
    8342:	e9cd 3300 	strd	r3, r3, [sp]
    8346:	4924      	ldr	r1, [pc, #144]	; (83d8 <bt_enable+0xf4>)
    8348:	4b24      	ldr	r3, [pc, #144]	; (83dc <bt_enable+0xf8>)
    834a:	4825      	ldr	r0, [pc, #148]	; (83e0 <bt_enable+0xfc>)
    834c:	f44f 7220 	mov.w	r2, #640	; 0x280
    8350:	f00c f852 	bl	143f8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    8354:	4923      	ldr	r1, [pc, #140]	; (83e4 <bt_enable+0x100>)
    8356:	4822      	ldr	r0, [pc, #136]	; (83e0 <bt_enable+0xfc>)
    8358:	f010 fdef 	bl	18f3a <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
    835c:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
    8360:	68db      	ldr	r3, [r3, #12]
    8362:	4798      	blx	r3
	if (err) {
    8364:	4604      	mov	r4, r0
    8366:	b158      	cbz	r0, 8380 <bt_enable+0x9c>
    8368:	4b17      	ldr	r3, [pc, #92]	; (83c8 <bt_enable+0xe4>)
    836a:	4a18      	ldr	r2, [pc, #96]	; (83cc <bt_enable+0xe8>)
    836c:	1ad2      	subs	r2, r2, r3
    836e:	08d2      	lsrs	r2, r2, #3
		BT_ERR("HCI driver open failed (%d)", err);
    8370:	0192      	lsls	r2, r2, #6
    8372:	4601      	mov	r1, r0
    8374:	f042 0201 	orr.w	r2, r2, #1
    8378:	481b      	ldr	r0, [pc, #108]	; (83e8 <bt_enable+0x104>)
    837a:	f00c ff73 	bl	15264 <log_1>
		return err;
    837e:	e7c4      	b.n	830a <bt_enable+0x26>
	if (!cb) {
    8380:	b93e      	cbnz	r6, 8392 <bt_enable+0xae>
	err = hci_init();
    8382:	f7ff fe07 	bl	7f94 <hci_init>
	if (err) {
    8386:	4604      	mov	r4, r0
    8388:	2800      	cmp	r0, #0
    838a:	d1be      	bne.n	830a <bt_enable+0x26>
	bt_finalize_init();
    838c:	f7ff fcc0 	bl	7d10 <bt_finalize_init>
	return 0;
    8390:	e7bb      	b.n	830a <bt_enable+0x26>
    8392:	f105 0394 	add.w	r3, r5, #148	; 0x94
    8396:	f3bf 8f5b 	dmb	ish
    839a:	e853 2f00 	ldrex	r2, [r3]
    839e:	f042 0101 	orr.w	r1, r2, #1
    83a2:	e843 1000 	strex	r0, r1, [r3]
    83a6:	2800      	cmp	r0, #0
    83a8:	d1f7      	bne.n	839a <bt_enable+0xb6>
    83aa:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    83ae:	07d3      	lsls	r3, r2, #31
    83b0:	d4ab      	bmi.n	830a <bt_enable+0x26>
		k_queue_append(&work_q->queue, work);
    83b2:	480e      	ldr	r0, [pc, #56]	; (83ec <bt_enable+0x108>)
    83b4:	f105 018c 	add.w	r1, r5, #140	; 0x8c
    83b8:	f010 fbf5 	bl	18ba6 <k_queue_append>
    83bc:	e7a5      	b.n	830a <bt_enable+0x26>
		return -EALREADY;
    83be:	f06f 0444 	mvn.w	r4, #68	; 0x44
    83c2:	e7a2      	b.n	830a <bt_enable+0x26>
    83c4:	2000ba38 	.word	0x2000ba38
    83c8:	0001956c 	.word	0x0001956c
    83cc:	000195f4 	.word	0x000195f4
    83d0:	0001b1a9 	.word	0x0001b1a9
    83d4:	20002b30 	.word	0x20002b30
    83d8:	200092e0 	.word	0x200092e0
    83dc:	00007a4d 	.word	0x00007a4d
    83e0:	20002b40 	.word	0x20002b40
    83e4:	0001b1c2 	.word	0x0001b1c2
    83e8:	0001b1c8 	.word	0x0001b1c8
    83ec:	20004124 	.word	0x20004124

000083f0 <init_work>:
{
    83f0:	b510      	push	{r4, lr}
	err = hci_init();
    83f2:	f7ff fdcf 	bl	7f94 <hci_init>
	if (err) {
    83f6:	4604      	mov	r4, r0
    83f8:	b908      	cbnz	r0, 83fe <init_work+0xe>
	bt_finalize_init();
    83fa:	f7ff fc89 	bl	7d10 <bt_finalize_init>
	if (ready_cb) {
    83fe:	4b04      	ldr	r3, [pc, #16]	; (8410 <init_work+0x20>)
    8400:	681b      	ldr	r3, [r3, #0]
    8402:	b11b      	cbz	r3, 840c <init_work+0x1c>
		ready_cb(err);
    8404:	4620      	mov	r0, r4
}
    8406:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    840a:	4718      	bx	r3
}
    840c:	bd10      	pop	{r4, pc}
    840e:	bf00      	nop
    8410:	20002b30 	.word	0x20002b30

00008414 <bt_le_adv_update_data>:
{
    8414:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8416:	4605      	mov	r5, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    8418:	480c      	ldr	r0, [pc, #48]	; (844c <bt_le_adv_update_data+0x38>)
    841a:	f00d ff04 	bl	16226 <atomic_get>
	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    841e:	0680      	lsls	r0, r0, #26
    8420:	d511      	bpl.n	8446 <bt_le_adv_update_data+0x32>
    8422:	480a      	ldr	r0, [pc, #40]	; (844c <bt_le_adv_update_data+0x38>)
    8424:	f00d feff 	bl	16226 <atomic_get>
    8428:	4604      	mov	r4, r0
    842a:	4808      	ldr	r0, [pc, #32]	; (844c <bt_le_adv_update_data+0x38>)
    842c:	f00d fefb 	bl	16226 <atomic_get>
	return le_adv_update(adv, ad, ad_len, sd, sd_len, connectable,
    8430:	f3c4 14c0 	ubfx	r4, r4, #7, #1
    8434:	f3c0 1080 	ubfx	r0, r0, #6, #1
    8438:	9001      	str	r0, [sp, #4]
    843a:	9400      	str	r4, [sp, #0]
    843c:	4628      	mov	r0, r5
    843e:	f7ff fa03 	bl	7848 <le_adv_update.isra.0>
}
    8442:	b003      	add	sp, #12
    8444:	bd30      	pop	{r4, r5, pc}
		return -EAGAIN;
    8446:	f06f 000a 	mvn.w	r0, #10
    844a:	e7fa      	b.n	8442 <bt_le_adv_update_data+0x2e>
    844c:	2000ba64 	.word	0x2000ba64

00008450 <bt_le_adv_start_legacy>:
}

int bt_le_adv_start_legacy(const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
    8450:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL);
    8454:	6906      	ldr	r6, [r0, #16]
{
    8456:	b089      	sub	sp, #36	; 0x24
    8458:	4605      	mov	r5, r0
    845a:	486b      	ldr	r0, [pc, #428]	; (8608 <bt_le_adv_start_legacy+0x1b8>)
    845c:	4688      	mov	r8, r1
    845e:	4691      	mov	r9, r2
    8460:	461f      	mov	r7, r3
    8462:	f00d fee0 	bl	16226 <atomic_get>
	int err;
	struct bt_le_ext_adv *adv;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    8466:	0784      	lsls	r4, r0, #30
    8468:	f140 80c1 	bpl.w	85ee <bt_le_adv_start_legacy+0x19e>
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
    846c:	4628      	mov	r0, r5
    846e:	f7fe ffd3 	bl	7418 <valid_adv_param>
    8472:	2800      	cmp	r0, #0
    8474:	f000 80be 	beq.w	85f4 <bt_le_adv_start_legacy+0x1a4>
    8478:	4863      	ldr	r0, [pc, #396]	; (8608 <bt_le_adv_start_legacy+0x1b8>)
    847a:	f00d fed4 	bl	16226 <atomic_get>
	if (!IS_ENABLED(CONFIG_BT_OBSERVER) ||
    847e:	0500      	lsls	r0, r0, #20
    8480:	d402      	bmi.n	8488 <bt_le_adv_start_legacy+0x38>
    8482:	4861      	ldr	r0, [pc, #388]	; (8608 <bt_le_adv_start_legacy+0x1b8>)
    8484:	f00d fecf 	bl	16226 <atomic_get>

	if (!bt_le_adv_random_addr_check(param)) {
		return -EINVAL;
	}

	(void)memset(&set_param, 0, sizeof(set_param));
    8488:	2100      	movs	r1, #0
    848a:	220f      	movs	r2, #15
    848c:	a804      	add	r0, sp, #16
    848e:	f00d fdff 	bl	16090 <memset>

	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    8492:	68ab      	ldr	r3, [r5, #8]
    8494:	f8ad 3010 	strh.w	r3, [sp, #16]
    8498:	4c5c      	ldr	r4, [pc, #368]	; (860c <bt_le_adv_start_legacy+0x1bc>)
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    849a:	68eb      	ldr	r3, [r5, #12]
    849c:	f8ad 3012 	strh.w	r3, [sp, #18]
	set_param.channel_map  = 0x07;
    84a0:	2307      	movs	r3, #7
    84a2:	f88d 301d 	strb.w	r3, [sp, #29]
    84a6:	f104 002c 	add.w	r0, r4, #44	; 0x2c
	set_param.filter_policy = get_filter_policy(param->options);
    84aa:	2300      	movs	r3, #0
    84ac:	f88d 301e 	strb.w	r3, [sp, #30]
    84b0:	f00d feb9 	bl	16226 <atomic_get>

	adv = adv_new_legacy();
	if (!adv || atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    84b4:	0681      	lsls	r1, r0, #26
    84b6:	f100 80a0 	bmi.w	85fa <bt_le_adv_start_legacy+0x1aa>
		return -EALREADY;
	}

	if (adv->id != param->id) {
    84ba:	7e22      	ldrb	r2, [r4, #24]
    84bc:	782b      	ldrb	r3, [r5, #0]
    84be:	429a      	cmp	r2, r3
    84c0:	d005      	beq.n	84ce <bt_le_adv_start_legacy+0x7e>
 */
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    84c2:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
    84c6:	f104 0098 	add.w	r0, r4, #152	; 0x98
    84ca:	f00d feb5 	bl	16238 <atomic_and>
		atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
	}

	adv->id = param->id;
    84ce:	7828      	ldrb	r0, [r5, #0]
    84d0:	7620      	strb	r0, [r4, #24]
	bt_dev.adv_conn_id = adv->id;
    84d2:	f884 0037 	strb.w	r0, [r4, #55]	; 0x37

	err = le_adv_set_random_addr(adv, param->options, dir_adv,
    84d6:	6869      	ldr	r1, [r5, #4]
    84d8:	f10d 0215 	add.w	r2, sp, #21
    84dc:	f7ff f8ec 	bl	76b8 <le_adv_set_random_addr.isra.0>
				     &set_param.own_addr_type);
	if (err) {
    84e0:	4604      	mov	r4, r0
    84e2:	2800      	cmp	r0, #0
    84e4:	d15d      	bne.n	85a2 <bt_le_adv_start_legacy+0x152>
		return err;
	}

	if (dir_adv) {
    84e6:	2e00      	cmp	r6, #0
    84e8:	d03a      	beq.n	8560 <bt_le_adv_start_legacy+0x110>
		bt_addr_le_copy(&adv->target_addr, param->peer);
    84ea:	6929      	ldr	r1, [r5, #16]
	} else {
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    84ec:	4848      	ldr	r0, [pc, #288]	; (8610 <bt_le_adv_start_legacy+0x1c0>)
    84ee:	f00d fea0 	bl	16232 <bt_addr_le_copy>
	}

	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    84f2:	686b      	ldr	r3, [r5, #4]
    84f4:	07da      	lsls	r2, r3, #31
    84f6:	d53b      	bpl.n	8570 <bt_le_adv_start_legacy+0x120>
		if (dir_adv) {
    84f8:	2e00      	cmp	r6, #0
    84fa:	d036      	beq.n	856a <bt_le_adv_start_legacy+0x11a>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
			} else {
				set_param.type = BT_HCI_ADV_DIRECT_IND;
    84fc:	f013 0f10 	tst.w	r3, #16
    8500:	bf14      	ite	ne
    8502:	2304      	movne	r3, #4
    8504:	2301      	moveq	r3, #1
			}

			bt_addr_le_copy(&set_param.direct_addr, param->peer);
    8506:	6929      	ldr	r1, [r5, #16]
    8508:	f88d 3014 	strb.w	r3, [sp, #20]
    850c:	f10d 0016 	add.w	r0, sp, #22
    8510:	f00d fe8f 	bl	16232 <bt_addr_le_copy>
		} else {
			set_param.type = BT_HCI_ADV_NONCONN_IND;
		}
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    8514:	210f      	movs	r1, #15
    8516:	f242 0006 	movw	r0, #8198	; 0x2006
    851a:	f7fe ffb7 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    851e:	4604      	mov	r4, r0
    8520:	2800      	cmp	r0, #0
    8522:	d06d      	beq.n	8600 <bt_le_adv_start_legacy+0x1b0>
		return -ENOBUFS;
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    8524:	220f      	movs	r2, #15
    8526:	a904      	add	r1, sp, #16
    8528:	3008      	adds	r0, #8
    852a:	f00e fdc9 	bl	170c0 <net_buf_simple_add_mem>

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    852e:	4621      	mov	r1, r4
    8530:	2200      	movs	r2, #0
    8532:	f242 0006 	movw	r0, #8198	; 0x2006
    8536:	f7fe ffdf 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    853a:	4604      	mov	r4, r0
    853c:	bb88      	cbnz	r0, 85a2 <bt_le_adv_start_legacy+0x152>
		return err;
	}

	if (!dir_adv) {
    853e:	b306      	cbz	r6, 8582 <bt_le_adv_start_legacy+0x132>
	return set_le_adv_enable_legacy(adv, enable);
    8540:	2001      	movs	r0, #1
    8542:	f7ff f9cb 	bl	78dc <set_le_adv_enable_legacy.constprop.0>
			return err;
		}
	}

	err = set_le_adv_enable(adv, true);
	if (err) {
    8546:	4604      	mov	r4, r0
    8548:	b378      	cbz	r0, 85aa <bt_le_adv_start_legacy+0x15a>
    854a:	4b32      	ldr	r3, [pc, #200]	; (8614 <bt_le_adv_start_legacy+0x1c4>)
    854c:	4932      	ldr	r1, [pc, #200]	; (8618 <bt_le_adv_start_legacy+0x1c8>)
		BT_ERR("Failed to start advertiser");
    854e:	4833      	ldr	r0, [pc, #204]	; (861c <bt_le_adv_start_legacy+0x1cc>)
    8550:	1ac9      	subs	r1, r1, r3
    8552:	08c9      	lsrs	r1, r1, #3
    8554:	0189      	lsls	r1, r1, #6
    8556:	f041 0101 	orr.w	r1, r1, #1
    855a:	f00c fe76 	bl	1524a <log_0>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
			bt_conn_unref(conn);
		}

		return err;
    855e:	e020      	b.n	85a2 <bt_le_adv_start_legacy+0x152>
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    8560:	9602      	str	r6, [sp, #8]
    8562:	a902      	add	r1, sp, #8
    8564:	f8cd 600b 	str.w	r6, [sp, #11]
    8568:	e7c0      	b.n	84ec <bt_le_adv_start_legacy+0x9c>
			set_param.type = BT_HCI_ADV_IND;
    856a:	f88d 6014 	strb.w	r6, [sp, #20]
    856e:	e7d1      	b.n	8514 <bt_le_adv_start_legacy+0xc4>
		if (sd || (param->options & BT_LE_ADV_OPT_USE_NAME)) {
    8570:	b90f      	cbnz	r7, 8576 <bt_le_adv_start_legacy+0x126>
    8572:	071b      	lsls	r3, r3, #28
    8574:	d503      	bpl.n	857e <bt_le_adv_start_legacy+0x12e>
			set_param.type = BT_HCI_ADV_SCAN_IND;
    8576:	2302      	movs	r3, #2
			set_param.type = BT_HCI_ADV_NONCONN_IND;
    8578:	f88d 3014 	strb.w	r3, [sp, #20]
    857c:	e7ca      	b.n	8514 <bt_le_adv_start_legacy+0xc4>
    857e:	2303      	movs	r3, #3
    8580:	e7fa      	b.n	8578 <bt_le_adv_start_legacy+0x128>
				    param->options & BT_LE_ADV_OPT_CONNECTABLE,
    8582:	686b      	ldr	r3, [r5, #4]
		err = le_adv_update(adv, ad, ad_len, sd, sd_len,
    8584:	f3c3 02c0 	ubfx	r2, r3, #3, #1
    8588:	f003 0301 	and.w	r3, r3, #1
    858c:	9201      	str	r2, [sp, #4]
    858e:	9300      	str	r3, [sp, #0]
    8590:	463a      	mov	r2, r7
    8592:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8594:	4649      	mov	r1, r9
    8596:	4640      	mov	r0, r8
    8598:	f7ff f956 	bl	7848 <le_adv_update.isra.0>
		if (err) {
    859c:	4604      	mov	r4, r0
    859e:	2800      	cmp	r0, #0
    85a0:	d0ce      	beq.n	8540 <bt_le_adv_start_legacy+0xf0>

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
    85a2:	4620      	mov	r0, r4
    85a4:	b009      	add	sp, #36	; 0x24
    85a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    85aa:	b9f6      	cbnz	r6, 85ea <bt_le_adv_start_legacy+0x19a>
    85ac:	686a      	ldr	r2, [r5, #4]
    85ae:	f082 0202 	eor.w	r2, r2, #2
    85b2:	f3c2 0240 	ubfx	r2, r2, #1, #1
    85b6:	481a      	ldr	r0, [pc, #104]	; (8620 <bt_le_adv_start_legacy+0x1d0>)
    85b8:	2109      	movs	r1, #9
    85ba:	f00d fe4c 	bl	16256 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME,
    85be:	686a      	ldr	r2, [r5, #4]
    85c0:	4817      	ldr	r0, [pc, #92]	; (8620 <bt_le_adv_start_legacy+0x1d0>)
    85c2:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    85c6:	2106      	movs	r1, #6
    85c8:	f00d fe45 	bl	16256 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
    85cc:	686a      	ldr	r2, [r5, #4]
    85ce:	4814      	ldr	r0, [pc, #80]	; (8620 <bt_le_adv_start_legacy+0x1d0>)
    85d0:	f002 0201 	and.w	r2, r2, #1
    85d4:	2107      	movs	r1, #7
    85d6:	f00d fe3e 	bl	16256 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
    85da:	686a      	ldr	r2, [r5, #4]
    85dc:	4810      	ldr	r0, [pc, #64]	; (8620 <bt_le_adv_start_legacy+0x1d0>)
    85de:	f3c2 0280 	ubfx	r2, r2, #2, #1
    85e2:	2108      	movs	r1, #8
    85e4:	f00d fe37 	bl	16256 <atomic_set_bit_to>
	return 0;
    85e8:	e7db      	b.n	85a2 <bt_le_adv_start_legacy+0x152>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    85ea:	4602      	mov	r2, r0
    85ec:	e7e3      	b.n	85b6 <bt_le_adv_start_legacy+0x166>
		return -EAGAIN;
    85ee:	f06f 040a 	mvn.w	r4, #10
    85f2:	e7d6      	b.n	85a2 <bt_le_adv_start_legacy+0x152>
		return -EINVAL;
    85f4:	f06f 0415 	mvn.w	r4, #21
    85f8:	e7d3      	b.n	85a2 <bt_le_adv_start_legacy+0x152>
		return -EALREADY;
    85fa:	f06f 0444 	mvn.w	r4, #68	; 0x44
    85fe:	e7d0      	b.n	85a2 <bt_le_adv_start_legacy+0x152>
		return -ENOBUFS;
    8600:	f06f 0436 	mvn.w	r4, #54	; 0x36
    8604:	e7cd      	b.n	85a2 <bt_le_adv_start_legacy+0x152>
    8606:	bf00      	nop
    8608:	2000bad0 	.word	0x2000bad0
    860c:	2000ba38 	.word	0x2000ba38
    8610:	2000ba5b 	.word	0x2000ba5b
    8614:	0001956c 	.word	0x0001956c
    8618:	000195f4 	.word	0x000195f4
    861c:	0001b1e4 	.word	0x0001b1e4
    8620:	2000ba64 	.word	0x2000ba64

00008624 <bt_le_adv_stop>:

	return bt_le_adv_start_legacy(param, ad, ad_len, sd, sd_len);
}

int bt_le_adv_stop(void)
{
    8624:	b510      	push	{r4, lr}
    8626:	f46f 7100 	mvn.w	r1, #512	; 0x200
    862a:	480f      	ldr	r0, [pc, #60]	; (8668 <bt_le_adv_stop+0x44>)
    862c:	f00d fe04 	bl	16238 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    8630:	480d      	ldr	r0, [pc, #52]	; (8668 <bt_le_adv_stop+0x44>)
    8632:	f00d fdf8 	bl	16226 <atomic_get>
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    8636:	0682      	lsls	r2, r0, #26
    8638:	d402      	bmi.n	8640 <bt_le_adv_stop+0x1c>
		/* Legacy advertiser exists, but is not currently advertising.
		 * This happens when keep advertising behavior is active but
		 * no conn object is available to do connectable advertising.
		 */
		adv_delete_legacy();
		return 0;
    863a:	2400      	movs	r4, #0
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
    863c:	4620      	mov	r0, r4
    863e:	bd10      	pop	{r4, pc}
		err = set_le_adv_enable_legacy(adv, false);
    8640:	2000      	movs	r0, #0
    8642:	f7ff f94b 	bl	78dc <set_le_adv_enable_legacy.constprop.0>
		if (err) {
    8646:	4604      	mov	r4, r0
    8648:	2800      	cmp	r0, #0
    864a:	d1f7      	bne.n	863c <bt_le_adv_stop+0x18>
    864c:	4807      	ldr	r0, [pc, #28]	; (866c <bt_le_adv_stop+0x48>)
    864e:	f00d fdea 	bl	16226 <atomic_get>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    8652:	0683      	lsls	r3, r0, #26
    8654:	d5f1      	bpl.n	863a <bt_le_adv_stop+0x16>
	return set_le_scan_enable_legacy(enable);
    8656:	4620      	mov	r0, r4
    8658:	f7fe fff2 	bl	7640 <set_le_scan_enable_legacy>
			le_set_private_addr(BT_ID_DEFAULT);
    865c:	f00d fe15 	bl	1628a <le_adv_set_private_addr.isra.0>
	return set_le_scan_enable_legacy(enable);
    8660:	2001      	movs	r0, #1
    8662:	f7fe ffed 	bl	7640 <set_le_scan_enable_legacy>
    8666:	e7e9      	b.n	863c <bt_le_adv_stop+0x18>
    8668:	2000ba64 	.word	0x2000ba64
    866c:	2000bad0 	.word	0x2000bad0

00008670 <bt_le_scan_start>:

	return true;
}

int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
{
    8670:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    8674:	4605      	mov	r5, r0
    8676:	4856      	ldr	r0, [pc, #344]	; (87d0 <bt_le_scan_start+0x160>)
    8678:	460e      	mov	r6, r1
    867a:	f00d fdd4 	bl	16226 <atomic_get>
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    867e:	0780      	lsls	r0, r0, #30
    8680:	f140 809f 	bpl.w	87c2 <bt_le_scan_start+0x152>
	if (param->type != BT_HCI_LE_SCAN_PASSIVE &&
    8684:	782a      	ldrb	r2, [r5, #0]
    8686:	2a01      	cmp	r2, #1
    8688:	d905      	bls.n	8696 <bt_le_scan_start+0x26>
		return -EAGAIN;
	}

	/* Check that the parameters have valid values */
	if (!valid_le_scan_param(param)) {
		return -EINVAL;
    868a:	f06f 0415 	mvn.w	r4, #21
	}

	scan_dev_found_cb = cb;

	return 0;
}
    868e:	4620      	mov	r0, r4
    8690:	b003      	add	sp, #12
    8692:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE |
    8696:	686b      	ldr	r3, [r5, #4]
    8698:	f033 030f 	bics.w	r3, r3, #15
    869c:	d1f5      	bne.n	868a <bt_le_scan_start+0x1a>
	if (param->interval < 0x0004 || param->interval > 0x4000) {
    869e:	8928      	ldrh	r0, [r5, #8]
    86a0:	1f03      	subs	r3, r0, #4
    86a2:	b29b      	uxth	r3, r3
    86a4:	f643 74fc 	movw	r4, #16380	; 0x3ffc
    86a8:	42a3      	cmp	r3, r4
    86aa:	d8ee      	bhi.n	868a <bt_le_scan_start+0x1a>
	if (param->window < 0x0004 || param->window > 0x4000) {
    86ac:	8969      	ldrh	r1, [r5, #10]
    86ae:	1f0b      	subs	r3, r1, #4
    86b0:	b29b      	uxth	r3, r3
    86b2:	42a3      	cmp	r3, r4
    86b4:	d8e9      	bhi.n	868a <bt_le_scan_start+0x1a>
	if (param->window > param->interval) {
    86b6:	4288      	cmp	r0, r1
    86b8:	d3e7      	bcc.n	868a <bt_le_scan_start+0x1a>
	if (param->type && !bt_le_scan_random_addr_check()) {
    86ba:	b992      	cbnz	r2, 86e2 <bt_le_scan_start+0x72>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    86bc:	f3bf 8f5b 	dmb	ish
    86c0:	4f43      	ldr	r7, [pc, #268]	; (87d0 <bt_le_scan_start+0x160>)
    86c2:	e857 0f00 	ldrex	r0, [r7]
    86c6:	f040 0340 	orr.w	r3, r0, #64	; 0x40
    86ca:	e847 3200 	strex	r2, r3, [r7]
    86ce:	2a00      	cmp	r2, #0
    86d0:	d1f7      	bne.n	86c2 <bt_le_scan_start+0x52>
    86d2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    86d6:	f010 0340 	ands.w	r3, r0, #64	; 0x40
    86da:	d007      	beq.n	86ec <bt_le_scan_start+0x7c>
		return -EALREADY;
    86dc:	f06f 0444 	mvn.w	r4, #68	; 0x44
    86e0:	e7d5      	b.n	868e <bt_le_scan_start+0x1e>
	if (param->type && !bt_le_scan_random_addr_check()) {
    86e2:	f7ff f92b 	bl	793c <bt_le_scan_random_addr_check>
    86e6:	2800      	cmp	r0, #0
    86e8:	d1e8      	bne.n	86bc <bt_le_scan_start+0x4c>
    86ea:	e7ce      	b.n	868a <bt_le_scan_start+0x1a>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    86ec:	4638      	mov	r0, r7
    86ee:	f00d fd9a 	bl	16226 <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    86f2:	0681      	lsls	r1, r0, #26
    86f4:	d50a      	bpl.n	870c <bt_le_scan_start+0x9c>
	return set_le_scan_enable_legacy(enable);
    86f6:	4618      	mov	r0, r3
    86f8:	f7fe ffa2 	bl	7640 <set_le_scan_enable_legacy>
		if (err) {
    86fc:	4604      	mov	r4, r0
    86fe:	b128      	cbz	r0, 870c <bt_le_scan_start+0x9c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8700:	f06f 0140 	mvn.w	r1, #64	; 0x40
    8704:	4638      	mov	r0, r7
    8706:	f00d fd97 	bl	16238 <atomic_and>
		return err;
    870a:	e7c0      	b.n	868e <bt_le_scan_start+0x1e>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP,
    870c:	686a      	ldr	r2, [r5, #4]
    870e:	4f31      	ldr	r7, [pc, #196]	; (87d4 <bt_le_scan_start+0x164>)
    8710:	f002 0201 	and.w	r2, r2, #1
    8714:	2108      	movs	r1, #8
    8716:	f107 0098 	add.w	r0, r7, #152	; 0x98
    871a:	f00d fd9c 	bl	16256 <atomic_set_bit_to>
		if (param->timeout) {
    871e:	89ac      	ldrh	r4, [r5, #12]
    8720:	2c00      	cmp	r4, #0
    8722:	d151      	bne.n	87c8 <bt_le_scan_start+0x158>
		err = start_le_scan_legacy(param->type, param->interval,
    8724:	f895 8000 	ldrb.w	r8, [r5]
    8728:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    872c:	896d      	ldrh	r5, [r5, #10]
	(void)memset(&set_param, 0, sizeof(set_param));
    872e:	2207      	movs	r2, #7
    8730:	4621      	mov	r1, r4
    8732:	4668      	mov	r0, sp
    8734:	f00d fcac 	bl	16090 <memset>
	active_scan = scan_type == BT_HCI_LE_SCAN_ACTIVE;
    8738:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
		*own_addr_type = bt_dev.id_addr[0].type;
    873c:	4638      	mov	r0, r7
	set_param.scan_type = scan_type;
    873e:	f88d 8000 	strb.w	r8, [sp]
	active_scan = scan_type == BT_HCI_LE_SCAN_ACTIVE;
    8742:	f1d3 0800 	rsbs	r8, r3, #0
    8746:	eb48 0803 	adc.w	r8, r8, r3
		*own_addr_type = bt_dev.id_addr[0].type;
    874a:	f810 3b2c 	ldrb.w	r3, [r0], #44
	set_param.interval = sys_cpu_to_le16(interval);
    874e:	f8ad 9001 	strh.w	r9, [sp, #1]
	set_param.window = sys_cpu_to_le16(window);
    8752:	f8ad 5003 	strh.w	r5, [sp, #3]
		set_param.filter_policy = BT_HCI_LE_SCAN_FP_NO_WHITELIST;
    8756:	f88d 4006 	strb.w	r4, [sp, #6]
		*own_addr_type = bt_dev.id_addr[0].type;
    875a:	f88d 3005 	strb.w	r3, [sp, #5]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    875e:	f00d fd62 	bl	16226 <atomic_get>
		    adv && !atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    8762:	0682      	lsls	r2, r0, #26
    8764:	d406      	bmi.n	8774 <bt_le_scan_start+0x104>
			err = le_set_private_addr(BT_ID_DEFAULT);
    8766:	f00d fd90 	bl	1628a <le_adv_set_private_addr.isra.0>
			if (err) {
    876a:	4604      	mov	r4, r0
    876c:	bb28      	cbnz	r0, 87ba <bt_le_scan_start+0x14a>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    876e:	2301      	movs	r3, #1
    8770:	f88d 3005 	strb.w	r3, [sp, #5]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_PARAM, sizeof(set_param));
    8774:	2107      	movs	r1, #7
    8776:	f242 000b 	movw	r0, #8203	; 0x200b
    877a:	f7fe fe87 	bl	748c <bt_hci_cmd_create>
	if (!buf) {
    877e:	4604      	mov	r4, r0
    8780:	b1c8      	cbz	r0, 87b6 <bt_le_scan_start+0x146>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    8782:	2207      	movs	r2, #7
    8784:	4669      	mov	r1, sp
    8786:	3008      	adds	r0, #8
    8788:	f00e fc9a 	bl	170c0 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_PARAM, buf, NULL);
    878c:	4621      	mov	r1, r4
    878e:	2200      	movs	r2, #0
    8790:	f242 000b 	movw	r0, #8203	; 0x200b
    8794:	f7fe feb0 	bl	74f8 <bt_hci_cmd_send_sync>
	if (err) {
    8798:	4604      	mov	r4, r0
    879a:	b970      	cbnz	r0, 87ba <bt_le_scan_start+0x14a>
	return set_le_scan_enable_legacy(enable);
    879c:	2001      	movs	r0, #1
    879e:	f7fe ff4f 	bl	7640 <set_le_scan_enable_legacy>
	if (err) {
    87a2:	4604      	mov	r4, r0
    87a4:	b948      	cbnz	r0, 87ba <bt_le_scan_start+0x14a>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ACTIVE_SCAN, active_scan);
    87a6:	480a      	ldr	r0, [pc, #40]	; (87d0 <bt_le_scan_start+0x160>)
    87a8:	4642      	mov	r2, r8
    87aa:	2107      	movs	r1, #7
    87ac:	f00d fd53 	bl	16256 <atomic_set_bit_to>
	scan_dev_found_cb = cb;
    87b0:	4b09      	ldr	r3, [pc, #36]	; (87d8 <bt_le_scan_start+0x168>)
    87b2:	601e      	str	r6, [r3, #0]
	return 0;
    87b4:	e76b      	b.n	868e <bt_le_scan_start+0x1e>
		return -ENOBUFS;
    87b6:	f06f 0436 	mvn.w	r4, #54	; 0x36
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    87ba:	4805      	ldr	r0, [pc, #20]	; (87d0 <bt_le_scan_start+0x160>)
    87bc:	f06f 0140 	mvn.w	r1, #64	; 0x40
    87c0:	e7a1      	b.n	8706 <bt_le_scan_start+0x96>
		return -EAGAIN;
    87c2:	f06f 040a 	mvn.w	r4, #10
    87c6:	e762      	b.n	868e <bt_le_scan_start+0x1e>
			return -ENOTSUP;
    87c8:	f06f 0422 	mvn.w	r4, #34	; 0x22
    87cc:	e75f      	b.n	868e <bt_le_scan_start+0x1e>
    87ce:	bf00      	nop
    87d0:	2000bad0 	.word	0x2000bad0
    87d4:	2000ba38 	.word	0x2000ba38
    87d8:	20002b3c 	.word	0x20002b3c

000087dc <bt_le_scan_stop>:

int bt_le_scan_stop(void)
{
    87dc:	b508      	push	{r3, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    87de:	4808      	ldr	r0, [pc, #32]	; (8800 <bt_le_scan_stop+0x24>)
    87e0:	f06f 0140 	mvn.w	r1, #64	; 0x40
    87e4:	f00d fd28 	bl	16238 <atomic_and>
	/* Return if active scanning is already disabled */
	if (!atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    87e8:	0643      	lsls	r3, r0, #25
    87ea:	d506      	bpl.n	87fa <bt_le_scan_stop+0x1e>
		return -EALREADY;
	}

	scan_dev_found_cb = NULL;
    87ec:	4b05      	ldr	r3, [pc, #20]	; (8804 <bt_le_scan_stop+0x28>)
    87ee:	2000      	movs	r0, #0
    87f0:	6018      	str	r0, [r3, #0]
		pending_id_keys_update();
#endif
	}

	return bt_le_scan_update(false);
}
    87f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return bt_le_scan_update(false);
    87f6:	f7ff b8a9 	b.w	794c <bt_le_scan_update>
}
    87fa:	f06f 0044 	mvn.w	r0, #68	; 0x44
    87fe:	bd08      	pop	{r3, pc}
    8800:	2000bad0 	.word	0x2000bad0
    8804:	20002b3c 	.word	0x20002b3c

00008808 <bt_buf_get_rx>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
				    buf, NULL);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
    8808:	b538      	push	{r3, r4, r5, lr}
    880a:	4605      	mov	r5, r0
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
    880c:	4805      	ldr	r0, [pc, #20]	; (8824 <bt_buf_get_rx+0x1c>)
    880e:	f00e fc1d 	bl	1704c <net_buf_alloc_fixed>
#endif

	if (buf) {
    8812:	4604      	mov	r4, r0
    8814:	b120      	cbz	r0, 8820 <bt_buf_get_rx+0x18>
		net_buf_reserve(buf, BT_BUF_RESERVE);
    8816:	2100      	movs	r1, #0
    8818:	3008      	adds	r0, #8
    881a:	f00e fc36 	bl	1708a <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
    881e:	7525      	strb	r5, [r4, #20]
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    8820:	4620      	mov	r0, r4
    8822:	bd38      	pop	{r3, r4, r5, pc}
    8824:	2000c410 	.word	0x2000c410

00008828 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(s32_t timeout)
{
    8828:	b510      	push	{r4, lr}
	__asm__ volatile(
    882a:	f04f 0320 	mov.w	r3, #32
    882e:	f3ef 8211 	mrs	r2, BASEPRI
    8832:	f383 8811 	msr	BASEPRI, r3
    8836:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
    883a:	4b0d      	ldr	r3, [pc, #52]	; (8870 <bt_buf_get_cmd_complete+0x48>)
	bt_dev.sent_cmd = NULL;
    883c:	2100      	movs	r1, #0
	buf = bt_dev.sent_cmd;
    883e:	f8d3 40c8 	ldr.w	r4, [r3, #200]	; 0xc8
	bt_dev.sent_cmd = NULL;
    8842:	f8c3 10c8 	str.w	r1, [r3, #200]	; 0xc8
	__asm__ volatile(
    8846:	f382 8811 	msr	BASEPRI, r2
    884a:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    884e:	b92c      	cbnz	r4, 885c <bt_buf_get_cmd_complete+0x34>
		net_buf_reserve(buf, BT_BUF_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    8850:	4601      	mov	r1, r0
}
    8852:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    8856:	2001      	movs	r0, #1
    8858:	f7ff bfd6 	b.w	8808 <bt_buf_get_rx>
    885c:	2301      	movs	r3, #1
		net_buf_reserve(buf, BT_BUF_RESERVE);
    885e:	f104 0008 	add.w	r0, r4, #8
    8862:	7523      	strb	r3, [r4, #20]
		buf->len = 0U;
    8864:	81a1      	strh	r1, [r4, #12]
		net_buf_reserve(buf, BT_BUF_RESERVE);
    8866:	f00e fc10 	bl	1708a <net_buf_simple_reserve>
}
    886a:	4620      	mov	r0, r4
    886c:	bd10      	pop	{r4, pc}
    886e:	bf00      	nop
    8870:	2000ba38 	.word	0x2000ba38

00008874 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(u8_t evt, bool discardable, s32_t timeout)
{
	switch (evt) {
    8874:	380e      	subs	r0, #14
    8876:	2801      	cmp	r0, #1
{
    8878:	460b      	mov	r3, r1
    887a:	b510      	push	{r4, lr}
    887c:	4611      	mov	r1, r2
	switch (evt) {
    887e:	d804      	bhi.n	888a <bt_buf_get_evt+0x16>
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    8880:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_cmd_complete(timeout);
    8884:	4610      	mov	r0, r2
    8886:	f7ff bfcf 	b.w	8828 <bt_buf_get_cmd_complete>
		if (discardable) {
    888a:	b163      	cbz	r3, 88a6 <bt_buf_get_evt+0x32>
			buf = net_buf_alloc(&discardable_pool, timeout);
    888c:	4808      	ldr	r0, [pc, #32]	; (88b0 <bt_buf_get_evt+0x3c>)
    888e:	f00e fbdd 	bl	1704c <net_buf_alloc_fixed>
			if (buf) {
    8892:	4604      	mov	r4, r0
    8894:	b128      	cbz	r0, 88a2 <bt_buf_get_evt+0x2e>
				net_buf_reserve(buf, BT_BUF_RESERVE);
    8896:	2100      	movs	r1, #0
    8898:	3008      	adds	r0, #8
    889a:	f00e fbf6 	bl	1708a <net_buf_simple_reserve>
    889e:	2301      	movs	r3, #1
    88a0:	7523      	strb	r3, [r4, #20]
}
    88a2:	4620      	mov	r0, r4
    88a4:	bd10      	pop	{r4, pc}
    88a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    88aa:	2001      	movs	r0, #1
    88ac:	f7ff bfac 	b.w	8808 <bt_buf_get_rx>
    88b0:	2000c3d0 	.word	0x2000c3d0

000088b4 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
    88b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
    88b8:	4f11      	ldr	r7, [pc, #68]	; (8900 <mayfly_init+0x4c>)
    88ba:	f8df a048 	ldr.w	sl, [pc, #72]	; 8904 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
    88be:	2404      	movs	r4, #4
	while (callee_id--) {
    88c0:	3c01      	subs	r4, #1
    88c2:	b2e4      	uxtb	r4, r4
    88c4:	2cff      	cmp	r4, #255	; 0xff
    88c6:	d018      	beq.n	88fa <mayfly_init+0x46>
    88c8:	eb04 0644 	add.w	r6, r4, r4, lsl #1
    88cc:	ea4f 0984 	mov.w	r9, r4, lsl #2
    88d0:	0136      	lsls	r6, r6, #4
		caller_id = MAYFLY_CALLER_COUNT;
    88d2:	2504      	movs	r5, #4
    88d4:	f04f 080c 	mov.w	r8, #12
    88d8:	e00a      	b.n	88f0 <mayfly_init+0x3c>
			memq_init(&mfl[callee_id][caller_id],
    88da:	fb18 6105 	smlabb	r1, r8, r5, r6
    88de:	1d0a      	adds	r2, r1, #4
    88e0:	eb05 0009 	add.w	r0, r5, r9
    88e4:	443a      	add	r2, r7
    88e6:	4439      	add	r1, r7
    88e8:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    88ec:	f00d fd5b 	bl	163a6 <memq_init>
		while (caller_id--) {
    88f0:	3d01      	subs	r5, #1
    88f2:	b2ed      	uxtb	r5, r5
    88f4:	2dff      	cmp	r5, #255	; 0xff
    88f6:	d1f0      	bne.n	88da <mayfly_init+0x26>
    88f8:	e7e2      	b.n	88c0 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
    88fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    88fe:	bf00      	nop
    8900:	20002c34 	.word	0x20002c34
    8904:	20002bb4 	.word	0x20002bb4

00008908 <mayfly_enqueue>:
	}
}

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
    8908:	b570      	push	{r4, r5, r6, lr}
    890a:	4606      	mov	r6, r0
    890c:	460d      	mov	r5, r1
    890e:	461c      	mov	r4, r3
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
    8910:	b1a2      	cbz	r2, 893c <mayfly_enqueue+0x34>
    8912:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
    8914:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
    8916:	7820      	ldrb	r0, [r4, #0]
    8918:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
    891a:	f010 0003 	ands.w	r0, r0, #3
    891e:	d02c      	beq.n	897a <mayfly_enqueue+0x72>
		if (chain) {
    8920:	b31b      	cbz	r3, 896a <mayfly_enqueue+0x62>
			if (state != 1U) {
    8922:	2801      	cmp	r0, #1
    8924:	d028      	beq.n	8978 <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
    8926:	3201      	adds	r2, #1
    8928:	b2d2      	uxtb	r2, r2
    892a:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
    892c:	4b1c      	ldr	r3, [pc, #112]	; (89a0 <mayfly_enqueue+0x98>)
    892e:	2201      	movs	r2, #1

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
    8930:	4629      	mov	r1, r5
    8932:	4630      	mov	r0, r6
	mfp[callee_id] = 1U;
    8934:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
    8936:	f003 ffbf 	bl	c8b8 <mayfly_pend>
    893a:	e01c      	b.n	8976 <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    893c:	f00e f92b 	bl	16b96 <mayfly_prio_is_equal>
    8940:	2800      	cmp	r0, #0
    8942:	d0e6      	beq.n	8912 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
    8944:	4629      	mov	r1, r5
    8946:	4630      	mov	r0, r6
    8948:	f003 ff96 	bl	c878 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    894c:	2800      	cmp	r0, #0
    894e:	d0e0      	beq.n	8912 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
    8950:	2330      	movs	r3, #48	; 0x30
    8952:	220c      	movs	r2, #12
    8954:	436b      	muls	r3, r5
    8956:	fb02 3306 	mla	r3, r2, r6, r3
    895a:	4a12      	ldr	r2, [pc, #72]	; (89a4 <mayfly_enqueue+0x9c>)
    895c:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
    895e:	7a93      	ldrb	r3, [r2, #10]
    8960:	7ad2      	ldrb	r2, [r2, #11]
    8962:	1a9b      	subs	r3, r3, r2
    8964:	bf18      	it	ne
    8966:	2301      	movne	r3, #1
    8968:	e7d4      	b.n	8914 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
    896a:	3202      	adds	r2, #2
    896c:	b2d2      	uxtb	r2, r2
    896e:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
    8970:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
    8974:	4798      	blx	r3

	return 0;
    8976:	2000      	movs	r0, #0
}
    8978:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
    897a:	2b00      	cmp	r3, #0
    897c:	d0f8      	beq.n	8970 <mayfly_enqueue+0x68>
	m->_req = ack + 1;
    897e:	3201      	adds	r2, #1
    8980:	b2d2      	uxtb	r2, r2
    8982:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
    8984:	2304      	movs	r3, #4
    8986:	2230      	movs	r2, #48	; 0x30
    8988:	fb12 3205 	smlabb	r2, r2, r5, r3
    898c:	230c      	movs	r3, #12
    898e:	fb13 2306 	smlabb	r3, r3, r6, r2
    8992:	4a04      	ldr	r2, [pc, #16]	; (89a4 <mayfly_enqueue+0x9c>)
    8994:	6860      	ldr	r0, [r4, #4]
    8996:	441a      	add	r2, r3
    8998:	4621      	mov	r1, r4
    899a:	f00d fd07 	bl	163ac <memq_enqueue>
    899e:	e7c5      	b.n	892c <mayfly_enqueue+0x24>
    89a0:	200086f3 	.word	0x200086f3
    89a4:	20002c34 	.word	0x20002c34

000089a8 <mayfly_run>:
		}
	}
}

void mayfly_run(u8_t callee_id)
{
    89a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
    89ac:	4b5b      	ldr	r3, [pc, #364]	; (8b1c <mayfly_run+0x174>)
    89ae:	5c1a      	ldrb	r2, [r3, r0]
{
    89b0:	b089      	sub	sp, #36	; 0x24
    89b2:	4604      	mov	r4, r0
	if (!mfp[callee_id]) {
    89b4:	2a00      	cmp	r2, #0
    89b6:	f000 80aa 	beq.w	8b0e <mayfly_run+0x166>
		return;
	}
	mfp[callee_id] = 0U;
    89ba:	2700      	movs	r7, #0
    89bc:	541f      	strb	r7, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
    89be:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    89c2:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    89c4:	f8df b158 	ldr.w	fp, [pc, #344]	; 8b20 <mayfly_run+0x178>
    89c8:	9304      	str	r3, [sp, #16]
    89ca:	2504      	movs	r5, #4
    89cc:	233c      	movs	r3, #60	; 0x3c
    89ce:	fb13 5300 	smlabb	r3, r3, r0, r5
    89d2:	445b      	add	r3, fp
    89d4:	9303      	str	r3, [sp, #12]
	u8_t disable = 0U;
    89d6:	9700      	str	r7, [sp, #0]
    89d8:	46da      	mov	sl, fp
	while (caller_id--) {
    89da:	3d01      	subs	r5, #1
    89dc:	b2ed      	uxtb	r5, r5
    89de:	2dff      	cmp	r5, #255	; 0xff
    89e0:	d10c      	bne.n	89fc <mayfly_run+0x54>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
    89e2:	9b00      	ldr	r3, [sp, #0]
    89e4:	2b00      	cmp	r3, #0
    89e6:	f000 8092 	beq.w	8b0e <mayfly_run+0x166>
    89ea:	2f00      	cmp	r7, #0
    89ec:	f040 808f 	bne.w	8b0e <mayfly_run+0x166>
		mayfly_enable_cb(callee_id, callee_id, 0);
    89f0:	463a      	mov	r2, r7
    89f2:	4621      	mov	r1, r4
    89f4:	4620      	mov	r0, r4
    89f6:	f003 ff1f 	bl	c838 <mayfly_enable_cb>
    89fa:	e088      	b.n	8b0e <mayfly_run+0x166>
		struct mayfly *m = 0;
    89fc:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
    89fe:	f04f 080c 	mov.w	r8, #12
		struct mayfly *m = 0;
    8a02:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
    8a04:	fb08 f805 	mul.w	r8, r8, r5
    8a08:	2330      	movs	r3, #48	; 0x30
    8a0a:	fb03 8304 	mla	r3, r3, r4, r8
    8a0e:	eb0a 0103 	add.w	r1, sl, r3
    8a12:	f85a 0003 	ldr.w	r0, [sl, r3]
    8a16:	6849      	ldr	r1, [r1, #4]
    8a18:	aa07      	add	r2, sp, #28
    8a1a:	f00d fcce 	bl	163ba <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
    8a1e:	9a04      	ldr	r2, [sp, #16]
    8a20:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    8a24:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8a28:	4453      	add	r3, sl
    8a2a:	e9cd 8301 	strd	r8, r3, [sp, #4]
		link = memq_peek(mft[callee_id][caller_id].head,
    8a2e:	4606      	mov	r6, r0
		while (link) {
    8a30:	2e00      	cmp	r6, #0
    8a32:	d04e      	beq.n	8ad2 <mayfly_run+0x12a>
			state = (m->_req - m->_ack) & 0x03;
    8a34:	9b07      	ldr	r3, [sp, #28]
    8a36:	f893 9000 	ldrb.w	r9, [r3]
    8a3a:	785a      	ldrb	r2, [r3, #1]
    8a3c:	eba9 0902 	sub.w	r9, r9, r2
    8a40:	f009 0903 	and.w	r9, r9, #3
			if (state == 1U) {
    8a44:	f1b9 0f01 	cmp.w	r9, #1
    8a48:	d104      	bne.n	8a54 <mayfly_run+0xac>
				m->_ack--;
    8a4a:	3a01      	subs	r2, #1
    8a4c:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
    8a4e:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
    8a52:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
    8a54:	f8dd 801c 	ldr.w	r8, [sp, #28]
	req = m->_req;
    8a58:	f898 2000 	ldrb.w	r2, [r8]
	if (((req - m->_ack) & 0x03) != 1U) {
    8a5c:	f898 1001 	ldrb.w	r1, [r8, #1]
	req = m->_req;
    8a60:	b2d3      	uxtb	r3, r2
	if (((req - m->_ack) & 0x03) != 1U) {
    8a62:	1a52      	subs	r2, r2, r1
    8a64:	f002 0203 	and.w	r2, r2, #3
    8a68:	2a01      	cmp	r2, #1
	req = m->_req;
    8a6a:	9305      	str	r3, [sp, #20]
	if (((req - m->_ack) & 0x03) != 1U) {
    8a6c:	d01f      	beq.n	8aae <mayfly_run+0x106>
		memq_dequeue(mft[callee_id][caller_id].tail,
    8a6e:	9b01      	ldr	r3, [sp, #4]
    8a70:	9902      	ldr	r1, [sp, #8]
    8a72:	2030      	movs	r0, #48	; 0x30
    8a74:	fb00 3004 	mla	r0, r0, r4, r3
    8a78:	4b29      	ldr	r3, [pc, #164]	; (8b20 <mayfly_run+0x178>)
    8a7a:	4418      	add	r0, r3
    8a7c:	2200      	movs	r2, #0
    8a7e:	6840      	ldr	r0, [r0, #4]
    8a80:	f00d fca3 	bl	163ca <memq_dequeue>
		m->_ack = req;
    8a84:	9b05      	ldr	r3, [sp, #20]
		ack = m->_ack;
    8a86:	f898 2001 	ldrb.w	r2, [r8, #1]
		m->_ack = req;
    8a8a:	f888 3001 	strb.w	r3, [r8, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
    8a8e:	f898 3000 	ldrb.w	r3, [r8]
		m->_link = link;
    8a92:	f8c8 6004 	str.w	r6, [r8, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
    8a96:	1a9b      	subs	r3, r3, r2
    8a98:	f003 0303 	and.w	r3, r3, #3
    8a9c:	2b01      	cmp	r3, #1
    8a9e:	d106      	bne.n	8aae <mayfly_run+0x106>
			m->_ack = ack;
    8aa0:	f888 2001 	strb.w	r2, [r8, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    8aa4:	4641      	mov	r1, r8
    8aa6:	9a03      	ldr	r2, [sp, #12]
    8aa8:	4630      	mov	r0, r6
    8aaa:	f00d fc7f 	bl	163ac <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
    8aae:	9a01      	ldr	r2, [sp, #4]
    8ab0:	2330      	movs	r3, #48	; 0x30
    8ab2:	fb03 2304 	mla	r3, r3, r4, r2
    8ab6:	eb0a 0103 	add.w	r1, sl, r3
    8aba:	f85a 0003 	ldr.w	r0, [sl, r3]
    8abe:	6849      	ldr	r1, [r1, #4]
    8ac0:	aa07      	add	r2, sp, #28
    8ac2:	f00d fc7a 	bl	163ba <memq_peek>
			if (state == 1U) {
    8ac6:	f1b9 0f01 	cmp.w	r9, #1
			link = memq_peek(mft[callee_id][caller_id].head,
    8aca:	4606      	mov	r6, r0
			if (state == 1U) {
    8acc:	d1b0      	bne.n	8a30 <mayfly_run+0x88>
				if (caller_id || link) {
    8ace:	b9bd      	cbnz	r5, 8b00 <mayfly_run+0x158>
    8ad0:	b9b0      	cbnz	r0, 8b00 <mayfly_run+0x158>
		if (mft[callee_id][caller_id].disable_req !=
    8ad2:	2230      	movs	r2, #48	; 0x30
    8ad4:	4912      	ldr	r1, [pc, #72]	; (8b20 <mayfly_run+0x178>)
    8ad6:	230c      	movs	r3, #12
    8ad8:	4362      	muls	r2, r4
    8ada:	fb03 2205 	mla	r2, r3, r5, r2
    8ade:	440a      	add	r2, r1
    8ae0:	7a91      	ldrb	r1, [r2, #10]
    8ae2:	7ad0      	ldrb	r0, [r2, #11]
    8ae4:	4288      	cmp	r0, r1
    8ae6:	d115      	bne.n	8b14 <mayfly_run+0x16c>
		if (mft[callee_id][caller_id].enable_req !=
    8ae8:	2230      	movs	r2, #48	; 0x30
    8aea:	4362      	muls	r2, r4
    8aec:	fb03 2305 	mla	r3, r3, r5, r2
    8af0:	445b      	add	r3, fp
    8af2:	7a1a      	ldrb	r2, [r3, #8]
    8af4:	7a59      	ldrb	r1, [r3, #9]
    8af6:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
    8af8:	bf1c      	itt	ne
    8afa:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
    8afc:	2701      	movne	r7, #1
    8afe:	e76c      	b.n	89da <mayfly_run+0x32>
					mfp[callee_id] = 1U;
    8b00:	4b06      	ldr	r3, [pc, #24]	; (8b1c <mayfly_run+0x174>)
    8b02:	2201      	movs	r2, #1
					mayfly_pend(callee_id, callee_id);
    8b04:	4621      	mov	r1, r4
    8b06:	4620      	mov	r0, r4
					mfp[callee_id] = 1U;
    8b08:	551a      	strb	r2, [r3, r4]
					mayfly_pend(callee_id, callee_id);
    8b0a:	f003 fed5 	bl	c8b8 <mayfly_pend>
	}
}
    8b0e:	b009      	add	sp, #36	; 0x24
    8b10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
    8b14:	72d1      	strb	r1, [r2, #11]
			disable = 1U;
    8b16:	2201      	movs	r2, #1
    8b18:	9200      	str	r2, [sp, #0]
    8b1a:	e7e5      	b.n	8ae8 <mayfly_run+0x140>
    8b1c:	200086f3 	.word	0x200086f3
    8b20:	20002c34 	.word	0x20002c34

00008b24 <util_rand>:

	return one_count;
}

int util_rand(void *buf, size_t len)
{
    8b24:	b570      	push	{r4, r5, r6, lr}
	static struct device *dev;

	if (unlikely(!dev)) {
    8b26:	4c08      	ldr	r4, [pc, #32]	; (8b48 <util_rand+0x24>)
    8b28:	6823      	ldr	r3, [r4, #0]
{
    8b2a:	4605      	mov	r5, r0
    8b2c:	460e      	mov	r6, r1
	if (unlikely(!dev)) {
    8b2e:	b91b      	cbnz	r3, 8b38 <util_rand+0x14>
    8b30:	4806      	ldr	r0, [pc, #24]	; (8b4c <util_rand+0x28>)
    8b32:	f00a fd9b 	bl	1366c <z_impl_device_get_binding>
		/* Only one entropy device exists, so this is safe even
		 * if the whole operation isn't atomic.
		 */
		dev = device_get_binding(DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
    8b36:	6020      	str	r0, [r4, #0]
			"Device driver for %s (DT_CHOSEN_ZEPHYR_ENTROPY_LABEL) not found. "
			"Check your build configuration!",
			DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
	}

	return entropy_get_entropy(dev, (u8_t *)buf, len);
    8b38:	6820      	ldr	r0, [r4, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    8b3a:	6843      	ldr	r3, [r0, #4]
    8b3c:	b2b2      	uxth	r2, r6
    8b3e:	4629      	mov	r1, r5
    8b40:	681b      	ldr	r3, [r3, #0]
}
    8b42:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    8b46:	4718      	bx	r3
    8b48:	20002cf4 	.word	0x20002cf4
    8b4c:	0001b210 	.word	0x0001b210

00008b50 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
    8b50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer worker, as job is now running */
	if (instance->worker_trigger) {
    8b54:	7fc3      	ldrb	r3, [r0, #31]
{
    8b56:	b08f      	sub	sp, #60	; 0x3c
    8b58:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
    8b5a:	9304      	str	r3, [sp, #16]
    8b5c:	2b00      	cmp	r3, #0
    8b5e:	f040 83b7 	bne.w	92d0 <ticker_job+0x780>
		return;
	}
	instance->job_guard = 1U;

	/* Back up the previous known tick */
	ticks_previous = instance->ticks_current;
    8b62:	6943      	ldr	r3, [r0, #20]

	/* Update current tick with the elapsed value from queue, and dequeue */
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    8b64:	7ac1      	ldrb	r1, [r0, #11]
	ticks_previous = instance->ticks_current;
    8b66:	9307      	str	r3, [sp, #28]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    8b68:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
    8b6a:	2201      	movs	r2, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    8b6c:	4299      	cmp	r1, r3
	instance->job_guard = 1U;
    8b6e:	7782      	strb	r2, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    8b70:	d056      	beq.n	8c20 <ticker_job+0xd0>
	u8_t idx = *ticks_elapsed_index + 1;
    8b72:	4413      	add	r3, r2
    8b74:	b2db      	uxtb	r3, r3
		idx = 0U;
    8b76:	2b02      	cmp	r3, #2
    8b78:	bf08      	it	eq
    8b7a:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
    8b7c:	7283      	strb	r3, [r0, #10]
		ticker_next_elapsed(&instance->ticks_elapsed_first);

		ticks_elapsed =
    8b7e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
		    instance->ticks_elapsed[instance->ticks_elapsed_first];

		instance->ticks_current += ticks_elapsed;
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;

		flag_elapsed = 1U;
    8b82:	9205      	str	r2, [sp, #20]
		ticks_elapsed =
    8b84:	68db      	ldr	r3, [r3, #12]
    8b86:	9301      	str	r3, [sp, #4]
		instance->ticks_current += ticks_elapsed;
    8b88:	9901      	ldr	r1, [sp, #4]
    8b8a:	9b07      	ldr	r3, [sp, #28]
    8b8c:	440b      	add	r3, r1
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
    8b8e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8b92:	6143      	str	r3, [r0, #20]
	flag_compare_update = 0U;

	/* Remember the old head, so as to decide if new compare needs to be
	 * set.
	 */
	ticker_id_old_head = instance->ticker_id_head;
    8b94:	7f63      	ldrb	r3, [r4, #29]
    8b96:	9306      	str	r3, [sp, #24]
	node = &instance->nodes[0];
    8b98:	6823      	ldr	r3, [r4, #0]
    8b9a:	9309      	str	r3, [sp, #36]	; 0x24
	users = &instance->users[0];
    8b9c:	6863      	ldr	r3, [r4, #4]
    8b9e:	930c      	str	r3, [sp, #48]	; 0x30
	count_user = instance->count_user;
    8ba0:	7a63      	ldrb	r3, [r4, #9]
    8ba2:	9303      	str	r3, [sp, #12]
	pending = 0U;
    8ba4:	2300      	movs	r3, #0
    8ba6:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
    8ba8:	23ff      	movs	r3, #255	; 0xff
    8baa:	9302      	str	r3, [sp, #8]
	while (count_user--) {
    8bac:	9b03      	ldr	r3, [sp, #12]
    8bae:	3b01      	subs	r3, #1
    8bb0:	b2db      	uxtb	r3, r3
    8bb2:	2bff      	cmp	r3, #255	; 0xff
    8bb4:	9303      	str	r3, [sp, #12]
    8bb6:	d137      	bne.n	8c28 <ticker_job+0xd8>

	/* Manage user operations (updates and deletions) in ticker list */
	pending = ticker_job_list_manage(instance, ticks_elapsed, &insert_head);

	/* Detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
    8bb8:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
    8bba:	9a06      	ldr	r2, [sp, #24]
    8bbc:	1a9b      	subs	r3, r3, r2
    8bbe:	bf18      	it	ne
    8bc0:	2301      	movne	r3, #1
    8bc2:	9303      	str	r3, [sp, #12]
	}

	/* Handle expired tickers */
	if (flag_elapsed) {
    8bc4:	9b05      	ldr	r3, [sp, #20]
    8bc6:	2b00      	cmp	r3, #0
    8bc8:	f000 8284 	beq.w	90d4 <ticker_job+0x584>
	ticks_now = cntr_cnt_get();
    8bcc:	f003 face 	bl	c16c <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    8bd0:	9b07      	ldr	r3, [sp, #28]
	while (instance->ticker_id_head != TICKER_NULL) {
    8bd2:	9f01      	ldr	r7, [sp, #4]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    8bd4:	1ac0      	subs	r0, r0, r3
	node = &instance->nodes[0];
    8bd6:	6823      	ldr	r3, [r4, #0]
    8bd8:	9309      	str	r3, [sp, #36]	; 0x24
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    8bda:	f020 4b7f 	bic.w	fp, r0, #4278190080	; 0xff000000
	ticks_expired = 0U;
    8bde:	f04f 0a00 	mov.w	sl, #0
	while (instance->ticker_id_head != TICKER_NULL) {
    8be2:	7f65      	ldrb	r5, [r4, #29]
    8be4:	2dff      	cmp	r5, #255	; 0xff
    8be6:	d00d      	beq.n	8c04 <ticker_job+0xb4>
		ticker = &node[id_expired];
    8be8:	b228      	sxth	r0, r5
    8bea:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    8bee:	0103      	lsls	r3, r0, #4
    8bf0:	930b      	str	r3, [sp, #44]	; 0x2c
    8bf2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8bf4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
    8bf8:	6882      	ldr	r2, [r0, #8]
		if (ticks_elapsed < ticks_to_expire) {
    8bfa:	42ba      	cmp	r2, r7
    8bfc:	f240 812e 	bls.w	8e5c <ticker_job+0x30c>
			ticker->ticks_to_expire -= ticks_elapsed;
    8c00:	1bd7      	subs	r7, r2, r7
    8c02:	6087      	str	r7, [r0, #8]
			flag_compare_update = 1U;
    8c04:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
    8c08:	9b03      	ldr	r3, [sp, #12]
		ticker_job_list_insert(instance, insert_head);
    8c0a:	4620      	mov	r0, r4
			flag_compare_update = 1U;
    8c0c:	42a9      	cmp	r1, r5
    8c0e:	bf18      	it	ne
    8c10:	4613      	movne	r3, r2
		ticker_job_list_insert(instance, insert_head);
    8c12:	9902      	ldr	r1, [sp, #8]
			flag_compare_update = 1U;
    8c14:	9303      	str	r3, [sp, #12]
		ticker_job_list_insert(instance, insert_head);
    8c16:	f00d fc22 	bl	1645e <ticker_job_list_insert>
	nodes = &instance->nodes[0];
    8c1a:	6825      	ldr	r5, [r4, #0]
		ticker_id_head = instance->ticker_id_head;
    8c1c:	7f66      	ldrb	r6, [r4, #29]
		while (ticker_id_head != TICKER_NULL) {
    8c1e:	e1cd      	b.n	8fbc <ticker_job+0x46c>
		flag_elapsed = 0U;
    8c20:	9b04      	ldr	r3, [sp, #16]
    8c22:	9305      	str	r3, [sp, #20]
		ticks_elapsed = 0U;
    8c24:	9301      	str	r3, [sp, #4]
    8c26:	e7b5      	b.n	8b94 <ticker_job+0x44>
		user = &users[count_user];
    8c28:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8c2a:	9a03      	ldr	r2, [sp, #12]
    8c2c:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
		user_ops = &user->user_op[0];
    8c30:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8c34:	930a      	str	r3, [sp, #40]	; 0x28
		while (user->middle != user->last) {
    8c36:	f898 2003 	ldrb.w	r2, [r8, #3]
			user_op = &user_ops[user->middle];
    8c3a:	2034      	movs	r0, #52	; 0x34
		while (user->middle != user->last) {
    8c3c:	f898 7002 	ldrb.w	r7, [r8, #2]
    8c40:	4297      	cmp	r7, r2
    8c42:	d0b3      	beq.n	8bac <ticker_job+0x5c>
			user_op = &user_ops[user->middle];
    8c44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			if (middle == user->count_user_op) {
    8c46:	f898 5000 	ldrb.w	r5, [r8]
			user_op = &user_ops[user->middle];
    8c4a:	fb17 f100 	smulbb	r1, r7, r0
    8c4e:	185e      	adds	r6, r3, r1
			middle = user->middle + 1;
    8c50:	1c7b      	adds	r3, r7, #1
    8c52:	b2db      	uxtb	r3, r3
				middle = 0U;
    8c54:	429d      	cmp	r5, r3
    8c56:	bf08      	it	eq
    8c58:	2300      	moveq	r3, #0
			user->middle = middle;
    8c5a:	f888 3002 	strb.w	r3, [r8, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
    8c5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8c60:	5c59      	ldrb	r1, [r3, r1]
    8c62:	2904      	cmp	r1, #4
    8c64:	d9ea      	bls.n	8c3c <ticker_job+0xec>
			ticker = &node[user_op->id];
    8c66:	7870      	ldrb	r0, [r6, #1]
    8c68:	eb00 0540 	add.w	r5, r0, r0, lsl #1
    8c6c:	012b      	lsls	r3, r5, #4
    8c6e:	930d      	str	r3, [sp, #52]	; 0x34
    8c70:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8c72:	eb03 1505 	add.w	r5, r3, r5, lsl #4
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    8c76:	2907      	cmp	r1, #7
			state = (ticker->req - ticker->ack) & 0xff;
    8c78:	f895 c002 	ldrb.w	ip, [r5, #2]
    8c7c:	786a      	ldrb	r2, [r5, #1]
    8c7e:	eba2 020c 	sub.w	r2, r2, ip
    8c82:	b2d2      	uxtb	r2, r2
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    8c84:	d80e      	bhi.n	8ca4 <ticker_job+0x154>
    8c86:	b16a      	cbz	r2, 8ca4 <ticker_job+0x154>
			    (state == 0U) ||
    8c88:	2905      	cmp	r1, #5
    8c8a:	d110      	bne.n	8cae <ticker_job+0x15e>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
    8c8c:	6873      	ldr	r3, [r6, #4]
    8c8e:	b973      	cbnz	r3, 8cae <ticker_job+0x15e>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
    8c90:	68b3      	ldr	r3, [r6, #8]
    8c92:	b963      	cbnz	r3, 8cae <ticker_job+0x15e>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
    8c94:	68f3      	ldr	r3, [r6, #12]
    8c96:	b953      	cbnz	r3, 8cae <ticker_job+0x15e>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
    8c98:	6933      	ldr	r3, [r6, #16]
    8c9a:	b943      	cbnz	r3, 8cae <ticker_job+0x15e>
			     (user_op->params.update.lazy == 0U) &&
    8c9c:	6973      	ldr	r3, [r6, #20]
    8c9e:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
    8ca2:	d104      	bne.n	8cae <ticker_job+0x15e>
				ticker_job_op_cb(user_op,
    8ca4:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    8ca6:	4630      	mov	r0, r6
    8ca8:	f00d fbcf 	bl	1644a <ticker_job_op_cb>
}
    8cac:	e7c3      	b.n	8c36 <ticker_job+0xe6>
			if (state == 1U) {
    8cae:	2a01      	cmp	r2, #1
    8cb0:	f040 80c9 	bne.w	8e46 <ticker_job+0x2f6>
	previous = instance->ticker_id_head;
    8cb4:	7f63      	ldrb	r3, [r4, #29]
	node = &instance->nodes[0];
    8cb6:	f8d4 9000 	ldr.w	r9, [r4]
	previous = instance->ticker_id_head;
    8cba:	461a      	mov	r2, r3
	total = 0U;
    8cbc:	2700      	movs	r7, #0
	while (current != TICKER_NULL) {
    8cbe:	2bff      	cmp	r3, #255	; 0xff
    8cc0:	d130      	bne.n	8d24 <ticker_job+0x1d4>
		return 0;
    8cc2:	2700      	movs	r7, #0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
    8cc4:	2905      	cmp	r1, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    8cc6:	60af      	str	r7, [r5, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
    8cc8:	f040 809a 	bne.w	8e00 <ticker_job+0x2b0>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    8ccc:	f8d4 9014 	ldr.w	r9, [r4, #20]
	ticks_now = cntr_cnt_get();
    8cd0:	f003 fa4c 	bl	c16c <cntr_cnt_get>
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    8cd4:	9901      	ldr	r1, [sp, #4]
	ticks_now = cntr_cnt_get();
    8cd6:	900b      	str	r0, [sp, #44]	; 0x2c
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    8cd8:	eba0 0309 	sub.w	r3, r0, r9
    8cdc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    8ce0:	440b      	add	r3, r1
	if (ticks_to_expire > ticks_elapsed) {
    8ce2:	429f      	cmp	r7, r3
		ticker->ticks_to_expire_minus += ticks_elapsed -
    8ce4:	bf98      	it	ls
    8ce6:	6969      	ldrls	r1, [r5, #20]
	if ((ticker->ticks_periodic != 0U) &&
    8ce8:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
    8cea:	bf9d      	ittte	ls
    8cec:	1bcf      	subls	r7, r1, r7
    8cee:	19db      	addls	r3, r3, r7
    8cf0:	616b      	strls	r3, [r5, #20]
		ticks_to_expire -= ticks_elapsed;
    8cf2:	1afb      	subhi	r3, r7, r3
		ticks_to_expire = 0U;
    8cf4:	bf98      	it	ls
    8cf6:	2300      	movls	r3, #0
	if ((ticker->ticks_periodic != 0U) &&
    8cf8:	2800      	cmp	r0, #0
    8cfa:	d057      	beq.n	8dac <ticker_job+0x25c>
	    (user_op->params.update.lazy != 0U)) {
    8cfc:	8ab1      	ldrh	r1, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
    8cfe:	2900      	cmp	r1, #0
    8d00:	d054      	beq.n	8dac <ticker_job+0x25c>
		user_op->params.update.lazy--;
    8d02:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
    8d06:	fa1f fc8c 	uxth.w	ip, ip
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
    8d0a:	f8df b2cc 	ldr.w	fp, [pc, #716]	; 8fd8 <ticker_job+0x488>
		user_op->params.update.lazy--;
    8d0e:	f8a6 c014 	strh.w	ip, [r6, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    8d12:	4298      	cmp	r0, r3
    8d14:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
    8d18:	d201      	bcs.n	8d1e <ticker_job+0x1ce>
    8d1a:	45f4      	cmp	ip, lr
    8d1c:	d313      	bcc.n	8d46 <ticker_job+0x1f6>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    8d1e:	f8df a2bc 	ldr.w	sl, [pc, #700]	; 8fdc <ticker_job+0x48c>
    8d22:	e03d      	b.n	8da0 <ticker_job+0x250>
		ticker_current = &node[current];
    8d24:	eb03 0e43 	add.w	lr, r3, r3, lsl #1
    8d28:	ea4f 1b0e 	mov.w	fp, lr, lsl #4
    8d2c:	eb09 1e0e 	add.w	lr, r9, lr, lsl #4
		if (current == id) {
    8d30:	4298      	cmp	r0, r3
    8d32:	f8de a008 	ldr.w	sl, [lr, #8]
    8d36:	f819 b00b 	ldrb.w	fp, [r9, fp]
    8d3a:	4457      	add	r7, sl
    8d3c:	f000 82a9 	beq.w	9292 <ticker_job+0x742>
    8d40:	461a      	mov	r2, r3
    8d42:	465b      	mov	r3, fp
    8d44:	e7bb      	b.n	8cbe <ticker_job+0x16e>
	if ((ticker->remainder_current >= BIT(31)) ||
    8d46:	6a69      	ldr	r1, [r5, #36]	; 0x24
    8d48:	4fa1      	ldr	r7, [pc, #644]	; (8fd0 <ticker_job+0x480>)
    8d4a:	4aa2      	ldr	r2, [pc, #648]	; (8fd4 <ticker_job+0x484>)
    8d4c:	19cf      	adds	r7, r1, r7
    8d4e:	4297      	cmp	r7, r2
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
    8d50:	bf84      	itt	hi
    8d52:	4459      	addhi	r1, fp
    8d54:	6269      	strhi	r1, [r5, #36]	; 0x24
	ticker->remainder_current -= ticker->remainder_periodic;
    8d56:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
		decrement++;
    8d5a:	bf8c      	ite	hi
    8d5c:	f04f 0a01 	movhi.w	sl, #1
	u8_t decrement = 0U;
    8d60:	f04f 0a00 	movls.w	sl, #0
	ticker->remainder_current -= ticker->remainder_periodic;
    8d64:	1a7f      	subs	r7, r7, r1
			ticks_to_expire -= ticker->ticks_periodic +
    8d66:	4482      	add	sl, r0
			ticker->lazy_current--;
    8d68:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
	ticker->remainder_current -= ticker->remainder_periodic;
    8d6c:	626f      	str	r7, [r5, #36]	; 0x24
			ticks_to_expire -= ticker->ticks_periodic +
    8d6e:	eba3 030a 	sub.w	r3, r3, sl
			ticker->lazy_current--;
    8d72:	f8a5 e01e 	strh.w	lr, [r5, #30]
    8d76:	e7cc      	b.n	8d12 <ticker_job+0x1c2>
	ticker->remainder_current += ticker->remainder_periodic;
    8d78:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
    8d7c:	440f      	add	r7, r1
	if ((ticker->remainder_current < BIT(31)) &&
    8d7e:	4994      	ldr	r1, [pc, #592]	; (8fd0 <ticker_job+0x480>)
    8d80:	4a94      	ldr	r2, [pc, #592]	; (8fd4 <ticker_job+0x484>)
    8d82:	1879      	adds	r1, r7, r1
    8d84:	4291      	cmp	r1, r2
	return 0;
    8d86:	bf8e      	itee	hi
    8d88:	2100      	movhi	r1, #0
		return 1;
    8d8a:	2101      	movls	r1, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    8d8c:	4457      	addls	r7, sl
			ticks_to_expire += ticker->ticks_periodic +
    8d8e:	4401      	add	r1, r0
			ticker->lazy_current++;
    8d90:	f10e 0e01 	add.w	lr, lr, #1
	ticker->remainder_current += ticker->remainder_periodic;
    8d94:	bf8c      	ite	hi
    8d96:	626f      	strhi	r7, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    8d98:	626f      	strls	r7, [r5, #36]	; 0x24
			ticks_to_expire += ticker->ticks_periodic +
    8d9a:	440b      	add	r3, r1
			ticker->lazy_current++;
    8d9c:	f8a5 e01e 	strh.w	lr, [r5, #30]
		while (ticker->lazy_current < user_op->params.update.lazy) {
    8da0:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
    8da4:	45f4      	cmp	ip, lr
    8da6:	d8e7      	bhi.n	8d78 <ticker_job+0x228>
		ticker->lazy_periodic = user_op->params.update.lazy;
    8da8:	f8a5 c01c 	strh.w	ip, [r5, #28]
				  user_op->params.update.ticks_drift_plus;
    8dac:	6871      	ldr	r1, [r6, #4]
				user_op->params.update.ticks_drift_minus;
    8dae:	68b0      	ldr	r0, [r6, #8]
	struct ticker_ext *ext_data = ticker->ext_data;
    8db0:	6aaf      	ldr	r7, [r5, #40]	; 0x28
	ticker->ticks_to_expire = ticks_to_expire +
    8db2:	440b      	add	r3, r1
    8db4:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus +=
    8db6:	696b      	ldr	r3, [r5, #20]
    8db8:	4403      	add	r3, r0
    8dba:	616b      	str	r3, [r5, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
    8dbc:	b11f      	cbz	r7, 8dc6 <ticker_job+0x276>
    8dbe:	683b      	ldr	r3, [r7, #0]
    8dc0:	b10b      	cbz	r3, 8dc6 <ticker_job+0x276>
			user_op->params.update.ticks_drift_plus -
    8dc2:	1a09      	subs	r1, r1, r0
		ext_data->ticks_drift =
    8dc4:	6079      	str	r1, [r7, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
    8dc6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    8dc8:	4649      	mov	r1, r9
    8dca:	4628      	mov	r0, r5
    8dcc:	f00d fb1f 	bl	1640e <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
    8dd0:	68f2      	ldr	r2, [r6, #12]
    8dd2:	69ab      	ldr	r3, [r5, #24]
    8dd4:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
    8dd6:	6932      	ldr	r2, [r6, #16]
    8dd8:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
    8dda:	bf8c      	ite	hi
    8ddc:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
    8dde:	2300      	movls	r3, #0
    8de0:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
    8de2:	7db3      	ldrb	r3, [r6, #22]
    8de4:	b103      	cbz	r3, 8de8 <ticker_job+0x298>
		ticker->force = user_op->params.update.force;
    8de6:	70eb      	strb	r3, [r5, #3]
	ticker->next = *insert_head;
    8de8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8dea:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    8dec:	4619      	mov	r1, r3
    8dee:	9b02      	ldr	r3, [sp, #8]
    8df0:	548b      	strb	r3, [r1, r2]
	*insert_head = user_op->id;
    8df2:	7873      	ldrb	r3, [r6, #1]
    8df4:	9302      	str	r3, [sp, #8]
		ticker->req++;
    8df6:	786b      	ldrb	r3, [r5, #1]
    8df8:	3301      	adds	r3, #1
    8dfa:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    8dfc:	2100      	movs	r1, #0
    8dfe:	e752      	b.n	8ca6 <ticker_job+0x156>
		ticker->req = ticker->ack;
    8e00:	f885 c001 	strb.w	ip, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
    8e04:	7f23      	ldrb	r3, [r4, #28]
    8e06:	4283      	cmp	r3, r0
    8e08:	d1f8      	bne.n	8dfc <ticker_job+0x2ac>
			instance->ticker_id_slot_previous = TICKER_NULL;
    8e0a:	23ff      	movs	r3, #255	; 0xff
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
    8e0c:	2907      	cmp	r1, #7
			instance->ticker_id_slot_previous = TICKER_NULL;
    8e0e:	7723      	strb	r3, [r4, #28]
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
    8e10:	d10d      	bne.n	8e2e <ticker_job+0x2de>
				ticks_at_stop =
    8e12:	6870      	ldr	r0, [r6, #4]
			ticks_current = instance->ticks_current;
    8e14:	6963      	ldr	r3, [r4, #20]
			if (!((ticks_at_stop - ticks_current) &
    8e16:	1ac2      	subs	r2, r0, r3
    8e18:	0211      	lsls	r1, r2, #8
    8e1a:	d40b      	bmi.n	8e34 <ticker_job+0x2e4>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    8e1c:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
    8e20:	9a01      	ldr	r2, [sp, #4]
    8e22:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
    8e24:	69a2      	ldr	r2, [r4, #24]
    8e26:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
    8e28:	bf88      	it	hi
    8e2a:	61a3      	strhi	r3, [r4, #24]
    8e2c:	e7e6      	b.n	8dfc <ticker_job+0x2ac>
				ticks_at_stop = cntr_cnt_get();
    8e2e:	f003 f99d 	bl	c16c <cntr_cnt_get>
    8e32:	e7ef      	b.n	8e14 <ticker_job+0x2c4>
				if (ticks_elapsed > ticks_used) {
    8e34:	9a01      	ldr	r2, [sp, #4]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    8e36:	1a1b      	subs	r3, r3, r0
    8e38:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
    8e3c:	429a      	cmp	r2, r3
					ticks_used = ticks_elapsed -
    8e3e:	bf8c      	ite	hi
    8e40:	1ad3      	subhi	r3, r2, r3
					ticks_used = 0;
    8e42:	2300      	movls	r3, #0
    8e44:	e7ee      	b.n	8e24 <ticker_job+0x2d4>
				instance->sched_cb(TICKER_CALL_ID_JOB,
    8e46:	2104      	movs	r1, #4
    8e48:	4623      	mov	r3, r4
    8e4a:	6a65      	ldr	r5, [r4, #36]	; 0x24
    8e4c:	2201      	movs	r2, #1
    8e4e:	4608      	mov	r0, r1
    8e50:	47a8      	blx	r5
				pending = 1U;
    8e52:	2301      	movs	r3, #1
				user->middle = prev;
    8e54:	f888 7002 	strb.w	r7, [r8, #2]
				pending = 1U;
    8e58:	9308      	str	r3, [sp, #32]
				break;
    8e5a:	e6a7      	b.n	8bac <ticker_job+0x5c>
		is_must_expire_skip = (ticker->must_expire &&
    8e5c:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
		ticks_elapsed -= ticks_to_expire;
    8e60:	1abf      	subs	r7, r7, r2
		ticks_expired += ticks_to_expire;
    8e62:	4492      	add	sl, r2
		ticks_latency -= ticks_to_expire;
    8e64:	ebab 0b02 	sub.w	fp, fp, r2
		is_must_expire_skip = (ticker->must_expire &&
    8e68:	2b00      	cmp	r3, #0
    8e6a:	d048      	beq.n	8efe <ticker_job+0x3ae>
    8e6c:	8bc6      	ldrh	r6, [r0, #30]
    8e6e:	3e00      	subs	r6, #0
    8e70:	bf18      	it	ne
    8e72:	2601      	movne	r6, #1
		if (instance->ticks_slot_previous > ticks_to_expire) {
    8e74:	69a1      	ldr	r1, [r4, #24]
    8e76:	428a      	cmp	r2, r1
			instance->ticker_id_slot_previous = TICKER_NULL;
    8e78:	bf24      	itt	cs
    8e7a:	22ff      	movcs	r2, #255	; 0xff
    8e7c:	7722      	strbcs	r2, [r4, #28]
		if ((ticker->ticks_slot != 0U) &&
    8e7e:	f8d0 c018 	ldr.w	ip, [r0, #24]
			instance->ticks_slot_previous -= ticks_to_expire;
    8e82:	bf34      	ite	cc
    8e84:	1a8a      	subcc	r2, r1, r2
			instance->ticks_slot_previous = 0U;
    8e86:	2200      	movcs	r2, #0
    8e88:	61a2      	str	r2, [r4, #24]
		if ((ticker->ticks_slot != 0U) &&
    8e8a:	6a82      	ldr	r2, [r0, #40]	; 0x28
    8e8c:	f1bc 0f00 	cmp.w	ip, #0
    8e90:	d00f      	beq.n	8eb2 <ticker_job+0x362>
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
    8e92:	7841      	ldrb	r1, [r0, #1]
    8e94:	f890 e002 	ldrb.w	lr, [r0, #2]
    8e98:	eba1 010e 	sub.w	r1, r1, lr
    8e9c:	b2c9      	uxtb	r1, r1
		if ((ticker->ticks_slot != 0U) &&
    8e9e:	2902      	cmp	r1, #2
    8ea0:	d107      	bne.n	8eb2 <ticker_job+0x362>
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
    8ea2:	b936      	cbnz	r6, 8eb2 <ticker_job+0x362>
		    !is_must_expire_skip &&
    8ea4:	b112      	cbz	r2, 8eac <ticker_job+0x35c>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    8ea6:	7a11      	ldrb	r1, [r2, #8]
    8ea8:	2901      	cmp	r1, #1
    8eaa:	d002      	beq.n	8eb2 <ticker_job+0x362>
			instance->ticker_id_slot_previous = id_expired;
    8eac:	7725      	strb	r5, [r4, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
    8eae:	f8c4 c018 	str.w	ip, [r4, #24]
		ticker->ticks_to_expire = 0U;
    8eb2:	2100      	movs	r1, #0
    8eb4:	6081      	str	r1, [r0, #8]
		instance->ticker_id_head = ticker->next;
    8eb6:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    8eb8:	9909      	ldr	r1, [sp, #36]	; 0x24
    8eba:	5d89      	ldrb	r1, [r1, r6]
    8ebc:	7761      	strb	r1, [r4, #29]
		if ((ticker->ticks_periodic != 0U) ||
    8ebe:	f8d0 e004 	ldr.w	lr, [r0, #4]
    8ec2:	f1be 0f00 	cmp.w	lr, #0
    8ec6:	d11c      	bne.n	8f02 <ticker_job+0x3b2>
    8ec8:	2a00      	cmp	r2, #0
    8eca:	d065      	beq.n	8f98 <ticker_job+0x448>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
    8ecc:	7a11      	ldrb	r1, [r2, #8]
    8ece:	2901      	cmp	r1, #1
    8ed0:	d162      	bne.n	8f98 <ticker_job+0x448>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    8ed2:	7a12      	ldrb	r2, [r2, #8]
    8ed4:	2a01      	cmp	r2, #1
    8ed6:	d116      	bne.n	8f06 <ticker_job+0x3b6>
				ticker->req = ticker->ack;
    8ed8:	7883      	ldrb	r3, [r0, #2]
				ticker->ticks_to_expire = ticks_elapsed;
    8eda:	6087      	str	r7, [r0, #8]
				ticker->req = ticker->ack;
    8edc:	7043      	strb	r3, [r0, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
    8ede:	9b07      	ldr	r3, [sp, #28]
    8ee0:	6961      	ldr	r1, [r4, #20]
    8ee2:	eb03 020a 	add.w	r2, r3, sl
    8ee6:	f00d fa92 	bl	1640e <ticks_to_expire_prep>
			ticker->next = *insert_head;
    8eea:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8eec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    8eee:	4619      	mov	r1, r3
    8ef0:	9b02      	ldr	r3, [sp, #8]
    8ef2:	548b      	strb	r3, [r1, r2]
			ticker->req++;
    8ef4:	7843      	ldrb	r3, [r0, #1]
    8ef6:	3301      	adds	r3, #1
    8ef8:	7043      	strb	r3, [r0, #1]
			ticker->req = ticker->ack;
    8efa:	9502      	str	r5, [sp, #8]
    8efc:	e671      	b.n	8be2 <ticker_job+0x92>
		is_must_expire_skip = (ticker->must_expire &&
    8efe:	461e      	mov	r6, r3
    8f00:	e7b8      	b.n	8e74 <ticker_job+0x324>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    8f02:	2a00      	cmp	r2, #0
    8f04:	d1e5      	bne.n	8ed2 <ticker_job+0x382>
				if (!ticker->lazy_current) {
    8f06:	f8b0 801e 	ldrh.w	r8, [r0, #30]
    8f0a:	f1b8 0f00 	cmp.w	r8, #0
    8f0e:	d127      	bne.n	8f60 <ticker_job+0x410>
					lazy_periodic = ticker->lazy_periodic;
    8f10:	8b82      	ldrh	r2, [r0, #28]
					lazy_periodic = 0U;
    8f12:	920a      	str	r2, [sp, #40]	; 0x28
				while (count--) {
    8f14:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
				ticks_to_expire = 0U;
    8f18:	f04f 0c00 	mov.w	ip, #0
	ticker->remainder_current += ticker->remainder_periodic;
    8f1c:	e9d0 6108 	ldrd	r6, r1, [r0, #32]
    8f20:	4431      	add	r1, r6
	if ((ticker->remainder_current < BIT(31)) &&
    8f22:	4e2b      	ldr	r6, [pc, #172]	; (8fd0 <ticker_job+0x480>)
    8f24:	4a2b      	ldr	r2, [pc, #172]	; (8fd4 <ticker_job+0x484>)
    8f26:	198e      	adds	r6, r1, r6
    8f28:	4296      	cmp	r6, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    8f2a:	bf9f      	itttt	ls
    8f2c:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
    8f30:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
    8f34:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
    8f38:	6241      	strls	r1, [r0, #36]	; 0x24
		return 1;
    8f3a:	bf92      	itee	ls
    8f3c:	9905      	ldrls	r1, [sp, #20]
	ticker->remainder_current += ticker->remainder_periodic;
    8f3e:	6241      	strhi	r1, [r0, #36]	; 0x24
	return 0;
    8f40:	2100      	movhi	r1, #0
					ticks_to_expire +=
    8f42:	4471      	add	r1, lr
				while (count--) {
    8f44:	f1b9 0901 	subs.w	r9, r9, #1
					ticks_to_expire +=
    8f48:	448c      	add	ip, r1
				while (count--) {
    8f4a:	d2e7      	bcs.n	8f1c <ticker_job+0x3cc>
				if (!ticker->must_expire) {
    8f4c:	b30b      	cbz	r3, 8f92 <ticker_job+0x442>
				lazy = 0U;
    8f4e:	2100      	movs	r1, #0
				ticker->lazy_current += (lazy_periodic + lazy);
    8f50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
				ticker->ticks_to_expire = ticks_to_expire;
    8f52:	f8c0 c008 	str.w	ip, [r0, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
    8f56:	440b      	add	r3, r1
    8f58:	4498      	add	r8, r3
    8f5a:	f8a0 801e 	strh.w	r8, [r0, #30]
    8f5e:	e7be      	b.n	8ede <ticker_job+0x38e>
					ticker->req = ticker->ack;
    8f60:	7882      	ldrb	r2, [r0, #2]
    8f62:	7042      	strb	r2, [r0, #1]
					lazy_periodic = 0U;
    8f64:	2200      	movs	r2, #0
    8f66:	e7d4      	b.n	8f12 <ticker_job+0x3c2>
	ticker->remainder_current += ticker->remainder_periodic;
    8f68:	e9d0 6108 	ldrd	r6, r1, [r0, #32]
    8f6c:	4431      	add	r1, r6
	if ((ticker->remainder_current < BIT(31)) &&
    8f6e:	4e18      	ldr	r6, [pc, #96]	; (8fd0 <ticker_job+0x480>)
    8f70:	4a18      	ldr	r2, [pc, #96]	; (8fd4 <ticker_job+0x484>)
    8f72:	198e      	adds	r6, r1, r6
    8f74:	4296      	cmp	r6, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    8f76:	bf9d      	ittte	ls
    8f78:	4449      	addls	r1, r9
    8f7a:	6241      	strls	r1, [r0, #36]	; 0x24
		return 1;
    8f7c:	9905      	ldrls	r1, [sp, #20]
	ticker->remainder_current += ticker->remainder_periodic;
    8f7e:	6241      	strhi	r1, [r0, #36]	; 0x24
	return 0;
    8f80:	bf88      	it	hi
    8f82:	2100      	movhi	r1, #0
						ticks_to_expire +=
    8f84:	4471      	add	r1, lr
    8f86:	448c      	add	ip, r1
						lazy++;
    8f88:	3301      	adds	r3, #1
					while (ticks_to_expire <
    8f8a:	45e3      	cmp	fp, ip
    8f8c:	b299      	uxth	r1, r3
    8f8e:	d8eb      	bhi.n	8f68 <ticker_job+0x418>
    8f90:	e7de      	b.n	8f50 <ticker_job+0x400>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    8f92:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8fdc <ticker_job+0x48c>
    8f96:	e7f8      	b.n	8f8a <ticker_job+0x43a>
			ticker->req = ticker->ack;
    8f98:	7883      	ldrb	r3, [r0, #2]
    8f9a:	9d02      	ldr	r5, [sp, #8]
    8f9c:	7043      	strb	r3, [r0, #1]
    8f9e:	e7ac      	b.n	8efa <ticker_job+0x3aa>
			ticker = &nodes[ticker_id_head];
    8fa0:	eb06 0146 	add.w	r1, r6, r6, lsl #1
    8fa4:	010b      	lsls	r3, r1, #4
    8fa6:	eb05 1101 	add.w	r1, r5, r1, lsl #4
			ext_data = ticker->ext_data;
    8faa:	f815 e003 	ldrb.w	lr, [r5, r3]
    8fae:	6a8f      	ldr	r7, [r1, #40]	; 0x28
			if (ext_data && ext_data->reschedule_state ==
    8fb0:	b11f      	cbz	r7, 8fba <ticker_job+0x46a>
    8fb2:	7a3b      	ldrb	r3, [r7, #8]
    8fb4:	2b01      	cmp	r3, #1
    8fb6:	f000 8185 	beq.w	92c4 <ticker_job+0x774>
			ticker_id_head = ticker->next;
    8fba:	4676      	mov	r6, lr
		while (ticker_id_head != TICKER_NULL) {
    8fbc:	2eff      	cmp	r6, #255	; 0xff
    8fbe:	d1ef      	bne.n	8fa0 <ticker_job+0x450>
			flag_compare_update = 1U;
    8fc0:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
    8fc4:	2b00      	cmp	r3, #0
    8fc6:	bf08      	it	eq
    8fc8:	4613      	moveq	r3, r2
    8fca:	9303      	str	r3, [sp, #12]
    8fcc:	e086      	b.n	90dc <ticker_job+0x58c>
    8fce:	bf00      	nop
    8fd0:	ff172b5a 	.word	0xff172b5a
    8fd4:	7f172b59 	.word	0x7f172b59
    8fd8:	01d1a94a 	.word	0x01d1a94a
    8fdc:	fe2e56b6 	.word	0xfe2e56b6
			instance->ticks_slot_previous > ticks_elapsed) {
    8fe0:	69a0      	ldr	r0, [r4, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    8fe2:	9b01      	ldr	r3, [sp, #4]
    8fe4:	4283      	cmp	r3, r0
    8fe6:	f080 8171 	bcs.w	92cc <ticker_job+0x77c>
			window_start_ticks = instance->ticks_slot_previous -
    8fea:	1ac3      	subs	r3, r0, r3
		window_start_ticks = 0U;
    8fec:	9302      	str	r3, [sp, #8]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
    8fee:	e9d7 2300 	ldrd	r2, r3, [r7]
    8ff2:	4293      	cmp	r3, r2
    8ff4:	d255      	bcs.n	90a2 <ticker_job+0x552>
			ticks_slot_window = ext_data->ticks_slot_window -
    8ff6:	f04f 0c00 	mov.w	ip, #0
    8ffa:	eba2 0a03 	sub.w	sl, r2, r3
		ticker_id_iter = nodes[ticker_id_head].next;
    8ffe:	4672      	mov	r2, lr
			ticks_slot_window = ext_data->ticks_slot_window -
    9000:	4663      	mov	r3, ip
		while (ticker_id_iter != TICKER_NULL &&
    9002:	2aff      	cmp	r2, #255	; 0xff
    9004:	d006      	beq.n	9014 <ticker_job+0x4c4>
		       ticks_start_offset + ticker->ticks_slot <=
    9006:	f8d1 8018 	ldr.w	r8, [r1, #24]
    900a:	eb0c 0008 	add.w	r0, ip, r8
		while (ticker_id_iter != TICKER_NULL &&
    900e:	4582      	cmp	sl, r0
		       ticks_start_offset + ticker->ticks_slot <=
    9010:	9004      	str	r0, [sp, #16]
		while (ticker_id_iter != TICKER_NULL &&
    9012:	d217      	bcs.n	9044 <ticker_job+0x4f4>
		ticker->ticks_to_expire = ticks_to_expire;
    9014:	608b      	str	r3, [r1, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
    9016:	4672      	mov	r2, lr
		ticker_id_prev = TICKER_NULL;
    9018:	23ff      	movs	r3, #255	; 0xff
		while (ticker_id_iter != TICKER_NULL) {
    901a:	2aff      	cmp	r2, #255	; 0xff
    901c:	d046      	beq.n	90ac <ticker_job+0x55c>
			node = &nodes[ticker_id_iter];
    901e:	eb02 0042 	add.w	r0, r2, r2, lsl #1
    9022:	ea4f 1900 	mov.w	r9, r0, lsl #4
    9026:	eb05 1000 	add.w	r0, r5, r0, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
    902a:	f8d1 8008 	ldr.w	r8, [r1, #8]
    902e:	f8d0 c008 	ldr.w	ip, [r0, #8]
    9032:	45e0      	cmp	r8, ip
    9034:	d937      	bls.n	90a6 <ticker_job+0x556>
				ticker->ticks_to_expire -=
    9036:	eba8 030c 	sub.w	r3, r8, ip
    903a:	608b      	str	r3, [r1, #8]
			ticker_id_iter = node->next;
    903c:	4613      	mov	r3, r2
    903e:	f815 2009 	ldrb.w	r2, [r5, r9]
    9042:	e7ea      	b.n	901a <ticker_job+0x4ca>
			node = &nodes[ticker_id_iter];
    9044:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    9048:	ea4f 1b02 	mov.w	fp, r2, lsl #4
    904c:	eb05 1202 	add.w	r2, r5, r2, lsl #4
			if (node->ext_data &&
    9050:	f8d2 9028 	ldr.w	r9, [r2, #40]	; 0x28
    9054:	f1b9 0f00 	cmp.w	r9, #0
    9058:	d007      	beq.n	906a <ticker_job+0x51a>
    905a:	f899 9008 	ldrb.w	r9, [r9, #8]
    905e:	f1b9 0f01 	cmp.w	r9, #1
    9062:	d102      	bne.n	906a <ticker_job+0x51a>
			ticker_id_iter = node->next;
    9064:	f815 200b 	ldrb.w	r2, [r5, fp]
    9068:	e7cb      	b.n	9002 <ticker_job+0x4b2>
			if (node->ticks_to_expire >
    906a:	f8d2 9008 	ldr.w	r9, [r2, #8]
    906e:	f1b9 0f04 	cmp.w	r9, #4
    9072:	d90e      	bls.n	9092 <ticker_job+0x542>
					MIN(ticks_slot_window,
    9074:	f1ac 0304 	sub.w	r3, ip, #4
    9078:	444b      	add	r3, r9
				window_end_ticks =
    907a:	4553      	cmp	r3, sl
			if (window_end_ticks > ticks_start_offset +
    907c:	9804      	ldr	r0, [sp, #16]
				window_end_ticks =
    907e:	bf28      	it	cs
    9080:	4653      	movcs	r3, sl
			if (window_end_ticks > ticks_start_offset +
    9082:	4283      	cmp	r3, r0
    9084:	d905      	bls.n	9092 <ticker_job+0x542>
			if (ticks_to_expire != 0U &&
    9086:	ebb3 0308 	subs.w	r3, r3, r8
    908a:	d002      	beq.n	9092 <ticker_job+0x542>
    908c:	9802      	ldr	r0, [sp, #8]
    908e:	4283      	cmp	r3, r0
    9090:	d2c0      	bcs.n	9014 <ticker_job+0x4c4>
			window_start_ticks  = node->ticks_to_expire +
    9092:	6990      	ldr	r0, [r2, #24]
    9094:	eb00 0309 	add.w	r3, r0, r9
    9098:	9302      	str	r3, [sp, #8]
			ticks_start_offset += node->ticks_to_expire;
    909a:	44cc      	add	ip, r9
			ticks_to_expire     = ticks_slot_window -
    909c:	ebaa 0308 	sub.w	r3, sl, r8
    90a0:	e7e0      	b.n	9064 <ticker_job+0x514>
    90a2:	2300      	movs	r3, #0
    90a4:	e7b6      	b.n	9014 <ticker_job+0x4c4>
				node->ticks_to_expire -=
    90a6:	ebac 0208 	sub.w	r2, ip, r8
    90aa:	6082      	str	r2, [r0, #8]
		if (ticker_id_prev != TICKER_NULL) {
    90ac:	2bff      	cmp	r3, #255	; 0xff
    90ae:	d008      	beq.n	90c2 <ticker_job+0x572>
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    90b0:	b21b      	sxth	r3, r3
    90b2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    90b6:	011b      	lsls	r3, r3, #4
			instance->ticker_id_head = nodes[ticker_id_head].next;
    90b8:	f884 e01d 	strb.w	lr, [r4, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    90bc:	5cea      	ldrb	r2, [r5, r3]
    90be:	700a      	strb	r2, [r1, #0]
			nodes[ticker_id_prev].next = ticker_id_head;
    90c0:	54ee      	strb	r6, [r5, r3]
		ticker->lazy_current--;
    90c2:	8bcb      	ldrh	r3, [r1, #30]
    90c4:	3b01      	subs	r3, #1
    90c6:	83cb      	strh	r3, [r1, #30]
		ext_data->reschedule_state =
    90c8:	f04f 0302 	mov.w	r3, #2
    90cc:	723b      	strb	r3, [r7, #8]
		rescheduled  = 1U;
    90ce:	2301      	movs	r3, #1
    90d0:	9304      	str	r3, [sp, #16]
    90d2:	e5a3      	b.n	8c1c <ticker_job+0xcc>
		ticker_job_list_insert(instance, insert_head);
    90d4:	9902      	ldr	r1, [sp, #8]
    90d6:	4620      	mov	r0, r4
    90d8:	f00d f9c1 	bl	1645e <ticker_job_list_insert>
	if (instance->ticker_id_head != ticker_id_old_head) {
    90dc:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
    90de:	9a03      	ldr	r2, [sp, #12]
    90e0:	9906      	ldr	r1, [sp, #24]
    90e2:	428b      	cmp	r3, r1
    90e4:	bf18      	it	ne
    90e6:	2201      	movne	r2, #1
	if (!pending) {
    90e8:	9b08      	ldr	r3, [sp, #32]
		flag_compare_update = 1U;
    90ea:	9203      	str	r2, [sp, #12]
	if (!pending) {
    90ec:	b1e3      	cbz	r3, 9128 <ticker_job+0x5d8>
	instance->job_guard = 0U;
    90ee:	2300      	movs	r3, #0
    90f0:	77a3      	strb	r3, [r4, #30]
	if (flag_compare_update) {
    90f2:	9b03      	ldr	r3, [sp, #12]
    90f4:	b153      	cbz	r3, 910c <ticker_job+0x5bc>
	if (instance->ticker_id_head == TICKER_NULL) {
    90f6:	7f63      	ldrb	r3, [r4, #29]
    90f8:	2bff      	cmp	r3, #255	; 0xff
    90fa:	f040 8081 	bne.w	9200 <ticker_job+0x6b0>
		if (cntr_stop() == 0) {
    90fe:	f003 f80f 	bl	c120 <cntr_stop>
    9102:	b918      	cbnz	r0, 910c <ticker_job+0x5bc>
			instance->ticks_slot_previous = 0U;
    9104:	61a0      	str	r0, [r4, #24]
			instance->ticks_current = cntr_cnt_get();
    9106:	f003 f831 	bl	c16c <cntr_cnt_get>
    910a:	6160      	str	r0, [r4, #20]
	if (instance->worker_trigger) {
    910c:	7fe3      	ldrb	r3, [r4, #31]
    910e:	2b00      	cmp	r3, #0
    9110:	f000 80de 	beq.w	92d0 <ticker_job+0x780>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    9114:	6a65      	ldr	r5, [r4, #36]	; 0x24
    9116:	4623      	mov	r3, r4
    9118:	2201      	movs	r2, #1
    911a:	2103      	movs	r1, #3
    911c:	2004      	movs	r0, #4
    911e:	46ac      	mov	ip, r5
}
    9120:	b00f      	add	sp, #60	; 0x3c
    9122:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    9126:	4760      	bx	ip
	users = &instance->users[0];
    9128:	6863      	ldr	r3, [r4, #4]
	count_user = instance->count_user;
    912a:	7a65      	ldrb	r5, [r4, #9]
		uop->status = TICKER_STATUS_SUCCESS;
    912c:	f8dd a020 	ldr.w	sl, [sp, #32]
	users = &instance->users[0];
    9130:	9301      	str	r3, [sp, #4]
	while (count_user--) {
    9132:	3d01      	subs	r5, #1
    9134:	b2ed      	uxtb	r5, r5
    9136:	2dff      	cmp	r5, #255	; 0xff
    9138:	d0d9      	beq.n	90ee <ticker_job+0x59e>
		user = &users[count_user];
    913a:	9b01      	ldr	r3, [sp, #4]
    913c:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
    9140:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
    9144:	7873      	ldrb	r3, [r6, #1]
    9146:	78f2      	ldrb	r2, [r6, #3]
    9148:	429a      	cmp	r2, r3
    914a:	d0f2      	beq.n	9132 <ticker_job+0x5e2>
			ticker_job_op_inquire(instance, &user_op[user->first]);
    914c:	2234      	movs	r2, #52	; 0x34
    914e:	fb13 f202 	smulbb	r2, r3, r2
    9152:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
    9156:	f818 2002 	ldrb.w	r2, [r8, r2]
    915a:	2a02      	cmp	r2, #2
    915c:	d013      	beq.n	9186 <ticker_job+0x636>
    915e:	2a03      	cmp	r2, #3
    9160:	d03e      	beq.n	91e0 <ticker_job+0x690>
    9162:	2a01      	cmp	r2, #1
    9164:	d106      	bne.n	9174 <ticker_job+0x624>
			uop->status = TICKER_STATUS_SUCCESS;
    9166:	f8c3 a028 	str.w	sl, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
    916a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	if (fp_op_func) {
    916c:	b112      	cbz	r2, 9174 <ticker_job+0x624>
		fp_op_func(uop->status, uop->op_context);
    916e:	6b19      	ldr	r1, [r3, #48]	; 0x30
    9170:	6a98      	ldr	r0, [r3, #40]	; 0x28
    9172:	4790      	blx	r2
			first = user->first + 1;
    9174:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
    9176:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
    9178:	3301      	adds	r3, #1
    917a:	b2db      	uxtb	r3, r3
				first = 0U;
    917c:	429a      	cmp	r2, r3
    917e:	bf08      	it	eq
    9180:	2300      	moveq	r3, #0
			user->first = first;
    9182:	7073      	strb	r3, [r6, #1]
    9184:	e7de      	b.n	9144 <ticker_job+0x5f4>
		ticker_by_next_slot_get(instance,
    9186:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
    918a:	f899 2000 	ldrb.w	r2, [r9]
		ticker_by_next_slot_get(instance,
    918e:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
    9192:	f8d4 c000 	ldr.w	ip, [r4]
	if ((_ticker_id_head == TICKER_NULL) ||
    9196:	6961      	ldr	r1, [r4, #20]
    9198:	2aff      	cmp	r2, #255	; 0xff
    919a:	d002      	beq.n	91a2 <ticker_job+0x652>
    919c:	6807      	ldr	r7, [r0, #0]
    919e:	42b9      	cmp	r1, r7
    91a0:	d013      	beq.n	91ca <ticker_job+0x67a>
		_ticker_id_head = instance->ticker_id_head;
    91a2:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
    91a4:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
    91a6:	2000      	movs	r0, #0
	while ((_ticker_id_head != TICKER_NULL) &&
    91a8:	2aff      	cmp	r2, #255	; 0xff
    91aa:	d009      	beq.n	91c0 <ticker_job+0x670>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
    91ac:	eb02 0142 	add.w	r1, r2, r2, lsl #1
    91b0:	ea4f 1b01 	mov.w	fp, r1, lsl #4
    91b4:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
    91b8:	688f      	ldr	r7, [r1, #8]
	while ((_ticker_id_head != TICKER_NULL) &&
    91ba:	6989      	ldr	r1, [r1, #24]
    91bc:	4438      	add	r0, r7
    91be:	b161      	cbz	r1, 91da <ticker_job+0x68a>
	*ticker_id_head = _ticker_id_head;
    91c0:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
    91c4:	f8ce 0000 	str.w	r0, [lr]
}
    91c8:	e7cd      	b.n	9166 <ticker_job+0x616>
		ticker = &node[_ticker_id_head];
    91ca:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    91ce:	0112      	lsls	r2, r2, #4
	_ticks_to_expire = *ticks_to_expire;
    91d0:	f8de 0000 	ldr.w	r0, [lr]
		_ticker_id_head = ticker->next;
    91d4:	f81c 2002 	ldrb.w	r2, [ip, r2]
    91d8:	e7e6      	b.n	91a8 <ticker_job+0x658>
		_ticker_id_head = ticker->next;
    91da:	f81c 200b 	ldrb.w	r2, [ip, fp]
    91de:	e7e3      	b.n	91a8 <ticker_job+0x658>
		if (uop->id < instance->count_node) {
    91e0:	785a      	ldrb	r2, [r3, #1]
    91e2:	7a21      	ldrb	r1, [r4, #8]
    91e4:	4291      	cmp	r1, r2
    91e6:	d908      	bls.n	91fa <ticker_job+0x6aa>
			node[uop->id].priority =
    91e8:	eb02 0142 	add.w	r1, r2, r2, lsl #1
    91ec:	6822      	ldr	r2, [r4, #0]
    91ee:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    91f2:	7919      	ldrb	r1, [r3, #4]
    91f4:	f882 102d 	strb.w	r1, [r2, #45]	; 0x2d
    91f8:	e7b5      	b.n	9166 <ticker_job+0x616>
			uop->status = TICKER_STATUS_FAILURE;
    91fa:	2201      	movs	r2, #1
    91fc:	629a      	str	r2, [r3, #40]	; 0x28
    91fe:	e7b4      	b.n	916a <ticker_job+0x61a>
	if (ticker_id_old_head == TICKER_NULL) {
    9200:	9b06      	ldr	r3, [sp, #24]
    9202:	2bff      	cmp	r3, #255	; 0xff
    9204:	d106      	bne.n	9214 <ticker_job+0x6c4>
		ticks_current = cntr_cnt_get();
    9206:	f002 ffb1 	bl	c16c <cntr_cnt_get>
    920a:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
    920c:	f002 ff7a 	bl	c104 <cntr_start>
    9210:	b900      	cbnz	r0, 9214 <ticker_job+0x6c4>
			instance->ticks_current = ticks_current;
    9212:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
    9214:	7f63      	ldrb	r3, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
    9216:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
    9218:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 92d8 <ticker_job+0x788>
    921c:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 92dc <ticker_job+0x78c>
    9220:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 92e0 <ticker_job+0x790>
	ticker = &instance->nodes[instance->ticker_id_head];
    9224:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	ticks_to_expire = ticker->ticks_to_expire;
    9228:	eb02 1303 	add.w	r3, r2, r3, lsl #4
	i = 10U;
    922c:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
    922e:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
    9230:	f002 ff9c 	bl	c16c <cntr_cnt_get>
		cc = instance->ticks_current;
    9234:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    9236:	1b43      	subs	r3, r0, r5
    9238:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
    923c:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
    923e:	42bb      	cmp	r3, r7
    9240:	bf2c      	ite	cs
    9242:	18ed      	addcs	r5, r5, r3
    9244:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
    9246:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
    924a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		ctr = cntr_cnt_get();
    924c:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
    924e:	4628      	mov	r0, r5
    9250:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
    9252:	f002 ff8b 	bl	c16c <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    9256:	eba0 030b 	sub.w	r3, r0, fp
    925a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    925e:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
    9262:	3303      	adds	r3, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    9264:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
    9268:	42ab      	cmp	r3, r5
		i--;
    926a:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
    926e:	f67f af4d 	bls.w	910c <ticker_job+0x5bc>
		LL_ASSERT(i);
    9272:	2e00      	cmp	r6, #0
    9274:	d1dc      	bne.n	9230 <ticker_job+0x6e0>
    9276:	f640 0371 	movw	r3, #2161	; 0x871
    927a:	4642      	mov	r2, r8
    927c:	4649      	mov	r1, r9
    927e:	4650      	mov	r0, sl
    9280:	f00b fc53 	bl	14b2a <printk>
    9284:	4040      	eors	r0, r0
    9286:	f380 8811 	msr	BASEPRI, r0
    928a:	f04f 0003 	mov.w	r0, #3
    928e:	df02      	svc	2
    9290:	e7ce      	b.n	9230 <ticker_job+0x6e0>
	if (previous == current) {
    9292:	4290      	cmp	r0, r2
    9294:	d101      	bne.n	929a <ticker_job+0x74a>
		instance->ticker_id_head = ticker_current->next;
    9296:	f884 b01d 	strb.w	fp, [r4, #29]
	node[previous].next = ticker_current->next;
    929a:	b212      	sxth	r2, r2
    929c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    92a0:	0112      	lsls	r2, r2, #4
    92a2:	f809 b002 	strb.w	fp, [r9, r2]
	if (ticker_current->next != TICKER_NULL) {
    92a6:	f89e 3000 	ldrb.w	r3, [lr]
    92aa:	2bff      	cmp	r3, #255	; 0xff
    92ac:	f43f ad0a 	beq.w	8cc4 <ticker_job+0x174>
		node[ticker_current->next].ticks_to_expire += timeout;
    92b0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    92b4:	eb09 1903 	add.w	r9, r9, r3, lsl #4
    92b8:	f8d9 2008 	ldr.w	r2, [r9, #8]
    92bc:	4452      	add	r2, sl
    92be:	f8c9 2008 	str.w	r2, [r9, #8]
	return (total + timeout);
    92c2:	e4ff      	b.n	8cc4 <ticker_job+0x174>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    92c4:	7f23      	ldrb	r3, [r4, #28]
    92c6:	2bff      	cmp	r3, #255	; 0xff
    92c8:	f47f ae8a 	bne.w	8fe0 <ticker_job+0x490>
		window_start_ticks = 0U;
    92cc:	2300      	movs	r3, #0
    92ce:	e68d      	b.n	8fec <ticker_job+0x49c>
}
    92d0:	b00f      	add	sp, #60	; 0x3c
    92d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    92d6:	bf00      	nop
    92d8:	0001b214 	.word	0x0001b214
    92dc:	0001b39b 	.word	0x0001b39b
    92e0:	0001aebe 	.word	0x0001aebe

000092e4 <ticker_init>:
{
    92e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    92e6:	9f05      	ldr	r7, [sp, #20]
    92e8:	f89d e018 	ldrb.w	lr, [sp, #24]
    92ec:	f8dd c01c 	ldr.w	ip, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
    92f0:	4605      	mov	r5, r0
    92f2:	b108      	cbz	r0, 92f8 <ticker_init+0x14>
		return TICKER_STATUS_FAILURE;
    92f4:	2001      	movs	r0, #1
}
    92f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
    92f8:	4c19      	ldr	r4, [pc, #100]	; (9360 <ticker_init+0x7c>)
    92fa:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
    92fc:	6022      	str	r2, [r4, #0]
	while (count_node--) {
    92fe:	3901      	subs	r1, #1
    9300:	b2c9      	uxtb	r1, r1
    9302:	29ff      	cmp	r1, #255	; 0xff
    9304:	d118      	bne.n	9338 <ticker_init+0x54>
	instance->count_user = count_user;
    9306:	7263      	strb	r3, [r4, #9]
	instance->users = user;
    9308:	6067      	str	r7, [r4, #4]
		user_op_ += users[count_user].count_user_op;
    930a:	2134      	movs	r1, #52	; 0x34
	while (count_user--) {
    930c:	3b01      	subs	r3, #1
    930e:	b2db      	uxtb	r3, r3
    9310:	2bff      	cmp	r3, #255	; 0xff
    9312:	d118      	bne.n	9346 <ticker_init+0x62>
	if (count_op) {
    9314:	f1be 0f00 	cmp.w	lr, #0
    9318:	d1ec      	bne.n	92f4 <ticker_init+0x10>
	instance->caller_id_get_cb = caller_id_get_cb;
    931a:	9b08      	ldr	r3, [sp, #32]
    931c:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
    931e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9320:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
    9322:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9324:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
    9326:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
    932a:	e9c4 ee05 	strd	lr, lr, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
    932e:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
    9330:	f8a4 e00a 	strh.w	lr, [r4, #10]
	return TICKER_STATUS_SUCCESS;
    9334:	4670      	mov	r0, lr
    9336:	e7de      	b.n	92f6 <ticker_init+0x12>
		instance->nodes[count_node].priority = 0;
    9338:	eb01 0641 	add.w	r6, r1, r1, lsl #1
    933c:	eb02 1606 	add.w	r6, r2, r6, lsl #4
    9340:	f886 502d 	strb.w	r5, [r6, #45]	; 0x2d
    9344:	e7db      	b.n	92fe <ticker_init+0x1a>
		users[count_user].user_op = user_op_;
    9346:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    934a:	f8c2 c004 	str.w	ip, [r2, #4]
		user_op_ += users[count_user].count_user_op;
    934e:	f817 2033 	ldrb.w	r2, [r7, r3, lsl #3]
    9352:	fb02 cc01 	mla	ip, r2, r1, ip
		count_op -= users[count_user].count_user_op;
    9356:	ebae 0202 	sub.w	r2, lr, r2
    935a:	fa5f fe82 	uxtb.w	lr, r2
    935e:	e7d5      	b.n	930c <ticker_init+0x28>
    9360:	20002cf8 	.word	0x20002cf8

00009364 <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
    9364:	4b04      	ldr	r3, [pc, #16]	; (9378 <ticker_is_initialized+0x14>)
    9366:	222c      	movs	r2, #44	; 0x2c
    9368:	fb02 3000 	mla	r0, r2, r0, r3
    936c:	7a00      	ldrb	r0, [r0, #8]
}
    936e:	3800      	subs	r0, #0
    9370:	bf18      	it	ne
    9372:	2001      	movne	r0, #1
    9374:	4770      	bx	lr
    9376:	bf00      	nop
    9378:	20002cf8 	.word	0x20002cf8

0000937c <ticker_trigger>:
	if (instance->sched_cb) {
    937c:	4b07      	ldr	r3, [pc, #28]	; (939c <ticker_trigger+0x20>)
    937e:	222c      	movs	r2, #44	; 0x2c
    9380:	fb02 3100 	mla	r1, r2, r0, r3
{
    9384:	b410      	push	{r4}
	if (instance->sched_cb) {
    9386:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    9388:	b134      	cbz	r4, 9398 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    938a:	460b      	mov	r3, r1
    938c:	46a4      	mov	ip, r4
    938e:	2201      	movs	r2, #1
}
    9390:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    9392:	2103      	movs	r1, #3
    9394:	2002      	movs	r0, #2
    9396:	4760      	bx	ip
}
    9398:	bc10      	pop	{r4}
    939a:	4770      	bx	lr
    939c:	20002cf8 	.word	0x20002cf8

000093a0 <ticker_start_ext>:
{
    93a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    93a4:	4605      	mov	r5, r0
    93a6:	4608      	mov	r0, r1
    93a8:	4611      	mov	r1, r2
    93aa:	461a      	mov	r2, r3
	struct ticker_instance *instance = &_instance[instance_index];
    93ac:	4b22      	ldr	r3, [pc, #136]	; (9438 <ticker_start_ext+0x98>)
    93ae:	242c      	movs	r4, #44	; 0x2c
    93b0:	fb05 3904 	mla	r9, r5, r4, r3
	user = &instance->users[user_id];
    93b4:	f8d9 3004 	ldr.w	r3, [r9, #4]
    93b8:	eb03 0cc0 	add.w	ip, r3, r0, lsl #3
	if (last >= user->count_user_op) {
    93bc:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
    93c0:	f89c 7003 	ldrb.w	r7, [ip, #3]
    93c4:	1c7e      	adds	r6, r7, #1
    93c6:	b2f6      	uxtb	r6, r6
		last = 0U;
    93c8:	42b3      	cmp	r3, r6
    93ca:	bf98      	it	ls
    93cc:	2600      	movls	r6, #0
	if (last == user->first) {
    93ce:	f89c 3001 	ldrb.w	r3, [ip, #1]
    93d2:	42b3      	cmp	r3, r6
    93d4:	d02e      	beq.n	9434 <ticker_start_ext+0x94>
	user_op = &user->user_op[user->last];
    93d6:	2334      	movs	r3, #52	; 0x34
    93d8:	fb17 f703 	smulbb	r7, r7, r3
    93dc:	f8dc 3004 	ldr.w	r3, [ip, #4]
	user_op->op = TICKER_USER_OP_TYPE_START;
    93e0:	f04f 0804 	mov.w	r8, #4
	user_op = &user->user_op[user->last];
    93e4:	19dc      	adds	r4, r3, r7
	user_op->op = TICKER_USER_OP_TYPE_START;
    93e6:	f803 8007 	strb.w	r8, [r3, r7]
	user_op->params.start.ticks_first = ticks_first;
    93ea:	9b08      	ldr	r3, [sp, #32]
    93ec:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
    93ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
    93f0:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
    93f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    93f4:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
    93f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    93f8:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
    93fa:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    93fe:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.ext_data = ext_data;
    9400:	9b11      	ldr	r3, [sp, #68]	; 0x44
    9402:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
    9404:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    9406:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
    9408:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    940a:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
    940c:	2302      	movs	r3, #2
    940e:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    9410:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    9412:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    9414:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
    9416:	7061      	strb	r1, [r4, #1]
	user_op->params.start.ticks_at_start = ticks_anchor;
    9418:	6062      	str	r2, [r4, #4]
	user_op->op_context = op_context;
    941a:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    941c:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    9420:	e9d9 3608 	ldrd	r3, r6, [r9, #32]
    9424:	4798      	blx	r3
    9426:	464b      	mov	r3, r9
    9428:	2200      	movs	r2, #0
    942a:	4641      	mov	r1, r8
    942c:	47b0      	blx	r6
	return user_op->status;
    942e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    9430:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    9434:	2001      	movs	r0, #1
    9436:	e7fb      	b.n	9430 <ticker_start_ext+0x90>
    9438:	20002cf8 	.word	0x20002cf8

0000943c <ticker_update>:
{
    943c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9440:	4605      	mov	r5, r0
    9442:	4608      	mov	r0, r1
    9444:	4619      	mov	r1, r3
	struct ticker_instance *instance = &_instance[instance_index];
    9446:	4b20      	ldr	r3, [pc, #128]	; (94c8 <ticker_update+0x8c>)
    9448:	242c      	movs	r4, #44	; 0x2c
    944a:	fb05 3804 	mla	r8, r5, r4, r3
	user = &instance->users[user_id];
    944e:	f8d8 3004 	ldr.w	r3, [r8, #4]
    9452:	eb03 0cc0 	add.w	ip, r3, r0, lsl #3
	if (last >= user->count_user_op) {
    9456:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
    945a:	f89c 7003 	ldrb.w	r7, [ip, #3]
    945e:	1c7e      	adds	r6, r7, #1
    9460:	b2f6      	uxtb	r6, r6
		last = 0U;
    9462:	42b3      	cmp	r3, r6
    9464:	bf98      	it	ls
    9466:	2600      	movls	r6, #0
	if (last == user->first) {
    9468:	f89c 3001 	ldrb.w	r3, [ip, #1]
    946c:	42b3      	cmp	r3, r6
    946e:	d029      	beq.n	94c4 <ticker_update+0x88>
	user_op = &user->user_op[user->last];
    9470:	2334      	movs	r3, #52	; 0x34
    9472:	fb17 f703 	smulbb	r7, r7, r3
    9476:	f8dc 3004 	ldr.w	r3, [ip, #4]
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
    947a:	f04f 0e05 	mov.w	lr, #5
	user_op = &user->user_op[user->last];
    947e:	19dc      	adds	r4, r3, r7
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
    9480:	f803 e007 	strb.w	lr, [r3, r7]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
    9484:	9b06      	ldr	r3, [sp, #24]
    9486:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
    9488:	9b07      	ldr	r3, [sp, #28]
    948a:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
    948c:	9b08      	ldr	r3, [sp, #32]
    948e:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
    9490:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    9494:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
    9496:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    949a:	75a3      	strb	r3, [r4, #22]
	user_op->status = TICKER_STATUS_BUSY;
    949c:	2302      	movs	r3, #2
    949e:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    94a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    94a2:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    94a4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
    94a6:	7062      	strb	r2, [r4, #1]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
    94a8:	6061      	str	r1, [r4, #4]
	user_op->op_context = op_context;
    94aa:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    94ac:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    94b0:	e9d8 3608 	ldrd	r3, r6, [r8, #32]
    94b4:	4798      	blx	r3
    94b6:	4643      	mov	r3, r8
    94b8:	2200      	movs	r2, #0
    94ba:	2104      	movs	r1, #4
    94bc:	47b0      	blx	r6
	return user_op->status;
    94be:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    94c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    94c4:	2001      	movs	r0, #1
    94c6:	e7fb      	b.n	94c0 <ticker_update+0x84>
    94c8:	20002cf8 	.word	0x20002cf8

000094cc <ticker_stop>:
{
    94cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    94d0:	4604      	mov	r4, r0
    94d2:	4608      	mov	r0, r1
    94d4:	4619      	mov	r1, r3
	struct ticker_instance *instance = &_instance[instance_index];
    94d6:	4b19      	ldr	r3, [pc, #100]	; (953c <ticker_stop+0x70>)
    94d8:	252c      	movs	r5, #44	; 0x2c
    94da:	fb04 3905 	mla	r9, r4, r5, r3
	user = &instance->users[user_id];
    94de:	f8d9 3004 	ldr.w	r3, [r9, #4]
    94e2:	eb03 07c0 	add.w	r7, r3, r0, lsl #3
	if (last >= user->count_user_op) {
    94e6:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
    94ea:	78fe      	ldrb	r6, [r7, #3]
    94ec:	1c75      	adds	r5, r6, #1
    94ee:	b2ed      	uxtb	r5, r5
		last = 0U;
    94f0:	42ab      	cmp	r3, r5
    94f2:	bf98      	it	ls
    94f4:	2500      	movls	r5, #0
	if (last == user->first) {
    94f6:	787b      	ldrb	r3, [r7, #1]
    94f8:	42ab      	cmp	r3, r5
    94fa:	d01d      	beq.n	9538 <ticker_stop+0x6c>
	user_op = &user->user_op[user->last];
    94fc:	2334      	movs	r3, #52	; 0x34
    94fe:	fb16 f603 	smulbb	r6, r6, r3
    9502:	687b      	ldr	r3, [r7, #4]
	user_op->op = TICKER_USER_OP_TYPE_STOP;
    9504:	f04f 0c06 	mov.w	ip, #6
    9508:	f803 c006 	strb.w	ip, [r3, r6]
	user_op = &user->user_op[user->last];
    950c:	eb03 0806 	add.w	r8, r3, r6
	user_op->status = TICKER_STATUS_BUSY;
    9510:	2302      	movs	r3, #2
	user_op->fp_op_func = fp_op_func;
    9512:	e9c8 310a 	strd	r3, r1, [r8, #40]	; 0x28
	user_op->op_context = op_context;
    9516:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
    9518:	f888 2001 	strb.w	r2, [r8, #1]
	user_op->op_context = op_context;
    951c:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
	user->last = last;
    9520:	70fd      	strb	r5, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    9522:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
    9526:	4798      	blx	r3
    9528:	464b      	mov	r3, r9
    952a:	2200      	movs	r2, #0
    952c:	2104      	movs	r1, #4
    952e:	47a8      	blx	r5
	return user_op->status;
    9530:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
}
    9534:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    9538:	2001      	movs	r0, #1
    953a:	e7fb      	b.n	9534 <ticker_stop+0x68>
    953c:	20002cf8 	.word	0x20002cf8

00009540 <ll_addr_get>:

static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
    9540:	b508      	push	{r3, lr}
    9542:	4603      	mov	r3, r0
	if (addr_type > 1) {
    9544:	2b01      	cmp	r3, #1
{
    9546:	4608      	mov	r0, r1
	if (addr_type > 1) {
    9548:	d80e      	bhi.n	9568 <ll_addr_get+0x28>
		return NULL;
	}

	if (addr_type) {
    954a:	b133      	cbz	r3, 955a <ll_addr_get+0x1a>
		if (bdaddr) {
    954c:	b119      	cbz	r1, 9556 <ll_addr_get+0x16>
			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
    954e:	4907      	ldr	r1, [pc, #28]	; (956c <ll_addr_get+0x2c>)
    9550:	2206      	movs	r2, #6
    9552:	f00c fd72 	bl	1603a <memcpy>
		}

		return rnd_addr;
    9556:	4805      	ldr	r0, [pc, #20]	; (956c <ll_addr_get+0x2c>)
    9558:	e007      	b.n	956a <ll_addr_get+0x2a>
	}

	if (bdaddr) {
    955a:	b119      	cbz	r1, 9564 <ll_addr_get+0x24>
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
    955c:	4904      	ldr	r1, [pc, #16]	; (9570 <ll_addr_get+0x30>)
    955e:	2206      	movs	r2, #6
    9560:	f00c fd6b 	bl	1603a <memcpy>
	}

	return pub_addr;
    9564:	4802      	ldr	r0, [pc, #8]	; (9570 <ll_addr_get+0x30>)
    9566:	e000      	b.n	956a <ll_addr_get+0x2a>
		return NULL;
    9568:	2000      	movs	r0, #0
}
    956a:	bd08      	pop	{r3, pc}
    956c:	200086fd 	.word	0x200086fd
    9570:	200086f7 	.word	0x200086f7

00009574 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
    9574:	b570      	push	{r4, r5, r6, lr}
    9576:	4606      	mov	r6, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
    9578:	2000      	movs	r0, #0
{
    957a:	460d      	mov	r5, r1
	    ull_adv_is_enabled(0)) {
    957c:	f00d f9ba 	bl	168f4 <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
    9580:	b110      	cbz	r0, 9588 <ll_addr_set+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
    9582:	240c      	movs	r4, #12
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
}
    9584:	4620      	mov	r0, r4
    9586:	bd70      	pop	{r4, r5, r6, pc}
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
    9588:	f00d f9ff 	bl	1698a <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
    958c:	f010 0406 	ands.w	r4, r0, #6
    9590:	d1f7      	bne.n	9582 <ll_addr_set+0xe>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    9592:	2206      	movs	r2, #6
    9594:	4629      	mov	r1, r5
	if (addr_type) {
    9596:	b11e      	cbz	r6, 95a0 <ll_addr_set+0x2c>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    9598:	4802      	ldr	r0, [pc, #8]	; (95a4 <ll_addr_set+0x30>)
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
    959a:	f00c fd4e 	bl	1603a <memcpy>
    959e:	e7f1      	b.n	9584 <ll_addr_set+0x10>
    95a0:	4801      	ldr	r0, [pc, #4]	; (95a8 <ll_addr_set+0x34>)
    95a2:	e7fa      	b.n	959a <ll_addr_set+0x26>
    95a4:	200086fd 	.word	0x200086fd
    95a8:	200086f7 	.word	0x200086f7

000095ac <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
    95ac:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
    95ae:	4802      	ldr	r0, [pc, #8]	; (95b8 <hci_driver_init+0xc>)
    95b0:	f7fe fb9a 	bl	7ce8 <bt_hci_driver_register>

	return 0;
}
    95b4:	2000      	movs	r0, #0
    95b6:	bd08      	pop	{r3, pc}
    95b8:	000198e4 	.word	0x000198e4

000095bc <hci_driver_send>:
	if (!buf->len) {
    95bc:	8983      	ldrh	r3, [r0, #12]
{
    95be:	b537      	push	{r0, r1, r2, r4, r5, lr}
    95c0:	4604      	mov	r4, r0
	if (!buf->len) {
    95c2:	b963      	cbnz	r3, 95de <hci_driver_send+0x22>
    95c4:	4918      	ldr	r1, [pc, #96]	; (9628 <hci_driver_send+0x6c>)
    95c6:	4b19      	ldr	r3, [pc, #100]	; (962c <hci_driver_send+0x70>)
		BT_ERR("Empty HCI packet");
    95c8:	4819      	ldr	r0, [pc, #100]	; (9630 <hci_driver_send+0x74>)
    95ca:	1ac9      	subs	r1, r1, r3
    95cc:	08c9      	lsrs	r1, r1, #3
    95ce:	0189      	lsls	r1, r1, #6
    95d0:	f041 0101 	orr.w	r1, r1, #1
    95d4:	f00b fe39 	bl	1524a <log_0>
		return -EINVAL;
    95d8:	f06f 0015 	mvn.w	r0, #21
    95dc:	e016      	b.n	960c <hci_driver_send+0x50>
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    95de:	7d01      	ldrb	r1, [r0, #20]
	switch (type) {
    95e0:	b9b1      	cbnz	r1, 9610 <hci_driver_send+0x54>
	struct node_rx_pdu *node_rx = NULL;
    95e2:	9101      	str	r1, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    95e4:	a901      	add	r1, sp, #4
    95e6:	f000 f987 	bl	98f8 <hci_cmd_handle>
	if (evt) {
    95ea:	b158      	cbz	r0, 9604 <hci_driver_send+0x48>
		bt_recv_prio(evt);
    95ec:	f7fe fb2c 	bl	7c48 <bt_recv_prio>
		if (node_rx) {
    95f0:	9d01      	ldr	r5, [sp, #4]
    95f2:	b13d      	cbz	r5, 9604 <hci_driver_send+0x48>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    95f4:	4628      	mov	r0, r5
    95f6:	f00d f967 	bl	168c8 <hci_get_class>
			k_fifo_put(&recv_fifo, node_rx);
    95fa:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    95fc:	7168      	strb	r0, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
    95fe:	480d      	ldr	r0, [pc, #52]	; (9634 <hci_driver_send+0x78>)
    9600:	f00f fad1 	bl	18ba6 <k_queue_append>
		net_buf_unref(buf);
    9604:	4620      	mov	r0, r4
    9606:	f004 f983 	bl	d910 <net_buf_unref>
	return err;
    960a:	2000      	movs	r0, #0
}
    960c:	b003      	add	sp, #12
    960e:	bd30      	pop	{r4, r5, pc}
    9610:	4b06      	ldr	r3, [pc, #24]	; (962c <hci_driver_send+0x70>)
    9612:	4a05      	ldr	r2, [pc, #20]	; (9628 <hci_driver_send+0x6c>)
		BT_ERR("Unknown HCI type %u", type);
    9614:	4808      	ldr	r0, [pc, #32]	; (9638 <hci_driver_send+0x7c>)
    9616:	1ad2      	subs	r2, r2, r3
    9618:	08d2      	lsrs	r2, r2, #3
    961a:	0192      	lsls	r2, r2, #6
    961c:	f042 0201 	orr.w	r2, r2, #1
    9620:	f00b fe20 	bl	15264 <log_1>
    9624:	e7d8      	b.n	95d8 <hci_driver_send+0x1c>
    9626:	bf00      	nop
    9628:	0001959c 	.word	0x0001959c
    962c:	0001956c 	.word	0x0001956c
    9630:	0001b262 	.word	0x0001b262
    9634:	2000c3c0 	.word	0x2000c3c0
    9638:	0001b273 	.word	0x0001b273

0000963c <prio_recv_thread>:
{
    963c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return z_impl_k_sem_take(sem, timeout);
    963e:	4d0e      	ldr	r5, [pc, #56]	; (9678 <prio_recv_thread+0x3c>)
				k_fifo_put(&recv_fifo, node_rx);
    9640:	4e0e      	ldr	r6, [pc, #56]	; (967c <prio_recv_thread+0x40>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
    9642:	f10d 0102 	add.w	r1, sp, #2
    9646:	a801      	add	r0, sp, #4
    9648:	f000 fe3e 	bl	a2c8 <ll_rx_get>
    964c:	2800      	cmp	r0, #0
    964e:	d1f8      	bne.n	9642 <prio_recv_thread+0x6>
		if (node_rx) {
    9650:	9b01      	ldr	r3, [sp, #4]
    9652:	b15b      	cbz	r3, 966c <prio_recv_thread+0x30>
			ll_rx_dequeue();
    9654:	f000 fe4a 	bl	a2ec <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    9658:	9c01      	ldr	r4, [sp, #4]
    965a:	4620      	mov	r0, r4
    965c:	f00d f934 	bl	168c8 <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
    9660:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    9662:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
    9664:	4630      	mov	r0, r6
    9666:	f00f fa9e 	bl	18ba6 <k_queue_append>
			continue;
    966a:	e7ea      	b.n	9642 <prio_recv_thread+0x6>
    966c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    9670:	4628      	mov	r0, r5
    9672:	f00a fe61 	bl	14338 <z_impl_k_sem_take>
		BT_DBG("sem taken");
    9676:	e7e4      	b.n	9642 <prio_recv_thread+0x6>
    9678:	2000c35c 	.word	0x2000c35c
    967c:	2000c3c0 	.word	0x2000c3c0

00009680 <recv_thread>:
{
    9680:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
    9682:	4d21      	ldr	r5, [pc, #132]	; (9708 <recv_thread+0x88>)
		LL_ASSERT(0);
    9684:	4e21      	ldr	r6, [pc, #132]	; (970c <recv_thread+0x8c>)
    9686:	4f22      	ldr	r7, [pc, #136]	; (9710 <recv_thread+0x90>)
    9688:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    968c:	4628      	mov	r0, r5
    968e:	f00f fab9 	bl	18c04 <z_impl_k_queue_get>
		if (node_rx && !buf) {
    9692:	b1f0      	cbz	r0, 96d2 <recv_thread+0x52>
	buf = encode_node(node_rx, class);
    9694:	f990 3005 	ldrsb.w	r3, [r0, #5]
    9698:	9001      	str	r0, [sp, #4]
	switch (class) {
    969a:	1e5a      	subs	r2, r3, #1
    969c:	2a03      	cmp	r2, #3
    969e:	d821      	bhi.n	96e4 <recv_thread+0x64>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
    96a0:	2b02      	cmp	r3, #2
    96a2:	d119      	bne.n	96d8 <recv_thread+0x58>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
    96a4:	2200      	movs	r2, #0
    96a6:	2101      	movs	r1, #1
    96a8:	4610      	mov	r0, r2
    96aa:	f7ff f8e3 	bl	8874 <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    96ae:	4604      	mov	r4, r0
		if (buf) {
    96b0:	b118      	cbz	r0, 96ba <recv_thread+0x3a>
			hci_evt_encode(node_rx, buf);
    96b2:	4601      	mov	r1, r0
    96b4:	9801      	ldr	r0, [sp, #4]
    96b6:	f000 fb2d 	bl	9d14 <hci_evt_encode>
	node_rx->hdr.next = NULL;
    96ba:	9b01      	ldr	r3, [sp, #4]
    96bc:	2200      	movs	r2, #0
    96be:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
    96c0:	a801      	add	r0, sp, #4
    96c2:	f000 fe57 	bl	a374 <ll_rx_mem_release>
		if (buf) {
    96c6:	b124      	cbz	r4, 96d2 <recv_thread+0x52>
			if (buf->len) {
    96c8:	89a3      	ldrh	r3, [r4, #12]
				bt_recv(buf);
    96ca:	4620      	mov	r0, r4
			if (buf->len) {
    96cc:	b1c3      	cbz	r3, 9700 <recv_thread+0x80>
				bt_recv(buf);
    96ce:	f7fe fa63 	bl	7b98 <bt_recv>
	z_impl_k_yield();
    96d2:	f00a fd8f 	bl	141f4 <z_impl_k_yield>
}
    96d6:	e7d7      	b.n	9688 <recv_thread+0x8>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    96d8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    96dc:	2001      	movs	r0, #1
    96de:	f7ff f893 	bl	8808 <bt_buf_get_rx>
    96e2:	e7e4      	b.n	96ae <recv_thread+0x2e>
		LL_ASSERT(0);
    96e4:	480b      	ldr	r0, [pc, #44]	; (9714 <recv_thread+0x94>)
    96e6:	23c3      	movs	r3, #195	; 0xc3
    96e8:	4632      	mov	r2, r6
    96ea:	4639      	mov	r1, r7
    96ec:	f00b fa1d 	bl	14b2a <printk>
    96f0:	4040      	eors	r0, r0
    96f2:	f380 8811 	msr	BASEPRI, r0
    96f6:	f04f 0003 	mov.w	r0, #3
    96fa:	df02      	svc	2
	struct net_buf *buf = NULL;
    96fc:	2400      	movs	r4, #0
		break;
    96fe:	e7dc      	b.n	96ba <recv_thread+0x3a>
				net_buf_unref(buf);
    9700:	f004 f906 	bl	d910 <net_buf_unref>
    9704:	e7e5      	b.n	96d2 <recv_thread+0x52>
    9706:	bf00      	nop
    9708:	2000c3c0 	.word	0x2000c3c0
    970c:	0001b287 	.word	0x0001b287
    9710:	0001b96a 	.word	0x0001b96a
    9714:	0001aebe 	.word	0x0001aebe

00009718 <hci_driver_open>:
{
    9718:	b510      	push	{r4, lr}
	err = ll_init(&sem_prio_recv);
    971a:	481e      	ldr	r0, [pc, #120]	; (9794 <hci_driver_open+0x7c>)
{
    971c:	b086      	sub	sp, #24
	err = ll_init(&sem_prio_recv);
    971e:	f000 fcfd 	bl	a11c <ll_init>
	if (err) {
    9722:	4604      	mov	r4, r0
    9724:	b168      	cbz	r0, 9742 <hci_driver_open+0x2a>
    9726:	4a1c      	ldr	r2, [pc, #112]	; (9798 <hci_driver_open+0x80>)
    9728:	4b1c      	ldr	r3, [pc, #112]	; (979c <hci_driver_open+0x84>)
    972a:	1ad2      	subs	r2, r2, r3
    972c:	08d2      	lsrs	r2, r2, #3
		BT_ERR("LL initialization failed: %u", err);
    972e:	0192      	lsls	r2, r2, #6
    9730:	4601      	mov	r1, r0
    9732:	f042 0201 	orr.w	r2, r2, #1
    9736:	481a      	ldr	r0, [pc, #104]	; (97a0 <hci_driver_open+0x88>)
    9738:	f00b fd94 	bl	15264 <log_1>
}
    973c:	4620      	mov	r0, r4
    973e:	b006      	add	sp, #24
    9740:	bd10      	pop	{r4, pc}
	hci_init(NULL);
    9742:	f000 fbc9 	bl	9ed8 <hci_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    9746:	f06f 0309 	mvn.w	r3, #9
    974a:	e9cd 4302 	strd	r4, r3, [sp, #8]
    974e:	e9cd 4404 	strd	r4, r4, [sp, #16]
    9752:	e9cd 4400 	strd	r4, r4, [sp]
    9756:	4b13      	ldr	r3, [pc, #76]	; (97a4 <hci_driver_open+0x8c>)
    9758:	4913      	ldr	r1, [pc, #76]	; (97a8 <hci_driver_open+0x90>)
    975a:	4814      	ldr	r0, [pc, #80]	; (97ac <hci_driver_open+0x94>)
    975c:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
    9760:	f00a fe4a 	bl	143f8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    9764:	4912      	ldr	r1, [pc, #72]	; (97b0 <hci_driver_open+0x98>)
    9766:	4811      	ldr	r0, [pc, #68]	; (97ac <hci_driver_open+0x94>)
    9768:	f00f fbe7 	bl	18f3a <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    976c:	f06f 0307 	mvn.w	r3, #7
    9770:	e9cd 4302 	strd	r4, r3, [sp, #8]
    9774:	e9cd 4404 	strd	r4, r4, [sp, #16]
    9778:	e9cd 4400 	strd	r4, r4, [sp]
    977c:	4b0d      	ldr	r3, [pc, #52]	; (97b4 <hci_driver_open+0x9c>)
    977e:	490e      	ldr	r1, [pc, #56]	; (97b8 <hci_driver_open+0xa0>)
    9780:	480e      	ldr	r0, [pc, #56]	; (97bc <hci_driver_open+0xa4>)
    9782:	f44f 6280 	mov.w	r2, #1024	; 0x400
    9786:	f00a fe37 	bl	143f8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    978a:	490d      	ldr	r1, [pc, #52]	; (97c0 <hci_driver_open+0xa8>)
    978c:	480b      	ldr	r0, [pc, #44]	; (97bc <hci_driver_open+0xa4>)
    978e:	f00f fbd4 	bl	18f3a <z_impl_k_thread_name_set>
	return 0;
    9792:	e7d3      	b.n	973c <hci_driver_open+0x24>
    9794:	2000c35c 	.word	0x2000c35c
    9798:	0001959c 	.word	0x0001959c
    979c:	0001956c 	.word	0x0001956c
    97a0:	0001b2c7 	.word	0x0001b2c7
    97a4:	0000963d 	.word	0x0000963d
    97a8:	20009560 	.word	0x20009560
    97ac:	20002d24 	.word	0x20002d24
    97b0:	0001b2e4 	.word	0x0001b2e4
    97b4:	00009681 	.word	0x00009681
    97b8:	20009720 	.word	0x20009720
    97bc:	20002d98 	.word	0x20002d98
    97c0:	0001b2ee 	.word	0x0001b2ee

000097c4 <hci_cmd_complete>:

	return buf;
}

void *hci_cmd_complete(struct net_buf **buf, u8_t plen)
{
    97c4:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    97c6:	4b06      	ldr	r3, [pc, #24]	; (97e0 <hci_cmd_complete+0x1c>)
{
    97c8:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    97ca:	8818      	ldrh	r0, [r3, #0]
{
    97cc:	460c      	mov	r4, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    97ce:	f00d f857 	bl	16880 <bt_hci_cmd_complete_create>

	return net_buf_add(*buf, plen);
    97d2:	4621      	mov	r1, r4
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    97d4:	6028      	str	r0, [r5, #0]
}
    97d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
    97da:	3008      	adds	r0, #8
    97dc:	f00d bc6a 	b.w	170b4 <net_buf_simple_add>
    97e0:	200041ac 	.word	0x200041ac

000097e4 <hci_vendor_cmd_handle_common>:
}
#endif /* CONFIG_BT_HCI_MESH_EXT */

int hci_vendor_cmd_handle_common(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
    97e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    97e6:	3801      	subs	r0, #1
    97e8:	b087      	sub	sp, #28
    97ea:	4614      	mov	r4, r2
    97ec:	2809      	cmp	r0, #9
    97ee:	d87e      	bhi.n	98ee <hci_vendor_cmd_handle_common+0x10a>
    97f0:	e8df f000 	tbb	[pc, r0]
    97f4:	7d321b05 	.word	0x7d321b05
    97f8:	3e7d597d 	.word	0x3e7d597d
    97fc:	7164      	.short	0x7164
	rp = hci_cmd_complete(evt, sizeof(*rp));
    97fe:	210d      	movs	r1, #13
    9800:	4610      	mov	r0, r2
    9802:	f7ff ffdf 	bl	97c4 <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    9806:	2302      	movs	r3, #2
	rp->status = 0x00;
    9808:	2100      	movs	r1, #0
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    980a:	7043      	strb	r3, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    980c:	70c3      	strb	r3, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
    980e:	7183      	strb	r3, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    9810:	71c3      	strb	r3, [r0, #7]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    9812:	2363      	movs	r3, #99	; 0x63
	rp->status = 0x00;
    9814:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    9816:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    9818:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
    981a:	7141      	strb	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    981c:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    981e:	7243      	strb	r3, [r0, #9]
    9820:	7281      	strb	r1, [r0, #10]
    9822:	72c1      	strb	r1, [r0, #11]
    9824:	7301      	strb	r1, [r0, #12]

	default:
		return -EINVAL;
	}

	return 0;
    9826:	460c      	mov	r4, r1
}
    9828:	e013      	b.n	9852 <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    982a:	2141      	movs	r1, #65	; 0x41
    982c:	4610      	mov	r0, r2
    982e:	f7ff ffc9 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9832:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9834:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    9836:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    9838:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    983c:	4621      	mov	r1, r4
    983e:	f00c fc27 	bl	16090 <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
    9842:	786b      	ldrb	r3, [r5, #1]
    9844:	f063 0358 	orn	r3, r3, #88	; 0x58
    9848:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
    984a:	78ab      	ldrb	r3, [r5, #2]
    984c:	f043 0303 	orr.w	r3, r3, #3
    9850:	70ab      	strb	r3, [r5, #2]
}
    9852:	4620      	mov	r0, r4
    9854:	b007      	add	sp, #28
    9856:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9858:	2109      	movs	r1, #9
    985a:	4610      	mov	r0, r2
    985c:	f7ff ffb2 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9860:	2400      	movs	r4, #0
    9862:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    9866:	2208      	movs	r2, #8
    9868:	4621      	mov	r1, r4
    986a:	f00c fc11 	bl	16090 <memset>
}
    986e:	e7f0      	b.n	9852 <hci_vendor_cmd_handle_common+0x6e>
	const char build_info[] = HCI_VS_BUILD_INFO;
    9870:	4b20      	ldr	r3, [pc, #128]	; (98f4 <hci_vendor_cmd_handle_common+0x110>)
    9872:	aa01      	add	r2, sp, #4
    9874:	f103 0710 	add.w	r7, r3, #16
    9878:	4616      	mov	r6, r2
    987a:	6818      	ldr	r0, [r3, #0]
    987c:	6859      	ldr	r1, [r3, #4]
    987e:	4615      	mov	r5, r2
    9880:	c503      	stmia	r5!, {r0, r1}
    9882:	3308      	adds	r3, #8
    9884:	42bb      	cmp	r3, r7
    9886:	462a      	mov	r2, r5
    9888:	d1f7      	bne.n	987a <hci_vendor_cmd_handle_common+0x96>
    988a:	881b      	ldrh	r3, [r3, #0]
    988c:	802b      	strh	r3, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
    988e:	2113      	movs	r1, #19
    9890:	4620      	mov	r0, r4
    9892:	f7ff ff97 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9896:	2400      	movs	r4, #0
    9898:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
    989c:	2212      	movs	r2, #18
    989e:	4631      	mov	r1, r6
    98a0:	f00c fbcb 	bl	1603a <memcpy>
}
    98a4:	e7d5      	b.n	9852 <hci_vendor_cmd_handle_common+0x6e>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
    98a6:	6889      	ldr	r1, [r1, #8]
    98a8:	2000      	movs	r0, #0
    98aa:	f7ff fe63 	bl	9574 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    98ae:	2101      	movs	r1, #1
    98b0:	4620      	mov	r0, r4
    98b2:	f7ff ff87 	bl	97c4 <hci_cmd_complete>
	ccst->status = 0x00;
    98b6:	2100      	movs	r1, #0
    98b8:	7001      	strb	r1, [r0, #0]
    98ba:	e7b4      	b.n	9826 <hci_vendor_cmd_handle_common+0x42>
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    98bc:	2118      	movs	r1, #24
    98be:	4610      	mov	r0, r2
    98c0:	f7ff ff80 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    98c4:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    98c6:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    98c8:	2101      	movs	r1, #1
	rp->status = 0x00;
    98ca:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    98ce:	f00d f988 	bl	16be2 <hci_vendor_read_static_addr>
    98d2:	7068      	strb	r0, [r5, #1]
}
    98d4:	e7bd      	b.n	9852 <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    98d6:	2121      	movs	r1, #33	; 0x21
    98d8:	4610      	mov	r0, r2
    98da:	f7ff ff73 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    98de:	4601      	mov	r1, r0
    98e0:	2400      	movs	r4, #0
    98e2:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
    98e6:	3001      	adds	r0, #1
    98e8:	f00d f9d1 	bl	16c8e <hci_vendor_read_key_hierarchy_roots>
}
    98ec:	e7b1      	b.n	9852 <hci_vendor_cmd_handle_common+0x6e>
	return 0;
    98ee:	f06f 0415 	mvn.w	r4, #21
    98f2:	e7ae      	b.n	9852 <hci_vendor_cmd_handle_common+0x6e>
    98f4:	0001b312 	.word	0x0001b312

000098f8 <hci_cmd_handle>:
#endif

struct net_buf *hci_cmd_handle(struct net_buf *cmd, void **node_rx)
{
    98f8:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_hci_cmd_hdr *chdr;
	struct net_buf *evt = NULL;
	u16_t ocf;
	int err;

	if (cmd->len < sizeof(*chdr)) {
    98fa:	8983      	ldrh	r3, [r0, #12]
{
    98fc:	b08b      	sub	sp, #44	; 0x2c
	struct net_buf *evt = NULL;
    98fe:	2600      	movs	r6, #0
	if (cmd->len < sizeof(*chdr)) {
    9900:	2b02      	cmp	r3, #2
{
    9902:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
    9904:	9605      	str	r6, [sp, #20]
	if (cmd->len < sizeof(*chdr)) {
    9906:	d80c      	bhi.n	9922 <hci_cmd_handle+0x2a>
    9908:	49ca      	ldr	r1, [pc, #808]	; (9c34 <hci_cmd_handle+0x33c>)
    990a:	4bcb      	ldr	r3, [pc, #812]	; (9c38 <hci_cmd_handle+0x340>)
		BT_ERR("No HCI Command header");
    990c:	48cb      	ldr	r0, [pc, #812]	; (9c3c <hci_cmd_handle+0x344>)
    990e:	1ac9      	subs	r1, r1, r3
    9910:	08c9      	lsrs	r1, r1, #3
    9912:	0189      	lsls	r1, r1, #6
    9914:	f041 0101 	orr.w	r1, r1, #1
		return NULL;
	}

	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
	if (cmd->len < chdr->param_len) {
		BT_ERR("Invalid HCI CMD packet length");
    9918:	f00b fc97 	bl	1524a <log_0>
		return NULL;
    991c:	4630      	mov	r0, r6
	if (err == -EINVAL) {
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
	}

	return evt;
}
    991e:	b00b      	add	sp, #44	; 0x2c
    9920:	bdf0      	pop	{r4, r5, r6, r7, pc}
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
    9922:	2103      	movs	r1, #3
    9924:	3008      	adds	r0, #8
    9926:	f00d fbe4 	bl	170f2 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
    992a:	89a2      	ldrh	r2, [r4, #12]
    992c:	7883      	ldrb	r3, [r0, #2]
    992e:	429a      	cmp	r2, r3
    9930:	d208      	bcs.n	9944 <hci_cmd_handle+0x4c>
    9932:	49c0      	ldr	r1, [pc, #768]	; (9c34 <hci_cmd_handle+0x33c>)
    9934:	4bc0      	ldr	r3, [pc, #768]	; (9c38 <hci_cmd_handle+0x340>)
		BT_ERR("Invalid HCI CMD packet length");
    9936:	48c2      	ldr	r0, [pc, #776]	; (9c40 <hci_cmd_handle+0x348>)
    9938:	1ac9      	subs	r1, r1, r3
    993a:	08c9      	lsrs	r1, r1, #3
    993c:	0189      	lsls	r1, r1, #6
    993e:	f041 0101 	orr.w	r1, r1, #1
    9942:	e7e9      	b.n	9918 <hci_cmd_handle+0x20>
	_opcode = sys_le16_to_cpu(chdr->opcode);
    9944:	8803      	ldrh	r3, [r0, #0]
    9946:	4fbf      	ldr	r7, [pc, #764]	; (9c44 <hci_cmd_handle+0x34c>)
	ocf = BT_OCF(_opcode);
    9948:	f3c3 0509 	ubfx	r5, r3, #0, #10
	_opcode = sys_le16_to_cpu(chdr->opcode);
    994c:	803b      	strh	r3, [r7, #0]
	switch (BT_OGF(_opcode)) {
    994e:	f3c3 2385 	ubfx	r3, r3, #10, #6
    9952:	2b08      	cmp	r3, #8
    9954:	f000 80b8 	beq.w	9ac8 <hci_cmd_handle+0x1d0>
    9958:	d809      	bhi.n	996e <hci_cmd_handle+0x76>
    995a:	2b03      	cmp	r3, #3
    995c:	d011      	beq.n	9982 <hci_cmd_handle+0x8a>
    995e:	2b04      	cmp	r3, #4
    9960:	d035      	beq.n	99ce <hci_cmd_handle+0xd6>
	return bt_hci_cmd_status_create(_opcode, status);
    9962:	8838      	ldrh	r0, [r7, #0]
    9964:	2101      	movs	r1, #1
    9966:	f00c ff9d 	bl	168a4 <bt_hci_cmd_status_create>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
    996a:	9005      	str	r0, [sp, #20]
    996c:	e01a      	b.n	99a4 <hci_cmd_handle+0xac>
	switch (BT_OGF(_opcode)) {
    996e:	2b3f      	cmp	r3, #63	; 0x3f
    9970:	d1f7      	bne.n	9962 <hci_cmd_handle+0x6a>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
    9972:	aa05      	add	r2, sp, #20
    9974:	4621      	mov	r1, r4
    9976:	4628      	mov	r0, r5
    9978:	f7ff ff34 	bl	97e4 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
    997c:	3016      	adds	r0, #22
    997e:	d0f0      	beq.n	9962 <hci_cmd_handle+0x6a>
    9980:	e010      	b.n	99a4 <hci_cmd_handle+0xac>
	switch (ocf) {
    9982:	2d03      	cmp	r5, #3
    9984:	d010      	beq.n	99a8 <hci_cmd_handle+0xb0>
    9986:	2d63      	cmp	r5, #99	; 0x63
    9988:	d007      	beq.n	999a <hci_cmd_handle+0xa2>
    998a:	2d01      	cmp	r5, #1
    998c:	d1e9      	bne.n	9962 <hci_cmd_handle+0x6a>
	event_mask = sys_get_le64(cmd->events);
    998e:	68a0      	ldr	r0, [r4, #8]
    9990:	f00c ff59 	bl	16846 <sys_get_le64>
    9994:	4bac      	ldr	r3, [pc, #688]	; (9c48 <hci_cmd_handle+0x350>)
    9996:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    999a:	2101      	movs	r1, #1
    999c:	a805      	add	r0, sp, #20
    999e:	f7ff ff11 	bl	97c4 <hci_cmd_complete>
	ccst->status = 0x00;
    99a2:	7006      	strb	r6, [r0, #0]
	return evt;
    99a4:	9805      	ldr	r0, [sp, #20]
    99a6:	e7ba      	b.n	991e <hci_cmd_handle+0x26>
	dup_count = -1;
    99a8:	4ba8      	ldr	r3, [pc, #672]	; (9c4c <hci_cmd_handle+0x354>)
    99aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    99ae:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
    99b0:	4ba5      	ldr	r3, [pc, #660]	; (9c48 <hci_cmd_handle+0x350>)
    99b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    99b6:	f641 71ff 	movw	r1, #8191	; 0x1fff
    99ba:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    99be:	4ba4      	ldr	r3, [pc, #656]	; (9c50 <hci_cmd_handle+0x358>)
    99c0:	201f      	movs	r0, #31
    99c2:	2100      	movs	r1, #0
    99c4:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
    99c8:	f000 fc10 	bl	a1ec <ll_reset>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
    99cc:	e7e5      	b.n	999a <hci_cmd_handle+0xa2>
	switch (ocf) {
    99ce:	3d01      	subs	r5, #1
    99d0:	2d08      	cmp	r5, #8
    99d2:	d8c6      	bhi.n	9962 <hci_cmd_handle+0x6a>
    99d4:	a301      	add	r3, pc, #4	; (adr r3, 99dc <hci_cmd_handle+0xe4>)
    99d6:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
    99da:	bf00      	nop
    99dc:	00009a01 	.word	0x00009a01
    99e0:	00009a2b 	.word	0x00009a2b
    99e4:	00009a97 	.word	0x00009a97
    99e8:	00009963 	.word	0x00009963
    99ec:	00009963 	.word	0x00009963
    99f0:	00009963 	.word	0x00009963
    99f4:	00009963 	.word	0x00009963
    99f8:	00009963 	.word	0x00009963
    99fc:	00009ab3 	.word	0x00009ab3
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9a00:	2109      	movs	r1, #9
    9a02:	a805      	add	r0, sp, #20
    9a04:	f7ff fede 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9a08:	2300      	movs	r3, #0
    9a0a:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
    9a0c:	7083      	strb	r3, [r0, #2]
    9a0e:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    9a10:	f06f 030e 	mvn.w	r3, #14
	rp->hci_version = LL_VERSION_NUMBER;
    9a14:	220a      	movs	r2, #10
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    9a16:	7143      	strb	r3, [r0, #5]
    9a18:	2305      	movs	r3, #5
    9a1a:	7183      	strb	r3, [r0, #6]
	rp->hci_version = LL_VERSION_NUMBER;
    9a1c:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
    9a1e:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
    9a20:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	dst[0] = val;
    9a24:	71c3      	strb	r3, [r0, #7]
	dst[1] = val >> 8;
    9a26:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
    9a28:	e7bc      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9a2a:	2141      	movs	r1, #65	; 0x41
    9a2c:	a805      	add	r0, sp, #20
    9a2e:	f7ff fec9 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9a32:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9a34:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    9a36:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    9a38:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    9a3c:	f00c fb28 	bl	16090 <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
    9a40:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[27] |= BIT(6) | BIT(7);
    9a42:	7f21      	ldrb	r1, [r4, #28]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
    9a44:	7ea2      	ldrb	r2, [r4, #26]
	rp->commands[5] |= BIT(6) | BIT(7);
    9a46:	f063 033f 	orn	r3, r3, #63	; 0x3f
    9a4a:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
    9a4c:	7ae3      	ldrb	r3, [r4, #11]
    9a4e:	f043 0304 	orr.w	r3, r3, #4
    9a52:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
    9a54:	7be3      	ldrb	r3, [r4, #15]
    9a56:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    9a5a:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
    9a5c:	7c23      	ldrb	r3, [r4, #16]
    9a5e:	f043 0302 	orr.w	r3, r3, #2
    9a62:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
    9a64:	7de3      	ldrb	r3, [r4, #23]
    9a66:	f043 0304 	orr.w	r3, r3, #4
    9a6a:	75e3      	strb	r3, [r4, #23]
	rp->commands[26] |= BIT(6) | BIT(7);
    9a6c:	7ee3      	ldrb	r3, [r4, #27]
	rp->commands[27] |= BIT(6) | BIT(7);
    9a6e:	f061 013c 	orn	r1, r1, #60	; 0x3c
	rp->commands[26] |= BIT(2) | BIT(3);
    9a72:	f063 0330 	orn	r3, r3, #48	; 0x30
	rp->commands[27] |= BIT(6) | BIT(7);
    9a76:	7721      	strb	r1, [r4, #28]
	rp->commands[26] |= BIT(2) | BIT(3);
    9a78:	76e3      	strb	r3, [r4, #27]
	rp->commands[28] |= BIT(3);
    9a7a:	7f61      	ldrb	r1, [r4, #29]
	rp->commands[38] |= BIT(7);
    9a7c:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[28] |= BIT(3);
    9a80:	f041 0108 	orr.w	r1, r1, #8
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    9a84:	f062 0208 	orn	r2, r2, #8
	rp->commands[38] |= BIT(7);
    9a88:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[28] |= BIT(3);
    9a8c:	7761      	strb	r1, [r4, #29]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    9a8e:	76a2      	strb	r2, [r4, #26]
	rp->commands[38] |= BIT(7);
    9a90:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	if (err == -EINVAL) {
    9a94:	e786      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9a96:	2109      	movs	r1, #9
    9a98:	a805      	add	r0, sp, #20
    9a9a:	f7ff fe93 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9a9e:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9aa0:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    9aa2:	2208      	movs	r2, #8
	rp->status = 0x00;
    9aa4:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    9aa8:	f00c faf2 	bl	16090 <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
    9aac:	2360      	movs	r3, #96	; 0x60
    9aae:	7163      	strb	r3, [r4, #5]
	if (err == -EINVAL) {
    9ab0:	e778      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9ab2:	2107      	movs	r1, #7
    9ab4:	a805      	add	r0, sp, #20
    9ab6:	f7ff fe85 	bl	97c4 <hci_cmd_complete>
    9aba:	4601      	mov	r1, r0
	rp->status = 0x00;
    9abc:	2000      	movs	r0, #0
    9abe:	f801 0b01 	strb.w	r0, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
    9ac2:	f7ff fd3d 	bl	9540 <ll_addr_get>
	if (err == -EINVAL) {
    9ac6:	e76d      	b.n	99a4 <hci_cmd_handle+0xac>
	switch (ocf) {
    9ac8:	2d1c      	cmp	r5, #28
    9aca:	d841      	bhi.n	9b50 <hci_cmd_handle+0x258>
    9acc:	2d00      	cmp	r5, #0
    9ace:	f43f af48 	beq.w	9962 <hci_cmd_handle+0x6a>
    9ad2:	3d01      	subs	r5, #1
    9ad4:	2d1b      	cmp	r5, #27
    9ad6:	f63f af44 	bhi.w	9962 <hci_cmd_handle+0x6a>
    9ada:	a301      	add	r3, pc, #4	; (adr r3, 9ae0 <hci_cmd_handle+0x1e8>)
    9adc:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
    9ae0:	00009b6d 	.word	0x00009b6d
    9ae4:	00009b87 	.word	0x00009b87
    9ae8:	00009b9f 	.word	0x00009b9f
    9aec:	00009963 	.word	0x00009963
    9af0:	00009bbf 	.word	0x00009bbf
    9af4:	00009c87 	.word	0x00009c87
    9af8:	00009ca3 	.word	0x00009ca3
    9afc:	00009cb3 	.word	0x00009cb3
    9b00:	00009cbf 	.word	0x00009cbf
    9b04:	00009ccb 	.word	0x00009ccb
    9b08:	00009cd5 	.word	0x00009cd5
    9b0c:	00009ced 	.word	0x00009ced
    9b10:	00009963 	.word	0x00009963
    9b14:	00009963 	.word	0x00009963
    9b18:	00009bd5 	.word	0x00009bd5
    9b1c:	00009beb 	.word	0x00009beb
    9b20:	00009bfd 	.word	0x00009bfd
    9b24:	00009c05 	.word	0x00009c05
    9b28:	00009963 	.word	0x00009963
    9b2c:	00009963 	.word	0x00009963
    9b30:	00009963 	.word	0x00009963
    9b34:	00009963 	.word	0x00009963
    9b38:	00009c0d 	.word	0x00009c0d
    9b3c:	00009c55 	.word	0x00009c55
    9b40:	00009963 	.word	0x00009963
    9b44:	00009963 	.word	0x00009963
    9b48:	00009963 	.word	0x00009963
    9b4c:	00009c6b 	.word	0x00009c6b
    9b50:	2d4b      	cmp	r5, #75	; 0x4b
    9b52:	f47f af06 	bne.w	9962 <hci_cmd_handle+0x6a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9b56:	2103      	movs	r1, #3
    9b58:	a805      	add	r0, sp, #20
    9b5a:	f7ff fe33 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9b5e:	4601      	mov	r1, r0
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
    9b60:	3001      	adds	r0, #1
	rp->status = 0x00;
    9b62:	f801 6b02 	strb.w	r6, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
    9b66:	f00c fe6a 	bl	1683e <ll_tx_pwr_get>
	if (err == -EINVAL) {
    9b6a:	e71b      	b.n	99a4 <hci_cmd_handle+0xac>
	le_event_mask = sys_get_le64(cmd->events);
    9b6c:	68a0      	ldr	r0, [r4, #8]
    9b6e:	f00c fe6a 	bl	16846 <sys_get_le64>
    9b72:	4b37      	ldr	r3, [pc, #220]	; (9c50 <hci_cmd_handle+0x358>)
    9b74:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    9b78:	2101      	movs	r1, #1
    9b7a:	a805      	add	r0, sp, #20
    9b7c:	f7ff fe22 	bl	97c4 <hci_cmd_complete>
	ccst->status = 0x00;
    9b80:	2300      	movs	r3, #0
    9b82:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
    9b84:	e70e      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9b86:	2104      	movs	r1, #4
    9b88:	a805      	add	r0, sp, #20
    9b8a:	f7ff fe1b 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9b8e:	2300      	movs	r3, #0
    9b90:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
    9b92:	221b      	movs	r2, #27
    9b94:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
    9b96:	2303      	movs	r3, #3
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
    9b98:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
    9b9a:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
    9b9c:	e702      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9b9e:	2109      	movs	r1, #9
    9ba0:	a805      	add	r0, sp, #20
    9ba2:	f7ff fe0f 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9ba6:	2500      	movs	r5, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9ba8:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    9baa:	2208      	movs	r2, #8
	rp->status = 0x00;
    9bac:	f800 5b01 	strb.w	r5, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    9bb0:	4629      	mov	r1, r5
    9bb2:	f00c fa6d 	bl	16090 <memset>
	dst[0] = val;
    9bb6:	7065      	strb	r5, [r4, #1]
	dst[1] = val >> 8;
    9bb8:	70a5      	strb	r5, [r4, #2]
	dst[2] = val >> 16;
    9bba:	70e5      	strb	r5, [r4, #3]
	if (err == -EINVAL) {
    9bbc:	e6f2      	b.n	99a4 <hci_cmd_handle+0xac>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
    9bbe:	68a1      	ldr	r1, [r4, #8]
    9bc0:	2001      	movs	r0, #1
    9bc2:	f7ff fcd7 	bl	9574 <ll_addr_set>
	status = ll_scan_enable(cmd->enable);
    9bc6:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    9bc8:	2101      	movs	r1, #1
    9bca:	a805      	add	r0, sp, #20
    9bcc:	f7ff fdfa 	bl	97c4 <hci_cmd_complete>
	ccst->status = status;
    9bd0:	7004      	strb	r4, [r0, #0]
	if (err == -EINVAL) {
    9bd2:	e6e7      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9bd4:	2102      	movs	r1, #2
    9bd6:	a805      	add	r0, sp, #20
    9bd8:	f7ff fdf4 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9bdc:	2300      	movs	r3, #0
    9bde:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9be0:	4604      	mov	r4, r0
	rp->wl_size = ll_wl_size_get();
    9be2:	f00c fee9 	bl	169b8 <ll_wl_size_get>
    9be6:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
    9be8:	e6dc      	b.n	99a4 <hci_cmd_handle+0xac>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    9bea:	2101      	movs	r1, #1
    9bec:	a805      	add	r0, sp, #20
    9bee:	f7ff fde9 	bl	97c4 <hci_cmd_complete>
    9bf2:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
    9bf4:	f001 f924 	bl	ae40 <ll_wl_clear>
    9bf8:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
    9bfa:	e6d3      	b.n	99a4 <hci_cmd_handle+0xac>
	status = ll_wl_add(&cmd->addr);
    9bfc:	68a0      	ldr	r0, [r4, #8]
    9bfe:	f001 f935 	bl	ae6c <ll_wl_add>
    9c02:	e7e0      	b.n	9bc6 <hci_cmd_handle+0x2ce>
	status = ll_wl_remove(&cmd->addr);
    9c04:	68a0      	ldr	r0, [r4, #8]
    9c06:	f001 f96b 	bl	aee0 <ll_wl_remove>
    9c0a:	e7dc      	b.n	9bc6 <hci_cmd_handle+0x2ce>
		le_encrypt(cmd, evt);
    9c0c:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
    9c0e:	aa06      	add	r2, sp, #24
    9c10:	2300      	movs	r3, #0
    9c12:	f100 0110 	add.w	r1, r0, #16
    9c16:	f00c ff96 	bl	16b46 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9c1a:	2111      	movs	r1, #17
    9c1c:	a805      	add	r0, sp, #20
    9c1e:	f7ff fdd1 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9c22:	2300      	movs	r3, #0
    9c24:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
    9c28:	2210      	movs	r2, #16
    9c2a:	a906      	add	r1, sp, #24
    9c2c:	f00c fa05 	bl	1603a <memcpy>
	if (err == -EINVAL) {
    9c30:	e6b8      	b.n	99a4 <hci_cmd_handle+0xac>
    9c32:	bf00      	nop
    9c34:	00019594 	.word	0x00019594
    9c38:	0001956c 	.word	0x0001956c
    9c3c:	0001b324 	.word	0x0001b324
    9c40:	0001b33a 	.word	0x0001b33a
    9c44:	200041ac 	.word	0x200041ac
    9c48:	2000bb18 	.word	0x2000bb18
    9c4c:	20002e0c 	.word	0x20002e0c
    9c50:	2000bb20 	.word	0x2000bb20
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9c54:	2109      	movs	r1, #9
    9c56:	a805      	add	r0, sp, #20
    9c58:	f7ff fdb4 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9c5c:	2300      	movs	r3, #0
    9c5e:	f800 3b01 	strb.w	r3, [r0], #1
	util_rand(rp->rand, count);
    9c62:	2108      	movs	r1, #8
    9c64:	f7fe ff5e 	bl	8b24 <util_rand>
	if (err == -EINVAL) {
    9c68:	e69c      	b.n	99a4 <hci_cmd_handle+0xac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9c6a:	2109      	movs	r1, #9
    9c6c:	a805      	add	r0, sp, #20
    9c6e:	f7ff fda9 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9c72:	2300      	movs	r3, #0
	dst[0] = val;
    9c74:	2233      	movs	r2, #51	; 0x33
    9c76:	7003      	strb	r3, [r0, #0]
    9c78:	7042      	strb	r2, [r0, #1]
	dst[1] = val >> 8;
    9c7a:	7082      	strb	r2, [r0, #2]
	dst[0] = val;
    9c7c:	70c3      	strb	r3, [r0, #3]
	dst[1] = val >> 8;
    9c7e:	7103      	strb	r3, [r0, #4]
	dst[0] = val;
    9c80:	7143      	strb	r3, [r0, #5]
	dst[1] = val >> 8;
    9c82:	7183      	strb	r3, [r0, #6]
    9c84:	e6ce      	b.n	9a24 <hci_cmd_handle+0x12c>
		le_set_adv_param(cmd, evt);
    9c86:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
    9c88:	7ba5      	ldrb	r5, [r4, #14]
    9c8a:	79a3      	ldrb	r3, [r4, #6]
    9c8c:	7962      	ldrb	r2, [r4, #5]
    9c8e:	7921      	ldrb	r1, [r4, #4]
    9c90:	8820      	ldrh	r0, [r4, #0]
    9c92:	9502      	str	r5, [sp, #8]
    9c94:	7b65      	ldrb	r5, [r4, #13]
    9c96:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
    9c98:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
    9c9a:	9400      	str	r4, [sp, #0]
    9c9c:	f000 fe96 	bl	a9cc <ll_adv_params_set>
    9ca0:	e791      	b.n	9bc6 <hci_cmd_handle+0x2ce>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    9ca2:	2102      	movs	r1, #2
    9ca4:	a805      	add	r0, sp, #20
    9ca6:	f7ff fd8d 	bl	97c4 <hci_cmd_complete>
	rp->status = 0x00;
    9caa:	2300      	movs	r3, #0
    9cac:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
    9cae:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
    9cb0:	e678      	b.n	99a4 <hci_cmd_handle+0xac>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
    9cb2:	68a1      	ldr	r1, [r4, #8]
    9cb4:	f811 0b01 	ldrb.w	r0, [r1], #1
    9cb8:	f000 fef0 	bl	aa9c <ll_adv_data_set>
    9cbc:	e783      	b.n	9bc6 <hci_cmd_handle+0x2ce>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
    9cbe:	68a1      	ldr	r1, [r4, #8]
    9cc0:	f811 0b01 	ldrb.w	r0, [r1], #1
    9cc4:	f000 ff2a 	bl	ab1c <ll_adv_scan_rsp_set>
    9cc8:	e77d      	b.n	9bc6 <hci_cmd_handle+0x2ce>
	status = ll_adv_enable(cmd->enable);
    9cca:	68a3      	ldr	r3, [r4, #8]
    9ccc:	7818      	ldrb	r0, [r3, #0]
    9cce:	f7f6 ffa7 	bl	c20 <ll_adv_enable>
    9cd2:	e778      	b.n	9bc6 <hci_cmd_handle+0x2ce>
		le_set_scan_param(cmd, evt);
    9cd4:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
    9cd6:	7963      	ldrb	r3, [r4, #5]
    9cd8:	f8b4 2003 	ldrh.w	r2, [r4, #3]
    9cdc:	f8b4 1001 	ldrh.w	r1, [r4, #1]
    9ce0:	7820      	ldrb	r0, [r4, #0]
    9ce2:	79a4      	ldrb	r4, [r4, #6]
    9ce4:	9400      	str	r4, [sp, #0]
    9ce6:	f7f7 f8fb 	bl	ee0 <ll_scan_params_set>
    9cea:	e76c      	b.n	9bc6 <hci_cmd_handle+0x2ce>
		le_set_scan_enable(cmd, evt);
    9cec:	68a2      	ldr	r2, [r4, #8]
	if (cmd->enable && cmd->filter_dup) {
    9cee:	4b07      	ldr	r3, [pc, #28]	; (9d0c <hci_cmd_handle+0x414>)
    9cf0:	7810      	ldrb	r0, [r2, #0]
    9cf2:	b140      	cbz	r0, 9d06 <hci_cmd_handle+0x40e>
    9cf4:	7852      	ldrb	r2, [r2, #1]
    9cf6:	b132      	cbz	r2, 9d06 <hci_cmd_handle+0x40e>
		dup_count = 0;
    9cf8:	2200      	movs	r2, #0
    9cfa:	601a      	str	r2, [r3, #0]
		dup_curr = 0U;
    9cfc:	4b04      	ldr	r3, [pc, #16]	; (9d10 <hci_cmd_handle+0x418>)
		dup_count = -1;
    9cfe:	601a      	str	r2, [r3, #0]
	status = ll_scan_enable(cmd->enable);
    9d00:	f00c fe22 	bl	16948 <ll_scan_enable>
    9d04:	e75f      	b.n	9bc6 <hci_cmd_handle+0x2ce>
		dup_count = -1;
    9d06:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9d0a:	e7f8      	b.n	9cfe <hci_cmd_handle+0x406>
    9d0c:	20002e0c 	.word	0x20002e0c
    9d10:	20002e10 	.word	0x20002e10

00009d14 <hci_evt_encode>:
	}
}
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
    9d14:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    9d18:	7903      	ldrb	r3, [r0, #4]
    9d1a:	2b02      	cmp	r3, #2
{
    9d1c:	4604      	mov	r4, r0
    9d1e:	4688      	mov	r8, r1
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    9d20:	f000 80b2 	beq.w	9e88 <hci_evt_encode+0x174>
	switch (node_rx->hdr.type) {
    9d24:	2b04      	cmp	r3, #4
    9d26:	f040 80b6 	bne.w	9e96 <hci_evt_encode+0x182>
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    9d2a:	4b62      	ldr	r3, [pc, #392]	; (9eb4 <hci_evt_encode+0x1a0>)
		le_advertising_report(pdu_data, node_rx, buf);
    9d2c:	7f07      	ldrb	r7, [r0, #28]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    9d2e:	889a      	ldrh	r2, [r3, #4]
    9d30:	6818      	ldr	r0, [r3, #0]
    9d32:	799b      	ldrb	r3, [r3, #6]
    9d34:	f88d 3006 	strb.w	r3, [sp, #6]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    9d38:	4b5f      	ldr	r3, [pc, #380]	; (9eb8 <hci_evt_encode+0x1a4>)
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    9d3a:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    9d3e:	6859      	ldr	r1, [r3, #4]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    9d40:	9000      	str	r0, [sp, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    9d42:	2500      	movs	r5, #0
    9d44:	462a      	mov	r2, r5
    9d46:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
    9d4a:	4313      	orrs	r3, r2
    9d4c:	f000 809c 	beq.w	9e88 <hci_evt_encode+0x174>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
    9d50:	4b5a      	ldr	r3, [pc, #360]	; (9ebc <hci_evt_encode+0x1a8>)
    9d52:	6819      	ldr	r1, [r3, #0]
    9d54:	462b      	mov	r3, r5
    9d56:	f001 0202 	and.w	r2, r1, #2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    9d5a:	4313      	orrs	r3, r2
    9d5c:	f000 8094 	beq.w	9e88 <hci_evt_encode+0x174>
	if (dup_count >= 0) {
    9d60:	4e57      	ldr	r6, [pc, #348]	; (9ec0 <hci_evt_encode+0x1ac>)
    9d62:	6833      	ldr	r3, [r6, #0]
    9d64:	42ab      	cmp	r3, r5
    9d66:	f104 0922 	add.w	r9, r4, #34	; 0x22
    9d6a:	db4c      	blt.n	9e06 <hci_evt_encode+0xf2>
    9d6c:	f8df b164 	ldr.w	fp, [pc, #356]	; 9ed4 <hci_evt_encode+0x1c0>
    9d70:	46da      	mov	sl, fp
		for (i = 0; i < dup_count; i++) {
    9d72:	6833      	ldr	r3, [r6, #0]
    9d74:	429d      	cmp	r5, r3
    9d76:	db27      	blt.n	9dc8 <hci_evt_encode+0xb4>
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
    9d78:	4d52      	ldr	r5, [pc, #328]	; (9ec4 <hci_evt_encode+0x1b0>)
    9d7a:	6828      	ldr	r0, [r5, #0]
    9d7c:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    9d80:	2206      	movs	r2, #6
    9d82:	4649      	mov	r1, r9
    9d84:	3002      	adds	r0, #2
    9d86:	f00c f958 	bl	1603a <memcpy>
		dup_filter[dup_curr].addr.type = adv->tx_addr;
    9d8a:	682a      	ldr	r2, [r5, #0]
    9d8c:	f894 3020 	ldrb.w	r3, [r4, #32]
    9d90:	eb0a 01c2 	add.w	r1, sl, r2, lsl #3
    9d94:	f3c3 1380 	ubfx	r3, r3, #6, #1
    9d98:	704b      	strb	r3, [r1, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
    9d9a:	f894 3020 	ldrb.w	r3, [r4, #32]
    9d9e:	f003 010f 	and.w	r1, r3, #15
    9da2:	2301      	movs	r3, #1
    9da4:	408b      	lsls	r3, r1
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    9da6:	6831      	ldr	r1, [r6, #0]
		dup_filter[dup_curr].mask = BIT(adv->type);
    9da8:	f80a 3032 	strb.w	r3, [sl, r2, lsl #3]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    9dac:	290f      	cmp	r1, #15
			dup_count++;
    9dae:	bfd5      	itete	le
    9db0:	3101      	addle	r1, #1
			dup_curr++;
    9db2:	3201      	addgt	r2, #1
			dup_curr = dup_count;
    9db4:	6029      	strle	r1, [r5, #0]
			dup_curr++;
    9db6:	602a      	strgt	r2, [r5, #0]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    9db8:	682a      	ldr	r2, [r5, #0]
			dup_count++;
    9dba:	bfd8      	it	le
    9dbc:	6031      	strle	r1, [r6, #0]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    9dbe:	2a10      	cmp	r2, #16
			dup_curr = 0U;
    9dc0:	bf04      	itt	eq
    9dc2:	2200      	moveq	r2, #0
    9dc4:	602a      	streq	r2, [r5, #0]
    9dc6:	e01e      	b.n	9e06 <hci_evt_encode+0xf2>
			if (!memcmp(&adv->adv_ind.addr[0],
    9dc8:	2206      	movs	r2, #6
    9dca:	f10b 0102 	add.w	r1, fp, #2
    9dce:	4648      	mov	r0, r9
    9dd0:	f00c f923 	bl	1601a <memcmp>
    9dd4:	2800      	cmp	r0, #0
    9dd6:	d15a      	bne.n	9e8e <hci_evt_encode+0x17a>
			    adv->tx_addr == dup_filter[i].addr.type) {
    9dd8:	f894 3020 	ldrb.w	r3, [r4, #32]
    9ddc:	f89b 1001 	ldrb.w	r1, [fp, #1]
    9de0:	461a      	mov	r2, r3
    9de2:	f3c3 1380 	ubfx	r3, r3, #6, #1
				    sizeof(bt_addr_t)) &&
    9de6:	428b      	cmp	r3, r1
    9de8:	d151      	bne.n	9e8e <hci_evt_encode+0x17a>
				if (dup_filter[i].mask & BIT(adv->type)) {
    9dea:	f81a 3035 	ldrb.w	r3, [sl, r5, lsl #3]
    9dee:	f002 020f 	and.w	r2, r2, #15
    9df2:	fa23 f102 	lsr.w	r1, r3, r2
    9df6:	07c9      	lsls	r1, r1, #31
    9df8:	d446      	bmi.n	9e88 <hci_evt_encode+0x174>
				dup_filter[i].mask |= BIT(adv->type);
    9dfa:	2101      	movs	r1, #1
    9dfc:	fa01 f202 	lsl.w	r2, r1, r2
    9e00:	4313      	orrs	r3, r2
    9e02:	f80a 3035 	strb.w	r3, [sl, r5, lsl #3]
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
    9e06:	f894 3020 	ldrb.w	r3, [r4, #32]
    9e0a:	f003 030f 	and.w	r3, r3, #15
    9e0e:	2b01      	cmp	r3, #1
		data_len = (adv->len - BDADDR_SIZE);
    9e10:	bf1d      	ittte	ne
    9e12:	f894 6021 	ldrbne.w	r6, [r4, #33]	; 0x21
    9e16:	3e06      	subne	r6, #6
    9e18:	b2f6      	uxtbne	r6, r6
		data_len = 0U;
    9e1a:	2600      	moveq	r6, #0
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
    9e1c:	f106 020c 	add.w	r2, r6, #12
    9e20:	b2d2      	uxtb	r2, r2
    9e22:	4640      	mov	r0, r8
    9e24:	213e      	movs	r1, #62	; 0x3e
	me = net_buf_add(buf, sizeof(*me));
    9e26:	f108 0808 	add.w	r8, r8, #8
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
    9e2a:	f00c fd10 	bl	1684e <hci_evt_create>
	me = net_buf_add(buf, sizeof(*me));
    9e2e:	2101      	movs	r1, #1
    9e30:	4640      	mov	r0, r8
    9e32:	f00d f93f 	bl	170b4 <net_buf_simple_add>
	me->subevent = subevt;
    9e36:	2302      	movs	r3, #2
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
    9e38:	f106 010b 	add.w	r1, r6, #11
	me->subevent = subevt;
    9e3c:	7003      	strb	r3, [r0, #0]
	return net_buf_add(buf, melen);
    9e3e:	b2c9      	uxtb	r1, r1
    9e40:	4640      	mov	r0, r8
    9e42:	f00d f937 	bl	170b4 <net_buf_simple_add>
	sep->num_reports = 1U;
    9e46:	2301      	movs	r3, #1
    9e48:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
    9e4a:	f894 3020 	ldrb.w	r3, [r4, #32]
    9e4e:	aa02      	add	r2, sp, #8
    9e50:	f003 030f 	and.w	r3, r3, #15
    9e54:	4413      	add	r3, r2
	return net_buf_add(buf, melen);
    9e56:	4605      	mov	r5, r0
	adv_info->evt_type = c_adv_type[adv->type];
    9e58:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    9e5c:	7043      	strb	r3, [r0, #1]
		adv_info->addr.type = adv->tx_addr;
    9e5e:	f894 3020 	ldrb.w	r3, [r4, #32]
    9e62:	f3c3 1380 	ubfx	r3, r3, #6, #1
    9e66:	7083      	strb	r3, [r0, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
    9e68:	2206      	movs	r2, #6
    9e6a:	4649      	mov	r1, r9
    9e6c:	3003      	adds	r0, #3
    9e6e:	f00c f8e4 	bl	1603a <memcpy>
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    9e72:	350a      	adds	r5, #10
	adv_info->length = data_len;
    9e74:	f805 6c01 	strb.w	r6, [r5, #-1]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    9e78:	4632      	mov	r2, r6
    9e7a:	f104 0128 	add.w	r1, r4, #40	; 0x28
    9e7e:	4628      	mov	r0, r5
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    9e80:	427f      	negs	r7, r7
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    9e82:	f00c f8da 	bl	1603a <memcpy>
	*prssi = rssi;
    9e86:	55af      	strb	r7, [r5, r6]
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
    9e88:	b003      	add	sp, #12
    9e8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < dup_count; i++) {
    9e8e:	3501      	adds	r5, #1
    9e90:	f10b 0b08 	add.w	fp, fp, #8
    9e94:	e76d      	b.n	9d72 <hci_evt_encode+0x5e>
		LL_ASSERT(0);
    9e96:	4a0c      	ldr	r2, [pc, #48]	; (9ec8 <hci_evt_encode+0x1b4>)
    9e98:	490c      	ldr	r1, [pc, #48]	; (9ecc <hci_evt_encode+0x1b8>)
    9e9a:	480d      	ldr	r0, [pc, #52]	; (9ed0 <hci_evt_encode+0x1bc>)
    9e9c:	f640 4372 	movw	r3, #3186	; 0xc72
    9ea0:	f00a fe43 	bl	14b2a <printk>
    9ea4:	4040      	eors	r0, r0
    9ea6:	f380 8811 	msr	BASEPRI, r0
    9eaa:	f04f 0003 	mov.w	r0, #3
    9eae:	df02      	svc	2
}
    9eb0:	e7ea      	b.n	9e88 <hci_evt_encode+0x174>
    9eb2:	bf00      	nop
    9eb4:	00019707 	.word	0x00019707
    9eb8:	2000bb18 	.word	0x2000bb18
    9ebc:	2000bb20 	.word	0x2000bb20
    9ec0:	20002e0c 	.word	0x20002e0c
    9ec4:	20002e10 	.word	0x20002e10
    9ec8:	0001b358 	.word	0x0001b358
    9ecc:	0001b96a 	.word	0x0001b96a
    9ed0:	0001aebe 	.word	0x0001aebe
    9ed4:	20008703 	.word	0x20008703

00009ed8 <hci_init>:
	dup_count = -1;
    9ed8:	4b08      	ldr	r3, [pc, #32]	; (9efc <hci_init+0x24>)
    9eda:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9ede:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
    9ee0:	4b07      	ldr	r3, [pc, #28]	; (9f00 <hci_init+0x28>)
    9ee2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9ee6:	f641 71ff 	movw	r1, #8191	; 0x1fff
    9eea:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    9eee:	4b05      	ldr	r3, [pc, #20]	; (9f04 <hci_init+0x2c>)
    9ef0:	201f      	movs	r0, #31
    9ef2:	2100      	movs	r1, #0
    9ef4:	e9c3 0100 	strd	r0, r1, [r3]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
    9ef8:	4770      	bx	lr
    9efa:	bf00      	nop
    9efc:	20002e0c 	.word	0x20002e0c
    9f00:	2000bb18 	.word	0x2000bb18
    9f04:	2000bb20 	.word	0x2000bb20

00009f08 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
    9f08:	b510      	push	{r4, lr}
    9f0a:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
    9f0c:	f00c fd68 	bl	169e0 <lll_reset>
	LL_ASSERT(!err);
    9f10:	b160      	cbz	r0, 9f2c <perform_lll_reset+0x24>
    9f12:	4a19      	ldr	r2, [pc, #100]	; (9f78 <perform_lll_reset+0x70>)
    9f14:	4919      	ldr	r1, [pc, #100]	; (9f7c <perform_lll_reset+0x74>)
    9f16:	481a      	ldr	r0, [pc, #104]	; (9f80 <perform_lll_reset+0x78>)
    9f18:	f44f 6399 	mov.w	r3, #1224	; 0x4c8
    9f1c:	f00a fe05 	bl	14b2a <printk>
    9f20:	4040      	eors	r0, r0
    9f22:	f380 8811 	msr	BASEPRI, r0
    9f26:	f04f 0003 	mov.w	r0, #3
    9f2a:	df02      	svc	2

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
    9f2c:	f00c fdbe 	bl	16aac <lll_adv_reset>
	LL_ASSERT(!err);
    9f30:	b160      	cbz	r0, 9f4c <perform_lll_reset+0x44>
    9f32:	4a11      	ldr	r2, [pc, #68]	; (9f78 <perform_lll_reset+0x70>)
    9f34:	4911      	ldr	r1, [pc, #68]	; (9f7c <perform_lll_reset+0x74>)
    9f36:	4812      	ldr	r0, [pc, #72]	; (9f80 <perform_lll_reset+0x78>)
    9f38:	f240 43cd 	movw	r3, #1229	; 0x4cd
    9f3c:	f00a fdf5 	bl	14b2a <printk>
    9f40:	4040      	eors	r0, r0
    9f42:	f380 8811 	msr	BASEPRI, r0
    9f46:	f04f 0003 	mov.w	r0, #3
    9f4a:	df02      	svc	2
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	/* Reset scan state */
	err = lll_scan_reset();
    9f4c:	f00c fdf9 	bl	16b42 <lll_scan_reset>
	LL_ASSERT(!err);
    9f50:	b160      	cbz	r0, 9f6c <perform_lll_reset+0x64>
    9f52:	4a09      	ldr	r2, [pc, #36]	; (9f78 <perform_lll_reset+0x70>)
    9f54:	4909      	ldr	r1, [pc, #36]	; (9f7c <perform_lll_reset+0x74>)
    9f56:	480a      	ldr	r0, [pc, #40]	; (9f80 <perform_lll_reset+0x78>)
    9f58:	f240 43d3 	movw	r3, #1235	; 0x4d3
    9f5c:	f00a fde5 	bl	14b2a <printk>
    9f60:	4040      	eors	r0, r0
    9f62:	f380 8811 	msr	BASEPRI, r0
    9f66:	f04f 0003 	mov.w	r0, #3
    9f6a:	df02      	svc	2
	z_impl_k_sem_give(sem);
    9f6c:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CONN */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
    9f6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9f72:	f00a b9bb 	b.w	142ec <z_impl_k_sem_give>
    9f76:	bf00      	nop
    9f78:	0001b3ac 	.word	0x0001b3ac
    9f7c:	0001b3e7 	.word	0x0001b3e7
    9f80:	0001aebe 	.word	0x0001aebe

00009f84 <rx_alloc.constprop.0>:
	MFIFO_BY_IDX_ENQUEUE(done, idx, done);

	return done;
}

static inline void rx_alloc(u8_t max)
    9f84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */

	if (max > mem_link_rx.quota_pdu) {
    9f88:	4b1a      	ldr	r3, [pc, #104]	; (9ff4 <rx_alloc.constprop.0+0x70>)
		max = mem_link_rx.quota_pdu;
	}

	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    9f8a:	4f1b      	ldr	r7, [pc, #108]	; (9ff8 <rx_alloc.constprop.0+0x74>)
	if (max > mem_link_rx.quota_pdu) {
    9f8c:	f893 9000 	ldrb.w	r9, [r3]
    9f90:	4698      	mov	r8, r3
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
    9f92:	1d1e      	adds	r6, r3, #4
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    9f94:	f1b9 0f00 	cmp.w	r9, #0
    9f98:	d00e      	beq.n	9fb8 <rx_alloc.constprop.0+0x34>
 */
static inline bool mfifo_enqueue_idx_get(u8_t count, u8_t first, u8_t last,
					 u8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
    9f9a:	78fc      	ldrb	r4, [r7, #3]
	if (last == count) {
    9f9c:	787a      	ldrb	r2, [r7, #1]
    9f9e:	78bb      	ldrb	r3, [r7, #2]
	last = last + 1;
    9fa0:	3401      	adds	r4, #1
    9fa2:	b2e4      	uxtb	r4, r4
		last = 0U;
    9fa4:	42a2      	cmp	r2, r4
    9fa6:	bf08      	it	eq
    9fa8:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
    9faa:	429c      	cmp	r4, r3
    9fac:	d004      	beq.n	9fb8 <rx_alloc.constprop.0+0x34>
		link = mem_acquire(&mem_link_rx.free);
    9fae:	4630      	mov	r0, r6
    9fb0:	f00c f9b1 	bl	16316 <mem_acquire>
		if (!link) {
    9fb4:	4605      	mov	r5, r0
    9fb6:	b908      	cbnz	r0, 9fbc <rx_alloc.constprop.0+0x38>

		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
}
    9fb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		rx = mem_acquire(&mem_pdu_rx.free);
    9fbc:	480f      	ldr	r0, [pc, #60]	; (9ffc <rx_alloc.constprop.0+0x78>)
    9fbe:	f00c f9aa 	bl	16316 <mem_acquire>
		if (!rx) {
    9fc2:	b928      	cbnz	r0, 9fd0 <rx_alloc.constprop.0+0x4c>
			mem_release(link, &mem_link_rx.free);
    9fc4:	4628      	mov	r0, r5
    9fc6:	490e      	ldr	r1, [pc, #56]	; (a000 <rx_alloc.constprop.0+0x7c>)
}
    9fc8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
    9fcc:	f00c b9bc 	b.w	16348 <mem_release>
		rx->link = link;
    9fd0:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(u8_t *fifo, u8_t size, u8_t idx,
					void *mem, u8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    9fd2:	78fa      	ldrb	r2, [r7, #3]
    9fd4:	783b      	ldrb	r3, [r7, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    9fd6:	fb02 7303 	mla	r3, r2, r3, r7
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    9fda:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    9fde:	6058      	str	r0, [r3, #4]
	mem_link_rx.quota_pdu += delta;
    9fe0:	f898 3000 	ldrb.w	r3, [r8]

	*last = idx; /* Commit: Update write index */
    9fe4:	70fc      	strb	r4, [r7, #3]
    9fe6:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    9fe8:	fa5f f989 	uxtb.w	r9, r9
	mem_link_rx.quota_pdu += delta;
    9fec:	f888 3000 	strb.w	r3, [r8]
}
    9ff0:	e7d0      	b.n	9f94 <rx_alloc.constprop.0+0x10>
    9ff2:	bf00      	nop
    9ff4:	20002f08 	.word	0x20002f08
    9ff8:	2000bdc4 	.word	0x2000bdc4
    9ffc:	20002f50 	.word	0x20002f50
    a000:	20002f0c 	.word	0x20002f0c

0000a004 <init_reset>:
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
    a004:	4b3a      	ldr	r3, [pc, #232]	; (a0f0 <init_reset+0xec>)
{
    a006:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
    a00a:	1d18      	adds	r0, r3, #4
    a00c:	2203      	movs	r2, #3
    a00e:	2138      	movs	r1, #56	; 0x38
    a010:	f00c f95d 	bl	162ce <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
    a014:	4b37      	ldr	r3, [pc, #220]	; (a0f4 <init_reset+0xf0>)
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    a016:	4f38      	ldr	r7, [pc, #224]	; (a0f8 <init_reset+0xf4>)
		link = mem_acquire(&mem_link_done.free);
    a018:	4e36      	ldr	r6, [pc, #216]	; (a0f4 <init_reset+0xf0>)
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
    a01a:	2203      	movs	r2, #3
    a01c:	2108      	movs	r1, #8
    a01e:	1d18      	adds	r0, r3, #4
    a020:	f00c f955 	bl	162ce <mem_init>
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    a024:	46b8      	mov	r8, r7
	last = last + 1;
    a026:	78fc      	ldrb	r4, [r7, #3]
	if (last == count) {
    a028:	787a      	ldrb	r2, [r7, #1]
    a02a:	78bb      	ldrb	r3, [r7, #2]
	last = last + 1;
    a02c:	3401      	adds	r4, #1
    a02e:	b2e4      	uxtb	r4, r4
		last = 0U;
    a030:	42a2      	cmp	r2, r4
    a032:	bf08      	it	eq
    a034:	2400      	moveq	r4, #0
	if (last == first) {
    a036:	429c      	cmp	r4, r3
    a038:	d00d      	beq.n	a056 <init_reset+0x52>
		link = mem_acquire(&mem_link_done.free);
    a03a:	4630      	mov	r0, r6
    a03c:	f00c f96b 	bl	16316 <mem_acquire>
		if (!link) {
    a040:	4605      	mov	r5, r0
    a042:	b140      	cbz	r0, a056 <init_reset+0x52>
		rx = mem_acquire(&mem_done.free);
    a044:	482a      	ldr	r0, [pc, #168]	; (a0f0 <init_reset+0xec>)
    a046:	f00c f966 	bl	16316 <mem_acquire>
		if (!rx) {
    a04a:	2800      	cmp	r0, #0
    a04c:	d145      	bne.n	a0da <init_reset+0xd6>
			mem_release(link, &mem_link_done.free);
    a04e:	4929      	ldr	r1, [pc, #164]	; (a0f4 <init_reset+0xf0>)
    a050:	4628      	mov	r0, r5
    a052:	f00c f979 	bl	16348 <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
    a056:	4b29      	ldr	r3, [pc, #164]	; (a0fc <init_reset+0xf8>)
    a058:	2206      	movs	r2, #6
    a05a:	1d18      	adds	r0, r3, #4
    a05c:	2148      	movs	r1, #72	; 0x48
    a05e:	f00c f936 	bl	162ce <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
    a062:	4b27      	ldr	r3, [pc, #156]	; (a100 <init_reset+0xfc>)
    a064:	2208      	movs	r2, #8
    a066:	1d18      	adds	r0, r3, #4
    a068:	4611      	mov	r1, r2
    a06a:	f00c f930 	bl	162ce <mem_init>
	link = mem_acquire(&mem_link_rx.free);
    a06e:	4824      	ldr	r0, [pc, #144]	; (a100 <init_reset+0xfc>)
    a070:	f00c f951 	bl	16316 <mem_acquire>
	LL_ASSERT(link);
    a074:	4604      	mov	r4, r0
    a076:	b960      	cbnz	r0, a092 <init_reset+0x8e>
    a078:	4a22      	ldr	r2, [pc, #136]	; (a104 <init_reset+0x100>)
    a07a:	4923      	ldr	r1, [pc, #140]	; (a108 <init_reset+0x104>)
    a07c:	4823      	ldr	r0, [pc, #140]	; (a10c <init_reset+0x108>)
    a07e:	f240 43af 	movw	r3, #1199	; 0x4af
    a082:	f00a fd52 	bl	14b2a <printk>
    a086:	4040      	eors	r0, r0
    a088:	f380 8811 	msr	BASEPRI, r0
    a08c:	f04f 0003 	mov.w	r0, #3
    a090:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
    a092:	4a1f      	ldr	r2, [pc, #124]	; (a110 <init_reset+0x10c>)
    a094:	4620      	mov	r0, r4
    a096:	1f11      	subs	r1, r2, #4
    a098:	f00c f985 	bl	163a6 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
    a09c:	4818      	ldr	r0, [pc, #96]	; (a100 <init_reset+0xfc>)
    a09e:	f00c f93a 	bl	16316 <mem_acquire>
	LL_ASSERT(link);
    a0a2:	4604      	mov	r4, r0
    a0a4:	b960      	cbnz	r0, a0c0 <init_reset+0xbc>
    a0a6:	4a17      	ldr	r2, [pc, #92]	; (a104 <init_reset+0x100>)
    a0a8:	4917      	ldr	r1, [pc, #92]	; (a108 <init_reset+0x104>)
    a0aa:	4818      	ldr	r0, [pc, #96]	; (a10c <init_reset+0x108>)
    a0ac:	f240 43b6 	movw	r3, #1206	; 0x4b6
    a0b0:	f00a fd3b 	bl	14b2a <printk>
    a0b4:	4040      	eors	r0, r0
    a0b6:	f380 8811 	msr	BASEPRI, r0
    a0ba:	f04f 0003 	mov.w	r0, #3
    a0be:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
    a0c0:	4a14      	ldr	r2, [pc, #80]	; (a114 <init_reset+0x110>)
    a0c2:	4620      	mov	r0, r4
    a0c4:	1f11      	subs	r1, r2, #4
    a0c6:	f00c f96e 	bl	163a6 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
    a0ca:	4b13      	ldr	r3, [pc, #76]	; (a118 <init_reset+0x114>)
    a0cc:	2206      	movs	r2, #6
    a0ce:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
    a0d0:	f7ff ff58 	bl	9f84 <rx_alloc.constprop.0>
}
    a0d4:	2000      	movs	r0, #0
    a0d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx->link = link;
    a0da:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    a0dc:	f898 2003 	ldrb.w	r2, [r8, #3]
    a0e0:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    a0e4:	fb02 8303 	mla	r3, r2, r3, r8
    a0e8:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
    a0ea:	f888 4003 	strb.w	r4, [r8, #3]
}
    a0ee:	e79a      	b.n	a026 <init_reset+0x22>
    a0f0:	20002e40 	.word	0x20002e40
    a0f4:	20002eec 	.word	0x20002eec
    a0f8:	2000bdb0 	.word	0x2000bdb0
    a0fc:	20002f50 	.word	0x20002f50
    a100:	20002f0c 	.word	0x20002f0c
    a104:	0001b3ac 	.word	0x0001b3ac
    a108:	0001b3ec 	.word	0x0001b3ec
    a10c:	0001aebe 	.word	0x0001aebe
    a110:	20003110 	.word	0x20003110
    a114:	20003108 	.word	0x20003108
    a118:	20002f08 	.word	0x20002f08

0000a11c <ll_init>:
{
    a11c:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
    a11e:	4b28      	ldr	r3, [pc, #160]	; (a1c0 <ll_init+0xa4>)
{
    a120:	b086      	sub	sp, #24
	sem_recv = sem_rx;
    a122:	6018      	str	r0, [r3, #0]
	cntr_init();
    a124:	f001 ffe0 	bl	c0e8 <cntr_init>
	mayfly_init();
    a128:	f7fe fbc4 	bl	88b4 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    a12c:	4a25      	ldr	r2, [pc, #148]	; (a1c4 <ll_init+0xa8>)
    a12e:	2103      	movs	r1, #3
    a130:	7011      	strb	r1, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
    a132:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    a134:	2002      	movs	r0, #2
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    a136:	4924      	ldr	r1, [pc, #144]	; (a1c8 <ll_init+0xac>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    a138:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
    a13a:	2304      	movs	r3, #4
    a13c:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    a13e:	9105      	str	r1, [sp, #20]
    a140:	4922      	ldr	r1, [pc, #136]	; (a1cc <ll_init+0xb0>)
    a142:	9104      	str	r1, [sp, #16]
    a144:	4922      	ldr	r1, [pc, #136]	; (a1d0 <ll_init+0xb4>)
    a146:	9103      	str	r1, [sp, #12]
    a148:	4922      	ldr	r1, [pc, #136]	; (a1d4 <ll_init+0xb8>)
    a14a:	9102      	str	r1, [sp, #8]
    a14c:	210c      	movs	r1, #12
    a14e:	e9cd 2100 	strd	r2, r1, [sp]
    a152:	2000      	movs	r0, #0
    a154:	4a20      	ldr	r2, [pc, #128]	; (a1d8 <ll_init+0xbc>)
    a156:	2106      	movs	r1, #6
    a158:	f7ff f8c4 	bl	92e4 <ticker_init>
	LL_ASSERT(!err);
    a15c:	b160      	cbz	r0, a178 <ll_init+0x5c>
    a15e:	4a1f      	ldr	r2, [pc, #124]	; (a1dc <ll_init+0xc0>)
    a160:	491f      	ldr	r1, [pc, #124]	; (a1e0 <ll_init+0xc4>)
    a162:	4820      	ldr	r0, [pc, #128]	; (a1e4 <ll_init+0xc8>)
    a164:	f44f 7388 	mov.w	r3, #272	; 0x110
    a168:	f00a fcdf 	bl	14b2a <printk>
    a16c:	4040      	eors	r0, r0
    a16e:	f380 8811 	msr	BASEPRI, r0
    a172:	f04f 0003 	mov.w	r0, #3
    a176:	df02      	svc	2
	return z_impl_k_sem_init(sem, initial_count, limit);
    a178:	2201      	movs	r2, #1
    a17a:	2100      	movs	r1, #0
    a17c:	481a      	ldr	r0, [pc, #104]	; (a1e8 <ll_init+0xcc>)
    a17e:	f00e fec4 	bl	18f0a <z_impl_k_sem_init>
	err = lll_init();
    a182:	f001 f86d 	bl	b260 <lll_init>
	if (err) {
    a186:	4604      	mov	r4, r0
    a188:	b9b0      	cbnz	r0, a1b8 <ll_init+0x9c>
	err = init_reset();
    a18a:	f7ff ff3b 	bl	a004 <init_reset>
	if (err) {
    a18e:	4604      	mov	r4, r0
    a190:	b990      	cbnz	r0, a1b8 <ll_init+0x9c>
	err = lll_adv_init();
    a192:	f00c fc89 	bl	16aa8 <lll_adv_init>
	if (err) {
    a196:	4604      	mov	r4, r0
    a198:	b970      	cbnz	r0, a1b8 <ll_init+0x9c>
	err = ull_adv_init();
    a19a:	f00c fba4 	bl	168e6 <ull_adv_init>
	if (err) {
    a19e:	4604      	mov	r4, r0
    a1a0:	b950      	cbnz	r0, a1b8 <ll_init+0x9c>
	err = lll_scan_init();
    a1a2:	f00c fccc 	bl	16b3e <lll_scan_init>
	if (err) {
    a1a6:	4604      	mov	r4, r0
    a1a8:	b930      	cbnz	r0, a1b8 <ll_init+0x9c>
	err = ull_scan_init();
    a1aa:	f00c fbb2 	bl	16912 <ull_scan_init>
	if (err) {
    a1ae:	4604      	mov	r4, r0
    a1b0:	b910      	cbnz	r0, a1b8 <ll_init+0x9c>
		ull_filter_reset(true);
    a1b2:	2001      	movs	r0, #1
    a1b4:	f000 fedc 	bl	af70 <ull_filter_reset>
}
    a1b8:	4620      	mov	r0, r4
    a1ba:	b006      	add	sp, #24
    a1bc:	bd10      	pop	{r4, pc}
    a1be:	bf00      	nop
    a1c0:	20003114 	.word	0x20003114
    a1c4:	200034c0 	.word	0x200034c0
    a1c8:	00016bc9 	.word	0x00016bc9
    a1cc:	0000c95d 	.word	0x0000c95d
    a1d0:	0000c905 	.word	0x0000c905
    a1d4:	20003250 	.word	0x20003250
    a1d8:	20003130 	.word	0x20003130
    a1dc:	0001b3ac 	.word	0x0001b3ac
    a1e0:	0001b3e7 	.word	0x0001b3e7
    a1e4:	0001aebe 	.word	0x0001aebe
    a1e8:	20003118 	.word	0x20003118

0000a1ec <ll_reset>:
{
    a1ec:	b510      	push	{r4, lr}
    a1ee:	b086      	sub	sp, #24
	err = ull_adv_reset();
    a1f0:	f00c fb7b 	bl	168ea <ull_adv_reset>
	LL_ASSERT(!err);
    a1f4:	b160      	cbz	r0, a210 <ll_reset+0x24>
    a1f6:	4a2c      	ldr	r2, [pc, #176]	; (a2a8 <ll_reset+0xbc>)
    a1f8:	492c      	ldr	r1, [pc, #176]	; (a2ac <ll_reset+0xc0>)
    a1fa:	482d      	ldr	r0, [pc, #180]	; (a2b0 <ll_reset+0xc4>)
    a1fc:	f44f 73af 	mov.w	r3, #350	; 0x15e
    a200:	f00a fc93 	bl	14b2a <printk>
    a204:	4040      	eors	r0, r0
    a206:	f380 8811 	msr	BASEPRI, r0
    a20a:	f04f 0003 	mov.w	r0, #3
    a20e:	df02      	svc	2
	err = ull_scan_reset();
    a210:	f00c fb95 	bl	1693e <ull_scan_reset>
	LL_ASSERT(!err);
    a214:	b160      	cbz	r0, a230 <ll_reset+0x44>
    a216:	4a24      	ldr	r2, [pc, #144]	; (a2a8 <ll_reset+0xbc>)
    a218:	4924      	ldr	r1, [pc, #144]	; (a2ac <ll_reset+0xc0>)
    a21a:	4825      	ldr	r0, [pc, #148]	; (a2b0 <ll_reset+0xc4>)
    a21c:	f44f 73b2 	mov.w	r3, #356	; 0x164
    a220:	f00a fc83 	bl	14b2a <printk>
    a224:	4040      	eors	r0, r0
    a226:	f380 8811 	msr	BASEPRI, r0
    a22a:	f04f 0003 	mov.w	r0, #3
    a22e:	df02      	svc	2
		ull_filter_reset(false);
    a230:	2000      	movs	r0, #0
    a232:	f000 fe9d 	bl	af70 <ull_filter_reset>
	MFIFO_INIT(prep);
    a236:	4b1f      	ldr	r3, [pc, #124]	; (a2b4 <ll_reset+0xc8>)
    a238:	2400      	movs	r4, #0
    a23a:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
    a23c:	4b1e      	ldr	r3, [pc, #120]	; (a2b8 <ll_reset+0xcc>)
    a23e:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
    a240:	4b1e      	ldr	r3, [pc, #120]	; (a2bc <ll_reset+0xd0>)
    a242:	805c      	strh	r4, [r3, #2]
    a244:	2201      	movs	r2, #1
    a246:	4621      	mov	r1, r4
    a248:	4668      	mov	r0, sp
    a24a:	f00e fe5e 	bl	18f0a <z_impl_k_sem_init>
		mfy.param = &sem;
    a24e:	4b1c      	ldr	r3, [pc, #112]	; (a2c0 <ll_reset+0xd4>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    a250:	4622      	mov	r2, r4
    a252:	4621      	mov	r1, r4
    a254:	2003      	movs	r0, #3
		mfy.param = &sem;
    a256:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    a25a:	f7fe fb55 	bl	8908 <mayfly_enqueue>
		LL_ASSERT(!retval);
    a25e:	b160      	cbz	r0, a27a <ll_reset+0x8e>
    a260:	4a11      	ldr	r2, [pc, #68]	; (a2a8 <ll_reset+0xbc>)
    a262:	4918      	ldr	r1, [pc, #96]	; (a2c4 <ll_reset+0xd8>)
    a264:	4812      	ldr	r0, [pc, #72]	; (a2b0 <ll_reset+0xc4>)
    a266:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
    a26a:	f00a fc5e 	bl	14b2a <printk>
    a26e:	4040      	eors	r0, r0
    a270:	f380 8811 	msr	BASEPRI, r0
    a274:	f04f 0003 	mov.w	r0, #3
    a278:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    a27a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    a27e:	4668      	mov	r0, sp
    a280:	f00a f85a 	bl	14338 <z_impl_k_sem_take>
	err = init_reset();
    a284:	f7ff febe 	bl	a004 <init_reset>
	LL_ASSERT(!err);
    a288:	b160      	cbz	r0, a2a4 <ll_reset+0xb8>
    a28a:	4a07      	ldr	r2, [pc, #28]	; (a2a8 <ll_reset+0xbc>)
    a28c:	4907      	ldr	r1, [pc, #28]	; (a2ac <ll_reset+0xc0>)
    a28e:	4808      	ldr	r0, [pc, #32]	; (a2b0 <ll_reset+0xc4>)
    a290:	f44f 73de 	mov.w	r3, #444	; 0x1bc
    a294:	f00a fc49 	bl	14b2a <printk>
    a298:	4040      	eors	r0, r0
    a29a:	f380 8811 	msr	BASEPRI, r0
    a29e:	f04f 0003 	mov.w	r0, #3
    a2a2:	df02      	svc	2
}
    a2a4:	b006      	add	sp, #24
    a2a6:	bd10      	pop	{r4, pc}
    a2a8:	0001b3ac 	.word	0x0001b3ac
    a2ac:	0001b3e7 	.word	0x0001b3e7
    a2b0:	0001aebe 	.word	0x0001aebe
    a2b4:	2000bddc 	.word	0x2000bddc
    a2b8:	2000bdb0 	.word	0x2000bdb0
    a2bc:	2000bdc4 	.word	0x2000bdc4
    a2c0:	2000bf00 	.word	0x2000bf00
    a2c4:	0001b3f1 	.word	0x0001b3f1

0000a2c8 <ll_rx_get>:
{
    a2c8:	b513      	push	{r0, r1, r4, lr}
	*node_rx = NULL;
    a2ca:	2300      	movs	r3, #0
    a2cc:	6003      	str	r3, [r0, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    a2ce:	4b06      	ldr	r3, [pc, #24]	; (a2e8 <ll_rx_get+0x20>)
{
    a2d0:	4604      	mov	r4, r0
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    a2d2:	aa01      	add	r2, sp, #4
    a2d4:	e9d3 0100 	ldrd	r0, r1, [r3]
    a2d8:	f00c f86f 	bl	163ba <memq_peek>
	if (link) {
    a2dc:	b108      	cbz	r0, a2e2 <ll_rx_get+0x1a>
			*node_rx = rx;
    a2de:	9b01      	ldr	r3, [sp, #4]
    a2e0:	6023      	str	r3, [r4, #0]
}
    a2e2:	2000      	movs	r0, #0
    a2e4:	b002      	add	sp, #8
    a2e6:	bd10      	pop	{r4, pc}
    a2e8:	20003104 	.word	0x20003104

0000a2ec <ll_rx_dequeue>:
{
    a2ec:	b513      	push	{r0, r1, r4, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    a2ee:	491a      	ldr	r1, [pc, #104]	; (a358 <ll_rx_dequeue+0x6c>)
	struct node_rx_hdr *rx = NULL;
    a2f0:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    a2f2:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
    a2f4:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    a2f6:	aa01      	add	r2, sp, #4
    a2f8:	f00c f867 	bl	163ca <memq_dequeue>
	LL_ASSERT(link);
    a2fc:	4604      	mov	r4, r0
    a2fe:	b960      	cbnz	r0, a31a <ll_rx_dequeue+0x2e>
    a300:	4a16      	ldr	r2, [pc, #88]	; (a35c <ll_rx_dequeue+0x70>)
    a302:	4917      	ldr	r1, [pc, #92]	; (a360 <ll_rx_dequeue+0x74>)
    a304:	4817      	ldr	r0, [pc, #92]	; (a364 <ll_rx_dequeue+0x78>)
    a306:	f240 230e 	movw	r3, #526	; 0x20e
    a30a:	f00a fc0e 	bl	14b2a <printk>
    a30e:	4040      	eors	r0, r0
    a310:	f380 8811 	msr	BASEPRI, r0
    a314:	f04f 0003 	mov.w	r0, #3
    a318:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
    a31a:	4913      	ldr	r1, [pc, #76]	; (a368 <ll_rx_dequeue+0x7c>)
    a31c:	4620      	mov	r0, r4
    a31e:	f00c f813 	bl	16348 <mem_release>
	switch (rx->type) {
    a322:	9b01      	ldr	r3, [sp, #4]
    a324:	791b      	ldrb	r3, [r3, #4]
    a326:	f013 0ffb 	tst.w	r3, #251	; 0xfb
    a32a:	d10f      	bne.n	a34c <ll_rx_dequeue+0x60>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
    a32c:	b963      	cbnz	r3, a348 <ll_rx_dequeue+0x5c>
    a32e:	4a0b      	ldr	r2, [pc, #44]	; (a35c <ll_rx_dequeue+0x70>)
    a330:	490e      	ldr	r1, [pc, #56]	; (a36c <ll_rx_dequeue+0x80>)
    a332:	f240 239a 	movw	r3, #666	; 0x29a
		LL_ASSERT(0);
    a336:	480b      	ldr	r0, [pc, #44]	; (a364 <ll_rx_dequeue+0x78>)
    a338:	f00a fbf7 	bl	14b2a <printk>
    a33c:	4040      	eors	r0, r0
    a33e:	f380 8811 	msr	BASEPRI, r0
    a342:	f04f 0003 	mov.w	r0, #3
    a346:	df02      	svc	2
}
    a348:	b002      	add	sp, #8
    a34a:	bd10      	pop	{r4, pc}
		LL_ASSERT(0);
    a34c:	4a03      	ldr	r2, [pc, #12]	; (a35c <ll_rx_dequeue+0x70>)
    a34e:	4908      	ldr	r1, [pc, #32]	; (a370 <ll_rx_dequeue+0x84>)
    a350:	f240 239e 	movw	r3, #670	; 0x29e
    a354:	e7ef      	b.n	a336 <ll_rx_dequeue+0x4a>
    a356:	bf00      	nop
    a358:	20003104 	.word	0x20003104
    a35c:	0001b3ac 	.word	0x0001b3ac
    a360:	0001b3ec 	.word	0x0001b3ec
    a364:	0001aebe 	.word	0x0001aebe
    a368:	20002f0c 	.word	0x20002f0c
    a36c:	0001b3f9 	.word	0x0001b3f9
    a370:	0001b96a 	.word	0x0001b96a

0000a374 <ll_rx_mem_release>:
{
    a374:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	rx = *node_rx;
    a378:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
    a37a:	4e22      	ldr	r6, [pc, #136]	; (a404 <ll_rx_mem_release+0x90>)
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    a37c:	4f22      	ldr	r7, [pc, #136]	; (a408 <ll_rx_mem_release+0x94>)
{
    a37e:	4605      	mov	r5, r0
	while (rx) {
    a380:	b924      	cbnz	r4, a38c <ll_rx_mem_release+0x18>
	*node_rx = rx;
    a382:	602c      	str	r4, [r5, #0]
}
    a384:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	rx_alloc(UINT8_MAX);
    a388:	f7ff bdfc 	b.w	9f84 <rx_alloc.constprop.0>
		switch (rx_free->type) {
    a38c:	7923      	ldrb	r3, [r4, #4]
		rx = rx->next;
    a38e:	f8d4 8000 	ldr.w	r8, [r4]
		switch (rx_free->type) {
    a392:	f013 0ffb 	tst.w	r3, #251	; 0xfb
    a396:	d126      	bne.n	a3e6 <ll_rx_mem_release+0x72>
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
    a398:	b963      	cbnz	r3, a3b4 <ll_rx_mem_release+0x40>
    a39a:	491c      	ldr	r1, [pc, #112]	; (a40c <ll_rx_mem_release+0x98>)
    a39c:	481c      	ldr	r0, [pc, #112]	; (a410 <ll_rx_mem_release+0x9c>)
    a39e:	f240 3337 	movw	r3, #823	; 0x337
    a3a2:	4632      	mov	r2, r6
    a3a4:	f00a fbc1 	bl	14b2a <printk>
    a3a8:	4040      	eors	r0, r0
    a3aa:	f380 8811 	msr	BASEPRI, r0
    a3ae:	f04f 0003 	mov.w	r0, #3
    a3b2:	df02      	svc	2
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    a3b4:	783b      	ldrb	r3, [r7, #0]
    a3b6:	2b05      	cmp	r3, #5
    a3b8:	d90c      	bls.n	a3d4 <ll_rx_mem_release+0x60>
    a3ba:	4916      	ldr	r1, [pc, #88]	; (a414 <ll_rx_mem_release+0xa0>)
    a3bc:	4814      	ldr	r0, [pc, #80]	; (a410 <ll_rx_mem_release+0x9c>)
    a3be:	f240 335d 	movw	r3, #861	; 0x35d
    a3c2:	4632      	mov	r2, r6
    a3c4:	f00a fbb1 	bl	14b2a <printk>
    a3c8:	4040      	eors	r0, r0
    a3ca:	f380 8811 	msr	BASEPRI, r0
    a3ce:	f04f 0003 	mov.w	r0, #3
    a3d2:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
    a3d4:	783b      	ldrb	r3, [r7, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
    a3d6:	4910      	ldr	r1, [pc, #64]	; (a418 <ll_rx_mem_release+0xa4>)
	mem_link_rx.quota_pdu += delta;
    a3d8:	3301      	adds	r3, #1
			mem_release(rx_free, &mem_pdu_rx.free);
    a3da:	4620      	mov	r0, r4
	mem_link_rx.quota_pdu += delta;
    a3dc:	703b      	strb	r3, [r7, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
    a3de:	f00b ffb3 	bl	16348 <mem_release>
{
    a3e2:	4644      	mov	r4, r8
    a3e4:	e7cc      	b.n	a380 <ll_rx_mem_release+0xc>
			LL_ASSERT(0);
    a3e6:	490d      	ldr	r1, [pc, #52]	; (a41c <ll_rx_mem_release+0xa8>)
    a3e8:	4809      	ldr	r0, [pc, #36]	; (a410 <ll_rx_mem_release+0x9c>)
    a3ea:	f240 3351 	movw	r3, #849	; 0x351
    a3ee:	4632      	mov	r2, r6
    a3f0:	f00a fb9b 	bl	14b2a <printk>
    a3f4:	4040      	eors	r0, r0
    a3f6:	f380 8811 	msr	BASEPRI, r0
    a3fa:	f04f 0003 	mov.w	r0, #3
    a3fe:	df02      	svc	2
			break;
    a400:	e7ef      	b.n	a3e2 <ll_rx_mem_release+0x6e>
    a402:	bf00      	nop
    a404:	0001b3ac 	.word	0x0001b3ac
    a408:	20002f08 	.word	0x20002f08
    a40c:	0001b417 	.word	0x0001b417
    a410:	0001aebe 	.word	0x0001aebe
    a414:	0001b43a 	.word	0x0001b43a
    a418:	20002f50 	.word	0x20002f50
    a41c:	0001b96a 	.word	0x0001b96a

0000a420 <ll_rx_put>:
	memq_enqueue(link, rx, &memq_ll_rx.tail);
    a420:	4a01      	ldr	r2, [pc, #4]	; (a428 <ll_rx_put+0x8>)
    a422:	f00b bfc3 	b.w	163ac <memq_enqueue>
    a426:	bf00      	nop
    a428:	20003108 	.word	0x20003108

0000a42c <ll_rx_sched>:
	k_sem_give(sem_recv);
    a42c:	4b01      	ldr	r3, [pc, #4]	; (a434 <ll_rx_sched+0x8>)
    a42e:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
    a430:	f009 bf5c 	b.w	142ec <z_impl_k_sem_give>
    a434:	20003114 	.word	0x20003114

0000a438 <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
    a438:	2200      	movs	r2, #0
{
    a43a:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
    a43c:	4611      	mov	r1, r2
    a43e:	4b09      	ldr	r3, [pc, #36]	; (a464 <ll_radio_state_abort+0x2c>)
    a440:	2001      	movs	r0, #1
    a442:	f7fe fa61 	bl	8908 <mayfly_enqueue>
	LL_ASSERT(!ret);
    a446:	b160      	cbz	r0, a462 <ll_radio_state_abort+0x2a>
    a448:	4a07      	ldr	r2, [pc, #28]	; (a468 <ll_radio_state_abort+0x30>)
    a44a:	4908      	ldr	r1, [pc, #32]	; (a46c <ll_radio_state_abort+0x34>)
    a44c:	4808      	ldr	r0, [pc, #32]	; (a470 <ll_radio_state_abort+0x38>)
    a44e:	f240 33bf 	movw	r3, #959	; 0x3bf
    a452:	f00a fb6a 	bl	14b2a <printk>
    a456:	4040      	eors	r0, r0
    a458:	f380 8811 	msr	BASEPRI, r0
    a45c:	f04f 0003 	mov.w	r0, #3
    a460:	df02      	svc	2
}
    a462:	bd08      	pop	{r3, pc}
    a464:	2000bf10 	.word	0x2000bf10
    a468:	0001b3ac 	.word	0x0001b3ac
    a46c:	0001b46e 	.word	0x0001b46e
    a470:	0001aebe 	.word	0x0001aebe

0000a474 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
    a474:	6008      	str	r0, [r1, #0]
    a476:	4801      	ldr	r0, [pc, #4]	; (a47c <ull_ticker_status_give+0x8>)
    a478:	f009 bf38 	b.w	142ec <z_impl_k_sem_give>
    a47c:	20003118 	.word	0x20003118

0000a480 <ull_ticker_status_take>:
{
    a480:	b510      	push	{r4, lr}
    a482:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
    a484:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    a488:	4802      	ldr	r0, [pc, #8]	; (a494 <ull_ticker_status_take+0x14>)
    a48a:	f009 ff55 	bl	14338 <z_impl_k_sem_take>
	return *ret_cb;
    a48e:	6820      	ldr	r0, [r4, #0]
}
    a490:	bd10      	pop	{r4, pc}
    a492:	bf00      	nop
    a494:	20003118 	.word	0x20003118

0000a498 <ull_disable_mark>:
	if (!*m) {
    a498:	4b02      	ldr	r3, [pc, #8]	; (a4a4 <ull_disable_mark+0xc>)
    a49a:	681a      	ldr	r2, [r3, #0]
    a49c:	b902      	cbnz	r2, a4a0 <ull_disable_mark+0x8>
		*m = param;
    a49e:	6018      	str	r0, [r3, #0]
}
    a4a0:	6818      	ldr	r0, [r3, #0]
    a4a2:	4770      	bx	lr
    a4a4:	20002e3c 	.word	0x20002e3c

0000a4a8 <ull_disable_unmark>:
	if (*m && *m == param) {
    a4a8:	4a05      	ldr	r2, [pc, #20]	; (a4c0 <ull_disable_unmark+0x18>)
{
    a4aa:	4603      	mov	r3, r0
	if (*m && *m == param) {
    a4ac:	6810      	ldr	r0, [r2, #0]
    a4ae:	b130      	cbz	r0, a4be <ull_disable_unmark+0x16>
    a4b0:	4283      	cmp	r3, r0
    a4b2:	f04f 0300 	mov.w	r3, #0
    a4b6:	d101      	bne.n	a4bc <ull_disable_unmark+0x14>
		*m = NULL;
    a4b8:	6013      	str	r3, [r2, #0]
		return param;
    a4ba:	4770      	bx	lr
	return NULL;
    a4bc:	4618      	mov	r0, r3
}
    a4be:	4770      	bx	lr
    a4c0:	20002e3c 	.word	0x20002e3c

0000a4c4 <ull_disable_mark_get>:
}
    a4c4:	4b01      	ldr	r3, [pc, #4]	; (a4cc <ull_disable_mark_get+0x8>)
    a4c6:	6818      	ldr	r0, [r3, #0]
    a4c8:	4770      	bx	lr
    a4ca:	bf00      	nop
    a4cc:	20002e3c 	.word	0x20002e3c

0000a4d0 <ull_disable>:
{
    a4d0:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
    a4d2:	6805      	ldr	r5, [r0, #0]
	if (!hdr) {
    a4d4:	f115 0f10 	cmn.w	r5, #16
{
    a4d8:	b087      	sub	sp, #28
    a4da:	4604      	mov	r4, r0
	if (!hdr) {
    a4dc:	d102      	bne.n	a4e4 <ull_disable+0x14>
		return ULL_STATUS_SUCCESS;
    a4de:	2000      	movs	r0, #0
}
    a4e0:	b007      	add	sp, #28
    a4e2:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_sem_init(sem, initial_count, limit);
    a4e4:	2201      	movs	r2, #1
    a4e6:	2100      	movs	r1, #0
    a4e8:	4668      	mov	r0, sp
    a4ea:	f00e fd0e 	bl	18f0a <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
    a4ee:	4b11      	ldr	r3, [pc, #68]	; (a534 <ull_disable+0x64>)
    a4f0:	616b      	str	r3, [r5, #20]
	if (!hdr->ref) {
    a4f2:	7c2b      	ldrb	r3, [r5, #16]
	hdr->disabled_param = &sem;
    a4f4:	f8c5 d018 	str.w	sp, [r5, #24]
	if (!hdr->ref) {
    a4f8:	2b00      	cmp	r3, #0
    a4fa:	d0f0      	beq.n	a4de <ull_disable+0xe>
	mfy.param = lll;
    a4fc:	4b0e      	ldr	r3, [pc, #56]	; (a538 <ull_disable+0x68>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    a4fe:	2200      	movs	r2, #0
    a500:	4611      	mov	r1, r2
    a502:	2003      	movs	r0, #3
	mfy.param = lll;
    a504:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    a506:	f7fe f9ff 	bl	8908 <mayfly_enqueue>
	LL_ASSERT(!ret);
    a50a:	b160      	cbz	r0, a526 <ull_disable+0x56>
    a50c:	4a0b      	ldr	r2, [pc, #44]	; (a53c <ull_disable+0x6c>)
    a50e:	490c      	ldr	r1, [pc, #48]	; (a540 <ull_disable+0x70>)
    a510:	480c      	ldr	r0, [pc, #48]	; (a544 <ull_disable+0x74>)
    a512:	f240 4312 	movw	r3, #1042	; 0x412
    a516:	f00a fb08 	bl	14b2a <printk>
    a51a:	4040      	eors	r0, r0
    a51c:	f380 8811 	msr	BASEPRI, r0
    a520:	f04f 0003 	mov.w	r0, #3
    a524:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    a526:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    a52a:	4668      	mov	r0, sp
    a52c:	f009 ff04 	bl	14338 <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
    a530:	e7d6      	b.n	a4e0 <ull_disable+0x10>
    a532:	bf00      	nop
    a534:	000168d9 	.word	0x000168d9
    a538:	2000bf20 	.word	0x2000bf20
    a53c:	0001b3ac 	.word	0x0001b3ac
    a540:	0001b46e 	.word	0x0001b46e
    a544:	0001aebe 	.word	0x0001aebe

0000a548 <ull_pdu_rx_alloc_peek>:
{
    a548:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
    a54a:	4a0a      	ldr	r2, [pc, #40]	; (a574 <ull_pdu_rx_alloc_peek+0x2c>)
    a54c:	7891      	ldrb	r1, [r2, #2]
    a54e:	78d4      	ldrb	r4, [r2, #3]
    a550:	7853      	ldrb	r3, [r2, #1]
 * @details API 1 and 2
 *   Empty if first == last
 */
static inline u8_t mfifo_avail_count_get(u8_t count, u8_t first, u8_t last)
{
	if (last >= first) {
    a552:	42a1      	cmp	r1, r4
		return last - first;
	} else {
		return count - first + last;
    a554:	bf8a      	itet	hi
    a556:	1a5b      	subhi	r3, r3, r1
		return last - first;
    a558:	1a63      	subls	r3, r4, r1
		return count - first + last;
    a55a:	191b      	addhi	r3, r3, r4
    a55c:	b2db      	uxtb	r3, r3
    a55e:	4298      	cmp	r0, r3
    a560:	d806      	bhi.n	a570 <ull_pdu_rx_alloc_peek+0x28>
 * @details API 2
 */
static inline void *mfifo_dequeue_peek(u8_t *fifo, u8_t size, u8_t first,
				       u8_t last)
{
	if (first == last) {
    a562:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
    a564:	7813      	ldrb	r3, [r2, #0]
    a566:	d003      	beq.n	a570 <ull_pdu_rx_alloc_peek+0x28>
		return NULL; /* Queue is empty */
	}

	/* API 2: fifo is array of void-ptrs */
	return *((void **)(fifo + first * size));
    a568:	fb01 2203 	mla	r2, r1, r3, r2
    a56c:	6850      	ldr	r0, [r2, #4]
}
    a56e:	bd10      	pop	{r4, pc}
		return NULL;
    a570:	2000      	movs	r0, #0
    a572:	e7fc      	b.n	a56e <ull_pdu_rx_alloc_peek+0x26>
    a574:	2000bdc4 	.word	0x2000bdc4

0000a578 <ull_pdu_rx_alloc>:
{
    a578:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
    a57a:	4a09      	ldr	r2, [pc, #36]	; (a5a0 <ull_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
    a57c:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
    a57e:	78d0      	ldrb	r0, [r2, #3]
    a580:	7811      	ldrb	r1, [r2, #0]
    a582:	7854      	ldrb	r4, [r2, #1]
    a584:	4298      	cmp	r0, r3
    a586:	d009      	beq.n	a59c <ull_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
    a588:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
    a58c:	3301      	adds	r3, #1
    a58e:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
    a590:	429c      	cmp	r4, r3
    a592:	bf08      	it	eq
    a594:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
    a596:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
    a598:	7093      	strb	r3, [r2, #2]
}
    a59a:	bd10      	pop	{r4, pc}
		return NULL;
    a59c:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
    a59e:	e7fc      	b.n	a59a <ull_pdu_rx_alloc+0x22>
    a5a0:	2000bdc4 	.word	0x2000bdc4

0000a5a4 <ull_rx_put>:
	memq_enqueue(link, rx, &memq_ull_rx.tail);
    a5a4:	4a01      	ldr	r2, [pc, #4]	; (a5ac <ull_rx_put+0x8>)
    a5a6:	f00b bf01 	b.w	163ac <memq_enqueue>
    a5aa:	bf00      	nop
    a5ac:	20003110 	.word	0x20003110

0000a5b0 <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
    a5b0:	2201      	movs	r2, #1
    a5b2:	4b02      	ldr	r3, [pc, #8]	; (a5bc <ull_rx_sched+0xc>)
    a5b4:	4611      	mov	r1, r2
    a5b6:	2000      	movs	r0, #0
    a5b8:	f7fe b9a6 	b.w	8908 <mayfly_enqueue>
    a5bc:	2000bf30 	.word	0x2000bf30

0000a5c0 <ull_prepare_enqueue>:
{
    a5c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    a5c4:	4e17      	ldr	r6, [pc, #92]	; (a624 <ull_prepare_enqueue+0x64>)
{
    a5c6:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    a5c8:	78f3      	ldrb	r3, [r6, #3]
    a5ca:	7834      	ldrb	r4, [r6, #0]
{
    a5cc:	4680      	mov	r8, r0
	last = last + 1;
    a5ce:	1c5d      	adds	r5, r3, #1
	if (last == count) {
    a5d0:	7870      	ldrb	r0, [r6, #1]
    a5d2:	460f      	mov	r7, r1
	last = last + 1;
    a5d4:	b2ed      	uxtb	r5, r5
    a5d6:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    a5d8:	78b2      	ldrb	r2, [r6, #2]
		last = 0U;
    a5da:	42a8      	cmp	r0, r5
    a5dc:	bf08      	it	eq
    a5de:	2500      	moveq	r5, #0
	if (last == first) {
    a5e0:	42aa      	cmp	r2, r5
    a5e2:	d01b      	beq.n	a61c <ull_prepare_enqueue+0x5c>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
    a5e4:	1d32      	adds	r2, r6, #4
    a5e6:	fb03 2404 	mla	r4, r3, r4, r2
	if (!e) {
    a5ea:	b1bc      	cbz	r4, a61c <ull_prepare_enqueue+0x5c>
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
    a5ec:	2210      	movs	r2, #16
    a5ee:	4620      	mov	r0, r4
    a5f0:	f00b fd23 	bl	1603a <memcpy>
	e->prio = prio;
    a5f4:	9b08      	ldr	r3, [sp, #32]
	e->is_resume = is_resume;
    a5f6:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
	e->prio = prio;
    a5fa:	61e3      	str	r3, [r4, #28]
	e->is_resume = is_resume;
    a5fc:	f894 3020 	ldrb.w	r3, [r4, #32]
	e->abort_cb = abort_cb;
    a600:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
    a602:	f023 0303 	bic.w	r3, r3, #3
    a606:	f002 0201 	and.w	r2, r2, #1
	e->is_abort_cb = is_abort_cb;
    a60a:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_resume = is_resume;
    a60e:	4313      	orrs	r3, r2
    a610:	f884 3020 	strb.w	r3, [r4, #32]
	*last = idx; /* Commit: Update write index */
    a614:	70f5      	strb	r5, [r6, #3]
	return 0;
    a616:	2000      	movs	r0, #0
}
    a618:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -ENOBUFS;
    a61c:	f06f 0036 	mvn.w	r0, #54	; 0x36
    a620:	e7fa      	b.n	a618 <ull_prepare_enqueue+0x58>
    a622:	bf00      	nop
    a624:	2000bddc 	.word	0x2000bddc

0000a628 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
    a628:	4b05      	ldr	r3, [pc, #20]	; (a640 <ull_prepare_dequeue_get+0x18>)
    a62a:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
    a62c:	78d9      	ldrb	r1, [r3, #3]
    a62e:	7818      	ldrb	r0, [r3, #0]
    a630:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
    a632:	bf1a      	itte	ne
    a634:	3304      	addne	r3, #4
    a636:	fb02 3000 	mlane	r0, r2, r0, r3
		return NULL;
    a63a:	2000      	moveq	r0, #0
}
    a63c:	4770      	bx	lr
    a63e:	bf00      	nop
    a640:	2000bddc 	.word	0x2000bddc

0000a644 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
    a644:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
    a648:	4d67      	ldr	r5, [pc, #412]	; (a7e8 <rx_demux+0x1a4>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
    a64a:	4c68      	ldr	r4, [pc, #416]	; (a7ec <rx_demux+0x1a8>)
    a64c:	aa01      	add	r2, sp, #4
    a64e:	e9d4 0100 	ldrd	r0, r1, [r4]
    a652:	f00b feb2 	bl	163ba <memq_peek>
		if (link) {
    a656:	4607      	mov	r7, r0
    a658:	2800      	cmp	r0, #0
    a65a:	f000 80c2 	beq.w	a7e2 <rx_demux+0x19e>
			LL_ASSERT(rx);
    a65e:	9b01      	ldr	r3, [sp, #4]
    a660:	b963      	cbnz	r3, a67c <rx_demux+0x38>
    a662:	4a63      	ldr	r2, [pc, #396]	; (a7f0 <rx_demux+0x1ac>)
    a664:	4963      	ldr	r1, [pc, #396]	; (a7f4 <rx_demux+0x1b0>)
    a666:	4864      	ldr	r0, [pc, #400]	; (a7f8 <rx_demux+0x1b4>)
    a668:	f240 53ca 	movw	r3, #1482	; 0x5ca
    a66c:	f00a fa5d 	bl	14b2a <printk>
    a670:	4040      	eors	r0, r0
    a672:	f380 8811 	msr	BASEPRI, r0
    a676:	f04f 0003 	mov.w	r0, #3
    a67a:	df02      	svc	2
				nack = rx_demux_rx(link, rx);
    a67c:	9e01      	ldr	r6, [sp, #4]
	switch (rx->type) {
    a67e:	7933      	ldrb	r3, [r6, #4]
    a680:	2b01      	cmp	r3, #1
    a682:	d010      	beq.n	a6a6 <rx_demux+0x62>
    a684:	2b04      	cmp	r3, #4
    a686:	f000 80a0 	beq.w	a7ca <rx_demux+0x186>
		LL_ASSERT(0);
    a68a:	4a59      	ldr	r2, [pc, #356]	; (a7f0 <rx_demux+0x1ac>)
    a68c:	495b      	ldr	r1, [pc, #364]	; (a7fc <rx_demux+0x1b8>)
    a68e:	485a      	ldr	r0, [pc, #360]	; (a7f8 <rx_demux+0x1b4>)
    a690:	f240 635b 	movw	r3, #1627	; 0x65b
    a694:	f00a fa49 	bl	14b2a <printk>
    a698:	4040      	eors	r0, r0
    a69a:	f380 8811 	msr	BASEPRI, r0
    a69e:	f04f 0003 	mov.w	r0, #3
    a6a2:	df02      	svc	2
	break;
    a6a4:	e7d1      	b.n	a64a <rx_demux+0x6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    a6a6:	6860      	ldr	r0, [r4, #4]
    a6a8:	4950      	ldr	r1, [pc, #320]	; (a7ec <rx_demux+0x1a8>)
    a6aa:	2200      	movs	r2, #0
    a6ac:	f00b fe8d 	bl	163ca <memq_dequeue>
	switch (done->extra.type) {
    a6b0:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
	ull_hdr = done->param;
    a6b4:	6a34      	ldr	r4, [r6, #32]
	switch (done->extra.type) {
    a6b6:	b163      	cbz	r3, a6d2 <rx_demux+0x8e>
		LL_ASSERT(0);
    a6b8:	4a4d      	ldr	r2, [pc, #308]	; (a7f0 <rx_demux+0x1ac>)
    a6ba:	4950      	ldr	r1, [pc, #320]	; (a7fc <rx_demux+0x1b8>)
    a6bc:	484e      	ldr	r0, [pc, #312]	; (a7f8 <rx_demux+0x1b4>)
    a6be:	f240 6383 	movw	r3, #1667	; 0x683
    a6c2:	f00a fa32 	bl	14b2a <printk>
    a6c6:	4040      	eors	r0, r0
    a6c8:	f380 8811 	msr	BASEPRI, r0
    a6cc:	f04f 0003 	mov.w	r0, #3
    a6d0:	df02      	svc	2
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    a6d2:	4a4b      	ldr	r2, [pc, #300]	; (a800 <rx_demux+0x1bc>)
    a6d4:	78d1      	ldrb	r1, [r2, #3]
	if (last == count) {
    a6d6:	f892 c001 	ldrb.w	ip, [r2, #1]
    a6da:	7890      	ldrb	r0, [r2, #2]
	done->extra.type = 0U;
    a6dc:	2300      	movs	r3, #0
    a6de:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
	last = last + 1;
    a6e2:	1c4b      	adds	r3, r1, #1
    a6e4:	b2db      	uxtb	r3, r3
		last = 0U;
    a6e6:	459c      	cmp	ip, r3
    a6e8:	bf08      	it	eq
    a6ea:	2300      	moveq	r3, #0
	if (last == first) {
    a6ec:	4298      	cmp	r0, r3
    a6ee:	d15b      	bne.n	a7a8 <rx_demux+0x164>
	LL_ASSERT(release == done);
    a6f0:	4a3f      	ldr	r2, [pc, #252]	; (a7f0 <rx_demux+0x1ac>)
    a6f2:	4944      	ldr	r1, [pc, #272]	; (a804 <rx_demux+0x1c0>)
    a6f4:	4840      	ldr	r0, [pc, #256]	; (a7f8 <rx_demux+0x1b4>)
    a6f6:	f240 638a 	movw	r3, #1674	; 0x68a
    a6fa:	f00a fa16 	bl	14b2a <printk>
    a6fe:	4040      	eors	r0, r0
    a700:	f380 8811 	msr	BASEPRI, r0
    a704:	f04f 0003 	mov.w	r0, #3
    a708:	df02      	svc	2
	next = ull_prepare_dequeue_get();
    a70a:	f7ff ff8d 	bl	a628 <ull_prepare_dequeue_get>
			mfy.param = next;
    a70e:	4f3e      	ldr	r7, [pc, #248]	; (a808 <rx_demux+0x1c4>)
	while (next) {
    a710:	b350      	cbz	r0, a768 <rx_demux+0x124>
		u8_t is_aborted = next->is_aborted;
    a712:	f890 3020 	ldrb.w	r3, [r0, #32]
		if (!is_aborted) {
    a716:	079a      	lsls	r2, r3, #30
		u8_t is_aborted = next->is_aborted;
    a718:	f3c3 0640 	ubfx	r6, r3, #1, #1
		u8_t is_resume = next->is_resume;
    a71c:	f003 0801 	and.w	r8, r3, #1
		if (!is_aborted) {
    a720:	d414      	bmi.n	a74c <rx_demux+0x108>
			mfy.param = next;
    a722:	60b8      	str	r0, [r7, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    a724:	4b38      	ldr	r3, [pc, #224]	; (a808 <rx_demux+0x1c4>)
    a726:	4632      	mov	r2, r6
    a728:	4631      	mov	r1, r6
    a72a:	2001      	movs	r0, #1
    a72c:	f7fe f8ec 	bl	8908 <mayfly_enqueue>
			LL_ASSERT(!ret);
    a730:	b160      	cbz	r0, a74c <rx_demux+0x108>
    a732:	4a2f      	ldr	r2, [pc, #188]	; (a7f0 <rx_demux+0x1ac>)
    a734:	4935      	ldr	r1, [pc, #212]	; (a80c <rx_demux+0x1c8>)
    a736:	4830      	ldr	r0, [pc, #192]	; (a7f8 <rx_demux+0x1b4>)
    a738:	f240 639b 	movw	r3, #1691	; 0x69b
    a73c:	f00a f9f5 	bl	14b2a <printk>
    a740:	4040      	eors	r0, r0
    a742:	f380 8811 	msr	BASEPRI, r0
    a746:	f04f 0003 	mov.w	r0, #3
    a74a:	df02      	svc	2
	u8_t _first = *first; /* Copy read-index */
    a74c:	78ab      	ldrb	r3, [r5, #2]
	if (_first == last) {
    a74e:	78e9      	ldrb	r1, [r5, #3]
		MFIFO_DEQUEUE(prep);
    a750:	786a      	ldrb	r2, [r5, #1]
    a752:	4299      	cmp	r1, r3
    a754:	d005      	beq.n	a762 <rx_demux+0x11e>
	_first += 1U;
    a756:	3301      	adds	r3, #1
    a758:	b2db      	uxtb	r3, r3
		_first = 0U;
    a75a:	429a      	cmp	r2, r3
    a75c:	bf08      	it	eq
    a75e:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    a760:	70ab      	strb	r3, [r5, #2]

		next = ull_prepare_dequeue_get();
    a762:	f7ff ff61 	bl	a628 <ull_prepare_dequeue_get>

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
    a766:	bb30      	cbnz	r0, a7b6 <rx_demux+0x172>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
    a768:	2c00      	cmp	r4, #0
    a76a:	f43f af6e 	beq.w	a64a <rx_demux+0x6>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
    a76e:	7823      	ldrb	r3, [r4, #0]
    a770:	b963      	cbnz	r3, a78c <rx_demux+0x148>
    a772:	4a1f      	ldr	r2, [pc, #124]	; (a7f0 <rx_demux+0x1ac>)
    a774:	4926      	ldr	r1, [pc, #152]	; (a810 <rx_demux+0x1cc>)
    a776:	4820      	ldr	r0, [pc, #128]	; (a7f8 <rx_demux+0x1b4>)
    a778:	f240 63ad 	movw	r3, #1709	; 0x6ad
    a77c:	f00a f9d5 	bl	14b2a <printk>
    a780:	4040      	eors	r0, r0
    a782:	f380 8811 	msr	BASEPRI, r0
    a786:	f04f 0003 	mov.w	r0, #3
    a78a:	df02      	svc	2
	return hdr->ref--;
    a78c:	7823      	ldrb	r3, [r4, #0]
    a78e:	3b01      	subs	r3, #1
    a790:	b2db      	uxtb	r3, r3
    a792:	7023      	strb	r3, [r4, #0]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
    a794:	2b00      	cmp	r3, #0
    a796:	f47f af58 	bne.w	a64a <rx_demux+0x6>
    a79a:	6863      	ldr	r3, [r4, #4]
    a79c:	2b00      	cmp	r3, #0
    a79e:	f43f af54 	beq.w	a64a <rx_demux+0x6>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
    a7a2:	68a0      	ldr	r0, [r4, #8]
    a7a4:	4798      	blx	r3
    a7a6:	e750      	b.n	a64a <rx_demux+0x6>
	done->hdr.link = link;
    a7a8:	6037      	str	r7, [r6, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    a7aa:	7810      	ldrb	r0, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    a7ac:	fb00 2101 	mla	r1, r0, r1, r2
    a7b0:	604e      	str	r6, [r1, #4]
	*last = idx; /* Commit: Update write index */
    a7b2:	70d3      	strb	r3, [r2, #3]
	LL_ASSERT(release == done);
    a7b4:	e7a9      	b.n	a70a <rx_demux+0xc6>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
    a7b6:	2e00      	cmp	r6, #0
    a7b8:	d1aa      	bne.n	a710 <rx_demux+0xcc>
    a7ba:	f1b8 0f00 	cmp.w	r8, #0
    a7be:	d0d3      	beq.n	a768 <rx_demux+0x124>
    a7c0:	f890 3020 	ldrb.w	r3, [r0, #32]
    a7c4:	07db      	lsls	r3, r3, #31
    a7c6:	d4cf      	bmi.n	a768 <rx_demux+0x124>
    a7c8:	e7a2      	b.n	a710 <rx_demux+0xcc>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    a7ca:	2200      	movs	r2, #0
    a7cc:	4907      	ldr	r1, [pc, #28]	; (a7ec <rx_demux+0x1a8>)
    a7ce:	6860      	ldr	r0, [r4, #4]
    a7d0:	f00b fdfb 	bl	163ca <memq_dequeue>
		ll_rx_put(link, rx);
    a7d4:	4631      	mov	r1, r6
    a7d6:	4638      	mov	r0, r7
    a7d8:	f7ff fe22 	bl	a420 <ll_rx_put>
		ll_rx_sched();
    a7dc:	f7ff fe26 	bl	a42c <ll_rx_sched>
	break;
    a7e0:	e733      	b.n	a64a <rx_demux+0x6>
}
    a7e2:	b002      	add	sp, #8
    a7e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a7e8:	2000bddc 	.word	0x2000bddc
    a7ec:	2000310c 	.word	0x2000310c
    a7f0:	0001b3ac 	.word	0x0001b3ac
    a7f4:	0001b7e8 	.word	0x0001b7e8
    a7f8:	0001aebe 	.word	0x0001aebe
    a7fc:	0001b96a 	.word	0x0001b96a
    a800:	2000bdb0 	.word	0x2000bdb0
    a804:	0001b473 	.word	0x0001b473
    a808:	2000bf40 	.word	0x2000bf40
    a80c:	0001b46e 	.word	0x0001b46e
    a810:	0001b483 	.word	0x0001b483

0000a814 <ull_prepare_dequeue_iter>:
{
    a814:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    a816:	4a0c      	ldr	r2, [pc, #48]	; (a848 <ull_prepare_dequeue_iter+0x34>)
{
    a818:	4603      	mov	r3, r0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    a81a:	7854      	ldrb	r4, [r2, #1]
	if (*idx >= count) {
    a81c:	7819      	ldrb	r1, [r3, #0]
    a81e:	78d5      	ldrb	r5, [r2, #3]
    a820:	7810      	ldrb	r0, [r2, #0]
    a822:	42a1      	cmp	r1, r4
    a824:	bf24      	itt	cs
    a826:	7892      	ldrbcs	r2, [r2, #2]
		*idx = first;
    a828:	701a      	strbcs	r2, [r3, #0]
	if (*idx == last) {
    a82a:	7819      	ldrb	r1, [r3, #0]
    a82c:	428d      	cmp	r5, r1
    a82e:	d009      	beq.n	a844 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
    a830:	1c4a      	adds	r2, r1, #1
    a832:	b2d2      	uxtb	r2, r2
		i = 0U;
    a834:	4294      	cmp	r4, r2
    a836:	bf08      	it	eq
    a838:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
    a83a:	4c04      	ldr	r4, [pc, #16]	; (a84c <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
    a83c:	701a      	strb	r2, [r3, #0]
	p = (void *)(fifo + (*idx) * size);
    a83e:	fb01 4000 	mla	r0, r1, r0, r4
}
    a842:	bd30      	pop	{r4, r5, pc}
		return NULL;
    a844:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    a846:	e7fc      	b.n	a842 <ull_prepare_dequeue_iter+0x2e>
    a848:	2000bddc 	.word	0x2000bddc
    a84c:	2000bde0 	.word	0x2000bde0

0000a850 <ull_event_done>:
{
    a850:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
    a852:	4a10      	ldr	r2, [pc, #64]	; (a894 <ull_event_done+0x44>)
	u8_t _first = *first; /* Copy read-index */
    a854:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
    a856:	78d4      	ldrb	r4, [r2, #3]
    a858:	7855      	ldrb	r5, [r2, #1]
    a85a:	429c      	cmp	r4, r3
{
    a85c:	4601      	mov	r1, r0
	evdone = MFIFO_DEQUEUE(done);
    a85e:	7810      	ldrb	r0, [r2, #0]
    a860:	d016      	beq.n	a890 <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
    a862:	fb03 2000 	mla	r0, r3, r0, r2
	_first += 1U;
    a866:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
    a868:	6844      	ldr	r4, [r0, #4]
	_first += 1U;
    a86a:	b2db      	uxtb	r3, r3
		_first = 0U;
    a86c:	429d      	cmp	r5, r3
    a86e:	bf08      	it	eq
    a870:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    a872:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
    a874:	b154      	cbz	r4, a88c <ull_event_done+0x3c>
	evdone->hdr.link = NULL;
    a876:	2300      	movs	r3, #0
	link = evdone->hdr.link;
    a878:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
    a87a:	6023      	str	r3, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
    a87c:	2301      	movs	r3, #1
    a87e:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
    a880:	6221      	str	r1, [r4, #32]
	ull_rx_put(link, evdone);
    a882:	4621      	mov	r1, r4
    a884:	f7ff fe8e 	bl	a5a4 <ull_rx_put>
	ull_rx_sched();
    a888:	f7ff fe92 	bl	a5b0 <ull_rx_sched>
}
    a88c:	4620      	mov	r0, r4
    a88e:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
    a890:	2400      	movs	r4, #0
    a892:	e7fb      	b.n	a88c <ull_event_done+0x3c>
    a894:	2000bdb0 	.word	0x2000bdb0

0000a898 <ticker_cb>:
	return adv;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
    a898:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a89c:	461c      	mov	r4, r3

	DEBUG_RADIO_PREPARE_A(1);

	lll = &adv->lll;

	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
    a89e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a8a2:	429a      	cmp	r2, r3
{
    a8a4:	b08a      	sub	sp, #40	; 0x28
    a8a6:	4680      	mov	r8, r0
    a8a8:	460f      	mov	r7, r1
    a8aa:	4616      	mov	r6, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
    a8ac:	d02d      	beq.n	a90a <ticker_cb+0x72>
	return ++hdr->ref;
    a8ae:	7c23      	ldrb	r3, [r4, #16]
    a8b0:	3301      	adds	r3, #1
    a8b2:	b2db      	uxtb	r3, r3
    a8b4:	7423      	strb	r3, [r4, #16]
	    (lazy != TICKER_LAZY_MUST_EXPIRE)) {
		/* Increment prepare reference count */
		ref = ull_ref_inc(&adv->ull);
		LL_ASSERT(ref);
    a8b6:	b963      	cbnz	r3, a8d2 <ticker_cb+0x3a>
    a8b8:	4a2d      	ldr	r2, [pc, #180]	; (a970 <ticker_cb+0xd8>)
    a8ba:	492e      	ldr	r1, [pc, #184]	; (a974 <ticker_cb+0xdc>)
    a8bc:	482e      	ldr	r0, [pc, #184]	; (a978 <ticker_cb+0xe0>)
    a8be:	f240 4331 	movw	r3, #1073	; 0x431
    a8c2:	f00a f932 	bl	14b2a <printk>
    a8c6:	4040      	eors	r0, r0
    a8c8:	f380 8811 	msr	BASEPRI, r0
    a8cc:	f04f 0003 	mov.w	r0, #3
    a8d0:	df02      	svc	2

		/* Append timing parameters */
		p.ticks_at_expire = ticks_at_expire;
    a8d2:	4d2a      	ldr	r5, [pc, #168]	; (a97c <ticker_cb+0xe4>)
	lll = &adv->lll;
    a8d4:	f104 031c 	add.w	r3, r4, #28
		p.remainder = remainder;
		p.lazy = lazy;
		p.param = lll;
    a8d8:	60eb      	str	r3, [r5, #12]
		mfy.param = &p;

		/* Kick LLL prepare */
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    a8da:	2200      	movs	r2, #0
		mfy.param = &p;
    a8dc:	4b28      	ldr	r3, [pc, #160]	; (a980 <ticker_cb+0xe8>)
		p.lazy = lazy;
    a8de:	812e      	strh	r6, [r5, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    a8e0:	4611      	mov	r1, r2
    a8e2:	2001      	movs	r0, #1
		p.remainder = remainder;
    a8e4:	e9c5 8700 	strd	r8, r7, [r5]
		mfy.param = &p;
    a8e8:	609d      	str	r5, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    a8ea:	f7fe f80d 	bl	8908 <mayfly_enqueue>
				     TICKER_USER_ID_LLL, 0, &mfy);
		LL_ASSERT(!ret);
    a8ee:	b160      	cbz	r0, a90a <ticker_cb+0x72>
    a8f0:	4a1f      	ldr	r2, [pc, #124]	; (a970 <ticker_cb+0xd8>)
    a8f2:	4924      	ldr	r1, [pc, #144]	; (a984 <ticker_cb+0xec>)
    a8f4:	4820      	ldr	r0, [pc, #128]	; (a978 <ticker_cb+0xe0>)
    a8f6:	f240 433d 	movw	r3, #1085	; 0x43d
    a8fa:	f00a f916 	bl	14b2a <printk>
    a8fe:	4040      	eors	r0, r0
    a900:	f380 8811 	msr	BASEPRI, r0
    a904:	f04f 0003 	mov.w	r0, #3
    a908:	df02      	svc	2
#endif /* CONFIG_BT_PERIPHERAL */
	{
		u32_t random_delay;
		u32_t ret;

		lll_entropy_get(sizeof(random_delay), &random_delay);
    a90a:	a909      	add	r1, sp, #36	; 0x24
    a90c:	2004      	movs	r0, #4
    a90e:	f000 fcd9 	bl	b2c4 <lll_entropy_get>
		random_delay %= ULL_ADV_RANDOM_DELAY;
    a912:	9909      	ldr	r1, [sp, #36]	; 0x24
		random_delay += 1;

		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    a914:	9406      	str	r4, [sp, #24]
		random_delay %= ULL_ADV_RANDOM_DELAY;
    a916:	f240 1247 	movw	r2, #327	; 0x147
    a91a:	fbb1 f3f2 	udiv	r3, r1, r2
    a91e:	fb02 1313 	mls	r3, r2, r3, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
    a922:	4a19      	ldr	r2, [pc, #100]	; (a988 <ticker_cb+0xf0>)
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    a924:	2000      	movs	r0, #0
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
    a926:	21cc      	movs	r1, #204	; 0xcc
    a928:	1aa2      	subs	r2, r4, r2
    a92a:	fbb2 f2f1 	udiv	r2, r2, r1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    a92e:	4917      	ldr	r1, [pc, #92]	; (a98c <ticker_cb+0xf4>)
    a930:	9105      	str	r1, [sp, #20]
				    TICKER_USER_ID_ULL_HIGH,
				    (TICKER_ID_ADV_BASE +
    a932:	3202      	adds	r2, #2
		random_delay += 1;
    a934:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    a936:	e9cd 0003 	strd	r0, r0, [sp, #12]
    a93a:	e9cd 0001 	strd	r0, r0, [sp, #4]
    a93e:	9000      	str	r0, [sp, #0]
    a940:	b2d2      	uxtb	r2, r2
    a942:	2101      	movs	r1, #1
		random_delay += 1;
    a944:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    a946:	f7fe fd79 	bl	943c <ticker_update>
				     ull_adv_handle_get(adv)),
				    random_delay,
				    0, 0, 0, 0, 0,
				    ticker_op_update_cb, adv);
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    a94a:	f030 0302 	bics.w	r3, r0, #2
    a94e:	d00c      	beq.n	a96a <ticker_cb+0xd2>
    a950:	4a07      	ldr	r2, [pc, #28]	; (a970 <ticker_cb+0xd8>)
    a952:	490f      	ldr	r1, [pc, #60]	; (a990 <ticker_cb+0xf8>)
    a954:	4808      	ldr	r0, [pc, #32]	; (a978 <ticker_cb+0xe0>)
    a956:	f240 4353 	movw	r3, #1107	; 0x453
    a95a:	f00a f8e6 	bl	14b2a <printk>
    a95e:	4040      	eors	r0, r0
    a960:	f380 8811 	msr	BASEPRI, r0
    a964:	f04f 0003 	mov.w	r0, #3
    a968:	df02      	svc	2
			  (ret == TICKER_STATUS_BUSY));
	}

	DEBUG_RADIO_PREPARE_A(1);
}
    a96a:	b00a      	add	sp, #40	; 0x28
    a96c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a970:	0001b4ad 	.word	0x0001b4ad
    a974:	0001b48c 	.word	0x0001b48c
    a978:	0001aebe 	.word	0x0001aebe
    a97c:	200035c0 	.word	0x200035c0
    a980:	2000bf50 	.word	0x2000bf50
    a984:	0001b46e 	.word	0x0001b46e
    a988:	200034e8 	.word	0x200034e8
    a98c:	0000a995 	.word	0x0000a995
    a990:	0001b4ec 	.word	0x0001b4ec

0000a994 <ticker_op_update_cb>:

static void ticker_op_update_cb(u32_t status, void *param)
{
    a994:	b510      	push	{r4, lr}
    a996:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
    a998:	b180      	cbz	r0, a9bc <ticker_op_update_cb+0x28>
    a99a:	f7ff fd93 	bl	a4c4 <ull_disable_mark_get>
    a99e:	4284      	cmp	r4, r0
    a9a0:	d00c      	beq.n	a9bc <ticker_op_update_cb+0x28>
    a9a2:	4a07      	ldr	r2, [pc, #28]	; (a9c0 <ticker_op_update_cb+0x2c>)
    a9a4:	4907      	ldr	r1, [pc, #28]	; (a9c4 <ticker_op_update_cb+0x30>)
    a9a6:	4808      	ldr	r0, [pc, #32]	; (a9c8 <ticker_op_update_cb+0x34>)
    a9a8:	f240 435c 	movw	r3, #1116	; 0x45c
    a9ac:	f00a f8bd 	bl	14b2a <printk>
    a9b0:	4040      	eors	r0, r0
    a9b2:	f380 8811 	msr	BASEPRI, r0
    a9b6:	f04f 0003 	mov.w	r0, #3
    a9ba:	df02      	svc	2
		  param == ull_disable_mark_get());
}
    a9bc:	bd10      	pop	{r4, pc}
    a9be:	bf00      	nop
    a9c0:	0001b4ad 	.word	0x0001b4ad
    a9c4:	0001b505 	.word	0x0001b505
    a9c8:	0001aebe 	.word	0x0001aebe

0000a9cc <ll_adv_params_set>:
{
    a9cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    a9ce:	4c31      	ldr	r4, [pc, #196]	; (aa94 <ll_adv_params_set+0xc8>)
{
    a9d0:	4607      	mov	r7, r0
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    a9d2:	6820      	ldr	r0, [r4, #0]
    a9d4:	9000      	str	r0, [sp, #0]
    a9d6:	7920      	ldrb	r0, [r4, #4]
	if (!adv || adv->is_enabled) {
    a9d8:	4c2f      	ldr	r4, [pc, #188]	; (aa98 <ll_adv_params_set+0xcc>)
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    a9da:	f88d 0004 	strb.w	r0, [sp, #4]
	if (!adv || adv->is_enabled) {
    a9de:	f894 60c8 	ldrb.w	r6, [r4, #200]	; 0xc8
    a9e2:	f016 0601 	ands.w	r6, r6, #1
    a9e6:	d152      	bne.n	aa8e <ll_adv_params_set+0xc2>
	adv->lll.chan_map = chan_map;
    a9e8:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
    a9ec:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
    a9f0:	f000 0007 	and.w	r0, r0, #7
    a9f4:	ea40 1085 	orr.w	r0, r0, r5, lsl #6
    a9f8:	f894 5024 	ldrb.w	r5, [r4, #36]	; 0x24
	pdu->type = pdu_adv_type[adv_type];
    a9fc:	f10d 0c08 	add.w	ip, sp, #8
		adv->interval = 0;
    aa00:	2901      	cmp	r1, #1
	adv->lll.chan_map = chan_map;
    aa02:	f005 0538 	and.w	r5, r5, #56	; 0x38
	pdu->type = pdu_adv_type[adv_type];
    aa06:	4461      	add	r1, ip
	adv->lll.chan_map = chan_map;
    aa08:	ea40 0005 	orr.w	r0, r0, r5
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    aa0c:	f894 5026 	ldrb.w	r5, [r4, #38]	; 0x26
    aa10:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
	pdu->type = pdu_adv_type[adv_type];
    aa14:	f811 1c08 	ldrb.w	r1, [r1, #-8]
    aa18:	f04f 0027 	mov.w	r0, #39	; 0x27
    aa1c:	fb05 0000 	mla	r0, r5, r0, r0
    aa20:	ea4f 1582 	mov.w	r5, r2, lsl #6
    aa24:	f001 010f 	and.w	r1, r1, #15
    aa28:	f005 0240 	and.w	r2, r5, #64	; 0x40
    aa2c:	ea42 0201 	orr.w	r2, r2, r1
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    aa30:	f002 010f 	and.w	r1, r2, #15
		adv->interval = 0;
    aa34:	bf08      	it	eq
    aa36:	2700      	moveq	r7, #0
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    aa38:	2901      	cmp	r1, #1
    aa3a:	f8a4 70ca 	strh.w	r7, [r4, #202]	; 0xca
	pdu->type = pdu_adv_type[adv_type];
    aa3e:	5422      	strb	r2, [r4, r0]
    aa40:	eb04 0700 	add.w	r7, r4, r0
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    aa44:	d11e      	bne.n	aa84 <ll_adv_params_set+0xb8>
		pdu->rx_addr = direct_addr_type;
    aa46:	f363 12c7 	bfi	r2, r3, #7, #1
    aa4a:	5422      	strb	r2, [r4, r0]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
    aa4c:	9908      	ldr	r1, [sp, #32]
    aa4e:	2206      	movs	r2, #6
    aa50:	f107 0008 	add.w	r0, r7, #8
    aa54:	f00b faf1 	bl	1603a <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
    aa58:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
    aa5a:	707b      	strb	r3, [r7, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    aa5c:	f894 1076 	ldrb.w	r1, [r4, #118]	; 0x76
    aa60:	2277      	movs	r2, #119	; 0x77
    aa62:	2327      	movs	r3, #39	; 0x27
    aa64:	fb13 2301 	smlabb	r3, r3, r1, r2
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    aa68:	f005 0540 	and.w	r5, r5, #64	; 0x40
    aa6c:	f045 0504 	orr.w	r5, r5, #4
    aa70:	54e5      	strb	r5, [r4, r3]
    aa72:	18e2      	adds	r2, r4, r3
	if (pdu->len == 0) {
    aa74:	7853      	ldrb	r3, [r2, #1]
    aa76:	b913      	cbnz	r3, aa7e <ll_adv_params_set+0xb2>
		pdu->len = BDADDR_SIZE;
    aa78:	2106      	movs	r1, #6
    aa7a:	7051      	strb	r1, [r2, #1]
	return 0;
    aa7c:	461e      	mov	r6, r3
}
    aa7e:	4630      	mov	r0, r6
    aa80:	b003      	add	sp, #12
    aa82:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (pdu->len == 0) {
    aa84:	787b      	ldrb	r3, [r7, #1]
    aa86:	2b00      	cmp	r3, #0
    aa88:	d1e8      	bne.n	aa5c <ll_adv_params_set+0x90>
		pdu->len = BDADDR_SIZE;
    aa8a:	2306      	movs	r3, #6
    aa8c:	e7e5      	b.n	aa5a <ll_adv_params_set+0x8e>
		return BT_HCI_ERR_CMD_DISALLOWED;
    aa8e:	260c      	movs	r6, #12
    aa90:	e7f5      	b.n	aa7e <ll_adv_params_set+0xb2>
    aa92:	bf00      	nop
    aa94:	0001970e 	.word	0x0001970e
    aa98:	200034e8 	.word	0x200034e8

0000aa9c <ll_adv_data_set>:
{
    aa9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    aaa0:	4c1d      	ldr	r4, [pc, #116]	; (ab18 <ll_adv_data_set+0x7c>)
    aaa2:	f894 5026 	ldrb.w	r5, [r4, #38]	; 0x26
    aaa6:	2327      	movs	r3, #39	; 0x27
    aaa8:	fb05 3303 	mla	r3, r5, r3, r3
    aaac:	460f      	mov	r7, r1
    aaae:	18e1      	adds	r1, r4, r3
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
    aab0:	5ce3      	ldrb	r3, [r4, r3]
{
    aab2:	4606      	mov	r6, r0
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
    aab4:	f003 000f 	and.w	r0, r3, #15
    aab8:	2801      	cmp	r0, #1
    aaba:	f105 0201 	add.w	r2, r5, #1
    aabe:	d027      	beq.n	ab10 <ll_adv_data_set+0x74>
	if (pdu->first == pdu->last) {
    aac0:	f894 0025 	ldrb.w	r0, [r4, #37]	; 0x25
    aac4:	42a8      	cmp	r0, r5
    aac6:	d103      	bne.n	aad0 <ll_adv_data_set+0x34>
		last = pdu->last + 1;
    aac8:	b2d5      	uxtb	r5, r2
			last = 0U;
    aaca:	2d02      	cmp	r5, #2
    aacc:	bf08      	it	eq
    aace:	2500      	moveq	r5, #0
	pdu->tx_addr = prev->tx_addr;
    aad0:	f3c3 1c80 	ubfx	ip, r3, #6, #1
	pdu->type = prev->type;
    aad4:	f3c3 0003 	ubfx	r0, r3, #0, #4
	return (void *)pdu->pdu[last];
    aad8:	2227      	movs	r2, #39	; 0x27
    aada:	ea40 108c 	orr.w	r0, r0, ip, lsl #6
    aade:	fb05 2202 	mla	r2, r5, r2, r2
    aae2:	f003 0380 	and.w	r3, r3, #128	; 0x80
    aae6:	eb04 0802 	add.w	r8, r4, r2
    aaea:	4303      	orrs	r3, r0
    aaec:	54a3      	strb	r3, [r4, r2]
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
    aaee:	3102      	adds	r1, #2
    aaf0:	2206      	movs	r2, #6
    aaf2:	f108 0002 	add.w	r0, r8, #2
    aaf6:	f00b faa0 	bl	1603a <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
    aafa:	4632      	mov	r2, r6
    aafc:	4639      	mov	r1, r7
    aafe:	f108 0008 	add.w	r0, r8, #8
	pdu->len = BDADDR_SIZE + len;
    ab02:	3606      	adds	r6, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
    ab04:	f00b fa99 	bl	1603a <memcpy>
	pdu->len = BDADDR_SIZE + len;
    ab08:	f888 6001 	strb.w	r6, [r8, #1]
	pdu->last = idx;
    ab0c:	f884 5026 	strb.w	r5, [r4, #38]	; 0x26
}
    ab10:	2000      	movs	r0, #0
    ab12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ab16:	bf00      	nop
    ab18:	200034e8 	.word	0x200034e8

0000ab1c <ll_adv_scan_rsp_set>:
{
    ab1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    ab20:	4b19      	ldr	r3, [pc, #100]	; (ab88 <ll_adv_scan_rsp_set+0x6c>)
    ab22:	f893 4076 	ldrb.w	r4, [r3, #118]	; 0x76
    ab26:	2277      	movs	r2, #119	; 0x77
    ab28:	4605      	mov	r5, r0
    ab2a:	2027      	movs	r0, #39	; 0x27
    ab2c:	fb10 2004 	smlabb	r0, r0, r4, r2
	if (pdu->first == pdu->last) {
    ab30:	f893 2075 	ldrb.w	r2, [r3, #117]	; 0x75
    ab34:	42a2      	cmp	r2, r4
    ab36:	4688      	mov	r8, r1
    ab38:	461e      	mov	r6, r3
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    ab3a:	eb03 0100 	add.w	r1, r3, r0
	if (pdu->first == pdu->last) {
    ab3e:	d104      	bne.n	ab4a <ll_adv_scan_rsp_set+0x2e>
		last = pdu->last + 1;
    ab40:	3401      	adds	r4, #1
    ab42:	b2e4      	uxtb	r4, r4
			last = 0U;
    ab44:	2c02      	cmp	r4, #2
    ab46:	bf08      	it	eq
    ab48:	2400      	moveq	r4, #0
	pdu->tx_addr = prev->tx_addr;
    ab4a:	5c1b      	ldrb	r3, [r3, r0]
	return (void *)pdu->pdu[last];
    ab4c:	2777      	movs	r7, #119	; 0x77
    ab4e:	2227      	movs	r2, #39	; 0x27
    ab50:	f3c3 1380 	ubfx	r3, r3, #6, #1
    ab54:	fb12 7204 	smlabb	r2, r2, r4, r7
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    ab58:	019b      	lsls	r3, r3, #6
    ab5a:	18b7      	adds	r7, r6, r2
    ab5c:	f043 0304 	orr.w	r3, r3, #4
    ab60:	54b3      	strb	r3, [r6, r2]
	pdu->len = BDADDR_SIZE + len;
    ab62:	1dab      	adds	r3, r5, #6
    ab64:	707b      	strb	r3, [r7, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
    ab66:	2206      	movs	r2, #6
    ab68:	3102      	adds	r1, #2
    ab6a:	1cb8      	adds	r0, r7, #2
    ab6c:	f00b fa65 	bl	1603a <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
    ab70:	462a      	mov	r2, r5
    ab72:	4641      	mov	r1, r8
    ab74:	f107 0008 	add.w	r0, r7, #8
    ab78:	f00b fa5f 	bl	1603a <memcpy>
	pdu->last = idx;
    ab7c:	f886 4076 	strb.w	r4, [r6, #118]	; 0x76
}
    ab80:	2000      	movs	r0, #0
    ab82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ab86:	bf00      	nop
    ab88:	200034e8 	.word	0x200034e8

0000ab8c <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
    ab8c:	6800      	ldr	r0, [r0, #0]
    ab8e:	4b03      	ldr	r3, [pc, #12]	; (ab9c <ull_adv_lll_handle_get+0x10>)
    ab90:	1ac0      	subs	r0, r0, r3
    ab92:	23cc      	movs	r3, #204	; 0xcc
    ab94:	fbb0 f0f3 	udiv	r0, r0, r3
}
    ab98:	b280      	uxth	r0, r0
    ab9a:	4770      	bx	lr
    ab9c:	200034e8 	.word	0x200034e8

0000aba0 <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
    aba0:	b938      	cbnz	r0, abb2 <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
    aba2:	4805      	ldr	r0, [pc, #20]	; (abb8 <ull_adv_is_enabled_get+0x18>)
    aba4:	f890 30c8 	ldrb.w	r3, [r0, #200]	; 0xc8
	return &ll_adv[handle];
    aba8:	f013 0f01 	tst.w	r3, #1
    abac:	bf08      	it	eq
    abae:	2000      	moveq	r0, #0
    abb0:	4770      	bx	lr
		return NULL;
    abb2:	2000      	movs	r0, #0
}
    abb4:	4770      	bx	lr
    abb6:	bf00      	nop
    abb8:	200034e8 	.word	0x200034e8

0000abbc <disable.constprop.0>:
	ll_rx_link_release(adv->link_cc_free);
	adv->link_cc_free = NULL;
}
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
    abbc:	b530      	push	{r4, r5, lr}
    abbe:	b085      	sub	sp, #20
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    abc0:	2302      	movs	r3, #2
	struct ll_adv_set *adv;
	void *mark;
	u32_t ret;

	adv = ull_adv_is_enabled_get(handle);
    abc2:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    abc4:	9303      	str	r3, [sp, #12]
	adv = ull_adv_is_enabled_get(handle);
    abc6:	f7ff ffeb 	bl	aba0 <ull_adv_is_enabled_get>
	if (!adv) {
    abca:	4604      	mov	r4, r0
    abcc:	b910      	cbnz	r0, abd4 <disable.constprop.0+0x18>
	ret = ull_ticker_status_take(ret, &ret_cb);
	if (ret) {
		mark = ull_disable_mark(adv);
		LL_ASSERT(mark == adv);

		return BT_HCI_ERR_CMD_DISALLOWED;
    abce:	200c      	movs	r0, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
}
    abd0:	b005      	add	sp, #20
    abd2:	bd30      	pop	{r4, r5, pc}
	mark = ull_disable_mark(adv);
    abd4:	f7ff fc60 	bl	a498 <ull_disable_mark>
	LL_ASSERT(mark == adv);
    abd8:	4284      	cmp	r4, r0
    abda:	d00c      	beq.n	abf6 <disable.constprop.0+0x3a>
    abdc:	4a2b      	ldr	r2, [pc, #172]	; (ac8c <disable.constprop.0+0xd0>)
    abde:	492c      	ldr	r1, [pc, #176]	; (ac90 <disable.constprop.0+0xd4>)
    abe0:	482c      	ldr	r0, [pc, #176]	; (ac94 <disable.constprop.0+0xd8>)
    abe2:	f240 43ec 	movw	r3, #1260	; 0x4ec
    abe6:	f009 ffa0 	bl	14b2a <printk>
    abea:	4040      	eors	r0, r0
    abec:	f380 8811 	msr	BASEPRI, r0
    abf0:	f04f 0003 	mov.w	r0, #3
    abf4:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    abf6:	ad03      	add	r5, sp, #12
    abf8:	2103      	movs	r1, #3
    abfa:	4b27      	ldr	r3, [pc, #156]	; (ac98 <disable.constprop.0+0xdc>)
    abfc:	9500      	str	r5, [sp, #0]
    abfe:	2202      	movs	r2, #2
    ac00:	2000      	movs	r0, #0
    ac02:	f7fe fc63 	bl	94cc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
    ac06:	4629      	mov	r1, r5
    ac08:	f7ff fc3a 	bl	a480 <ull_ticker_status_take>
	if (ret) {
    ac0c:	b190      	cbz	r0, ac34 <disable.constprop.0+0x78>
		mark = ull_disable_mark(adv);
    ac0e:	4620      	mov	r0, r4
    ac10:	f7ff fc42 	bl	a498 <ull_disable_mark>
		LL_ASSERT(mark == adv);
    ac14:	4284      	cmp	r4, r0
    ac16:	d0da      	beq.n	abce <disable.constprop.0+0x12>
    ac18:	4a1c      	ldr	r2, [pc, #112]	; (ac8c <disable.constprop.0+0xd0>)
    ac1a:	491d      	ldr	r1, [pc, #116]	; (ac90 <disable.constprop.0+0xd4>)
    ac1c:	481d      	ldr	r0, [pc, #116]	; (ac94 <disable.constprop.0+0xd8>)
    ac1e:	f240 5305 	movw	r3, #1285	; 0x505
    ac22:	f009 ff82 	bl	14b2a <printk>
    ac26:	4040      	eors	r0, r0
    ac28:	f380 8811 	msr	BASEPRI, r0
    ac2c:	f04f 0003 	mov.w	r0, #3
    ac30:	df02      	svc	2
    ac32:	e7cc      	b.n	abce <disable.constprop.0+0x12>
	ret = ull_disable(&adv->lll);
    ac34:	f104 001c 	add.w	r0, r4, #28
    ac38:	f7ff fc4a 	bl	a4d0 <ull_disable>
	LL_ASSERT(!ret);
    ac3c:	b160      	cbz	r0, ac58 <disable.constprop.0+0x9c>
    ac3e:	4a13      	ldr	r2, [pc, #76]	; (ac8c <disable.constprop.0+0xd0>)
    ac40:	4916      	ldr	r1, [pc, #88]	; (ac9c <disable.constprop.0+0xe0>)
    ac42:	4814      	ldr	r0, [pc, #80]	; (ac94 <disable.constprop.0+0xd8>)
    ac44:	f240 530b 	movw	r3, #1291	; 0x50b
    ac48:	f009 ff6f 	bl	14b2a <printk>
    ac4c:	4040      	eors	r0, r0
    ac4e:	f380 8811 	msr	BASEPRI, r0
    ac52:	f04f 0003 	mov.w	r0, #3
    ac56:	df02      	svc	2
	mark = ull_disable_unmark(adv);
    ac58:	4620      	mov	r0, r4
    ac5a:	f7ff fc25 	bl	a4a8 <ull_disable_unmark>
	LL_ASSERT(mark == adv);
    ac5e:	4284      	cmp	r4, r0
    ac60:	d00c      	beq.n	ac7c <disable.constprop.0+0xc0>
    ac62:	4a0a      	ldr	r2, [pc, #40]	; (ac8c <disable.constprop.0+0xd0>)
    ac64:	490a      	ldr	r1, [pc, #40]	; (ac90 <disable.constprop.0+0xd4>)
    ac66:	480b      	ldr	r0, [pc, #44]	; (ac94 <disable.constprop.0+0xd8>)
    ac68:	f240 530e 	movw	r3, #1294	; 0x50e
    ac6c:	f009 ff5d 	bl	14b2a <printk>
    ac70:	4040      	eors	r0, r0
    ac72:	f380 8811 	msr	BASEPRI, r0
    ac76:	f04f 0003 	mov.w	r0, #3
    ac7a:	df02      	svc	2
	adv->is_enabled = 0U;
    ac7c:	f894 30c8 	ldrb.w	r3, [r4, #200]	; 0xc8
    ac80:	f36f 0300 	bfc	r3, #0, #1
    ac84:	f884 30c8 	strb.w	r3, [r4, #200]	; 0xc8
	return 0;
    ac88:	2000      	movs	r0, #0
    ac8a:	e7a1      	b.n	abd0 <disable.constprop.0+0x14>
    ac8c:	0001b4ad 	.word	0x0001b4ad
    ac90:	0001b534 	.word	0x0001b534
    ac94:	0001aebe 	.word	0x0001aebe
    ac98:	0000a475 	.word	0x0000a475
    ac9c:	0001b46e 	.word	0x0001b46e

0000aca0 <ticker_cb>:
	return 0;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
    aca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aca2:	461c      	mov	r4, r3
    aca4:	7c1b      	ldrb	r3, [r3, #16]
    aca6:	3301      	adds	r3, #1
    aca8:	b2db      	uxtb	r3, r3
    acaa:	4607      	mov	r7, r0
    acac:	460e      	mov	r6, r1
    acae:	4615      	mov	r5, r2
    acb0:	7423      	strb	r3, [r4, #16]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
    acb2:	b963      	cbnz	r3, acce <ticker_cb+0x2e>
    acb4:	4a14      	ldr	r2, [pc, #80]	; (ad08 <ticker_cb+0x68>)
    acb6:	4915      	ldr	r1, [pc, #84]	; (ad0c <ticker_cb+0x6c>)
    acb8:	4815      	ldr	r0, [pc, #84]	; (ad10 <ticker_cb+0x70>)
    acba:	f44f 73c4 	mov.w	r3, #392	; 0x188
    acbe:	f009 ff34 	bl	14b2a <printk>
    acc2:	4040      	eors	r0, r0
    acc4:	f380 8811 	msr	BASEPRI, r0
    acc8:	f04f 0003 	mov.w	r0, #3
    accc:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
    acce:	4a11      	ldr	r2, [pc, #68]	; (ad14 <ticker_cb+0x74>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.param = &scan->lll;
	mfy.param = &p;
    acd0:	4b11      	ldr	r3, [pc, #68]	; (ad18 <ticker_cb+0x78>)
	p.lazy = lazy;
    acd2:	8115      	strh	r5, [r2, #8]
	p.param = &scan->lll;
    acd4:	341c      	adds	r4, #28
	p.remainder = remainder;
    acd6:	e9c2 7600 	strd	r7, r6, [r2]
	p.param = &scan->lll;
    acda:	60d4      	str	r4, [r2, #12]
	mfy.param = &p;
    acdc:	609a      	str	r2, [r3, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    acde:	2200      	movs	r2, #0
    ace0:	4611      	mov	r1, r2
    ace2:	2001      	movs	r0, #1
    ace4:	f7fd fe10 	bl	8908 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    ace8:	b160      	cbz	r0, ad04 <ticker_cb+0x64>
    acea:	4a07      	ldr	r2, [pc, #28]	; (ad08 <ticker_cb+0x68>)
    acec:	490b      	ldr	r1, [pc, #44]	; (ad1c <ticker_cb+0x7c>)
    acee:	4808      	ldr	r0, [pc, #32]	; (ad10 <ticker_cb+0x70>)
    acf0:	f44f 73ca 	mov.w	r3, #404	; 0x194
    acf4:	f009 ff19 	bl	14b2a <printk>
    acf8:	4040      	eors	r0, r0
    acfa:	f380 8811 	msr	BASEPRI, r0
    acfe:	f04f 0003 	mov.w	r0, #3
    ad02:	df02      	svc	2
		LL_ASSERT(!retval);
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	DEBUG_RADIO_PREPARE_O(1);
}
    ad04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ad06:	bf00      	nop
    ad08:	0001b550 	.word	0x0001b550
    ad0c:	0001b48c 	.word	0x0001b48c
    ad10:	0001aebe 	.word	0x0001aebe
    ad14:	20003614 	.word	0x20003614
    ad18:	2000bf60 	.word	0x2000bf60
    ad1c:	0001b46e 	.word	0x0001b46e

0000ad20 <ull_scan_disable>:
{
    ad20:	b530      	push	{r4, r5, lr}
    ad22:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    ad24:	2302      	movs	r3, #2
{
    ad26:	4605      	mov	r5, r0
	mark = ull_disable_mark(scan);
    ad28:	4608      	mov	r0, r1
{
    ad2a:	460c      	mov	r4, r1
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    ad2c:	9303      	str	r3, [sp, #12]
	mark = ull_disable_mark(scan);
    ad2e:	f7ff fbb3 	bl	a498 <ull_disable_mark>
	LL_ASSERT(mark == scan);
    ad32:	4284      	cmp	r4, r0
    ad34:	d00c      	beq.n	ad50 <ull_scan_disable+0x30>
    ad36:	4a2a      	ldr	r2, [pc, #168]	; (ade0 <ull_scan_disable+0xc0>)
    ad38:	492a      	ldr	r1, [pc, #168]	; (ade4 <ull_scan_disable+0xc4>)
    ad3a:	482b      	ldr	r0, [pc, #172]	; (ade8 <ull_scan_disable+0xc8>)
    ad3c:	f240 1313 	movw	r3, #275	; 0x113
    ad40:	f009 fef3 	bl	14b2a <printk>
    ad44:	4040      	eors	r0, r0
    ad46:	f380 8811 	msr	BASEPRI, r0
    ad4a:	f04f 0003 	mov.w	r0, #3
    ad4e:	df02      	svc	2
			  TICKER_ID_SCAN_BASE + handle,
    ad50:	1d2a      	adds	r2, r5, #4
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    ad52:	ad03      	add	r5, sp, #12
    ad54:	2103      	movs	r1, #3
    ad56:	4b25      	ldr	r3, [pc, #148]	; (adec <ull_scan_disable+0xcc>)
    ad58:	9500      	str	r5, [sp, #0]
    ad5a:	b2d2      	uxtb	r2, r2
    ad5c:	2000      	movs	r0, #0
    ad5e:	f7fe fbb5 	bl	94cc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
    ad62:	4629      	mov	r1, r5
    ad64:	f7ff fb8c 	bl	a480 <ull_ticker_status_take>
	if (ret) {
    ad68:	b1a0      	cbz	r0, ad94 <ull_scan_disable+0x74>
		mark = ull_disable_unmark(scan);
    ad6a:	4620      	mov	r0, r4
    ad6c:	f7ff fb9c 	bl	a4a8 <ull_disable_unmark>
		LL_ASSERT(mark == scan);
    ad70:	4284      	cmp	r4, r0
    ad72:	d00c      	beq.n	ad8e <ull_scan_disable+0x6e>
    ad74:	4a1a      	ldr	r2, [pc, #104]	; (ade0 <ull_scan_disable+0xc0>)
    ad76:	491b      	ldr	r1, [pc, #108]	; (ade4 <ull_scan_disable+0xc4>)
    ad78:	481b      	ldr	r0, [pc, #108]	; (ade8 <ull_scan_disable+0xc8>)
    ad7a:	f44f 738e 	mov.w	r3, #284	; 0x11c
    ad7e:	f009 fed4 	bl	14b2a <printk>
    ad82:	4040      	eors	r0, r0
    ad84:	f380 8811 	msr	BASEPRI, r0
    ad88:	f04f 0003 	mov.w	r0, #3
    ad8c:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
    ad8e:	200c      	movs	r0, #12
}
    ad90:	b005      	add	sp, #20
    ad92:	bd30      	pop	{r4, r5, pc}
	ret = ull_disable(&scan->lll);
    ad94:	f104 001c 	add.w	r0, r4, #28
    ad98:	f7ff fb9a 	bl	a4d0 <ull_disable>
	LL_ASSERT(!ret);
    ad9c:	b160      	cbz	r0, adb8 <ull_scan_disable+0x98>
    ad9e:	4a10      	ldr	r2, [pc, #64]	; (ade0 <ull_scan_disable+0xc0>)
    ada0:	4913      	ldr	r1, [pc, #76]	; (adf0 <ull_scan_disable+0xd0>)
    ada2:	4811      	ldr	r0, [pc, #68]	; (ade8 <ull_scan_disable+0xc8>)
    ada4:	f44f 7391 	mov.w	r3, #290	; 0x122
    ada8:	f009 febf 	bl	14b2a <printk>
    adac:	4040      	eors	r0, r0
    adae:	f380 8811 	msr	BASEPRI, r0
    adb2:	f04f 0003 	mov.w	r0, #3
    adb6:	df02      	svc	2
	mark = ull_disable_unmark(scan);
    adb8:	4620      	mov	r0, r4
    adba:	f7ff fb75 	bl	a4a8 <ull_disable_unmark>
	LL_ASSERT(mark == scan);
    adbe:	4284      	cmp	r4, r0
    adc0:	d00c      	beq.n	addc <ull_scan_disable+0xbc>
    adc2:	4a07      	ldr	r2, [pc, #28]	; (ade0 <ull_scan_disable+0xc0>)
    adc4:	4907      	ldr	r1, [pc, #28]	; (ade4 <ull_scan_disable+0xc4>)
    adc6:	4808      	ldr	r0, [pc, #32]	; (ade8 <ull_scan_disable+0xc8>)
    adc8:	f240 1325 	movw	r3, #293	; 0x125
    adcc:	f009 fead 	bl	14b2a <printk>
    add0:	4040      	eors	r0, r0
    add2:	f380 8811 	msr	BASEPRI, r0
    add6:	f04f 0003 	mov.w	r0, #3
    adda:	df02      	svc	2
	return 0;
    addc:	2000      	movs	r0, #0
    adde:	e7d7      	b.n	ad90 <ull_scan_disable+0x70>
    ade0:	0001b550 	.word	0x0001b550
    ade4:	0001b590 	.word	0x0001b590
    ade8:	0001aebe 	.word	0x0001aebe
    adec:	0000a475 	.word	0x0000a475
    adf0:	0001b46e 	.word	0x0001b46e

0000adf4 <ull_scan_lll_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
    adf4:	6800      	ldr	r0, [r0, #0]
    adf6:	4b03      	ldr	r3, [pc, #12]	; (ae04 <ull_scan_lll_handle_get+0x10>)
    adf8:	1ac0      	subs	r0, r0, r3
    adfa:	233c      	movs	r3, #60	; 0x3c
    adfc:	fbb0 f0f3 	udiv	r0, r0, r3
}
    ae00:	b280      	uxth	r0, r0
    ae02:	4770      	bx	lr
    ae04:	200035d8 	.word	0x200035d8

0000ae08 <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
    ae08:	b938      	cbnz	r0, ae1a <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
    ae0a:	4805      	ldr	r0, [pc, #20]	; (ae20 <ull_scan_is_enabled_get+0x18>)
    ae0c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
	return &ll_scan[handle];
    ae10:	f013 0f01 	tst.w	r3, #1
    ae14:	bf08      	it	eq
    ae16:	2000      	moveq	r0, #0
    ae18:	4770      	bx	lr
		return NULL;
    ae1a:	2000      	movs	r0, #0
}
    ae1c:	4770      	bx	lr
    ae1e:	bf00      	nop
    ae20:	200035d8 	.word	0x200035d8

0000ae24 <ull_scan_is_disabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
    ae24:	b938      	cbnz	r0, ae36 <ull_scan_is_disabled_get+0x12>
	if (!scan || scan->is_enabled) {
    ae26:	4805      	ldr	r0, [pc, #20]	; (ae3c <ull_scan_is_disabled_get+0x18>)
    ae28:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
	return &ll_scan[handle];
    ae2c:	f013 0f01 	tst.w	r3, #1
    ae30:	bf18      	it	ne
    ae32:	2000      	movne	r0, #0
    ae34:	4770      	bx	lr
		return NULL;
    ae36:	2000      	movs	r0, #0
}
    ae38:	4770      	bx	lr
    ae3a:	bf00      	nop
    ae3c:	200035d8 	.word	0x200035d8

0000ae40 <ll_wl_clear>:
{
	return WL_SIZE;
}

u8_t ll_wl_clear(void)
{
    ae40:	b508      	push	{r3, lr}
#if defined(CONFIG_BT_BROADCASTER)
	if (ull_adv_filter_pol_get(0)) {
    ae42:	2000      	movs	r0, #0
    ae44:	f00b fd5d 	bl	16902 <ull_adv_filter_pol_get>
    ae48:	b108      	cbz	r0, ae4e <ll_wl_clear+0xe>
		return BT_HCI_ERR_CMD_DISALLOWED;
    ae4a:	200c      	movs	r0, #12
#endif /* CONFIG_BT_CTLR_PRIVACY */

	wl_anon = 0U;

	return 0;
}
    ae4c:	bd08      	pop	{r3, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
    ae4e:	f00b fdaa 	bl	169a6 <ull_scan_filter_pol_get>
    ae52:	f010 0001 	ands.w	r0, r0, #1
    ae56:	d1f8      	bne.n	ae4a <ll_wl_clear+0xa>
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
    ae58:	4b02      	ldr	r3, [pc, #8]	; (ae64 <ll_wl_clear+0x24>)
    ae5a:	7018      	strb	r0, [r3, #0]
	filter->addr_type_bitmask = 0;
    ae5c:	7058      	strb	r0, [r3, #1]
	wl_anon = 0U;
    ae5e:	4b02      	ldr	r3, [pc, #8]	; (ae68 <ll_wl_clear+0x28>)
    ae60:	7018      	strb	r0, [r3, #0]
	return 0;
    ae62:	e7f3      	b.n	ae4c <ll_wl_clear+0xc>
    ae64:	20008784 	.word	0x20008784
    ae68:	20008783 	.word	0x20008783

0000ae6c <ll_wl_add>:
{
    ae6c:	b570      	push	{r4, r5, r6, lr}
    ae6e:	4604      	mov	r4, r0
	if (ull_adv_filter_pol_get(0)) {
    ae70:	2000      	movs	r0, #0
    ae72:	f00b fd46 	bl	16902 <ull_adv_filter_pol_get>
    ae76:	b108      	cbz	r0, ae7c <ll_wl_add+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
    ae78:	200c      	movs	r0, #12
}
    ae7a:	bd70      	pop	{r4, r5, r6, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
    ae7c:	f00b fd93 	bl	169a6 <ull_scan_filter_pol_get>
    ae80:	f010 0001 	ands.w	r0, r0, #1
    ae84:	d1f8      	bne.n	ae78 <ll_wl_add+0xc>
	if (addr->type == ADDR_TYPE_ANON) {
    ae86:	7823      	ldrb	r3, [r4, #0]
    ae88:	2bff      	cmp	r3, #255	; 0xff
    ae8a:	d103      	bne.n	ae94 <ll_wl_add+0x28>
		wl_anon = 1U;
    ae8c:	4b12      	ldr	r3, [pc, #72]	; (aed8 <ll_wl_add+0x6c>)
    ae8e:	2201      	movs	r2, #1
    ae90:	701a      	strb	r2, [r3, #0]
		return 0;
    ae92:	e7f2      	b.n	ae7a <ll_wl_add+0xe>
	if (filter->enable_bitmask == 0xFF) {
    ae94:	4d11      	ldr	r5, [pc, #68]	; (aedc <ll_wl_add+0x70>)
    ae96:	782a      	ldrb	r2, [r5, #0]
    ae98:	2aff      	cmp	r2, #255	; 0xff
	return filter_add(&wl_filter, addr->type, addr->a.val);
    ae9a:	f104 0101 	add.w	r1, r4, #1
	if (filter->enable_bitmask == 0xFF) {
    ae9e:	d018      	beq.n	aed2 <ll_wl_add+0x66>
	     (filter->enable_bitmask & BIT(index));
    aea0:	fa22 f400 	lsr.w	r4, r2, r0
	for (index = 0;
    aea4:	f014 0401 	ands.w	r4, r4, #1
    aea8:	d111      	bne.n	aece <ll_wl_add+0x62>
	filter->enable_bitmask |= BIT(index);
    aeaa:	2601      	movs	r6, #1
    aeac:	4086      	lsls	r6, r0
    aeae:	4332      	orrs	r2, r6
    aeb0:	702a      	strb	r2, [r5, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    aeb2:	f003 0301 	and.w	r3, r3, #1
    aeb6:	786a      	ldrb	r2, [r5, #1]
    aeb8:	4083      	lsls	r3, r0
    aeba:	4313      	orrs	r3, r2
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    aebc:	2206      	movs	r2, #6
    aebe:	fb02 5000 	mla	r0, r2, r0, r5
    aec2:	3002      	adds	r0, #2
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    aec4:	706b      	strb	r3, [r5, #1]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    aec6:	f00b f8b8 	bl	1603a <memcpy>
	return filter_add(&wl_filter, addr->type, addr->a.val);
    aeca:	b2e0      	uxtb	r0, r4
    aecc:	e7d5      	b.n	ae7a <ll_wl_add+0xe>
	     index++) {
    aece:	3001      	adds	r0, #1
    aed0:	e7e6      	b.n	aea0 <ll_wl_add+0x34>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    aed2:	2407      	movs	r4, #7
    aed4:	e7f9      	b.n	aeca <ll_wl_add+0x5e>
    aed6:	bf00      	nop
    aed8:	20008783 	.word	0x20008783
    aedc:	20008784 	.word	0x20008784

0000aee0 <ll_wl_remove>:
{
    aee0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    aee4:	4682      	mov	sl, r0
	if (ull_adv_filter_pol_get(0)) {
    aee6:	2000      	movs	r0, #0
    aee8:	f00b fd0b 	bl	16902 <ull_adv_filter_pol_get>
    aeec:	b110      	cbz	r0, aef4 <ll_wl_remove+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
    aeee:	200c      	movs	r0, #12
}
    aef0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
    aef4:	f00b fd57 	bl	169a6 <ull_scan_filter_pol_get>
    aef8:	f010 0401 	ands.w	r4, r0, #1
    aefc:	d1f7      	bne.n	aeee <ll_wl_remove+0xe>
	if (addr->type == ADDR_TYPE_ANON) {
    aefe:	f89a 7000 	ldrb.w	r7, [sl]
    af02:	2fff      	cmp	r7, #255	; 0xff
    af04:	d103      	bne.n	af0e <ll_wl_remove+0x2e>
		wl_anon = 0U;
    af06:	4b18      	ldr	r3, [pc, #96]	; (af68 <ll_wl_remove+0x88>)
		return 0;
    af08:	4620      	mov	r0, r4
		wl_anon = 0U;
    af0a:	701c      	strb	r4, [r3, #0]
		return 0;
    af0c:	e7f0      	b.n	aef0 <ll_wl_remove+0x10>
	if (!filter->enable_bitmask) {
    af0e:	4d17      	ldr	r5, [pc, #92]	; (af6c <ll_wl_remove+0x8c>)
    af10:	782b      	ldrb	r3, [r5, #0]
	return filter_remove(&wl_filter, addr->type, addr->a.val);
    af12:	f10a 0a01 	add.w	sl, sl, #1
	if (!filter->enable_bitmask) {
    af16:	b913      	cbnz	r3, af1e <ll_wl_remove+0x3e>
		return BT_HCI_ERR_INVALID_PARAM;
    af18:	2412      	movs	r4, #18
	return filter_remove(&wl_filter, addr->type, addr->a.val);
    af1a:	b2e0      	uxtb	r0, r4
    af1c:	e7e8      	b.n	aef0 <ll_wl_remove+0x10>
	index = 8;
    af1e:	2608      	movs	r6, #8
		    !memcmp(filter->bdaddr[index], bdaddr, BDADDR_SIZE)) {
    af20:	f105 0802 	add.w	r8, r5, #2
    af24:	f04f 0906 	mov.w	r9, #6
	while (index--) {
    af28:	3e01      	subs	r6, #1
    af2a:	d3f5      	bcc.n	af18 <ll_wl_remove+0x38>
		if ((filter->enable_bitmask & BIT(index)) &&
    af2c:	782b      	ldrb	r3, [r5, #0]
    af2e:	40f3      	lsrs	r3, r6
    af30:	07da      	lsls	r2, r3, #31
    af32:	d5f9      	bpl.n	af28 <ll_wl_remove+0x48>
		    (((filter->addr_type_bitmask >> index) & 0x01) ==
    af34:	786b      	ldrb	r3, [r5, #1]
    af36:	4133      	asrs	r3, r6
    af38:	407b      	eors	r3, r7
		if ((filter->enable_bitmask & BIT(index)) &&
    af3a:	07db      	lsls	r3, r3, #31
    af3c:	d4f4      	bmi.n	af28 <ll_wl_remove+0x48>
		    !memcmp(filter->bdaddr[index], bdaddr, BDADDR_SIZE)) {
    af3e:	2206      	movs	r2, #6
    af40:	4651      	mov	r1, sl
    af42:	fb09 8006 	mla	r0, r9, r6, r8
    af46:	f00b f868 	bl	1601a <memcmp>
		     (addr_type & 0x01)) &&
    af4a:	2800      	cmp	r0, #0
    af4c:	d1ec      	bne.n	af28 <ll_wl_remove+0x48>
			filter->enable_bitmask &= ~BIT(index);
    af4e:	2301      	movs	r3, #1
    af50:	fa03 f606 	lsl.w	r6, r3, r6
    af54:	782b      	ldrb	r3, [r5, #0]
    af56:	ea23 0306 	bic.w	r3, r3, r6
    af5a:	702b      	strb	r3, [r5, #0]
			filter->addr_type_bitmask &= ~BIT(index);
    af5c:	786b      	ldrb	r3, [r5, #1]
    af5e:	ea23 0606 	bic.w	r6, r3, r6
    af62:	706e      	strb	r6, [r5, #1]
			return 0;
    af64:	e7d9      	b.n	af1a <ll_wl_remove+0x3a>
    af66:	bf00      	nop
    af68:	20008783 	.word	0x20008783
    af6c:	20008784 	.word	0x20008784

0000af70 <ull_filter_reset>:
	wl_anon = 0U;
    af70:	4a03      	ldr	r2, [pc, #12]	; (af80 <ull_filter_reset+0x10>)
    af72:	2300      	movs	r3, #0
    af74:	7013      	strb	r3, [r2, #0]
	filter->enable_bitmask = 0;
    af76:	4a03      	ldr	r2, [pc, #12]	; (af84 <ull_filter_reset+0x14>)
    af78:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
    af7a:	7053      	strb	r3, [r2, #1]
}
    af7c:	4770      	bx	lr
    af7e:	bf00      	nop
    af80:	20008783 	.word	0x20008783
    af84:	20008784 	.word	0x20008784

0000af88 <ull_filter_lll_get>:
{
    af88:	b508      	push	{r3, lr}
	LL_ASSERT(whitelist);
    af8a:	b960      	cbnz	r0, afa6 <ull_filter_lll_get+0x1e>
    af8c:	4a07      	ldr	r2, [pc, #28]	; (afac <ull_filter_lll_get+0x24>)
    af8e:	4908      	ldr	r1, [pc, #32]	; (afb0 <ull_filter_lll_get+0x28>)
    af90:	4808      	ldr	r0, [pc, #32]	; (afb4 <ull_filter_lll_get+0x2c>)
    af92:	f240 23d3 	movw	r3, #723	; 0x2d3
    af96:	f009 fdc8 	bl	14b2a <printk>
    af9a:	4040      	eors	r0, r0
    af9c:	f380 8811 	msr	BASEPRI, r0
    afa0:	f04f 0003 	mov.w	r0, #3
    afa4:	df02      	svc	2
}
    afa6:	4804      	ldr	r0, [pc, #16]	; (afb8 <ull_filter_lll_get+0x30>)
    afa8:	bd08      	pop	{r3, pc}
    afaa:	bf00      	nop
    afac:	0001b5ae 	.word	0x0001b5ae
    afb0:	0001b5f0 	.word	0x0001b5f0
    afb4:	0001aebe 	.word	0x0001aebe
    afb8:	20008784 	.word	0x20008784

0000afbc <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
    afbc:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
    afbe:	4b08      	ldr	r3, [pc, #32]	; (afe0 <rtc0_nrf5_isr+0x24>)
    afc0:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
    afc4:	b122      	cbz	r2, afd0 <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
    afc6:	2000      	movs	r0, #0
    afc8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
    afcc:	f7fe f9d6 	bl	937c <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
    afd0:	2001      	movs	r0, #1
    afd2:	f7fd fce9 	bl	89a8 <mayfly_run>
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
#endif

	DEBUG_TICKER_ISR(0);
}
    afd6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
    afda:	2002      	movs	r0, #2
    afdc:	f7fd bce4 	b.w	89a8 <mayfly_run>
    afe0:	4000b000 	.word	0x4000b000

0000afe4 <ticker_start_op_cb>:
	/* NOTE: this callback is present only for addition of debug messages
	 * when needed, else can be dispensed with.
	 */
	ARG_UNUSED(param);

	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
    afe4:	2801      	cmp	r0, #1
{
    afe6:	b508      	push	{r3, lr}
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
    afe8:	d90c      	bls.n	b004 <ticker_start_op_cb+0x20>
    afea:	4a07      	ldr	r2, [pc, #28]	; (b008 <ticker_start_op_cb+0x24>)
    afec:	4907      	ldr	r1, [pc, #28]	; (b00c <ticker_start_op_cb+0x28>)
    afee:	4808      	ldr	r0, [pc, #32]	; (b010 <ticker_start_op_cb+0x2c>)
    aff0:	f240 13f9 	movw	r3, #505	; 0x1f9
    aff4:	f009 fd99 	bl	14b2a <printk>
    aff8:	4040      	eors	r0, r0
    affa:	f380 8811 	msr	BASEPRI, r0
    affe:	f04f 0003 	mov.w	r0, #3
    b002:	df02      	svc	2
		  (status == TICKER_STATUS_FAILURE));
}
    b004:	bd08      	pop	{r3, pc}
    b006:	bf00      	nop
    b008:	0001b60d 	.word	0x0001b60d
    b00c:	0001b653 	.word	0x0001b653
    b010:	0001aebe 	.word	0x0001aebe

0000b014 <preempt_ticker_start>:

static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
{
    b014:	b530      	push	{r4, r5, lr}
	struct evt_hdr *evt;
	u32_t preempt_to;
	int ret;

	/* Calc the preempt timeout */
	evt = HDR_LLL2EVT(prepare_param->param);
    b016:	68c3      	ldr	r3, [r0, #12]
    b018:	6819      	ldr	r1, [r3, #0]
	preempt_to = MAX(evt->ticks_active_to_start,
			 evt->ticks_xtal_to_start) -
			 evt->ticks_preempt_to_start;

	/* Setup pre empt timeout */
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    b01a:	4b16      	ldr	r3, [pc, #88]	; (b074 <preempt_ticker_start+0x60>)
    b01c:	2200      	movs	r2, #0
{
    b01e:	b08b      	sub	sp, #44	; 0x2c
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    b020:	e9cd 2306 	strd	r2, r3, [sp, #24]
    b024:	4b14      	ldr	r3, [pc, #80]	; (b078 <preempt_ticker_start+0x64>)
    b026:	9208      	str	r2, [sp, #32]
    b028:	e9cd 2304 	strd	r2, r3, [sp, #16]
    b02c:	e9cd 2202 	strd	r2, r2, [sp, #8]
    b030:	9201      	str	r2, [sp, #4]
	preempt_to = MAX(evt->ticks_active_to_start,
    b032:	e9d1 5400 	ldrd	r5, r4, [r1]
    b036:	688b      	ldr	r3, [r1, #8]
    b038:	42a5      	cmp	r5, r4
    b03a:	bf2c      	ite	cs
    b03c:	ebc3 0305 	rsbcs	r3, r3, r5
    b040:	ebc3 0304 	rsbcc	r3, r3, r4
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    b044:	9300      	str	r3, [sp, #0]
    b046:	6803      	ldr	r3, [r0, #0]
    b048:	4611      	mov	r1, r2
    b04a:	4610      	mov	r0, r2
    b04c:	f00b fbd6 	bl	167fc <ticker_start>
			   TICKER_NULL_REMAINDER,
			   TICKER_NULL_LAZY,
			   TICKER_NULL_SLOT,
			   preempt_ticker_cb, NULL,
			   ticker_start_op_cb, NULL);
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    b050:	2802      	cmp	r0, #2
    b052:	d90c      	bls.n	b06e <preempt_ticker_start+0x5a>
    b054:	4a09      	ldr	r2, [pc, #36]	; (b07c <preempt_ticker_start+0x68>)
    b056:	490a      	ldr	r1, [pc, #40]	; (b080 <preempt_ticker_start+0x6c>)
    b058:	480a      	ldr	r0, [pc, #40]	; (b084 <preempt_ticker_start+0x70>)
    b05a:	f240 2317 	movw	r3, #535	; 0x217
    b05e:	f009 fd64 	bl	14b2a <printk>
    b062:	4040      	eors	r0, r0
    b064:	f380 8811 	msr	BASEPRI, r0
    b068:	f04f 0003 	mov.w	r0, #3
    b06c:	df02      	svc	2
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));
}
    b06e:	b00b      	add	sp, #44	; 0x2c
    b070:	bd30      	pop	{r4, r5, pc}
    b072:	bf00      	nop
    b074:	0000afe5 	.word	0x0000afe5
    b078:	0000b225 	.word	0x0000b225
    b07c:	0001b60d 	.word	0x0001b60d
    b080:	0001b672 	.word	0x0001b672
    b084:	0001aebe 	.word	0x0001aebe

0000b088 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
    b088:	b5f0      	push	{r4, r5, r6, r7, lr}
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
	int resume_prio;
	int ret;

	if (!event.curr.abort_cb || !event.curr.param) {
    b08a:	4d3c      	ldr	r5, [pc, #240]	; (b17c <preempt+0xf4>)
{
    b08c:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
    b08e:	f7ff facb 	bl	a628 <ull_prepare_dequeue_get>
	u8_t idx = UINT8_MAX;
    b092:	23ff      	movs	r3, #255	; 0xff
    b094:	f88d 300e 	strb.w	r3, [sp, #14]
	if (!event.curr.abort_cb || !event.curr.param) {
    b098:	68ab      	ldr	r3, [r5, #8]
    b09a:	b35b      	cbz	r3, b0f4 <preempt+0x6c>
    b09c:	682b      	ldr	r3, [r5, #0]
    b09e:	b34b      	cbz	r3, b0f4 <preempt+0x6c>
	if (!next) {
		return;
	}

	while (next && (next->is_aborted || next->is_resume)) {
		next = ull_prepare_dequeue_iter(&idx);
    b0a0:	f10d 000e 	add.w	r0, sp, #14
    b0a4:	f7ff fbb6 	bl	a814 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
    b0a8:	4604      	mov	r4, r0
    b0aa:	b318      	cbz	r0, b0f4 <preempt+0x6c>
    b0ac:	f890 0020 	ldrb.w	r0, [r0, #32]
    b0b0:	f010 0703 	ands.w	r7, r0, #3
    b0b4:	d1f4      	bne.n	b0a0 <preempt+0x18>

	if (!next) {
		return;
	}

	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
    b0b6:	ab05      	add	r3, sp, #20
    b0b8:	9300      	str	r3, [sp, #0]
    b0ba:	686e      	ldr	r6, [r5, #4]
    b0bc:	682a      	ldr	r2, [r5, #0]
    b0be:	69e1      	ldr	r1, [r4, #28]
    b0c0:	68e0      	ldr	r0, [r4, #12]
    b0c2:	ab04      	add	r3, sp, #16
    b0c4:	47b0      	blx	r6
				     event.curr.param,
				     &resume_cb, &resume_prio);
	if (!ret) {
    b0c6:	4606      	mov	r6, r0
    b0c8:	b9b0      	cbnz	r0, b0f8 <preempt+0x70>
		/* Let LLL know about the cancelled prepare */
		next->is_aborted = 1;
    b0ca:	f894 3020 	ldrb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    b0ce:	68e1      	ldr	r1, [r4, #12]
		next->is_aborted = 1;
    b0d0:	f043 0302 	orr.w	r3, r3, #2
    b0d4:	f884 3020 	strb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    b0d8:	4620      	mov	r0, r4
    b0da:	69a3      	ldr	r3, [r4, #24]
    b0dc:	4798      	blx	r3
		LL_ASSERT(ret == -ECANCELED);
	}

preempt_next:
	do {
		next = ull_prepare_dequeue_iter(&idx);
    b0de:	f10d 000e 	add.w	r0, sp, #14
    b0e2:	f7ff fb97 	bl	a814 <ull_prepare_dequeue_iter>
		if (!next) {
    b0e6:	b128      	cbz	r0, b0f4 <preempt+0x6c>
			return;
		}
	} while (next->is_aborted || next->is_resume);
    b0e8:	f890 3020 	ldrb.w	r3, [r0, #32]
    b0ec:	079b      	lsls	r3, r3, #30
    b0ee:	d1f6      	bne.n	b0de <preempt+0x56>

	preempt_ticker_start(&next->prepare_param);
    b0f0:	f7ff ff90 	bl	b014 <preempt_ticker_start>
}
    b0f4:	b00b      	add	sp, #44	; 0x2c
    b0f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	event.curr.abort_cb(NULL, event.curr.param);
    b0f8:	68ab      	ldr	r3, [r5, #8]
    b0fa:	6829      	ldr	r1, [r5, #0]
    b0fc:	4638      	mov	r0, r7
    b0fe:	4798      	blx	r3
	if (ret == -EAGAIN) {
    b100:	f116 0f0b 	cmn.w	r6, #11
    b104:	d133      	bne.n	b16e <preempt+0xe6>
		u8_t iter_idx = UINT8_MAX;
    b106:	23ff      	movs	r3, #255	; 0xff
    b108:	f88d 300f 	strb.w	r3, [sp, #15]
			iter = ull_prepare_dequeue_iter(&iter_idx);
    b10c:	f10d 000f 	add.w	r0, sp, #15
    b110:	f7ff fb80 	bl	a814 <ull_prepare_dequeue_iter>
		while (iter) {
    b114:	b9e0      	cbnz	r0, b150 <preempt+0xc8>
	prepare_param.param = event.curr.param;
    b116:	682b      	ldr	r3, [r5, #0]
    b118:	9309      	str	r3, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    b11a:	2301      	movs	r3, #1
    b11c:	9301      	str	r3, [sp, #4]
    b11e:	9b05      	ldr	r3, [sp, #20]
	event.curr.param = NULL;
    b120:	6028      	str	r0, [r5, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    b122:	9300      	str	r3, [sp, #0]
    b124:	e9d5 0101 	ldrd	r0, r1, [r5, #4]
    b128:	9b04      	ldr	r3, [sp, #16]
    b12a:	aa06      	add	r2, sp, #24
    b12c:	f7ff fa48 	bl	a5c0 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
    b130:	2800      	cmp	r0, #0
    b132:	d0d4      	beq.n	b0de <preempt+0x56>
    b134:	4a12      	ldr	r2, [pc, #72]	; (b180 <preempt+0xf8>)
    b136:	4913      	ldr	r1, [pc, #76]	; (b184 <preempt+0xfc>)
    b138:	f240 235f 	movw	r3, #607	; 0x25f
		LL_ASSERT(ret == -ECANCELED);
    b13c:	4812      	ldr	r0, [pc, #72]	; (b188 <preempt+0x100>)
    b13e:	f009 fcf4 	bl	14b2a <printk>
    b142:	4040      	eors	r0, r0
    b144:	f380 8811 	msr	BASEPRI, r0
    b148:	f04f 0003 	mov.w	r0, #3
    b14c:	df02      	svc	2
    b14e:	e7c6      	b.n	b0de <preempt+0x56>
			if (!iter->is_aborted &&
    b150:	f890 3020 	ldrb.w	r3, [r0, #32]
    b154:	079a      	lsls	r2, r3, #30
    b156:	d4d9      	bmi.n	b10c <preempt+0x84>
			    event.curr.param == iter->prepare_param.param) {
    b158:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
    b15a:	6829      	ldr	r1, [r5, #0]
    b15c:	4291      	cmp	r1, r2
    b15e:	d1d5      	bne.n	b10c <preempt+0x84>
				iter->is_aborted = 1;
    b160:	f043 0302 	orr.w	r3, r3, #2
    b164:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
    b168:	6983      	ldr	r3, [r0, #24]
    b16a:	4798      	blx	r3
    b16c:	e7ce      	b.n	b10c <preempt+0x84>
		LL_ASSERT(ret == -ECANCELED);
    b16e:	3648      	adds	r6, #72	; 0x48
    b170:	d0b5      	beq.n	b0de <preempt+0x56>
    b172:	4a03      	ldr	r2, [pc, #12]	; (b180 <preempt+0xf8>)
    b174:	4905      	ldr	r1, [pc, #20]	; (b18c <preempt+0x104>)
    b176:	f240 2361 	movw	r3, #609	; 0x261
    b17a:	e7df      	b.n	b13c <preempt+0xb4>
    b17c:	20003628 	.word	0x20003628
    b180:	0001b60d 	.word	0x0001b60d
    b184:	0001b46e 	.word	0x0001b46e
    b188:	0001aebe 	.word	0x0001aebe
    b18c:	0001b699 	.word	0x0001b699

0000b190 <prepare>:
{
    b190:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b194:	b085      	sub	sp, #20
    b196:	4698      	mov	r8, r3
    b198:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    b19a:	f89d 7034 	ldrb.w	r7, [sp, #52]	; 0x34
	u8_t idx = UINT8_MAX;
    b19e:	23ff      	movs	r3, #255	; 0xff
{
    b1a0:	4606      	mov	r6, r0
    b1a2:	4689      	mov	r9, r1
    b1a4:	4614      	mov	r4, r2
	u8_t idx = UINT8_MAX;
    b1a6:	f88d 300f 	strb.w	r3, [sp, #15]
		p = ull_prepare_dequeue_iter(&idx);
    b1aa:	f10d 000f 	add.w	r0, sp, #15
    b1ae:	f7ff fb31 	bl	a814 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
    b1b2:	b118      	cbz	r0, b1bc <prepare+0x2c>
    b1b4:	f890 3020 	ldrb.w	r3, [r0, #32]
    b1b8:	079b      	lsls	r3, r3, #30
    b1ba:	d1f6      	bne.n	b1aa <prepare+0x1a>
	if (event.curr.abort_cb || (p && is_resume)) {
    b1bc:	4b15      	ldr	r3, [pc, #84]	; (b214 <prepare+0x84>)
    b1be:	689a      	ldr	r2, [r3, #8]
    b1c0:	b90a      	cbnz	r2, b1c6 <prepare+0x36>
    b1c2:	b1e8      	cbz	r0, b200 <prepare+0x70>
    b1c4:	b1e7      	cbz	r7, b200 <prepare+0x70>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
    b1c6:	e9cd 8700 	strd	r8, r7, [sp]
    b1ca:	4623      	mov	r3, r4
    b1cc:	462a      	mov	r2, r5
    b1ce:	4649      	mov	r1, r9
    b1d0:	4630      	mov	r0, r6
    b1d2:	f7ff f9f5 	bl	a5c0 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
    b1d6:	b160      	cbz	r0, b1f2 <prepare+0x62>
    b1d8:	4a0f      	ldr	r2, [pc, #60]	; (b218 <prepare+0x88>)
    b1da:	4910      	ldr	r1, [pc, #64]	; (b21c <prepare+0x8c>)
    b1dc:	4810      	ldr	r0, [pc, #64]	; (b220 <prepare+0x90>)
    b1de:	f240 13ad 	movw	r3, #429	; 0x1ad
    b1e2:	f009 fca2 	bl	14b2a <printk>
    b1e6:	4040      	eors	r0, r0
    b1e8:	f380 8811 	msr	BASEPRI, r0
    b1ec:	f04f 0003 	mov.w	r0, #3
    b1f0:	df02      	svc	2
		if (is_resume) {
    b1f2:	b917      	cbnz	r7, b1fa <prepare+0x6a>
		preempt_ticker_start(prepare_param);
    b1f4:	4628      	mov	r0, r5
    b1f6:	f7ff ff0d 	bl	b014 <preempt_ticker_start>
		return -EINPROGRESS;
    b1fa:	f06f 0043 	mvn.w	r0, #67	; 0x43
    b1fe:	e006      	b.n	b20e <prepare+0x7e>
	event.curr.param = prepare_param->param;
    b200:	68ea      	ldr	r2, [r5, #12]
	event.curr.abort_cb = abort_cb;
    b202:	f8c3 9008 	str.w	r9, [r3, #8]
	event.curr.is_abort_cb = is_abort_cb;
    b206:	e9c3 2600 	strd	r2, r6, [r3]
	err = prepare_cb(prepare_param);
    b20a:	4628      	mov	r0, r5
    b20c:	47a0      	blx	r4
}
    b20e:	b005      	add	sp, #20
    b210:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    b214:	20003628 	.word	0x20003628
    b218:	0001b60d 	.word	0x0001b60d
    b21c:	0001b46e 	.word	0x0001b46e
    b220:	0001aebe 	.word	0x0001aebe

0000b224 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    b224:	2200      	movs	r2, #0
{
    b226:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    b228:	4611      	mov	r1, r2
    b22a:	4b09      	ldr	r3, [pc, #36]	; (b250 <preempt_ticker_cb+0x2c>)
    b22c:	2001      	movs	r0, #1
    b22e:	f7fd fb6b 	bl	8908 <mayfly_enqueue>
	LL_ASSERT(!ret);
    b232:	b160      	cbz	r0, b24e <preempt_ticker_cb+0x2a>
    b234:	4a07      	ldr	r2, [pc, #28]	; (b254 <preempt_ticker_cb+0x30>)
    b236:	4908      	ldr	r1, [pc, #32]	; (b258 <preempt_ticker_cb+0x34>)
    b238:	4808      	ldr	r0, [pc, #32]	; (b25c <preempt_ticker_cb+0x38>)
    b23a:	f240 2325 	movw	r3, #549	; 0x225
    b23e:	f009 fc74 	bl	14b2a <printk>
    b242:	4040      	eors	r0, r0
    b244:	f380 8811 	msr	BASEPRI, r0
    b248:	f04f 0003 	mov.w	r0, #3
    b24c:	df02      	svc	2
}
    b24e:	bd08      	pop	{r3, pc}
    b250:	2000bf70 	.word	0x2000bf70
    b254:	0001b60d 	.word	0x0001b60d
    b258:	0001b46e 	.word	0x0001b46e
    b25c:	0001aebe 	.word	0x0001aebe

0000b260 <lll_init>:
{
    b260:	b510      	push	{r4, lr}
    b262:	4815      	ldr	r0, [pc, #84]	; (b2b8 <lll_init+0x58>)
    b264:	f008 fa02 	bl	1366c <z_impl_device_get_binding>
	dev_entropy =
    b268:	4b14      	ldr	r3, [pc, #80]	; (b2bc <lll_init+0x5c>)
    b26a:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
    b26c:	b300      	cbz	r0, b2b0 <lll_init+0x50>
	event.curr.abort_cb = NULL;
    b26e:	4b14      	ldr	r3, [pc, #80]	; (b2c0 <lll_init+0x60>)
    b270:	2200      	movs	r2, #0
    b272:	609a      	str	r2, [r3, #8]
	err = lll_clock_init();
    b274:	f000 f920 	bl	b4b8 <lll_clock_init>
	if (err) {
    b278:	4604      	mov	r4, r0
    b27a:	b9b8      	cbnz	r0, b2ac <lll_init+0x4c>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
    b27c:	4602      	mov	r2, r0
    b27e:	4601      	mov	r1, r0
    b280:	2001      	movs	r0, #1
    b282:	f7fa fc5b 	bl	5b3c <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
    b286:	4622      	mov	r2, r4
    b288:	4621      	mov	r1, r4
    b28a:	200b      	movs	r0, #11
    b28c:	f7fa fc56 	bl	5b3c <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
    b290:	4622      	mov	r2, r4
    b292:	4621      	mov	r1, r4
    b294:	2018      	movs	r0, #24
    b296:	f7fa fc51 	bl	5b3c <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
    b29a:	2001      	movs	r0, #1
    b29c:	f7fa fc1c 	bl	5ad8 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
    b2a0:	200b      	movs	r0, #11
    b2a2:	f7fa fc19 	bl	5ad8 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
    b2a6:	2018      	movs	r0, #24
    b2a8:	f7fa fc16 	bl	5ad8 <arch_irq_enable>
}
    b2ac:	4620      	mov	r0, r4
    b2ae:	bd10      	pop	{r4, pc}
		return -ENODEV;
    b2b0:	f06f 0412 	mvn.w	r4, #18
    b2b4:	e7fa      	b.n	b2ac <lll_init+0x4c>
    b2b6:	bf00      	nop
    b2b8:	0001b210 	.word	0x0001b210
    b2bc:	20003624 	.word	0x20003624
    b2c0:	20003628 	.word	0x20003628

0000b2c4 <lll_entropy_get>:
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
    b2c4:	4b06      	ldr	r3, [pc, #24]	; (b2e0 <lll_entropy_get+0x1c>)
{
    b2c6:	4602      	mov	r2, r0
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
    b2c8:	6818      	ldr	r0, [r3, #0]
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
    b2ca:	6843      	ldr	r3, [r0, #4]
{
    b2cc:	b510      	push	{r4, lr}
    b2ce:	685c      	ldr	r4, [r3, #4]
    b2d0:	b11c      	cbz	r4, b2da <lll_entropy_get+0x16>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
    b2d2:	2300      	movs	r3, #0
    b2d4:	47a0      	blx	r4
}
    b2d6:	b2c0      	uxtb	r0, r0
    b2d8:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
    b2da:	f06f 0022 	mvn.w	r0, #34	; 0x22
    b2de:	e7fa      	b.n	b2d6 <lll_entropy_get+0x12>
    b2e0:	20003624 	.word	0x20003624

0000b2e4 <lll_resume>:
{
    b2e4:	b507      	push	{r0, r1, r2, lr}
		      next->prio, &next->prepare_param, next->is_resume);
    b2e6:	f890 3020 	ldrb.w	r3, [r0, #32]
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
    b2ea:	f003 0301 	and.w	r3, r3, #1
    b2ee:	e9cd 0300 	strd	r0, r3, [sp]
    b2f2:	69c3      	ldr	r3, [r0, #28]
    b2f4:	6902      	ldr	r2, [r0, #16]
    b2f6:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
    b2fa:	f7ff ff49 	bl	b190 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
    b2fe:	b168      	cbz	r0, b31c <lll_resume+0x38>
    b300:	3044      	adds	r0, #68	; 0x44
    b302:	d00b      	beq.n	b31c <lll_resume+0x38>
    b304:	4a07      	ldr	r2, [pc, #28]	; (b324 <lll_resume+0x40>)
    b306:	4908      	ldr	r1, [pc, #32]	; (b328 <lll_resume+0x44>)
    b308:	4808      	ldr	r0, [pc, #32]	; (b32c <lll_resume+0x48>)
    b30a:	23d3      	movs	r3, #211	; 0xd3
    b30c:	f009 fc0d 	bl	14b2a <printk>
    b310:	4040      	eors	r0, r0
    b312:	f380 8811 	msr	BASEPRI, r0
    b316:	f04f 0003 	mov.w	r0, #3
    b31a:	df02      	svc	2
}
    b31c:	b003      	add	sp, #12
    b31e:	f85d fb04 	ldr.w	pc, [sp], #4
    b322:	bf00      	nop
    b324:	0001b60d 	.word	0x0001b60d
    b328:	0001b6a4 	.word	0x0001b6a4
    b32c:	0001aebe 	.word	0x0001aebe

0000b330 <lll_disable>:
{
    b330:	b513      	push	{r0, r1, r4, lr}
    b332:	4b1b      	ldr	r3, [pc, #108]	; (b3a0 <lll_disable+0x70>)
	if (!param || (param == event.curr.param)) {
    b334:	4604      	mov	r4, r0
    b336:	b110      	cbz	r0, b33e <lll_disable+0xe>
    b338:	681a      	ldr	r2, [r3, #0]
    b33a:	4282      	cmp	r2, r0
    b33c:	d105      	bne.n	b34a <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
    b33e:	689a      	ldr	r2, [r3, #8]
    b340:	b16a      	cbz	r2, b35e <lll_disable+0x2e>
    b342:	6819      	ldr	r1, [r3, #0]
    b344:	b159      	cbz	r1, b35e <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
    b346:	2000      	movs	r0, #0
    b348:	4790      	blx	r2
		u8_t idx = UINT8_MAX;
    b34a:	23ff      	movs	r3, #255	; 0xff
    b34c:	f88d 3007 	strb.w	r3, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
    b350:	f10d 0007 	add.w	r0, sp, #7
    b354:	f7ff fa5e 	bl	a814 <ull_prepare_dequeue_iter>
		while (next) {
    b358:	b980      	cbnz	r0, b37c <lll_disable+0x4c>
}
    b35a:	b002      	add	sp, #8
    b35c:	bd10      	pop	{r4, pc}
			LL_ASSERT(!param);
    b35e:	2c00      	cmp	r4, #0
    b360:	d0f3      	beq.n	b34a <lll_disable+0x1a>
    b362:	4a10      	ldr	r2, [pc, #64]	; (b3a4 <lll_disable+0x74>)
    b364:	4910      	ldr	r1, [pc, #64]	; (b3a8 <lll_disable+0x78>)
    b366:	4811      	ldr	r0, [pc, #68]	; (b3ac <lll_disable+0x7c>)
    b368:	23dd      	movs	r3, #221	; 0xdd
    b36a:	f009 fbde 	bl	14b2a <printk>
    b36e:	4040      	eors	r0, r0
    b370:	f380 8811 	msr	BASEPRI, r0
    b374:	f04f 0003 	mov.w	r0, #3
    b378:	df02      	svc	2
    b37a:	e7e6      	b.n	b34a <lll_disable+0x1a>
			if (!next->is_aborted &&
    b37c:	f890 3020 	ldrb.w	r3, [r0, #32]
    b380:	079b      	lsls	r3, r3, #30
    b382:	d4e5      	bmi.n	b350 <lll_disable+0x20>
    b384:	68c1      	ldr	r1, [r0, #12]
    b386:	b10c      	cbz	r4, b38c <lll_disable+0x5c>
			    (!param || (param == next->prepare_param.param))) {
    b388:	428c      	cmp	r4, r1
    b38a:	d1e1      	bne.n	b350 <lll_disable+0x20>
				next->is_aborted = 1;
    b38c:	f890 3020 	ldrb.w	r3, [r0, #32]
    b390:	f043 0302 	orr.w	r3, r3, #2
    b394:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
    b398:	6983      	ldr	r3, [r0, #24]
    b39a:	4798      	blx	r3
    b39c:	e7d8      	b.n	b350 <lll_disable+0x20>
    b39e:	bf00      	nop
    b3a0:	20003628 	.word	0x20003628
    b3a4:	0001b60d 	.word	0x0001b60d
    b3a8:	0001b6b7 	.word	0x0001b6b7
    b3ac:	0001aebe 	.word	0x0001aebe

0000b3b0 <lll_done>:
{
    b3b0:	b510      	push	{r4, lr}
    b3b2:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
    b3b4:	f7ff f938 	bl	a628 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
    b3b8:	b17c      	cbz	r4, b3da <lll_done+0x2a>
    b3ba:	b960      	cbnz	r0, b3d6 <lll_done+0x26>
    b3bc:	4a1b      	ldr	r2, [pc, #108]	; (b42c <lll_done+0x7c>)
    b3be:	491c      	ldr	r1, [pc, #112]	; (b430 <lll_done+0x80>)
    b3c0:	481c      	ldr	r0, [pc, #112]	; (b434 <lll_done+0x84>)
    b3c2:	f44f 7386 	mov.w	r3, #268	; 0x10c
    b3c6:	f009 fbb0 	bl	14b2a <printk>
    b3ca:	4040      	eors	r0, r0
    b3cc:	f380 8811 	msr	BASEPRI, r0
    b3d0:	f04f 0003 	mov.w	r0, #3
    b3d4:	df02      	svc	2
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
    b3d6:	6820      	ldr	r0, [r4, #0]
    b3d8:	e015      	b.n	b406 <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
    b3da:	4c17      	ldr	r4, [pc, #92]	; (b438 <lll_done+0x88>)
    b3dc:	68a3      	ldr	r3, [r4, #8]
    b3de:	b963      	cbnz	r3, b3fa <lll_done+0x4a>
    b3e0:	4a12      	ldr	r2, [pc, #72]	; (b42c <lll_done+0x7c>)
    b3e2:	4916      	ldr	r1, [pc, #88]	; (b43c <lll_done+0x8c>)
    b3e4:	4813      	ldr	r0, [pc, #76]	; (b434 <lll_done+0x84>)
    b3e6:	f240 1311 	movw	r3, #273	; 0x111
    b3ea:	f009 fb9e 	bl	14b2a <printk>
    b3ee:	4040      	eors	r0, r0
    b3f0:	f380 8811 	msr	BASEPRI, r0
    b3f4:	f04f 0003 	mov.w	r0, #3
    b3f8:	df02      	svc	2
		param = event.curr.param;
    b3fa:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
    b3fc:	2300      	movs	r3, #0
    b3fe:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
    b400:	6023      	str	r3, [r4, #0]
		if (param) {
    b402:	b108      	cbz	r0, b408 <lll_done+0x58>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
    b404:	6800      	ldr	r0, [r0, #0]
    b406:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
    b408:	f7ff fa22 	bl	a850 <ull_event_done>
	LL_ASSERT(evdone);
    b40c:	b960      	cbnz	r0, b428 <lll_done+0x78>
    b40e:	4a07      	ldr	r2, [pc, #28]	; (b42c <lll_done+0x7c>)
    b410:	490b      	ldr	r1, [pc, #44]	; (b440 <lll_done+0x90>)
    b412:	4808      	ldr	r0, [pc, #32]	; (b434 <lll_done+0x84>)
    b414:	f240 1329 	movw	r3, #297	; 0x129
    b418:	f009 fb87 	bl	14b2a <printk>
    b41c:	4040      	eors	r0, r0
    b41e:	f380 8811 	msr	BASEPRI, r0
    b422:	f04f 0003 	mov.w	r0, #3
    b426:	df02      	svc	2
}
    b428:	2000      	movs	r0, #0
    b42a:	bd10      	pop	{r4, pc}
    b42c:	0001b60d 	.word	0x0001b60d
    b430:	0001b6be 	.word	0x0001b6be
    b434:	0001aebe 	.word	0x0001aebe
    b438:	20003628 	.word	0x20003628
    b43c:	0001b6cd 	.word	0x0001b6cd
    b440:	0001b6e1 	.word	0x0001b6e1

0000b444 <lll_is_done>:
	return !event.curr.abort_cb;
    b444:	4b02      	ldr	r3, [pc, #8]	; (b450 <lll_is_done+0xc>)
    b446:	6898      	ldr	r0, [r3, #8]
}
    b448:	fab0 f080 	clz	r0, r0
    b44c:	0940      	lsrs	r0, r0, #5
    b44e:	4770      	bx	lr
    b450:	20003628 	.word	0x20003628

0000b454 <lll_chan_set>:
	switch (chan) {
    b454:	2826      	cmp	r0, #38	; 0x26
{
    b456:	b510      	push	{r4, lr}
    b458:	4604      	mov	r4, r0
	switch (chan) {
    b45a:	d00b      	beq.n	b474 <lll_chan_set+0x20>
    b45c:	2827      	cmp	r0, #39	; 0x27
    b45e:	d00b      	beq.n	b478 <lll_chan_set+0x24>
    b460:	2825      	cmp	r0, #37	; 0x25
    b462:	d10b      	bne.n	b47c <lll_chan_set+0x28>
		radio_freq_chan_set(2);
    b464:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
    b466:	f000 ff9b 	bl	c3a0 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
    b46a:	4620      	mov	r0, r4
}
    b46c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
    b470:	f000 bf9c 	b.w	c3ac <radio_whiten_iv_set>
		radio_freq_chan_set(26);
    b474:	201a      	movs	r0, #26
    b476:	e7f6      	b.n	b466 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
    b478:	2050      	movs	r0, #80	; 0x50
    b47a:	e7f4      	b.n	b466 <lll_chan_set+0x12>
		if (chan < 11) {
    b47c:	280a      	cmp	r0, #10
    b47e:	d802      	bhi.n	b486 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
    b480:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    b482:	0040      	lsls	r0, r0, #1
    b484:	e7ef      	b.n	b466 <lll_chan_set+0x12>
		} else if (chan < 40) {
    b486:	2827      	cmp	r0, #39	; 0x27
    b488:	d801      	bhi.n	b48e <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    b48a:	3003      	adds	r0, #3
    b48c:	e7f9      	b.n	b482 <lll_chan_set+0x2e>
			LL_ASSERT(0);
    b48e:	4a07      	ldr	r2, [pc, #28]	; (b4ac <lll_chan_set+0x58>)
    b490:	4907      	ldr	r1, [pc, #28]	; (b4b0 <lll_chan_set+0x5c>)
    b492:	4808      	ldr	r0, [pc, #32]	; (b4b4 <lll_chan_set+0x60>)
    b494:	f240 136d 	movw	r3, #365	; 0x16d
    b498:	f009 fb47 	bl	14b2a <printk>
    b49c:	4040      	eors	r0, r0
    b49e:	f380 8811 	msr	BASEPRI, r0
    b4a2:	f04f 0003 	mov.w	r0, #3
    b4a6:	df02      	svc	2
    b4a8:	e7df      	b.n	b46a <lll_chan_set+0x16>
    b4aa:	bf00      	nop
    b4ac:	0001b60d 	.word	0x0001b60d
    b4b0:	0001b96a 	.word	0x0001b96a
    b4b4:	0001aebe 	.word	0x0001aebe

0000b4b8 <lll_clock_init>:
			void *user_data);

static struct device *dev;

int lll_clock_init(void)
{
    b4b8:	b510      	push	{r4, lr}
    b4ba:	4807      	ldr	r0, [pc, #28]	; (b4d8 <lll_clock_init+0x20>)
    b4bc:	f008 f8d6 	bl	1366c <z_impl_device_get_binding>
	int err;

	dev = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
    b4c0:	4a06      	ldr	r2, [pc, #24]	; (b4dc <lll_clock_init+0x24>)
    b4c2:	6010      	str	r0, [r2, #0]
	if (!dev) {
    b4c4:	b128      	cbz	r0, b4d2 <lll_clock_init+0x1a>
    b4c6:	6843      	ldr	r3, [r0, #4]
	}

	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_LF);

	return err;
}
    b4c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b4cc:	681b      	ldr	r3, [r3, #0]
    b4ce:	2101      	movs	r1, #1
    b4d0:	4718      	bx	r3
    b4d2:	f06f 0012 	mvn.w	r0, #18
    b4d6:	bd10      	pop	{r4, pc}
    b4d8:	0001a699 	.word	0x0001a699
    b4dc:	2000363c 	.word	0x2000363c

0000b4e0 <lll_hfclock_on>:
int lll_hfclock_on(void)
{
	int err;

	/* turn on radio clock in non-blocking mode. */
	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
    b4e0:	4b02      	ldr	r3, [pc, #8]	; (b4ec <lll_hfclock_on+0xc>)
    b4e2:	6818      	ldr	r0, [r3, #0]
    b4e4:	6843      	ldr	r3, [r0, #4]
    b4e6:	2100      	movs	r1, #0
    b4e8:	681b      	ldr	r3, [r3, #0]
    b4ea:	4718      	bx	r3
    b4ec:	2000363c 	.word	0x2000363c

0000b4f0 <lll_hfclock_off>:
int lll_hfclock_off(void)
{
	int err;

	/* turn off radio clock in non-blocking mode. */
	err = clock_control_off(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
    b4f0:	4b02      	ldr	r3, [pc, #8]	; (b4fc <lll_hfclock_off+0xc>)
    b4f2:	6818      	ldr	r0, [r3, #0]
	return api->off(dev, sys);
    b4f4:	6843      	ldr	r3, [r0, #4]
    b4f6:	2100      	movs	r1, #0
    b4f8:	685b      	ldr	r3, [r3, #4]
    b4fa:	4718      	bx	r3
    b4fc:	2000363c 	.word	0x2000363c

0000b500 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
    b500:	b508      	push	{r3, lr}
    b502:	4601      	mov	r1, r0
	int err;

	radio_isr_set(isr_race, param);
    b504:	4810      	ldr	r0, [pc, #64]	; (b548 <isr_cleanup+0x48>)
    b506:	f000 fef1 	bl	c2ec <radio_isr_set>
	if (!radio_is_idle()) {
    b50a:	f000 ffef 	bl	c4ec <radio_is_idle>
    b50e:	b908      	cbnz	r0, b514 <isr_cleanup+0x14>
		radio_disable();
    b510:	f000 ffba 	bl	c488 <radio_disable>
	}

	radio_tmr_stop();
    b514:	f001 f944 	bl	c7a0 <radio_tmr_stop>

	err = lll_hfclock_off();
    b518:	f7ff ffea 	bl	b4f0 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
    b51c:	b170      	cbz	r0, b53c <isr_cleanup+0x3c>
    b51e:	3010      	adds	r0, #16
    b520:	d00c      	beq.n	b53c <isr_cleanup+0x3c>
    b522:	4a0a      	ldr	r2, [pc, #40]	; (b54c <isr_cleanup+0x4c>)
    b524:	490a      	ldr	r1, [pc, #40]	; (b550 <isr_cleanup+0x50>)
    b526:	480b      	ldr	r0, [pc, #44]	; (b554 <isr_cleanup+0x54>)
    b528:	f240 2349 	movw	r3, #585	; 0x249
    b52c:	f009 fafd 	bl	14b2a <printk>
    b530:	4040      	eors	r0, r0
    b532:	f380 8811 	msr	BASEPRI, r0
    b536:	f04f 0003 	mov.w	r0, #3
    b53a:	df02      	svc	2

	lll_done(NULL);
}
    b53c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
    b540:	2000      	movs	r0, #0
    b542:	f7ff bf35 	b.w	b3b0 <lll_done>
    b546:	bf00      	nop
    b548:	00016a3f 	.word	0x00016a3f
    b54c:	0001b706 	.word	0x0001b706
    b550:	0001b750 	.word	0x0001b750
    b554:	0001aebe 	.word	0x0001aebe

0000b558 <isr_tx>:
{
    b558:	b538      	push	{r3, r4, r5, lr}
    b55a:	4604      	mov	r4, r0
	radio_status_reset();
    b55c:	f000 ffa6 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
    b560:	f001 f86c 	bl	c63c <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
    b564:	2096      	movs	r0, #150	; 0x96
    b566:	f001 f879 	bl	c65c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    b56a:	2300      	movs	r3, #0
    b56c:	461a      	mov	r2, r3
    b56e:	4619      	mov	r1, r3
    b570:	4618      	mov	r0, r3
    b572:	f000 ffeb 	bl	c54c <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
    b576:	f000 ffd9 	bl	c52c <radio_pkt_scratch_get>
    b57a:	f000 ff6d 	bl	c458 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
    b57e:	f000 ffa1 	bl	c4c4 <radio_is_ready>
    b582:	b160      	cbz	r0, b59e <isr_tx+0x46>
    b584:	4a12      	ldr	r2, [pc, #72]	; (b5d0 <isr_tx+0x78>)
    b586:	4913      	ldr	r1, [pc, #76]	; (b5d4 <isr_tx+0x7c>)
    b588:	4813      	ldr	r0, [pc, #76]	; (b5d8 <isr_tx+0x80>)
    b58a:	f240 1357 	movw	r3, #343	; 0x157
    b58e:	f009 facc 	bl	14b2a <printk>
    b592:	4040      	eors	r0, r0
    b594:	f380 8811 	msr	BASEPRI, r0
    b598:	f04f 0003 	mov.w	r0, #3
    b59c:	df02      	svc	2
	radio_isr_set(isr_rx, param);
    b59e:	4621      	mov	r1, r4
    b5a0:	480e      	ldr	r0, [pc, #56]	; (b5dc <isr_tx+0x84>)
    b5a2:	f000 fea3 	bl	c2ec <radio_isr_set>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    b5a6:	f001 f91b 	bl	c7e0 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
    b5aa:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    b5ac:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
    b5ae:	4608      	mov	r0, r1
    b5b0:	f00b faec 	bl	16b8c <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
    b5b4:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
    b5b6:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
    b5b8:	4608      	mov	r0, r1
    b5ba:	f00b fae5 	bl	16b88 <radio_tx_chain_delay_get>
    b5be:	442c      	add	r4, r5
    b5c0:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
    b5c2:	1a20      	subs	r0, r4, r0
    b5c4:	f001 f8f8 	bl	c7b8 <radio_tmr_hcto_configure>
}
    b5c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_end_capture();
    b5cc:	f001 b900 	b.w	c7d0 <radio_tmr_end_capture>
    b5d0:	0001b706 	.word	0x0001b706
    b5d4:	0001b763 	.word	0x0001b763
    b5d8:	0001aebe 	.word	0x0001aebe
    b5dc:	0000b635 	.word	0x0000b635

0000b5e0 <abort_cb>:
{
    b5e0:	b510      	push	{r4, lr}
    b5e2:	460c      	mov	r4, r1
	if (!prepare_param) {
    b5e4:	b930      	cbnz	r0, b5f4 <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
    b5e6:	480f      	ldr	r0, [pc, #60]	; (b624 <abort_cb+0x44>)
    b5e8:	f000 fe80 	bl	c2ec <radio_isr_set>
}
    b5ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
    b5f0:	f000 bf4a 	b.w	c488 <radio_disable>
	err = lll_hfclock_off();
    b5f4:	f7ff ff7c 	bl	b4f0 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
    b5f8:	b170      	cbz	r0, b618 <abort_cb+0x38>
    b5fa:	3010      	adds	r0, #16
    b5fc:	d00c      	beq.n	b618 <abort_cb+0x38>
    b5fe:	4a0a      	ldr	r2, [pc, #40]	; (b628 <abort_cb+0x48>)
    b600:	490a      	ldr	r1, [pc, #40]	; (b62c <abort_cb+0x4c>)
    b602:	480b      	ldr	r0, [pc, #44]	; (b630 <abort_cb+0x50>)
    b604:	f240 1339 	movw	r3, #313	; 0x139
    b608:	f009 fa8f 	bl	14b2a <printk>
    b60c:	4040      	eors	r0, r0
    b60e:	f380 8811 	msr	BASEPRI, r0
    b612:	f04f 0003 	mov.w	r0, #3
    b616:	df02      	svc	2
	lll_done(param);
    b618:	4620      	mov	r0, r4
}
    b61a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    b61e:	f7ff bec7 	b.w	b3b0 <lll_done>
    b622:	bf00      	nop
    b624:	00016a43 	.word	0x00016a43
    b628:	0001b706 	.word	0x0001b706
    b62c:	0001b750 	.word	0x0001b750
    b630:	0001aebe 	.word	0x0001aebe

0000b634 <isr_rx>:
{
    b634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b636:	4604      	mov	r4, r0
	trx_done = radio_is_done();
    b638:	f000 ff4e 	bl	c4d8 <radio_is_done>
	if (trx_done) {
    b63c:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
    b640:	d03b      	beq.n	b6ba <isr_rx+0x86>
		crc_ok = radio_crc_is_valid();
    b642:	f000 ff69 	bl	c518 <radio_crc_is_valid>
    b646:	b2c7      	uxtb	r7, r0
		devmatch_ok = radio_filter_has_match();
    b648:	f000 ffe8 	bl	c61c <radio_filter_has_match>
    b64c:	b2c6      	uxtb	r6, r0
		devmatch_id = radio_filter_match_get();
    b64e:	f000 ffef 	bl	c630 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
    b652:	f001 f8dd 	bl	c810 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
    b656:	f001 f8c9 	bl	c7ec <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
    b65a:	f000 ffa7 	bl	c5ac <radio_rssi_is_ready>
	radio_status_reset();
    b65e:	f000 ff25 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
    b662:	f000 ffeb 	bl	c63c <radio_tmr_status_reset>
	radio_filter_status_reset();
    b666:	f000 ffd1 	bl	c60c <radio_filter_status_reset>
	radio_ar_status_reset();
    b66a:	f001 f8c5 	bl	c7f8 <radio_ar_status_reset>
	radio_rssi_status_reset();
    b66e:	f000 ff95 	bl	c59c <radio_rssi_status_reset>
	if (!trx_done) {
    b672:	b1d5      	cbz	r5, b6aa <isr_rx+0x76>
	if (crc_ok) {
    b674:	b1cf      	cbz	r7, b6aa <isr_rx+0x76>
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
    b676:	f000 ff59 	bl	c52c <radio_pkt_scratch_get>
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
    b67a:	7a61      	ldrb	r1, [r4, #9]
    b67c:	220b      	movs	r2, #11
    b67e:	2327      	movs	r3, #39	; 0x27
    b680:	fb13 2301 	smlabb	r3, r3, r1, r2
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
    b684:	7802      	ldrb	r2, [r0, #0]
    b686:	f002 010f 	and.w	r1, r2, #15
    b68a:	2903      	cmp	r1, #3
    b68c:	eb04 0503 	add.w	r5, r4, r3
    b690:	d10b      	bne.n	b6aa <isr_rx+0x76>
    b692:	7841      	ldrb	r1, [r0, #1]
    b694:	290c      	cmp	r1, #12
    b696:	d108      	bne.n	b6aa <isr_rx+0x76>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
    b698:	5ce3      	ldrb	r3, [r4, r3]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
    b69a:	f003 010f 	and.w	r1, r3, #15
    b69e:	2901      	cmp	r1, #1
    b6a0:	d003      	beq.n	b6aa <isr_rx+0x76>
						rl_idx)) ||
		(((lll->filter_policy & 0x01) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
		isr_rx_sr_adva_check(adv, sr);
#else
	return (((lll->filter_policy & 0x01) == 0U) || devmatch_ok) &&
    b6a2:	7a21      	ldrb	r1, [r4, #8]
    b6a4:	0649      	lsls	r1, r1, #25
    b6a6:	d50b      	bpl.n	b6c0 <isr_rx+0x8c>
    b6a8:	b956      	cbnz	r6, b6c0 <isr_rx+0x8c>
	radio_isr_set(isr_done, param);
    b6aa:	4621      	mov	r1, r4
    b6ac:	481a      	ldr	r0, [pc, #104]	; (b718 <isr_rx+0xe4>)
    b6ae:	f000 fe1d 	bl	c2ec <radio_isr_set>
}
    b6b2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	radio_disable();
    b6b6:	f000 bee7 	b.w	c488 <radio_disable>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    b6ba:	462e      	mov	r6, r5
    b6bc:	462f      	mov	r7, r5
    b6be:	e7ce      	b.n	b65e <isr_rx+0x2a>
}

static inline bool isr_rx_sr_adva_check(struct pdu_adv *adv,
					struct pdu_adv *sr)
{
	return (adv->tx_addr == sr->rx_addr) &&
    b6c0:	f3c3 1380 	ubfx	r3, r3, #6, #1
    b6c4:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    b6c8:	d1ef      	bne.n	b6aa <isr_rx+0x76>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
    b6ca:	f100 0108 	add.w	r1, r0, #8
    b6ce:	2206      	movs	r2, #6
    b6d0:	1ca8      	adds	r0, r5, #2
    b6d2:	f00a fca2 	bl	1601a <memcmp>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
    b6d6:	2800      	cmp	r0, #0
    b6d8:	d1e7      	bne.n	b6aa <isr_rx+0x76>
		radio_isr_set(isr_done, lll);
    b6da:	480f      	ldr	r0, [pc, #60]	; (b718 <isr_rx+0xe4>)
    b6dc:	4621      	mov	r1, r4
    b6de:	f000 fe05 	bl	c2ec <radio_isr_set>
		radio_switch_complete_and_disable();
    b6e2:	f000 ff3d 	bl	c560 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
    b6e6:	f894 0059 	ldrb.w	r0, [r4, #89]	; 0x59
    b6ea:	2327      	movs	r3, #39	; 0x27
    b6ec:	fb03 4000 	mla	r0, r3, r0, r4
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
    b6f0:	305b      	adds	r0, #91	; 0x5b
    b6f2:	f000 feb7 	bl	c464 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    b6f6:	f000 fee5 	bl	c4c4 <radio_is_ready>
    b6fa:	b160      	cbz	r0, b716 <isr_rx+0xe2>
    b6fc:	4a07      	ldr	r2, [pc, #28]	; (b71c <isr_rx+0xe8>)
    b6fe:	4908      	ldr	r1, [pc, #32]	; (b720 <isr_rx+0xec>)
    b700:	4808      	ldr	r0, [pc, #32]	; (b724 <isr_rx+0xf0>)
    b702:	f240 239b 	movw	r3, #667	; 0x29b
    b706:	f009 fa10 	bl	14b2a <printk>
    b70a:	4040      	eors	r0, r0
    b70c:	f380 8811 	msr	BASEPRI, r0
    b710:	f04f 0003 	mov.w	r0, #3
    b714:	df02      	svc	2
}
    b716:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b718:	00016a69 	.word	0x00016a69
    b71c:	0001b706 	.word	0x0001b706
    b720:	0001b763 	.word	0x0001b763
    b724:	0001aebe 	.word	0x0001aebe

0000b728 <chan_prepare>:
{
    b728:	b570      	push	{r4, r5, r6, lr}
	first = pdu->first;
    b72a:	7a42      	ldrb	r2, [r0, #9]
	if (first != pdu->last) {
    b72c:	7a83      	ldrb	r3, [r0, #10]
    b72e:	429a      	cmp	r2, r3
    b730:	4604      	mov	r4, r0
    b732:	d005      	beq.n	b740 <chan_prepare+0x18>
		first += 1U;
    b734:	1c53      	adds	r3, r2, #1
    b736:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
    b738:	2b02      	cmp	r3, #2
			first = 0U;
    b73a:	bf08      	it	eq
    b73c:	2300      	moveq	r3, #0
		pdu->first = first;
    b73e:	7243      	strb	r3, [r0, #9]
	return (void *)pdu->pdu[first];
    b740:	2202      	movs	r2, #2
    b742:	2527      	movs	r5, #39	; 0x27
    b744:	fb15 2503 	smlabb	r5, r5, r3, r2
	first = pdu->first;
    b748:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
	if (first != pdu->last) {
    b74c:	f894 205a 	ldrb.w	r2, [r4, #90]	; 0x5a
	return (void *)pdu->pdu[first];
    b750:	f104 0609 	add.w	r6, r4, #9
	if (first != pdu->last) {
    b754:	429a      	cmp	r2, r3
	return (void *)pdu->pdu[first];
    b756:	eb06 0005 	add.w	r0, r6, r5
	if (first != pdu->last) {
    b75a:	d006      	beq.n	b76a <chan_prepare+0x42>
		first += 1U;
    b75c:	3301      	adds	r3, #1
    b75e:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
    b760:	2b02      	cmp	r3, #2
			first = 0U;
    b762:	bf08      	it	eq
    b764:	2300      	moveq	r3, #0
		pdu->first = first;
    b766:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
	radio_pkt_tx_set(pdu);
    b76a:	f000 fe7b 	bl	c464 <radio_pkt_tx_set>
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
    b76e:	5d73      	ldrb	r3, [r6, r5]
    b770:	f003 030f 	and.w	r3, r3, #15
    b774:	2b02      	cmp	r3, #2
		radio_isr_set(isr_tx, lll);
    b776:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
    b778:	d030      	beq.n	b7dc <chan_prepare+0xb4>
		radio_isr_set(isr_tx, lll);
    b77a:	481b      	ldr	r0, [pc, #108]	; (b7e8 <chan_prepare+0xc0>)
    b77c:	f000 fdb6 	bl	c2ec <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
    b780:	2096      	movs	r0, #150	; 0x96
    b782:	f000 ff6b 	bl	c65c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    b786:	2000      	movs	r0, #0
    b788:	f000 fed4 	bl	c534 <radio_switch_complete_and_rx>
	chan = find_lsb_set(lll->chan_map_curr);
    b78c:	7a23      	ldrb	r3, [r4, #8]
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
    b78e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    b792:	2b00      	cmp	r3, #0
    b794:	fa93 f0a3 	rbit	r0, r3
    b798:	fab0 f080 	clz	r0, r0
    b79c:	bf08      	it	eq
    b79e:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
    b7a2:	1c45      	adds	r5, r0, #1
    b7a4:	d10c      	bne.n	b7c0 <chan_prepare+0x98>
    b7a6:	4a11      	ldr	r2, [pc, #68]	; (b7ec <chan_prepare+0xc4>)
    b7a8:	4911      	ldr	r1, [pc, #68]	; (b7f0 <chan_prepare+0xc8>)
    b7aa:	4812      	ldr	r0, [pc, #72]	; (b7f4 <chan_prepare+0xcc>)
    b7ac:	f240 2379 	movw	r3, #633	; 0x279
    b7b0:	f009 f9bb 	bl	14b2a <printk>
    b7b4:	4040      	eors	r0, r0
    b7b6:	f380 8811 	msr	BASEPRI, r0
    b7ba:	f04f 0003 	mov.w	r0, #3
    b7be:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
    b7c0:	7a23      	ldrb	r3, [r4, #8]
    b7c2:	f3c3 02c2 	ubfx	r2, r3, #3, #3
    b7c6:	1e51      	subs	r1, r2, #1
    b7c8:	400a      	ands	r2, r1
    b7ca:	f362 03c5 	bfi	r3, r2, #3, #3
    b7ce:	7223      	strb	r3, [r4, #8]
	lll_chan_set(36 + chan);
    b7d0:	f105 0024 	add.w	r0, r5, #36	; 0x24
}
    b7d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	lll_chan_set(36 + chan);
    b7d8:	f7ff be3c 	b.w	b454 <lll_chan_set>
		radio_isr_set(isr_done, lll);
    b7dc:	4806      	ldr	r0, [pc, #24]	; (b7f8 <chan_prepare+0xd0>)
    b7de:	f000 fd85 	bl	c2ec <radio_isr_set>
		radio_switch_complete_and_disable();
    b7e2:	f000 febd 	bl	c560 <radio_switch_complete_and_disable>
    b7e6:	e7d1      	b.n	b78c <chan_prepare+0x64>
    b7e8:	0000b559 	.word	0x0000b559
    b7ec:	0001b706 	.word	0x0001b706
    b7f0:	0001b4a8 	.word	0x0001b4a8
    b7f4:	0001aebe 	.word	0x0001aebe
    b7f8:	00016a69 	.word	0x00016a69

0000b7fc <prepare_cb>:
{
    b7fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
    b7fe:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    b800:	4b3c      	ldr	r3, [pc, #240]	; (b8f4 <prepare_cb+0xf8>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
    b802:	7925      	ldrb	r5, [r4, #4]
    b804:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
    b806:	f015 0501 	ands.w	r5, r5, #1
{
    b80a:	4606      	mov	r6, r0
	if (lll_is_stop(lll)) {
    b80c:	d016      	beq.n	b83c <prepare_cb+0x40>
		err = lll_hfclock_off();
    b80e:	f7ff fe6f 	bl	b4f0 <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
    b812:	b168      	cbz	r0, b830 <prepare_cb+0x34>
    b814:	3010      	adds	r0, #16
    b816:	d00b      	beq.n	b830 <prepare_cb+0x34>
    b818:	4a37      	ldr	r2, [pc, #220]	; (b8f8 <prepare_cb+0xfc>)
    b81a:	4938      	ldr	r1, [pc, #224]	; (b8fc <prepare_cb+0x100>)
    b81c:	4838      	ldr	r0, [pc, #224]	; (b900 <prepare_cb+0x104>)
    b81e:	238b      	movs	r3, #139	; 0x8b
    b820:	f009 f983 	bl	14b2a <printk>
    b824:	4040      	eors	r0, r0
    b826:	f380 8811 	msr	BASEPRI, r0
    b82a:	f04f 0003 	mov.w	r0, #3
    b82e:	df02      	svc	2
		lll_done(NULL);
    b830:	2000      	movs	r0, #0
    b832:	f7ff fdbd 	bl	b3b0 <lll_done>
}
    b836:	2000      	movs	r0, #0
    b838:	b003      	add	sp, #12
    b83a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
    b83c:	f000 fd76 	bl	c32c <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    b840:	4628      	mov	r0, r5
    b842:	f000 fda7 	bl	c394 <radio_tx_power_set>
	radio_phy_set(0, 0);
    b846:	4629      	mov	r1, r5
    b848:	4628      	mov	r0, r5
    b84a:	f000 fd93 	bl	c374 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
    b84e:	462a      	mov	r2, r5
    b850:	2125      	movs	r1, #37	; 0x25
    b852:	2008      	movs	r0, #8
    b854:	f000 fdd4 	bl	c400 <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
    b858:	a801      	add	r0, sp, #4
    b85a:	f000 fdb9 	bl	c3d0 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
    b85e:	4929      	ldr	r1, [pc, #164]	; (b904 <prepare_cb+0x108>)
    b860:	f240 605b 	movw	r0, #1627	; 0x65b
    b864:	f000 fe4c 	bl	c500 <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
    b868:	7a23      	ldrb	r3, [r4, #8]
    b86a:	f3c3 0202 	ubfx	r2, r3, #0, #3
    b86e:	f362 03c5 	bfi	r3, r2, #3, #3
    b872:	7223      	strb	r3, [r4, #8]
	chan_prepare(lll);
    b874:	4620      	mov	r0, r4
    b876:	f7ff ff57 	bl	b728 <chan_prepare>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
    b87a:	7a23      	ldrb	r3, [r4, #8]
    b87c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    b880:	d007      	beq.n	b892 <prepare_cb+0x96>
		struct lll_filter *wl = ull_filter_lll_get(true);
    b882:	2001      	movs	r0, #1
    b884:	f7ff fb80 	bl	af88 <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
    b888:	7841      	ldrb	r1, [r0, #1]
    b88a:	1c82      	adds	r2, r0, #2
    b88c:	7800      	ldrb	r0, [r0, #0]
    b88e:	f000 fe97 	bl	c5c0 <radio_filter_configure>
	evt = HDR_LLL2EVT(lll);
    b892:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
    b894:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
    b896:	4638      	mov	r0, r7
    b898:	f00b f8af 	bl	169fa <lll_evt_offset_get>
    b89c:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
    b89e:	6872      	ldr	r2, [r6, #4]
    b8a0:	f105 0109 	add.w	r1, r5, #9
    b8a4:	2001      	movs	r0, #1
    b8a6:	f000 fee5 	bl	c674 <radio_tmr_start>
	radio_tmr_end_capture();
    b8aa:	f000 ff91 	bl	c7d0 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
    b8ae:	4620      	mov	r0, r4
    b8b0:	f7ff f96c 	bl	ab8c <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
    b8b4:	1c81      	adds	r1, r0, #2
    b8b6:	462a      	mov	r2, r5
    b8b8:	b2c9      	uxtb	r1, r1
    b8ba:	4638      	mov	r0, r7
    b8bc:	f00b f8ab 	bl	16a16 <lll_preempt_calc>
    b8c0:	b130      	cbz	r0, b8d0 <prepare_cb+0xd4>
		radio_isr_set(isr_abort, lll);
    b8c2:	4811      	ldr	r0, [pc, #68]	; (b908 <prepare_cb+0x10c>)
    b8c4:	4621      	mov	r1, r4
    b8c6:	f000 fd11 	bl	c2ec <radio_isr_set>
		radio_disable();
    b8ca:	f000 fddd 	bl	c488 <radio_disable>
    b8ce:	e7b2      	b.n	b836 <prepare_cb+0x3a>
		ret = lll_prepare_done(lll);
    b8d0:	4620      	mov	r0, r4
    b8d2:	f00b f890 	bl	169f6 <lll_prepare_done>
		LL_ASSERT(!ret);
    b8d6:	2800      	cmp	r0, #0
    b8d8:	d0ad      	beq.n	b836 <prepare_cb+0x3a>
    b8da:	4a07      	ldr	r2, [pc, #28]	; (b8f8 <prepare_cb+0xfc>)
    b8dc:	490b      	ldr	r1, [pc, #44]	; (b90c <prepare_cb+0x110>)
    b8de:	4808      	ldr	r0, [pc, #32]	; (b900 <prepare_cb+0x104>)
    b8e0:	23e9      	movs	r3, #233	; 0xe9
    b8e2:	f009 f922 	bl	14b2a <printk>
    b8e6:	4040      	eors	r0, r0
    b8e8:	f380 8811 	msr	BASEPRI, r0
    b8ec:	f04f 0003 	mov.w	r0, #3
    b8f0:	df02      	svc	2
    b8f2:	e7a0      	b.n	b836 <prepare_cb+0x3a>
    b8f4:	8e89bed6 	.word	0x8e89bed6
    b8f8:	0001b706 	.word	0x0001b706
    b8fc:	0001b750 	.word	0x0001b750
    b900:	0001aebe 	.word	0x0001aebe
    b904:	00555555 	.word	0x00555555
    b908:	00016a43 	.word	0x00016a43
    b90c:	0001b46e 	.word	0x0001b46e

0000b910 <lll_adv_prepare>:
{
    b910:	b513      	push	{r0, r1, r4, lr}
    b912:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    b914:	f7ff fde4 	bl	b4e0 <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
    b918:	b168      	cbz	r0, b936 <lll_adv_prepare+0x26>
    b91a:	3044      	adds	r0, #68	; 0x44
    b91c:	d00b      	beq.n	b936 <lll_adv_prepare+0x26>
    b91e:	4a12      	ldr	r2, [pc, #72]	; (b968 <lll_adv_prepare+0x58>)
    b920:	4912      	ldr	r1, [pc, #72]	; (b96c <lll_adv_prepare+0x5c>)
    b922:	4813      	ldr	r0, [pc, #76]	; (b970 <lll_adv_prepare+0x60>)
    b924:	236e      	movs	r3, #110	; 0x6e
    b926:	f009 f900 	bl	14b2a <printk>
    b92a:	4040      	eors	r0, r0
    b92c:	f380 8811 	msr	BASEPRI, r0
    b930:	f04f 0003 	mov.w	r0, #3
    b934:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
    b936:	4a0f      	ldr	r2, [pc, #60]	; (b974 <lll_adv_prepare+0x64>)
    b938:	490f      	ldr	r1, [pc, #60]	; (b978 <lll_adv_prepare+0x68>)
    b93a:	4810      	ldr	r0, [pc, #64]	; (b97c <lll_adv_prepare+0x6c>)
    b93c:	9400      	str	r4, [sp, #0]
    b93e:	2300      	movs	r3, #0
    b940:	f00b f850 	bl	169e4 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    b944:	b168      	cbz	r0, b962 <lll_adv_prepare+0x52>
    b946:	3044      	adds	r0, #68	; 0x44
    b948:	d00b      	beq.n	b962 <lll_adv_prepare+0x52>
    b94a:	4a07      	ldr	r2, [pc, #28]	; (b968 <lll_adv_prepare+0x58>)
    b94c:	4907      	ldr	r1, [pc, #28]	; (b96c <lll_adv_prepare+0x5c>)
    b94e:	4808      	ldr	r0, [pc, #32]	; (b970 <lll_adv_prepare+0x60>)
    b950:	2371      	movs	r3, #113	; 0x71
    b952:	f009 f8ea 	bl	14b2a <printk>
    b956:	4040      	eors	r0, r0
    b958:	f380 8811 	msr	BASEPRI, r0
    b95c:	f04f 0003 	mov.w	r0, #3
    b960:	df02      	svc	2
}
    b962:	b002      	add	sp, #8
    b964:	bd10      	pop	{r4, pc}
    b966:	bf00      	nop
    b968:	0001b706 	.word	0x0001b706
    b96c:	0001b775 	.word	0x0001b775
    b970:	0001aebe 	.word	0x0001aebe
    b974:	0000b7fd 	.word	0x0000b7fd
    b978:	0000b5e1 	.word	0x0000b5e1
    b97c:	00016a39 	.word	0x00016a39

0000b980 <ticker_stop_cb>:
	lll_done(param);
}

static void ticker_stop_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
			   void *param)
{
    b980:	b508      	push	{r3, lr}
	radio_isr_set(isr_cleanup, param);
    b982:	4619      	mov	r1, r3
    b984:	4803      	ldr	r0, [pc, #12]	; (b994 <ticker_stop_cb+0x14>)
    b986:	f000 fcb1 	bl	c2ec <radio_isr_set>
	radio_disable();
}
    b98a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_disable();
    b98e:	f000 bd7b 	b.w	c488 <radio_disable>
    b992:	bf00      	nop
    b994:	0000bd81 	.word	0x0000bd81

0000b998 <prepare_cb>:
{
    b998:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_scan *lll = prepare_param->param;
    b99a:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    b99c:	4b60      	ldr	r3, [pc, #384]	; (bb20 <prepare_cb+0x188>)
    b99e:	7925      	ldrb	r5, [r4, #4]
{
    b9a0:	b08d      	sub	sp, #52	; 0x34
	if (lll_is_stop(lll)) {
    b9a2:	f015 0501 	ands.w	r5, r5, #1
{
    b9a6:	4606      	mov	r6, r0
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    b9a8:	930b      	str	r3, [sp, #44]	; 0x2c
	if (lll_is_stop(lll)) {
    b9aa:	d016      	beq.n	b9da <prepare_cb+0x42>
		err = lll_hfclock_off();
    b9ac:	f7ff fda0 	bl	b4f0 <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
    b9b0:	b168      	cbz	r0, b9ce <prepare_cb+0x36>
    b9b2:	3010      	adds	r0, #16
    b9b4:	d00b      	beq.n	b9ce <prepare_cb+0x36>
    b9b6:	4a5b      	ldr	r2, [pc, #364]	; (bb24 <prepare_cb+0x18c>)
    b9b8:	495b      	ldr	r1, [pc, #364]	; (bb28 <prepare_cb+0x190>)
    b9ba:	485c      	ldr	r0, [pc, #368]	; (bb2c <prepare_cb+0x194>)
    b9bc:	238c      	movs	r3, #140	; 0x8c
    b9be:	f009 f8b4 	bl	14b2a <printk>
    b9c2:	4040      	eors	r0, r0
    b9c4:	f380 8811 	msr	BASEPRI, r0
    b9c8:	f04f 0003 	mov.w	r0, #3
    b9cc:	df02      	svc	2
		lll_done(NULL);
    b9ce:	2000      	movs	r0, #0
    b9d0:	f7ff fcee 	bl	b3b0 <lll_done>
}
    b9d4:	2000      	movs	r0, #0
    b9d6:	b00d      	add	sp, #52	; 0x34
    b9d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
    b9da:	f000 fca7 	bl	c32c <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    b9de:	4628      	mov	r0, r5
    b9e0:	f000 fcd8 	bl	c394 <radio_tx_power_set>
	radio_phy_set(0, 0);
    b9e4:	4629      	mov	r1, r5
    b9e6:	4628      	mov	r0, r5
    b9e8:	f000 fcc4 	bl	c374 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
    b9ec:	462a      	mov	r2, r5
    b9ee:	2125      	movs	r1, #37	; 0x25
    b9f0:	2008      	movs	r0, #8
    b9f2:	f000 fd05 	bl	c400 <radio_pkt_configure>
	node_rx = ull_pdu_rx_alloc_peek(1);
    b9f6:	2001      	movs	r0, #1
    b9f8:	f7fe fda6 	bl	a548 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    b9fc:	4605      	mov	r5, r0
    b9fe:	b958      	cbnz	r0, ba18 <prepare_cb+0x80>
    ba00:	4a48      	ldr	r2, [pc, #288]	; (bb24 <prepare_cb+0x18c>)
    ba02:	494b      	ldr	r1, [pc, #300]	; (bb30 <prepare_cb+0x198>)
    ba04:	4849      	ldr	r0, [pc, #292]	; (bb2c <prepare_cb+0x194>)
    ba06:	23a5      	movs	r3, #165	; 0xa5
    ba08:	f009 f88f 	bl	14b2a <printk>
    ba0c:	4040      	eors	r0, r0
    ba0e:	f380 8811 	msr	BASEPRI, r0
    ba12:	f04f 0003 	mov.w	r0, #3
    ba16:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    ba18:	f105 0020 	add.w	r0, r5, #32
    ba1c:	f000 fd1c 	bl	c458 <radio_pkt_rx_set>
	radio_aa_set((u8_t *)&aa);
    ba20:	a80b      	add	r0, sp, #44	; 0x2c
    ba22:	f000 fcd5 	bl	c3d0 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
    ba26:	4943      	ldr	r1, [pc, #268]	; (bb34 <prepare_cb+0x19c>)
    ba28:	f240 605b 	movw	r0, #1627	; 0x65b
    ba2c:	f000 fd68 	bl	c500 <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
    ba30:	7a20      	ldrb	r0, [r4, #8]
    ba32:	f3c0 0041 	ubfx	r0, r0, #1, #2
    ba36:	3025      	adds	r0, #37	; 0x25
    ba38:	f7ff fd0c 	bl	b454 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
    ba3c:	4621      	mov	r1, r4
    ba3e:	483e      	ldr	r0, [pc, #248]	; (bb38 <prepare_cb+0x1a0>)
    ba40:	f000 fc54 	bl	c2ec <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
    ba44:	2096      	movs	r0, #150	; 0x96
    ba46:	f000 fe09 	bl	c65c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    ba4a:	2300      	movs	r3, #0
    ba4c:	461a      	mov	r2, r3
    ba4e:	4619      	mov	r1, r3
    ba50:	4618      	mov	r0, r3
    ba52:	f000 fd7b 	bl	c54c <radio_switch_complete_and_tx>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
    ba56:	7a23      	ldrb	r3, [r4, #8]
    ba58:	f013 0f18 	tst.w	r3, #24
    ba5c:	d007      	beq.n	ba6e <prepare_cb+0xd6>
		struct lll_filter *wl = ull_filter_lll_get(true);
    ba5e:	2001      	movs	r0, #1
    ba60:	f7ff fa92 	bl	af88 <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
    ba64:	7841      	ldrb	r1, [r0, #1]
    ba66:	1c82      	adds	r2, r0, #2
    ba68:	7800      	ldrb	r0, [r0, #0]
    ba6a:	f000 fda9 	bl	c5c0 <radio_filter_configure>
	evt = HDR_LLL2EVT(lll);
    ba6e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
    ba70:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
    ba72:	4638      	mov	r0, r7
    ba74:	f00a ffc1 	bl	169fa <lll_evt_offset_get>
    ba78:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
    ba7a:	6872      	ldr	r2, [r6, #4]
    ba7c:	f105 0109 	add.w	r1, r5, #9
    ba80:	2000      	movs	r0, #0
    ba82:	f000 fdf7 	bl	c674 <radio_tmr_start>
	radio_tmr_end_capture();
    ba86:	f000 fea3 	bl	c7d0 <radio_tmr_end_capture>
	radio_rssi_measure();
    ba8a:	f000 fd77 	bl	c57c <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
    ba8e:	4620      	mov	r0, r4
    ba90:	f7ff f9b0 	bl	adf4 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_SCAN_BASE +
    ba94:	1d01      	adds	r1, r0, #4
    ba96:	b2c9      	uxtb	r1, r1
    ba98:	462a      	mov	r2, r5
    ba9a:	4638      	mov	r0, r7
    ba9c:	f00a ffbb 	bl	16a16 <lll_preempt_calc>
    baa0:	4601      	mov	r1, r0
    baa2:	b130      	cbz	r0, bab2 <prepare_cb+0x11a>
		radio_isr_set(isr_abort, lll);
    baa4:	4825      	ldr	r0, [pc, #148]	; (bb3c <prepare_cb+0x1a4>)
    baa6:	4621      	mov	r1, r4
    baa8:	f000 fc20 	bl	c2ec <radio_isr_set>
		radio_disable();
    baac:	f000 fcec 	bl	c488 <radio_disable>
    bab0:	e790      	b.n	b9d4 <prepare_cb+0x3c>
		if (lll->ticks_window) {
    bab2:	69a3      	ldr	r3, [r4, #24]
    bab4:	b1fb      	cbz	r3, baf6 <prepare_cb+0x15e>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    bab6:	22ff      	movs	r2, #255	; 0xff
    bab8:	9208      	str	r2, [sp, #32]
    baba:	4a21      	ldr	r2, [pc, #132]	; (bb40 <prepare_cb+0x1a8>)
    babc:	e9cd 4206 	strd	r4, r2, [sp, #24]
    bac0:	4a20      	ldr	r2, [pc, #128]	; (bb44 <prepare_cb+0x1ac>)
    bac2:	e9cd 3000 	strd	r3, r0, [sp]
    bac6:	e9cd 0204 	strd	r0, r2, [sp, #16]
    baca:	462b      	mov	r3, r5
    bacc:	e9cd 0002 	strd	r0, r0, [sp, #8]
    bad0:	2203      	movs	r2, #3
    bad2:	f00a fe93 	bl	167fc <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    bad6:	f030 0302 	bics.w	r3, r0, #2
    bada:	d00c      	beq.n	baf6 <prepare_cb+0x15e>
    badc:	4a11      	ldr	r2, [pc, #68]	; (bb24 <prepare_cb+0x18c>)
    bade:	491a      	ldr	r1, [pc, #104]	; (bb48 <prepare_cb+0x1b0>)
    bae0:	4812      	ldr	r0, [pc, #72]	; (bb2c <prepare_cb+0x194>)
    bae2:	f44f 7380 	mov.w	r3, #256	; 0x100
    bae6:	f009 f820 	bl	14b2a <printk>
    baea:	4040      	eors	r0, r0
    baec:	f380 8811 	msr	BASEPRI, r0
    baf0:	f04f 0003 	mov.w	r0, #3
    baf4:	df02      	svc	2
		ret = lll_prepare_done(lll);
    baf6:	4620      	mov	r0, r4
    baf8:	f00a ff7d 	bl	169f6 <lll_prepare_done>
		LL_ASSERT(!ret);
    bafc:	2800      	cmp	r0, #0
    bafe:	f43f af69 	beq.w	b9d4 <prepare_cb+0x3c>
    bb02:	4a08      	ldr	r2, [pc, #32]	; (bb24 <prepare_cb+0x18c>)
    bb04:	4911      	ldr	r1, [pc, #68]	; (bb4c <prepare_cb+0x1b4>)
    bb06:	4809      	ldr	r0, [pc, #36]	; (bb2c <prepare_cb+0x194>)
    bb08:	f240 1305 	movw	r3, #261	; 0x105
    bb0c:	f009 f80d 	bl	14b2a <printk>
    bb10:	4040      	eors	r0, r0
    bb12:	f380 8811 	msr	BASEPRI, r0
    bb16:	f04f 0003 	mov.w	r0, #3
    bb1a:	df02      	svc	2
    bb1c:	e75a      	b.n	b9d4 <prepare_cb+0x3c>
    bb1e:	bf00      	nop
    bb20:	8e89bed6 	.word	0x8e89bed6
    bb24:	0001b798 	.word	0x0001b798
    bb28:	0001b750 	.word	0x0001b750
    bb2c:	0001aebe 	.word	0x0001aebe
    bb30:	0001b7e3 	.word	0x0001b7e3
    bb34:	00555555 	.word	0x00555555
    bb38:	0000be55 	.word	0x0000be55
    bb3c:	00016b09 	.word	0x00016b09
    bb40:	0000bc79 	.word	0x0000bc79
    bb44:	0000b981 	.word	0x0000b981
    bb48:	0001b4ec 	.word	0x0001b4ec
    bb4c:	0001b46e 	.word	0x0001b46e

0000bb50 <isr_common_done>:

	radio_isr_set(isr_rx, param);
}

static void isr_common_done(void *param)
{
    bb50:	b538      	push	{r3, r4, r5, lr}
    bb52:	4605      	mov	r5, r0
	struct node_rx_pdu *node_rx;

	/* TODO: MOVE to a common interface, isr_lll_radio_status? */
	/* Clear radio status and events */
	radio_status_reset();
    bb54:	f000 fcaa 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
    bb58:	f000 fd70 	bl	c63c <radio_tmr_status_reset>
	radio_filter_status_reset();
    bb5c:	f000 fd56 	bl	c60c <radio_filter_status_reset>
	radio_ar_status_reset();
    bb60:	f000 fe4a 	bl	c7f8 <radio_ar_status_reset>
	radio_rssi_status_reset();
    bb64:	f000 fd1a 	bl	c59c <radio_rssi_status_reset>
		radio_gpio_pa_lna_disable();
	}
	/* TODO: MOVE ^^ */

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
    bb68:	2096      	movs	r0, #150	; 0x96
    bb6a:	f000 fd77 	bl	c65c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    bb6e:	2300      	movs	r3, #0
    bb70:	4618      	mov	r0, r3
    bb72:	461a      	mov	r2, r3
    bb74:	4619      	mov	r1, r3
    bb76:	f000 fce9 	bl	c54c <radio_switch_complete_and_tx>

	node_rx = ull_pdu_rx_alloc_peek(1);
    bb7a:	2001      	movs	r0, #1
    bb7c:	f7fe fce4 	bl	a548 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    bb80:	4604      	mov	r4, r0
    bb82:	b960      	cbnz	r0, bb9e <isr_common_done+0x4e>
    bb84:	4a0c      	ldr	r2, [pc, #48]	; (bbb8 <isr_common_done+0x68>)
    bb86:	490d      	ldr	r1, [pc, #52]	; (bbbc <isr_common_done+0x6c>)
    bb88:	480d      	ldr	r0, [pc, #52]	; (bbc0 <isr_common_done+0x70>)
    bb8a:	f240 13fd 	movw	r3, #509	; 0x1fd
    bb8e:	f008 ffcc 	bl	14b2a <printk>
    bb92:	4040      	eors	r0, r0
    bb94:	f380 8811 	msr	BASEPRI, r0
    bb98:	f04f 0003 	mov.w	r0, #3
    bb9c:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    bb9e:	f104 0020 	add.w	r0, r4, #32
    bba2:	f000 fc59 	bl	c458 <radio_pkt_rx_set>

		radio_ar_configure(count, irks);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	radio_rssi_measure();
    bba6:	f000 fce9 	bl	c57c <radio_rssi_measure>

	radio_isr_set(isr_rx, param);
    bbaa:	4629      	mov	r1, r5
    bbac:	4805      	ldr	r0, [pc, #20]	; (bbc4 <isr_common_done+0x74>)
}
    bbae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(isr_rx, param);
    bbb2:	f000 bb9b 	b.w	c2ec <radio_isr_set>
    bbb6:	bf00      	nop
    bbb8:	0001b798 	.word	0x0001b798
    bbbc:	0001b7e3 	.word	0x0001b7e3
    bbc0:	0001aebe 	.word	0x0001aebe
    bbc4:	0000be55 	.word	0x0000be55

0000bbc8 <isr_tx>:
{
    bbc8:	b570      	push	{r4, r5, r6, lr}
    bbca:	4605      	mov	r5, r0
	radio_status_reset();
    bbcc:	f000 fc6e 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
    bbd0:	f000 fd34 	bl	c63c <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
    bbd4:	2096      	movs	r0, #150	; 0x96
    bbd6:	f000 fd41 	bl	c65c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    bbda:	2300      	movs	r3, #0
    bbdc:	4618      	mov	r0, r3
    bbde:	461a      	mov	r2, r3
    bbe0:	4619      	mov	r1, r3
    bbe2:	f000 fcb3 	bl	c54c <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
    bbe6:	2001      	movs	r0, #1
    bbe8:	f7fe fcae 	bl	a548 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    bbec:	4604      	mov	r4, r0
    bbee:	b960      	cbnz	r0, bc0a <isr_tx+0x42>
    bbf0:	4a1c      	ldr	r2, [pc, #112]	; (bc64 <isr_tx+0x9c>)
    bbf2:	491d      	ldr	r1, [pc, #116]	; (bc68 <isr_tx+0xa0>)
    bbf4:	481d      	ldr	r0, [pc, #116]	; (bc6c <isr_tx+0xa4>)
    bbf6:	f44f 73e2 	mov.w	r3, #452	; 0x1c4
    bbfa:	f008 ff96 	bl	14b2a <printk>
    bbfe:	4040      	eors	r0, r0
    bc00:	f380 8811 	msr	BASEPRI, r0
    bc04:	f04f 0003 	mov.w	r0, #3
    bc08:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    bc0a:	f104 0020 	add.w	r0, r4, #32
    bc0e:	f000 fc23 	bl	c458 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
    bc12:	f000 fc57 	bl	c4c4 <radio_is_ready>
    bc16:	b160      	cbz	r0, bc32 <isr_tx+0x6a>
    bc18:	4a12      	ldr	r2, [pc, #72]	; (bc64 <isr_tx+0x9c>)
    bc1a:	4915      	ldr	r1, [pc, #84]	; (bc70 <isr_tx+0xa8>)
    bc1c:	4813      	ldr	r0, [pc, #76]	; (bc6c <isr_tx+0xa4>)
    bc1e:	f44f 73e4 	mov.w	r3, #456	; 0x1c8
    bc22:	f008 ff82 	bl	14b2a <printk>
    bc26:	4040      	eors	r0, r0
    bc28:	f380 8811 	msr	BASEPRI, r0
    bc2c:	f04f 0003 	mov.w	r0, #3
    bc30:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    bc32:	f000 fdd5 	bl	c7e0 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
    bc36:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    bc38:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
    bc3a:	4608      	mov	r0, r1
    bc3c:	f00a ffa6 	bl	16b8c <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
    bc40:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
    bc42:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
    bc44:	4608      	mov	r0, r1
    bc46:	f00a ff9f 	bl	16b88 <radio_tx_chain_delay_get>
    bc4a:	4434      	add	r4, r6
    bc4c:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
    bc4e:	1a20      	subs	r0, r4, r0
    bc50:	f000 fdb2 	bl	c7b8 <radio_tmr_hcto_configure>
	radio_rssi_measure();
    bc54:	f000 fc92 	bl	c57c <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
    bc58:	4629      	mov	r1, r5
    bc5a:	4806      	ldr	r0, [pc, #24]	; (bc74 <isr_tx+0xac>)
}
    bc5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(isr_rx, param);
    bc60:	f000 bb44 	b.w	c2ec <radio_isr_set>
    bc64:	0001b798 	.word	0x0001b798
    bc68:	0001b7e3 	.word	0x0001b7e3
    bc6c:	0001aebe 	.word	0x0001aebe
    bc70:	0001b763 	.word	0x0001b763
    bc74:	0000be55 	.word	0x0000be55

0000bc78 <ticker_op_start_cb>:
{
    bc78:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    bc7a:	b160      	cbz	r0, bc96 <ticker_op_start_cb+0x1e>
    bc7c:	4a06      	ldr	r2, [pc, #24]	; (bc98 <ticker_op_start_cb+0x20>)
    bc7e:	4907      	ldr	r1, [pc, #28]	; (bc9c <ticker_op_start_cb+0x24>)
    bc80:	4807      	ldr	r0, [pc, #28]	; (bca0 <ticker_op_start_cb+0x28>)
    bc82:	f240 1361 	movw	r3, #353	; 0x161
    bc86:	f008 ff50 	bl	14b2a <printk>
    bc8a:	4040      	eors	r0, r0
    bc8c:	f380 8811 	msr	BASEPRI, r0
    bc90:	f04f 0003 	mov.w	r0, #3
    bc94:	df02      	svc	2
}
    bc96:	bd08      	pop	{r3, pc}
    bc98:	0001b798 	.word	0x0001b798
    bc9c:	0001b7eb 	.word	0x0001b7eb
    bca0:	0001aebe 	.word	0x0001aebe

0000bca4 <abort_cb>:
{
    bca4:	b510      	push	{r4, lr}
    bca6:	460c      	mov	r4, r1
	if (!prepare_param) {
    bca8:	b930      	cbnz	r0, bcb8 <abort_cb+0x14>
			radio_isr_set(isr_abort, param);
    bcaa:	480f      	ldr	r0, [pc, #60]	; (bce8 <abort_cb+0x44>)
    bcac:	f000 fb1e 	bl	c2ec <radio_isr_set>
}
    bcb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
    bcb4:	f000 bbe8 	b.w	c488 <radio_disable>
	err = lll_hfclock_off();
    bcb8:	f7ff fc1a 	bl	b4f0 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
    bcbc:	b170      	cbz	r0, bcdc <abort_cb+0x38>
    bcbe:	3010      	adds	r0, #16
    bcc0:	d00c      	beq.n	bcdc <abort_cb+0x38>
    bcc2:	4a0a      	ldr	r2, [pc, #40]	; (bcec <abort_cb+0x48>)
    bcc4:	490a      	ldr	r1, [pc, #40]	; (bcf0 <abort_cb+0x4c>)
    bcc6:	480b      	ldr	r0, [pc, #44]	; (bcf4 <abort_cb+0x50>)
    bcc8:	f240 1351 	movw	r3, #337	; 0x151
    bccc:	f008 ff2d 	bl	14b2a <printk>
    bcd0:	4040      	eors	r0, r0
    bcd2:	f380 8811 	msr	BASEPRI, r0
    bcd6:	f04f 0003 	mov.w	r0, #3
    bcda:	df02      	svc	2
	lll_done(param);
    bcdc:	4620      	mov	r0, r4
}
    bcde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    bce2:	f7ff bb65 	b.w	b3b0 <lll_done>
    bce6:	bf00      	nop
    bce8:	00016b09 	.word	0x00016b09
    bcec:	0001b798 	.word	0x0001b798
    bcf0:	0001b750 	.word	0x0001b750
    bcf4:	0001aebe 	.word	0x0001aebe

0000bcf8 <is_abort_cb>:
	if (next != curr) {
    bcf8:	4282      	cmp	r2, r0
{
    bcfa:	b510      	push	{r4, lr}
    bcfc:	4614      	mov	r4, r2
	if (next != curr) {
    bcfe:	d019      	beq.n	bd34 <is_abort_cb+0x3c>
		*resume_cb = resume_prepare_cb;
    bd00:	4a1a      	ldr	r2, [pc, #104]	; (bd6c <is_abort_cb+0x74>)
    bd02:	601a      	str	r2, [r3, #0]
		*resume_prio = 0; /* TODO: */
    bd04:	9b02      	ldr	r3, [sp, #8]
    bd06:	2200      	movs	r2, #0
    bd08:	601a      	str	r2, [r3, #0]
		err = lll_hfclock_on();
    bd0a:	f7ff fbe9 	bl	b4e0 <lll_hfclock_on>
		LL_ASSERT(!err || err == -EINPROGRESS);
    bd0e:	b170      	cbz	r0, bd2e <is_abort_cb+0x36>
    bd10:	3044      	adds	r0, #68	; 0x44
    bd12:	d00c      	beq.n	bd2e <is_abort_cb+0x36>
    bd14:	4a16      	ldr	r2, [pc, #88]	; (bd70 <is_abort_cb+0x78>)
    bd16:	4917      	ldr	r1, [pc, #92]	; (bd74 <is_abort_cb+0x7c>)
    bd18:	4817      	ldr	r0, [pc, #92]	; (bd78 <is_abort_cb+0x80>)
    bd1a:	f240 1327 	movw	r3, #295	; 0x127
    bd1e:	f008 ff04 	bl	14b2a <printk>
    bd22:	4040      	eors	r0, r0
    bd24:	f380 8811 	msr	BASEPRI, r0
    bd28:	f04f 0003 	mov.w	r0, #3
    bd2c:	df02      	svc	2
    bd2e:	f06f 000a 	mvn.w	r0, #10
    bd32:	e019      	b.n	bd68 <is_abort_cb+0x70>
	radio_isr_set(isr_window, lll);
    bd34:	4611      	mov	r1, r2
    bd36:	4811      	ldr	r0, [pc, #68]	; (bd7c <is_abort_cb+0x84>)
    bd38:	f000 fad8 	bl	c2ec <radio_isr_set>
	radio_disable();
    bd3c:	f000 fba4 	bl	c488 <radio_disable>
	if (++lll->chan == 3U) {
    bd40:	7a23      	ldrb	r3, [r4, #8]
    bd42:	f3c3 0241 	ubfx	r2, r3, #1, #2
    bd46:	3201      	adds	r2, #1
    bd48:	f002 0203 	and.w	r2, r2, #3
    bd4c:	2a03      	cmp	r2, #3
    bd4e:	bf14      	ite	ne
    bd50:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
    bd54:	f36f 0342 	bfceq	r3, #1, #2
    bd58:	7223      	strb	r3, [r4, #8]
	lll_chan_set(37 + lll->chan);
    bd5a:	7a20      	ldrb	r0, [r4, #8]
    bd5c:	f3c0 0041 	ubfx	r0, r0, #1, #2
    bd60:	3025      	adds	r0, #37	; 0x25
    bd62:	f7ff fb77 	bl	b454 <lll_chan_set>
	return 0;
    bd66:	2000      	movs	r0, #0
}
    bd68:	bd10      	pop	{r4, pc}
    bd6a:	bf00      	nop
    bd6c:	00016ac7 	.word	0x00016ac7
    bd70:	0001b798 	.word	0x0001b798
    bd74:	0001b775 	.word	0x0001b775
    bd78:	0001aebe 	.word	0x0001aebe
    bd7c:	00016aef 	.word	0x00016aef

0000bd80 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
    bd80:	b538      	push	{r3, r4, r5, lr}
    bd82:	4604      	mov	r4, r0
	struct lll_scan *lll = param;
	struct node_rx_hdr *node_rx;
	int err;

	if (lll_is_done(param)) {
    bd84:	f7ff fb5e 	bl	b444 <lll_is_done>
    bd88:	4605      	mov	r5, r0
    bd8a:	bb80      	cbnz	r0, bdee <isr_cleanup+0x6e>
		return;
	}

	radio_filter_disable();
    bd8c:	f000 fc34 	bl	c5f8 <radio_filter_disable>

	if (++lll->chan == 3U) {
    bd90:	7a23      	ldrb	r3, [r4, #8]
	}
#else /* !CONFIG_BT_CTLR_SCAN_INDICATION */
	ARG_UNUSED(node_rx);
#endif /* !CONFIG_BT_CTLR_SCAN_INDICATION */

	radio_isr_set(isr_race, param);
    bd92:	4817      	ldr	r0, [pc, #92]	; (bdf0 <isr_cleanup+0x70>)
	if (++lll->chan == 3U) {
    bd94:	f3c3 0241 	ubfx	r2, r3, #1, #2
    bd98:	3201      	adds	r2, #1
    bd9a:	f002 0203 	and.w	r2, r2, #3
    bd9e:	2a03      	cmp	r2, #3
    bda0:	bf14      	ite	ne
    bda2:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
    bda6:	f365 0342 	bfieq	r3, r5, #1, #2
    bdaa:	7223      	strb	r3, [r4, #8]
	radio_isr_set(isr_race, param);
    bdac:	4621      	mov	r1, r4
    bdae:	f000 fa9d 	bl	c2ec <radio_isr_set>
	if (!radio_is_idle()) {
    bdb2:	f000 fb9b 	bl	c4ec <radio_is_idle>
    bdb6:	b908      	cbnz	r0, bdbc <isr_cleanup+0x3c>
		radio_disable();
    bdb8:	f000 fb66 	bl	c488 <radio_disable>
	}

	radio_tmr_stop();
    bdbc:	f000 fcf0 	bl	c7a0 <radio_tmr_stop>

	err = lll_hfclock_off();
    bdc0:	f7ff fb96 	bl	b4f0 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
    bdc4:	b170      	cbz	r0, bde4 <isr_cleanup+0x64>
    bdc6:	3010      	adds	r0, #16
    bdc8:	d00c      	beq.n	bde4 <isr_cleanup+0x64>
    bdca:	4a0a      	ldr	r2, [pc, #40]	; (bdf4 <isr_cleanup+0x74>)
    bdcc:	490a      	ldr	r1, [pc, #40]	; (bdf8 <isr_cleanup+0x78>)
    bdce:	480b      	ldr	r0, [pc, #44]	; (bdfc <isr_cleanup+0x7c>)
    bdd0:	f44f 7322 	mov.w	r3, #648	; 0x288
    bdd4:	f008 fea9 	bl	14b2a <printk>
    bdd8:	4040      	eors	r0, r0
    bdda:	f380 8811 	msr	BASEPRI, r0
    bdde:	f04f 0003 	mov.w	r0, #3
    bde2:	df02      	svc	2

	lll_done(NULL);
}
    bde4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
    bde8:	2000      	movs	r0, #0
    bdea:	f7ff bae1 	b.w	b3b0 <lll_done>
}
    bdee:	bd38      	pop	{r3, r4, r5, pc}
    bdf0:	00016ab1 	.word	0x00016ab1
    bdf4:	0001b798 	.word	0x0001b798
    bdf8:	0001b750 	.word	0x0001b750
    bdfc:	0001aebe 	.word	0x0001aebe

0000be00 <isr_rx_scan_report.isra.0>:
	return ((sreq->rx_addr == srsp->tx_addr) &&
		(memcmp(&sreq->scan_req.adv_addr[0],
			&srsp->scan_rsp.addr[0], BDADDR_SIZE) == 0));
}

static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
    be00:	b570      	push	{r4, r5, r6, lr}
    be02:	4605      	mov	r5, r0
				u8_t rl_idx, bool dir_report)
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;

	node_rx = ull_pdu_rx_alloc_peek(3);
    be04:	2003      	movs	r0, #3
static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
    be06:	460e      	mov	r6, r1
	node_rx = ull_pdu_rx_alloc_peek(3);
    be08:	f7fe fb9e 	bl	a548 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
    be0c:	4604      	mov	r4, r0
    be0e:	b1e8      	cbz	r0, be4c <isr_rx_scan_report.isra.0+0x4c>
		return 1;
	}
	ull_pdu_rx_alloc();
    be10:	f7fe fbb2 	bl	a578 <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
    be14:	f64f 73ff 	movw	r3, #65535	; 0xffff
    be18:	80e3      	strh	r3, [r4, #6]
			LL_ASSERT(0);
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
    be1a:	2304      	movs	r3, #4
    be1c:	7123      	strb	r3, [r4, #4]
	}

	pdu_adv_rx = (void *)node_rx->pdu;

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
    be1e:	b19e      	cbz	r6, be48 <isr_rx_scan_report.isra.0+0x48>
				   (radio_rssi_get() & 0x7f)
    be20:	f000 fbb6 	bl	c590 <radio_rssi_get>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
    be24:	f000 037f 	and.w	r3, r0, #127	; 0x7f
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
    be28:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
    be2a:	7723      	strb	r3, [r4, #28]
	ull_rx_put(node_rx->hdr.link, node_rx);
    be2c:	4621      	mov	r1, r4
    be2e:	f7fe fbb9 	bl	a5a4 <ull_rx_put>
	ull_rx_sched();
    be32:	f7fe fbbd 	bl	a5b0 <ull_rx_sched>
        #ifdef SAEWOO_HACK
        saewoo_hack[1] = 0xFF;
        saewoo_hack[0] = 0xFF;
        saewoo_hack[0] = lll->chan;
    be36:	7a2b      	ldrb	r3, [r5, #8]
    be38:	4a05      	ldr	r2, [pc, #20]	; (be50 <isr_rx_scan_report.isra.0+0x50>)
    be3a:	f3c3 0341 	ubfx	r3, r3, #1, #2
    be3e:	7013      	strb	r3, [r2, #0]
        saewoo_hack[1] = node_rx->hdr.rx_ftr.rssi;
    be40:	7f23      	ldrb	r3, [r4, #28]
    be42:	7053      	strb	r3, [r2, #1]
        #endif
	return 0;
    be44:	2000      	movs	r0, #0
}
    be46:	bd70      	pop	{r4, r5, r6, pc}
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
    be48:	237f      	movs	r3, #127	; 0x7f
    be4a:	e7ed      	b.n	be28 <isr_rx_scan_report.isra.0+0x28>
		return 1;
    be4c:	2001      	movs	r0, #1
    be4e:	e7fa      	b.n	be46 <isr_rx_scan_report.isra.0+0x46>
    be50:	20007a31 	.word	0x20007a31

0000be54 <isr_rx>:
{
    be54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    be58:	4605      	mov	r5, r0
	trx_done = radio_is_done();
    be5a:	f000 fb3d 	bl	c4d8 <radio_is_done>
	if (trx_done) {
    be5e:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
    be62:	f000 8097 	beq.w	bf94 <isr_rx+0x140>
		crc_ok = radio_crc_is_valid();
    be66:	f000 fb57 	bl	c518 <radio_crc_is_valid>
    be6a:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
    be6e:	f000 fbd5 	bl	c61c <radio_filter_has_match>
    be72:	b2c7      	uxtb	r7, r0
		devmatch_id = radio_filter_match_get();
    be74:	f000 fbdc 	bl	c630 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
    be78:	f000 fcca 	bl	c810 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
    be7c:	f000 fcb6 	bl	c7ec <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
    be80:	f000 fb94 	bl	c5ac <radio_rssi_is_ready>
    be84:	b2c6      	uxtb	r6, r0
	radio_status_reset();
    be86:	f000 fb11 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
    be8a:	f000 fbd7 	bl	c63c <radio_tmr_status_reset>
	radio_filter_status_reset();
    be8e:	f000 fbbd 	bl	c60c <radio_filter_status_reset>
	radio_ar_status_reset();
    be92:	f000 fcb1 	bl	c7f8 <radio_ar_status_reset>
	radio_rssi_status_reset();
    be96:	f000 fb81 	bl	c59c <radio_rssi_status_reset>
	if (!trx_done) {
    be9a:	2c00      	cmp	r4, #0
    be9c:	f000 8097 	beq.w	bfce <isr_rx+0x17a>
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
    bea0:	f1b8 0f00 	cmp.w	r8, #0
    bea4:	f000 8093 	beq.w	bfce <isr_rx+0x17a>
	return ((lll->filter_policy & 0x01) == 0U) ||
    bea8:	7a2b      	ldrb	r3, [r5, #8]
    beaa:	0719      	lsls	r1, r3, #28
    beac:	d502      	bpl.n	beb4 <isr_rx+0x60>
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
    beae:	2f00      	cmp	r7, #0
    beb0:	f000 808d 	beq.w	bfce <isr_rx+0x17a>
	node_rx = ull_pdu_rx_alloc_peek(1);
    beb4:	2001      	movs	r0, #1
    beb6:	f7fe fb47 	bl	a548 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    beba:	4604      	mov	r4, r0
    bebc:	b960      	cbnz	r0, bed8 <isr_rx+0x84>
    bebe:	4a68      	ldr	r2, [pc, #416]	; (c060 <CONFIG_USB_DEVICE_PID+0x47>)
    bec0:	4968      	ldr	r1, [pc, #416]	; (c064 <CONFIG_USB_DEVICE_PID+0x4b>)
    bec2:	4869      	ldr	r0, [pc, #420]	; (c068 <CONFIG_USB_DEVICE_PID+0x4f>)
    bec4:	f240 23ab 	movw	r3, #683	; 0x2ab
    bec8:	f008 fe2f 	bl	14b2a <printk>
    becc:	4040      	eors	r0, r0
    bece:	f380 8811 	msr	BASEPRI, r0
    bed2:	f04f 0003 	mov.w	r0, #3
    bed6:	df02      	svc	2
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    bed8:	f894 3020 	ldrb.w	r3, [r4, #32]
    bedc:	f013 020f 	ands.w	r2, r3, #15
    bee0:	d002      	beq.n	bee8 <isr_rx+0x94>
    bee2:	2a06      	cmp	r2, #6
    bee4:	f040 80b9 	bne.w	c05a <CONFIG_USB_DEVICE_PID+0x41>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    bee8:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
    beec:	2925      	cmp	r1, #37	; 0x25
    beee:	d855      	bhi.n	bf9c <isr_rx+0x148>
		   lll->type &&
    bef0:	f995 1008 	ldrsb.w	r1, [r5, #8]
    bef4:	2900      	cmp	r1, #0
    bef6:	da51      	bge.n	bf9c <isr_rx+0x148>
		radio_tmr_tifs_set(EVENT_IFS_US);
    bef8:	2096      	movs	r0, #150	; 0x96
    befa:	f000 fbaf 	bl	c65c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    befe:	2000      	movs	r0, #0
    bf00:	f000 fb18 	bl	c534 <radio_switch_complete_and_rx>
		err = isr_rx_scan_report(lll, rssi_ready,
    bf04:	4631      	mov	r1, r6
    bf06:	4628      	mov	r0, r5
    bf08:	f7ff ff7a 	bl	be00 <isr_rx_scan_report.isra.0>
		if (err) {
    bf0c:	2800      	cmp	r0, #0
    bf0e:	d15e      	bne.n	bfce <isr_rx+0x17a>
		pdu_tx = (void *)radio_pkt_scratch_get();
    bf10:	f000 fb0c 	bl	c52c <radio_pkt_scratch_get>
			pdu_tx->tx_addr = lll->init_addr_type;
    bf14:	7a2b      	ldrb	r3, [r5, #8]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    bf16:	f894 2020 	ldrb.w	r2, [r4, #32]
			pdu_tx->tx_addr = lll->init_addr_type;
    bf1a:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    bf1e:	019b      	lsls	r3, r3, #6
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    bf20:	f3c2 1280 	ubfx	r2, r2, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    bf24:	f043 0303 	orr.w	r3, r3, #3
    bf28:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
    bf2c:	7802      	ldrb	r2, [r0, #0]
    bf2e:	f002 0230 	and.w	r2, r2, #48	; 0x30
    bf32:	4313      	orrs	r3, r2
    bf34:	7003      	strb	r3, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
    bf36:	230c      	movs	r3, #12
    bf38:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
    bf3a:	4606      	mov	r6, r0
			memcpy(&pdu_tx->scan_req.scan_addr[0],
    bf3c:	2206      	movs	r2, #6
    bf3e:	f105 0109 	add.w	r1, r5, #9
    bf42:	3002      	adds	r0, #2
    bf44:	f00a f879 	bl	1603a <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
    bf48:	2206      	movs	r2, #6
    bf4a:	f104 0122 	add.w	r1, r4, #34	; 0x22
    bf4e:	f106 0008 	add.w	r0, r6, #8
    bf52:	f00a f872 	bl	1603a <memcpy>
		radio_pkt_tx_set(pdu_tx);
    bf56:	4630      	mov	r0, r6
    bf58:	f000 fa84 	bl	c464 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    bf5c:	f000 fab2 	bl	c4c4 <radio_is_ready>
    bf60:	b160      	cbz	r0, bf7c <isr_rx+0x128>
    bf62:	4a3f      	ldr	r2, [pc, #252]	; (c060 <CONFIG_USB_DEVICE_PID+0x47>)
    bf64:	4941      	ldr	r1, [pc, #260]	; (c06c <CONFIG_USB_DEVICE_PID+0x53>)
    bf66:	4840      	ldr	r0, [pc, #256]	; (c068 <CONFIG_USB_DEVICE_PID+0x4f>)
    bf68:	f240 33a5 	movw	r3, #933	; 0x3a5
    bf6c:	f008 fddd 	bl	14b2a <printk>
    bf70:	4040      	eors	r0, r0
    bf72:	f380 8811 	msr	BASEPRI, r0
    bf76:	f04f 0003 	mov.w	r0, #3
    bf7a:	df02      	svc	2
		radio_tmr_end_capture();
    bf7c:	f000 fc28 	bl	c7d0 <radio_tmr_end_capture>
		lll->state = 1U;
    bf80:	7a2b      	ldrb	r3, [r5, #8]
		radio_isr_set(isr_tx, lll);
    bf82:	483b      	ldr	r0, [pc, #236]	; (c070 <CONFIG_USB_DEVICE_PID+0x57>)
		lll->state = 1U;
    bf84:	f043 0301 	orr.w	r3, r3, #1
    bf88:	722b      	strb	r3, [r5, #8]
		radio_isr_set(isr_tx, lll);
    bf8a:	4629      	mov	r1, r5
}
    bf8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		radio_isr_set(isr_tx, lll);
    bf90:	f000 b9ac 	b.w	c2ec <radio_isr_set>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    bf94:	4626      	mov	r6, r4
    bf96:	4627      	mov	r7, r4
    bf98:	46a0      	mov	r8, r4
    bf9a:	e774      	b.n	be86 <isr_rx+0x32>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    bf9c:	f013 0f0d 	tst.w	r3, #13
    bfa0:	d001      	beq.n	bfa6 <isr_rx+0x152>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_NONCONN_IND) ||
    bfa2:	2a06      	cmp	r2, #6
    bfa4:	d10b      	bne.n	bfbe <isr_rx+0x16a>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    bfa6:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
    bfaa:	2925      	cmp	r1, #37	; 0x25
    bfac:	d807      	bhi.n	bfbe <isr_rx+0x16a>
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
    bfae:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    bfb2:	b163      	cbz	r3, bfce <isr_rx+0x17a>
		err = isr_rx_scan_report(lll, rssi_ready,
    bfb4:	4631      	mov	r1, r6
    bfb6:	4628      	mov	r0, r5
    bfb8:	f7ff ff22 	bl	be00 <isr_rx_scan_report.isra.0>
		if (err) {
    bfbc:	e007      	b.n	bfce <isr_rx+0x17a>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
    bfbe:	2a01      	cmp	r2, #1
    bfc0:	d00d      	beq.n	bfde <isr_rx+0x18a>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    bfc2:	f894 3020 	ldrb.w	r3, [r4, #32]
					&dir_report))) ||
    bfc6:	f003 030f 	and.w	r3, r3, #15
    bfca:	2b04      	cmp	r3, #4
    bfcc:	d02b      	beq.n	c026 <CONFIG_USB_DEVICE_PID+0xd>
	radio_isr_set(isr_done, lll);
    bfce:	4629      	mov	r1, r5
    bfd0:	4828      	ldr	r0, [pc, #160]	; (c074 <CONFIG_USB_DEVICE_PID+0x5b>)
    bfd2:	f000 f98b 	bl	c2ec <radio_isr_set>
}
    bfd6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	radio_disable();
    bfda:	f000 ba55 	b.w	c488 <radio_disable>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
    bfde:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    bfe2:	2a0c      	cmp	r2, #12
    bfe4:	d1f3      	bne.n	bfce <isr_rx+0x17a>
	return (((lll->init_addr_type == pdu->rx_addr) &&
    bfe6:	7a2a      	ldrb	r2, [r5, #8]
			BDADDR_SIZE))) ||
    bfe8:	f3c2 1280 	ubfx	r2, r2, #6, #1
    bfec:	ebb2 1fd3 	cmp.w	r2, r3, lsr #7
    bff0:	d00f      	beq.n	c012 <isr_rx+0x1be>
	if (((lll->filter_policy & 0x02) != 0U) &&
    bff2:	7a2b      	ldrb	r3, [r5, #8]
    bff4:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    bff8:	079a      	lsls	r2, r3, #30
    bffa:	d5e2      	bpl.n	bfc2 <isr_rx+0x16e>
    bffc:	f994 3020 	ldrsb.w	r3, [r4, #32]
    c000:	2b00      	cmp	r3, #0
    c002:	dade      	bge.n	bfc2 <isr_rx+0x16e>
		   (pdu_adv_rx->len == sizeof(struct pdu_adv_direct_ind)) &&
    c004:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    c008:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    c00c:	2b40      	cmp	r3, #64	; 0x40
    c00e:	d0ce      	beq.n	bfae <isr_rx+0x15a>
    c010:	e7d7      	b.n	bfc2 <isr_rx+0x16e>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
    c012:	2206      	movs	r2, #6
    c014:	f104 0128 	add.w	r1, r4, #40	; 0x28
    c018:	f105 0009 	add.w	r0, r5, #9
    c01c:	f009 fffd 	bl	1601a <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
    c020:	2800      	cmp	r0, #0
    c022:	d0c4      	beq.n	bfae <isr_rx+0x15a>
    c024:	e7e5      	b.n	bff2 <isr_rx+0x19e>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    c026:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    c02a:	2b25      	cmp	r3, #37	; 0x25
    c02c:	d8cf      	bhi.n	bfce <isr_rx+0x17a>
		   (lll->state != 0U) &&
    c02e:	7a2b      	ldrb	r3, [r5, #8]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
    c030:	07db      	lsls	r3, r3, #31
    c032:	d5cc      	bpl.n	bfce <isr_rx+0x17a>
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
    c034:	f000 fa7a 	bl	c52c <radio_pkt_scratch_get>
	return ((sreq->rx_addr == srsp->tx_addr) &&
    c038:	f894 3020 	ldrb.w	r3, [r4, #32]
    c03c:	7802      	ldrb	r2, [r0, #0]
    c03e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    c042:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    c046:	d1c2      	bne.n	bfce <isr_rx+0x17a>
		(memcmp(&sreq->scan_req.adv_addr[0],
    c048:	2206      	movs	r2, #6
    c04a:	f104 0122 	add.w	r1, r4, #34	; 0x22
    c04e:	3008      	adds	r0, #8
    c050:	f009 ffe3 	bl	1601a <memcmp>
		   (lll->state != 0U) &&
    c054:	2800      	cmp	r0, #0
    c056:	d0aa      	beq.n	bfae <isr_rx+0x15a>
    c058:	e7b9      	b.n	bfce <isr_rx+0x17a>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    c05a:	2a02      	cmp	r2, #2
    c05c:	e7a2      	b.n	bfa4 <isr_rx+0x150>
    c05e:	bf00      	nop
    c060:	0001b798 	.word	0x0001b798
    c064:	0001b7e3 	.word	0x0001b7e3
    c068:	0001aebe 	.word	0x0001aebe
    c06c:	0001b763 	.word	0x0001b763
    c070:	0000bbc9 	.word	0x0000bbc9
    c074:	00016ab5 	.word	0x00016ab5

0000c078 <lll_scan_prepare>:
{
    c078:	b513      	push	{r0, r1, r4, lr}
    c07a:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    c07c:	f7ff fa30 	bl	b4e0 <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
    c080:	b168      	cbz	r0, c09e <lll_scan_prepare+0x26>
    c082:	3044      	adds	r0, #68	; 0x44
    c084:	d00b      	beq.n	c09e <lll_scan_prepare+0x26>
    c086:	4a12      	ldr	r2, [pc, #72]	; (c0d0 <lll_scan_prepare+0x58>)
    c088:	4912      	ldr	r1, [pc, #72]	; (c0d4 <lll_scan_prepare+0x5c>)
    c08a:	4813      	ldr	r0, [pc, #76]	; (c0d8 <lll_scan_prepare+0x60>)
    c08c:	236e      	movs	r3, #110	; 0x6e
    c08e:	f008 fd4c 	bl	14b2a <printk>
    c092:	4040      	eors	r0, r0
    c094:	f380 8811 	msr	BASEPRI, r0
    c098:	f04f 0003 	mov.w	r0, #3
    c09c:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
    c09e:	4a0f      	ldr	r2, [pc, #60]	; (c0dc <lll_scan_prepare+0x64>)
    c0a0:	490f      	ldr	r1, [pc, #60]	; (c0e0 <lll_scan_prepare+0x68>)
    c0a2:	4810      	ldr	r0, [pc, #64]	; (c0e4 <lll_scan_prepare+0x6c>)
    c0a4:	9400      	str	r4, [sp, #0]
    c0a6:	2300      	movs	r3, #0
    c0a8:	f00a fc9c 	bl	169e4 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    c0ac:	b168      	cbz	r0, c0ca <lll_scan_prepare+0x52>
    c0ae:	3044      	adds	r0, #68	; 0x44
    c0b0:	d00b      	beq.n	c0ca <lll_scan_prepare+0x52>
    c0b2:	4a07      	ldr	r2, [pc, #28]	; (c0d0 <lll_scan_prepare+0x58>)
    c0b4:	4907      	ldr	r1, [pc, #28]	; (c0d4 <lll_scan_prepare+0x5c>)
    c0b6:	4808      	ldr	r0, [pc, #32]	; (c0d8 <lll_scan_prepare+0x60>)
    c0b8:	2371      	movs	r3, #113	; 0x71
    c0ba:	f008 fd36 	bl	14b2a <printk>
    c0be:	4040      	eors	r0, r0
    c0c0:	f380 8811 	msr	BASEPRI, r0
    c0c4:	f04f 0003 	mov.w	r0, #3
    c0c8:	df02      	svc	2
}
    c0ca:	b002      	add	sp, #8
    c0cc:	bd10      	pop	{r4, pc}
    c0ce:	bf00      	nop
    c0d0:	0001b798 	.word	0x0001b798
    c0d4:	0001b775 	.word	0x0001b775
    c0d8:	0001aebe 	.word	0x0001aebe
    c0dc:	0000b999 	.word	0x0000b999
    c0e0:	0000bca5 	.word	0x0000bca5
    c0e4:	0000bcf9 	.word	0x0000bcf9

0000c0e8 <cntr_init>:

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
    c0e8:	4b05      	ldr	r3, [pc, #20]	; (c100 <cntr_init+0x18>)
    c0ea:	2200      	movs	r2, #0
    c0ec:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    c0f0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    c0f4:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
    c0f8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
    c0fc:	4770      	bx	lr
    c0fe:	bf00      	nop
    c100:	4000b000 	.word	0x4000b000

0000c104 <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
    c104:	4a04      	ldr	r2, [pc, #16]	; (c118 <cntr_start+0x14>)
    c106:	7813      	ldrb	r3, [r2, #0]
    c108:	1c59      	adds	r1, r3, #1
    c10a:	7011      	strb	r1, [r2, #0]
    c10c:	2001      	movs	r0, #1
    c10e:	b913      	cbnz	r3, c116 <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    c110:	4a02      	ldr	r2, [pc, #8]	; (c11c <cntr_start+0x18>)
    c112:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
    c114:	4618      	mov	r0, r3
}
    c116:	4770      	bx	lr
    c118:	200087b6 	.word	0x200087b6
    c11c:	4000b000 	.word	0x4000b000

0000c120 <cntr_stop>:

u32_t cntr_stop(void)
{
    c120:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
    c122:	4c0d      	ldr	r4, [pc, #52]	; (c158 <cntr_stop+0x38>)
    c124:	7823      	ldrb	r3, [r4, #0]
    c126:	b95b      	cbnz	r3, c140 <cntr_stop+0x20>
    c128:	4a0c      	ldr	r2, [pc, #48]	; (c15c <cntr_stop+0x3c>)
    c12a:	490d      	ldr	r1, [pc, #52]	; (c160 <cntr_stop+0x40>)
    c12c:	480d      	ldr	r0, [pc, #52]	; (c164 <cntr_stop+0x44>)
    c12e:	232e      	movs	r3, #46	; 0x2e
    c130:	f008 fcfb 	bl	14b2a <printk>
    c134:	4040      	eors	r0, r0
    c136:	f380 8811 	msr	BASEPRI, r0
    c13a:	f04f 0003 	mov.w	r0, #3
    c13e:	df02      	svc	2

	if (--_refcount) {
    c140:	7820      	ldrb	r0, [r4, #0]
    c142:	3801      	subs	r0, #1
    c144:	b2c0      	uxtb	r0, r0
    c146:	7020      	strb	r0, [r4, #0]
    c148:	2301      	movs	r3, #1
    c14a:	b910      	cbnz	r0, c152 <cntr_stop+0x32>
    c14c:	4a06      	ldr	r2, [pc, #24]	; (c168 <cntr_stop+0x48>)
    c14e:	6013      	str	r3, [r2, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
    c150:	bd10      	pop	{r4, pc}
		return 1;
    c152:	4618      	mov	r0, r3
    c154:	e7fc      	b.n	c150 <cntr_stop+0x30>
    c156:	bf00      	nop
    c158:	200087b6 	.word	0x200087b6
    c15c:	0001b808 	.word	0x0001b808
    c160:	0001b854 	.word	0x0001b854
    c164:	0001aebe 	.word	0x0001aebe
    c168:	4000b004 	.word	0x4000b004

0000c16c <cntr_cnt_get>:
     return p_reg->COUNTER;
    c16c:	4b01      	ldr	r3, [pc, #4]	; (c174 <cntr_cnt_get+0x8>)
    c16e:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
    c172:	4770      	bx	lr
    c174:	4000b000 	.word	0x4000b000

0000c178 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
    c178:	4b02      	ldr	r3, [pc, #8]	; (c184 <cntr_cmp_set+0xc>)
    c17a:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    c17e:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
    c182:	4770      	bx	lr
    c184:	4000b000 	.word	0x4000b000

0000c188 <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
    c188:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
    c18a:	4b13      	ldr	r3, [pc, #76]	; (c1d8 <do_ecb+0x50>)

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c18c:	4c13      	ldr	r4, [pc, #76]	; (c1dc <do_ecb+0x54>)
    c18e:	2501      	movs	r5, #1
    c190:	462e      	mov	r6, r5
		NRF_ECB->EVENTS_ENDECB = 0;
    c192:	2700      	movs	r7, #0
    c194:	46a6      	mov	lr, r4
    c196:	461a      	mov	r2, r3
    c198:	6026      	str	r6, [r4, #0]
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
    c19a:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
    c19e:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
    c1a2:	f8c3 7104 	str.w	r7, [r3, #260]	; 0x104
    c1a6:	601e      	str	r6, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    c1a8:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    c1ac:	b931      	cbnz	r1, c1bc <do_ecb+0x34>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    c1ae:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    c1b2:	b919      	cbnz	r1, c1bc <do_ecb+0x34>
		       (NRF_ECB->ECBDATAPTR != 0)) {
    c1b4:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    c1b8:	2900      	cmp	r1, #0
    c1ba:	d1f5      	bne.n	c1a8 <do_ecb+0x20>
    c1bc:	f8ce 5000 	str.w	r5, [lr]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
    c1c0:	f8d2 1104 	ldr.w	r1, [r2, #260]	; 0x104
    c1c4:	2900      	cmp	r1, #0
    c1c6:	d1e7      	bne.n	c198 <do_ecb+0x10>
    c1c8:	f8d2 c504 	ldr.w	ip, [r2, #1284]	; 0x504
    c1cc:	f1bc 0f00 	cmp.w	ip, #0
    c1d0:	d0e2      	beq.n	c198 <do_ecb+0x10>

	NRF_ECB->ECBDATAPTR = 0;
    c1d2:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
}
    c1d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c1d8:	4000e000 	.word	0x4000e000
    c1dc:	4000e004 	.word	0x4000e004

0000c1e0 <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(u8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
    c1e0:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
    c1e2:	4b08      	ldr	r3, [pc, #32]	; (c204 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
    c1e4:	bf14      	ite	ne
    c1e6:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
    c1ea:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
    c1ee:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
    c1f2:	bf14      	ite	ne
    c1f4:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
    c1f8:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
    c1fc:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
    c200:	4770      	bx	lr
    c202:	bf00      	nop
    c204:	4001f000 	.word	0x4001f000

0000c208 <sw_switch.isra.0>:
}

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
    c208:	b5f0      	push	{r4, r5, r6, r7, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
    c20a:	4e2b      	ldr	r6, [pc, #172]	; (c2b8 <sw_switch.isra.0+0xb0>)
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c20c:	4f2b      	ldr	r7, [pc, #172]	; (c2bc <sw_switch.isra.0+0xb4>)
    c20e:	7835      	ldrb	r5, [r6, #0]
    c210:	f8df c0b4 	ldr.w	ip, [pc, #180]	; c2c8 <sw_switch.isra.0+0xc0>
    c214:	f8c7 c560 	str.w	ip, [r7, #1376]	; 0x560
	 */
	nrf_ppi_channel_endpoint_setup(
		NRF_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
    c218:	00ec      	lsls	r4, r5, #3
    c21a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    c21e:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c222:	f8c7 4564 	str.w	r4, [r7, #1380]	; 0x564
    c226:	f105 040b 	add.w	r4, r5, #11
    c22a:	b2e4      	uxtb	r4, r4
    c22c:	00e4      	lsls	r4, r4, #3
	 * (TX/RX).
	 */
	nrf_ppi_event_endpoint_setup(
		NRF_PPI,
		radio_enable_ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
    c22e:	f5a7 37af 	sub.w	r7, r7, #89600	; 0x15e00
    c232:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    c236:	3fc0      	subs	r7, #192	; 0xc0
    c238:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    c23c:	eb07 0785 	add.w	r7, r7, r5, lsl #2
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
    c240:	462b      	mov	r3, r5

NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                    nrf_ppi_channel_t channel,
                                                    uint32_t          eep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c242:	f8c4 7510 	str.w	r7, [r4, #1296]	; 0x510
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
    c246:	b390      	cbz	r0, c2ae <sw_switch.isra.0+0xa6>
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_2M_NS;
    c248:	f649 70c4 	movw	r0, #40900	; 0x9fc4
    c24c:	f649 4740 	movw	r7, #40000	; 0x9c40
    c250:	2a02      	cmp	r2, #2
    c252:	bf14      	ite	ne
    c254:	4602      	movne	r2, r0
    c256:	463a      	moveq	r2, r7
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_2M_NS;
    c258:	f242 40b8 	movw	r0, #9400	; 0x24b8
    c25c:	f241 3788 	movw	r7, #5000	; 0x1388
    c260:	2902      	cmp	r1, #2
    c262:	bf14      	ite	ne
    c264:	4601      	movne	r1, r0
    c266:	4639      	moveq	r1, r7
		/* TX */

		/* Calculate delay with respect to current (RX) and next
		 * (TX) PHY. If RX PHY is LE Coded, assume S8 coding scheme.
		 */
		delay = HAL_RADIO_NS2US_ROUND(
    c268:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
    c26c:	440a      	add	r2, r1
    c26e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    c272:	fbb2 f2f1 	udiv	r2, r2, r1

NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                   nrf_ppi_channel_t channel,
                                                   uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c276:	4912      	ldr	r1, [pc, #72]	; (c2c0 <sw_switch.isra.0+0xb8>)
    c278:	f8c4 1514 	str.w	r1, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
    c27c:	009b      	lsls	r3, r3, #2
    c27e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    c282:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
		SW_SWITCH_TIMER->CC[cc]) {
    c286:	f8d3 1540 	ldr.w	r1, [r3, #1344]	; 0x540
	if (delay <
    c28a:	4291      	cmp	r1, r2
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 SW_SWITCH_TIMER->CC[cc] - delay);
    c28c:	bf8a      	itet	hi
    c28e:	f8d3 1540 	ldrhi.w	r1, [r3, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
    c292:	2201      	movls	r2, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
    c294:	1a8a      	subhi	r2, r1, r2
    c296:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CHENSET = mask;
    c29a:	4b08      	ldr	r3, [pc, #32]	; (c2bc <sw_switch.isra.0+0xb4>)
    c29c:	f44f 6290 	mov.w	r2, #1152	; 0x480
    c2a0:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
    c2a4:	1c6b      	adds	r3, r5, #1
	sw_tifs_toggle &= 1;
    c2a6:	f003 0301 	and.w	r3, r3, #1
    c2aa:	7033      	strb	r3, [r6, #0]
}
    c2ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c2ae:	4a05      	ldr	r2, [pc, #20]	; (c2c4 <sw_switch.isra.0+0xbc>)
    c2b0:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
    c2b4:	2228      	movs	r2, #40	; 0x28
{
	nrf_ppi_task_endpoint_setup(
		NRF_PPI,
		ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_TASK_RX);
}
    c2b6:	e7e1      	b.n	c27c <sw_switch.isra.0+0x74>
    c2b8:	200087b7 	.word	0x200087b7
    c2bc:	4001f000 	.word	0x4001f000
    c2c0:	40001000 	.word	0x40001000
    c2c4:	40001004 	.word	0x40001004
    c2c8:	4000110c 	.word	0x4000110c

0000c2cc <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
    c2cc:	4b04      	ldr	r3, [pc, #16]	; (c2e0 <isr_radio+0x14>)
    c2ce:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
    c2d2:	b123      	cbz	r3, c2de <isr_radio+0x12>
		isr_cb(isr_cb_param);
    c2d4:	4b03      	ldr	r3, [pc, #12]	; (c2e4 <isr_radio+0x18>)
    c2d6:	4a04      	ldr	r2, [pc, #16]	; (c2e8 <isr_radio+0x1c>)
    c2d8:	681b      	ldr	r3, [r3, #0]
    c2da:	6810      	ldr	r0, [r2, #0]
    c2dc:	4718      	bx	r3
}
    c2de:	4770      	bx	lr
    c2e0:	40001000 	.word	0x40001000
    c2e4:	20003744 	.word	0x20003744
    c2e8:	20003748 	.word	0x20003748

0000c2ec <radio_isr_set>:
{
    c2ec:	b538      	push	{r3, r4, r5, lr}
    c2ee:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
    c2f0:	2001      	movs	r0, #1
{
    c2f2:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
    c2f4:	f7f9 fc00 	bl	5af8 <arch_irq_disable>
	isr_cb_param = param;
    c2f8:	4b08      	ldr	r3, [pc, #32]	; (c31c <radio_isr_set+0x30>)
    c2fa:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
    c2fc:	4b08      	ldr	r3, [pc, #32]	; (c320 <radio_isr_set+0x34>)
    c2fe:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    c300:	4b08      	ldr	r3, [pc, #32]	; (c324 <radio_isr_set+0x38>)
    c302:	2210      	movs	r2, #16
    c304:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c308:	4b07      	ldr	r3, [pc, #28]	; (c328 <radio_isr_set+0x3c>)
    c30a:	2202      	movs	r2, #2
    c30c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
    c310:	2001      	movs	r0, #1
}
    c312:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
    c316:	f7f9 bbdf 	b.w	5ad8 <arch_irq_enable>
    c31a:	bf00      	nop
    c31c:	20003748 	.word	0x20003748
    c320:	20003744 	.word	0x20003744
    c324:	40001000 	.word	0x40001000
    c328:	e000e100 	.word	0xe000e100

0000c32c <radio_reset>:
{
    c32c:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
    c32e:	2001      	movs	r0, #1
    c330:	f7f9 fbe2 	bl	5af8 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
    c334:	4b0c      	ldr	r3, [pc, #48]	; (c368 <radio_reset+0x3c>)
    c336:	2200      	movs	r2, #0
    c338:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
    c33c:	2201      	movs	r2, #1
    c33e:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
    c342:	4a0a      	ldr	r2, [pc, #40]	; (c36c <radio_reset+0x40>)
    c344:	6813      	ldr	r3, [r2, #0]
					 0xfffffffe) | 0x01000000;
    c346:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    c34a:	f023 0301 	bic.w	r3, r3, #1
    c34e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
    c352:	6013      	str	r3, [r2, #0]
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
    c354:	4b06      	ldr	r3, [pc, #24]	; (c370 <radio_reset+0x44>)
    c356:	f44f 6210 	mov.w	r2, #2304	; 0x900
    c35a:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
    c35e:	f44f 5290 	mov.w	r2, #4608	; 0x1200
    c362:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
    c366:	bd08      	pop	{r3, pc}
    c368:	40001000 	.word	0x40001000
    c36c:	40001774 	.word	0x40001774
    c370:	4001f000 	.word	0x4001f000

0000c374 <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
    c374:	4b06      	ldr	r3, [pc, #24]	; (c390 <radio_phy_set+0x1c>)
	switch (phy) {
    c376:	2802      	cmp	r0, #2
		mode = RADIO_MODE_MODE_Ble_2Mbit;
    c378:	bf14      	ite	ne
    c37a:	2203      	movne	r2, #3
    c37c:	2204      	moveq	r2, #4
    c37e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
    c382:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
    c386:	f042 0201 	orr.w	r2, r2, #1
    c38a:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
    c38e:	4770      	bx	lr
    c390:	40001000 	.word	0x40001000

0000c394 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
    c394:	4b01      	ldr	r3, [pc, #4]	; (c39c <radio_tx_power_set+0x8>)
    c396:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
    c39a:	4770      	bx	lr
    c39c:	40001000 	.word	0x40001000

0000c3a0 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
    c3a0:	4b01      	ldr	r3, [pc, #4]	; (c3a8 <radio_freq_chan_set+0x8>)
    c3a2:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
    c3a6:	4770      	bx	lr
    c3a8:	40001000 	.word	0x40001000

0000c3ac <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
    c3ac:	4b07      	ldr	r3, [pc, #28]	; (c3cc <radio_whiten_iv_set+0x20>)
    c3ae:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
    c3b2:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    c3b6:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
    c3ba:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
    c3be:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    c3c2:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    c3c6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    c3ca:	4770      	bx	lr
    c3cc:	40001000 	.word	0x40001000

0000c3d0 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
    c3d0:	4a0a      	ldr	r2, [pc, #40]	; (c3fc <radio_aa_set+0x2c>)
    c3d2:	2300      	movs	r3, #0
    c3d4:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
    c3d8:	2301      	movs	r3, #1
    c3da:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
    c3de:	78c3      	ldrb	r3, [r0, #3]
    c3e0:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
    c3e4:	7843      	ldrb	r3, [r0, #1]
    c3e6:	7881      	ldrb	r1, [r0, #2]
    c3e8:	041b      	lsls	r3, r3, #16
    c3ea:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    c3ee:	7801      	ldrb	r1, [r0, #0]
    c3f0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    c3f4:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
    c3f8:	4770      	bx	lr
    c3fa:	bf00      	nop
    c3fc:	40001000 	.word	0x40001000

0000c400 <radio_pkt_configure>:
	switch (phy) {
    c400:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
    c404:	2b02      	cmp	r3, #2
{
    c406:	b510      	push	{r4, lr}
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
    c408:	bf14      	ite	ne
    c40a:	2400      	movne	r4, #0
    c40c:	f04f 7480 	moveq.w	r4, #16777216	; 0x1000000
	if (dc) {
    c410:	07d3      	lsls	r3, r2, #31
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    c412:	f1c0 0308 	rsb	r3, r0, #8
		extra |= (RADIO_PCNF0_S1INCL_Include <<
    c416:	bf48      	it	mi
    c418:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    c41c:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
    c41e:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
    c422:	4320      	orrs	r0, r4
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    c424:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
    c428:	4a09      	ldr	r2, [pc, #36]	; (c450 <radio_pkt_configure+0x50>)
			    RADIO_PCNF0_S1LEN_Msk) |
    c42a:	4303      	orrs	r3, r0
    c42c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
    c430:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
    c434:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
    c438:	4b06      	ldr	r3, [pc, #24]	; (c454 <radio_pkt_configure+0x54>)
    c43a:	4003      	ands	r3, r0
    c43c:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
    c440:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
    c444:	4319      	orrs	r1, r3
    c446:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
    c44a:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
    c44e:	bd10      	pop	{r4, pc}
    c450:	40001000 	.word	0x40001000
    c454:	fef80000 	.word	0xfef80000

0000c458 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
    c458:	4b01      	ldr	r3, [pc, #4]	; (c460 <radio_pkt_rx_set+0x8>)
    c45a:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
    c45e:	4770      	bx	lr
    c460:	40001000 	.word	0x40001000

0000c464 <radio_pkt_tx_set>:
    c464:	4b01      	ldr	r3, [pc, #4]	; (c46c <radio_pkt_tx_set+0x8>)
    c466:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
    c46a:	4770      	bx	lr
    c46c:	40001000 	.word	0x40001000

0000c470 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c470:	4b01      	ldr	r3, [pc, #4]	; (c478 <radio_rx_enable+0x8>)
    c472:	2201      	movs	r2, #1
    c474:	601a      	str	r2, [r3, #0]
}
    c476:	4770      	bx	lr
    c478:	40001004 	.word	0x40001004

0000c47c <radio_tx_enable>:
    c47c:	4b01      	ldr	r3, [pc, #4]	; (c484 <radio_tx_enable+0x8>)
    c47e:	2201      	movs	r2, #1
    c480:	601a      	str	r2, [r3, #0]
}
    c482:	4770      	bx	lr
    c484:	40001000 	.word	0x40001000

0000c488 <radio_disable>:
    p_reg->CHENCLR = mask;
    c488:	4a07      	ldr	r2, [pc, #28]	; (c4a8 <radio_disable+0x20>)
    c48a:	f44f 6390 	mov.w	r3, #1152	; 0x480
    c48e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
    c492:	2301      	movs	r3, #1
    c494:	6053      	str	r3, [r2, #4]
    c496:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
    c498:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
    c49c:	2100      	movs	r1, #0
    c49e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    c4a2:	6113      	str	r3, [r2, #16]
}
    c4a4:	4770      	bx	lr
    c4a6:	bf00      	nop
    c4a8:	4001f000 	.word	0x4001f000

0000c4ac <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
    c4ac:	4b04      	ldr	r3, [pc, #16]	; (c4c0 <radio_status_reset+0x14>)
    c4ae:	2200      	movs	r2, #0
    c4b0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
    c4b4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
    c4b8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
    c4bc:	4770      	bx	lr
    c4be:	bf00      	nop
    c4c0:	40001000 	.word	0x40001000

0000c4c4 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
    c4c4:	4b03      	ldr	r3, [pc, #12]	; (c4d4 <radio_is_ready+0x10>)
    c4c6:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
    c4ca:	3800      	subs	r0, #0
    c4cc:	bf18      	it	ne
    c4ce:	2001      	movne	r0, #1
    c4d0:	4770      	bx	lr
    c4d2:	bf00      	nop
    c4d4:	40001000 	.word	0x40001000

0000c4d8 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
    c4d8:	4b03      	ldr	r3, [pc, #12]	; (c4e8 <radio_is_done+0x10>)
    c4da:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
    c4de:	3800      	subs	r0, #0
    c4e0:	bf18      	it	ne
    c4e2:	2001      	movne	r0, #1
    c4e4:	4770      	bx	lr
    c4e6:	bf00      	nop
    c4e8:	40001000 	.word	0x40001000

0000c4ec <radio_is_idle>:
	return (NRF_RADIO->STATE == 0);
    c4ec:	4b03      	ldr	r3, [pc, #12]	; (c4fc <radio_is_idle+0x10>)
    c4ee:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
    c4f2:	fab0 f080 	clz	r0, r0
    c4f6:	0940      	lsrs	r0, r0, #5
    c4f8:	4770      	bx	lr
    c4fa:	bf00      	nop
    c4fc:	40001000 	.word	0x40001000

0000c500 <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
    c500:	4b04      	ldr	r3, [pc, #16]	; (c514 <radio_crc_configure+0x14>)
    c502:	f240 1203 	movw	r2, #259	; 0x103
    c506:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
    c50a:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
    c50e:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
    c512:	4770      	bx	lr
    c514:	40001000 	.word	0x40001000

0000c518 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
    c518:	4b03      	ldr	r3, [pc, #12]	; (c528 <radio_crc_is_valid+0x10>)
    c51a:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    c51e:	3800      	subs	r0, #0
    c520:	bf18      	it	ne
    c522:	2001      	movne	r0, #1
    c524:	4770      	bx	lr
    c526:	bf00      	nop
    c528:	40001000 	.word	0x40001000

0000c52c <radio_pkt_scratch_get>:
}
    c52c:	4800      	ldr	r0, [pc, #0]	; (c530 <radio_pkt_scratch_get+0x4>)
    c52e:	4770      	bx	lr
    c530:	20003640 	.word	0x20003640

0000c534 <radio_switch_complete_and_rx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    c534:	4b04      	ldr	r3, [pc, #16]	; (c548 <radio_switch_complete_and_rx+0x14>)
    c536:	2103      	movs	r1, #3
    c538:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
    c53c:	2100      	movs	r1, #0
{
    c53e:	4602      	mov	r2, r0
	sw_switch(0, 0, 0, phy_rx, 0);
    c540:	4608      	mov	r0, r1
    c542:	f7ff be61 	b.w	c208 <sw_switch.isra.0>
    c546:	bf00      	nop
    c548:	40001000 	.word	0x40001000

0000c54c <radio_switch_complete_and_tx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    c54c:	4b03      	ldr	r3, [pc, #12]	; (c55c <radio_switch_complete_and_tx+0x10>)
{
    c54e:	4601      	mov	r1, r0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    c550:	2003      	movs	r0, #3
    c552:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
    c556:	2001      	movs	r0, #1
    c558:	f7ff be56 	b.w	c208 <sw_switch.isra.0>
    c55c:	40001000 	.word	0x40001000

0000c560 <radio_switch_complete_and_disable>:
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_switch_complete_and_disable(void)
{
	NRF_RADIO->SHORTS =
    c560:	4b05      	ldr	r3, [pc, #20]	; (c578 <radio_switch_complete_and_disable+0x18>)
    c562:	2203      	movs	r2, #3
    c564:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
    c568:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
    c56c:	f44f 6290 	mov.w	r2, #1152	; 0x480
    c570:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c574:	4770      	bx	lr
    c576:	bf00      	nop
    c578:	40001000 	.word	0x40001000

0000c57c <radio_rssi_measure>:

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
    c57c:	4a03      	ldr	r2, [pc, #12]	; (c58c <radio_rssi_measure+0x10>)
    c57e:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    c582:	f443 7388 	orr.w	r3, r3, #272	; 0x110
    c586:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
    c58a:	4770      	bx	lr
    c58c:	40001000 	.word	0x40001000

0000c590 <radio_rssi_get>:

u32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
    c590:	4b01      	ldr	r3, [pc, #4]	; (c598 <radio_rssi_get+0x8>)
    c592:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
    c596:	4770      	bx	lr
    c598:	40001000 	.word	0x40001000

0000c59c <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
    c59c:	4b02      	ldr	r3, [pc, #8]	; (c5a8 <radio_rssi_status_reset+0xc>)
    c59e:	2200      	movs	r2, #0
    c5a0:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
    c5a4:	4770      	bx	lr
    c5a6:	bf00      	nop
    c5a8:	40001000 	.word	0x40001000

0000c5ac <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
    c5ac:	4b03      	ldr	r3, [pc, #12]	; (c5bc <radio_rssi_is_ready+0x10>)
    c5ae:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
    c5b2:	3800      	subs	r0, #0
    c5b4:	bf18      	it	ne
    c5b6:	2001      	movne	r0, #1
    c5b8:	4770      	bx	lr
    c5ba:	bf00      	nop
    c5bc:	40001000 	.word	0x40001000

0000c5c0 <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
    c5c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    c5c2:	2400      	movs	r4, #0
    c5c4:	2706      	movs	r7, #6
    c5c6:	00a3      	lsls	r3, r4, #2
    c5c8:	fb07 2504 	mla	r5, r7, r4, r2
	u8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
    c5cc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    c5d0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
			((u32_t)bdaddr[2] << 16) |
			((u32_t)bdaddr[1] << 8) |
    c5d4:	682e      	ldr	r6, [r5, #0]
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
    c5d6:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
    c5da:	3401      	adds	r4, #1
    c5dc:	88ad      	ldrh	r5, [r5, #4]
    c5de:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
    c5e2:	2c08      	cmp	r4, #8
    c5e4:	d1ef      	bne.n	c5c6 <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
    c5e6:	4b03      	ldr	r3, [pc, #12]	; (c5f4 <radio_filter_configure+0x34>)
    c5e8:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    c5ec:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
    c5f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c5f2:	bf00      	nop
    c5f4:	40001000 	.word	0x40001000

0000c5f8 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
    c5f8:	4a03      	ldr	r2, [pc, #12]	; (c608 <radio_filter_disable+0x10>)
    c5fa:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
    c5fe:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    c602:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
    c606:	4770      	bx	lr
    c608:	40001000 	.word	0x40001000

0000c60c <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
    c60c:	4b02      	ldr	r3, [pc, #8]	; (c618 <radio_filter_status_reset+0xc>)
    c60e:	2200      	movs	r2, #0
    c610:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    c614:	4770      	bx	lr
    c616:	bf00      	nop
    c618:	40001000 	.word	0x40001000

0000c61c <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
    c61c:	4b03      	ldr	r3, [pc, #12]	; (c62c <radio_filter_has_match+0x10>)
    c61e:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
    c622:	3800      	subs	r0, #0
    c624:	bf18      	it	ne
    c626:	2001      	movne	r0, #1
    c628:	4770      	bx	lr
    c62a:	bf00      	nop
    c62c:	40001000 	.word	0x40001000

0000c630 <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
    c630:	4b01      	ldr	r3, [pc, #4]	; (c638 <radio_filter_match_get+0x8>)
    c632:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
    c636:	4770      	bx	lr
    c638:	40001000 	.word	0x40001000

0000c63c <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    c63c:	4b05      	ldr	r3, [pc, #20]	; (c654 <radio_tmr_status_reset+0x18>)
    c63e:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    c642:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
    c646:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
    c64a:	4a03      	ldr	r2, [pc, #12]	; (c658 <radio_tmr_status_reset+0x1c>)
    c64c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
    c650:	4770      	bx	lr
    c652:	bf00      	nop
    c654:	4000b000 	.word	0x4000b000
    c658:	0e700060 	.word	0x0e700060

0000c65c <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
    c65c:	4b03      	ldr	r3, [pc, #12]	; (c66c <radio_tmr_tifs_set+0x10>)
    c65e:	4a04      	ldr	r2, [pc, #16]	; (c670 <radio_tmr_tifs_set+0x14>)
    c660:	781b      	ldrb	r3, [r3, #0]
    c662:	f503 73a8 	add.w	r3, r3, #336	; 0x150
    c666:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c66a:	4770      	bx	lr
    c66c:	200087b7 	.word	0x200087b7
    c670:	40009000 	.word	0x40009000

0000c674 <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
    c674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
    c676:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
    c67a:	4c2f      	ldr	r4, [pc, #188]	; (c738 <radio_tmr_start+0xc4>)
    c67c:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
    c680:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
    c682:	bf88      	it	hi
    c684:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c688:	4b2c      	ldr	r3, [pc, #176]	; (c73c <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
    c68a:	4c2d      	ldr	r4, [pc, #180]	; (c740 <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
    c68c:	bf84      	itt	hi
    c68e:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
    c692:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
    c696:	f04f 0501 	mov.w	r5, #1

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
    c69a:	f04f 0600 	mov.w	r6, #0
	remainder /= 1000000UL;
    c69e:	fbb2 f4f4 	udiv	r4, r2, r4
	EVENT_TIMER->PRESCALER = 4;
    c6a2:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    c6a6:	f04f 0202 	mov.w	r2, #2
    c6aa:	601d      	str	r5, [r3, #0]
	EVENT_TIMER->MODE = 0;
    c6ac:	f8c3 64f8 	str.w	r6, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
    c6b0:	f8c3 7504 	str.w	r7, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    c6b4:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
    p_reg->CC[ch] = cc_val;
    c6b8:	4a22      	ldr	r2, [pc, #136]	; (c744 <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
    c6ba:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
		ticks_start--;
    c6be:	bf88      	it	hi
    c6c0:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
    c6c4:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
    c6c8:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    c6cc:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c6d0:	491d      	ldr	r1, [pc, #116]	; (c748 <radio_tmr_start+0xd4>)
    c6d2:	f502 72a4 	add.w	r2, r2, #328	; 0x148
	EVENT_TIMER->MODE = 0;
    c6d6:	3b0c      	subs	r3, #12
    c6d8:	f8c1 2538 	str.w	r2, [r1, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c6dc:	f8c1 353c 	str.w	r3, [r1, #1340]	; 0x53c
    p_reg->CHENSET = mask;
    c6e0:	2320      	movs	r3, #32
    c6e2:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
    c6e6:	f7ff fd7b 	bl	c1e0 <hal_radio_enable_on_tick_ppi_config_and_enable>
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
    c6ea:	4b18      	ldr	r3, [pc, #96]	; (c74c <radio_tmr_start+0xd8>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c6ec:	4a18      	ldr	r2, [pc, #96]	; (c750 <radio_tmr_start+0xdc>)
    c6ee:	6015      	str	r5, [r2, #0]
    c6f0:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
    c6f4:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
    c6f8:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
    c6fc:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c6fe:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
    c702:	3b74      	subs	r3, #116	; 0x74
    c704:	f8c1 3548 	str.w	r3, [r1, #1352]	; 0x548
    c708:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
    c70c:	3334      	adds	r3, #52	; 0x34
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c70e:	f8c1 254c 	str.w	r2, [r1, #1356]	; 0x54c
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c712:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c716:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
    c71a:	33c4      	adds	r3, #196	; 0xc4
    c71c:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c720:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
    c724:	3bc0      	subs	r3, #192	; 0xc0
    c726:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c72a:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
    c72e:	33c8      	adds	r3, #200	; 0xc8
    c730:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
    c734:	4620      	mov	r0, r4
    c736:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c738:	7ff0bdbf 	.word	0x7ff0bdbf
    c73c:	4000800c 	.word	0x4000800c
    c740:	000f4240 	.word	0x000f4240
    c744:	4000b000 	.word	0x4000b000
    c748:	4001f000 	.word	0x4001f000
    c74c:	40009000 	.word	0x40009000
    c750:	4000900c 	.word	0x4000900c

0000c754 <radio_tmr_start_tick>:
    c754:	4b0e      	ldr	r3, [pc, #56]	; (c790 <radio_tmr_start_tick+0x3c>)
    p_reg->CC[cc_channel] = cc_value;
    c756:	4a0f      	ldr	r2, [pc, #60]	; (c794 <radio_tmr_start_tick+0x40>)

u32_t radio_tmr_start_tick(u8_t trx, u32_t tick)
{
    c758:	b510      	push	{r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c75a:	2401      	movs	r4, #1
    c75c:	601c      	str	r4, [r3, #0]
    c75e:	609c      	str	r4, [r3, #8]
    p_reg->CC[ch] = cc_val;
    c760:	4b0d      	ldr	r3, [pc, #52]	; (c798 <radio_tmr_start_tick+0x44>)
    p_reg->CC[cc_channel] = cc_value;
    c762:	f8c2 4540 	str.w	r4, [r2, #1344]	; 0x540
    c766:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
    p_reg->EVTENSET = mask;
    c76a:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    c76e:	f8c3 1344 	str.w	r1, [r3, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c772:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
    c776:	4909      	ldr	r1, [pc, #36]	; (c79c <radio_tmr_start_tick+0x48>)
    c778:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c77c:	f8c3 253c 	str.w	r2, [r3, #1340]	; 0x53c
    p_reg->CHENSET = mask;
    c780:	2220      	movs	r2, #32
    c782:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
    c786:	f7ff fd2b 	bl	c1e0 <hal_radio_enable_on_tick_ppi_config_and_enable>
	last_pdu_end_us = 0U;
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
    c78a:	4620      	mov	r0, r4
    c78c:	bd10      	pop	{r4, pc}
    c78e:	bf00      	nop
    c790:	40008004 	.word	0x40008004
    c794:	40008000 	.word	0x40008000
    c798:	4000b000 	.word	0x4000b000
    c79c:	4000b148 	.word	0x4000b148

0000c7a0 <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c7a0:	4a04      	ldr	r2, [pc, #16]	; (c7b4 <radio_tmr_stop+0x14>)
    c7a2:	2301      	movs	r3, #1
    c7a4:	6013      	str	r3, [r2, #0]
    c7a6:	60d3      	str	r3, [r2, #12]
    c7a8:	320c      	adds	r2, #12
    c7aa:	f602 72f4 	addw	r2, r2, #4084	; 0xff4
    c7ae:	6013      	str	r3, [r2, #0]
    c7b0:	60d3      	str	r3, [r2, #12]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c7b2:	4770      	bx	lr
    c7b4:	40008004 	.word	0x40008004

0000c7b8 <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
    c7b8:	4b04      	ldr	r3, [pc, #16]	; (c7cc <radio_tmr_hcto_configure+0x14>)
    c7ba:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    c7be:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
    c7c2:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
    c7c6:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
    c7ca:	4770      	bx	lr
    c7cc:	40008000 	.word	0x40008000

0000c7d0 <radio_tmr_end_capture>:
    c7d0:	4b02      	ldr	r3, [pc, #8]	; (c7dc <radio_tmr_end_capture+0xc>)
    c7d2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    c7d6:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

void radio_tmr_end_capture(void)
{
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
    c7da:	4770      	bx	lr
    c7dc:	4001f000 	.word	0x4001f000

0000c7e0 <radio_tmr_tifs_base_get>:
    c7e0:	4b01      	ldr	r3, [pc, #4]	; (c7e8 <radio_tmr_tifs_base_get+0x8>)
    c7e2:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
    c7e6:	4770      	bx	lr
    c7e8:	40008000 	.word	0x40008000

0000c7ec <radio_ar_match_get>:
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
    c7ec:	4b01      	ldr	r3, [pc, #4]	; (c7f4 <radio_ar_match_get+0x8>)
    c7ee:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    c7f2:	4770      	bx	lr
    c7f4:	4000f000 	.word	0x4000f000

0000c7f8 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
    c7f8:	4a04      	ldr	r2, [pc, #16]	; (c80c <radio_ar_status_reset+0x14>)
    c7fa:	2300      	movs	r3, #0
    c7fc:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
    c800:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    c804:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
    c808:	4770      	bx	lr
    c80a:	bf00      	nop
    c80c:	40001000 	.word	0x40001000

0000c810 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
    c810:	4b08      	ldr	r3, [pc, #32]	; (c834 <radio_ar_has_match+0x24>)
    c812:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
    c816:	b160      	cbz	r0, c832 <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
    c818:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    c81c:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
    c820:	b138      	cbz	r0, c832 <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
    c822:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
    c826:	b120      	cbz	r0, c832 <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
    c828:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
    c82c:	fab0 f080 	clz	r0, r0
    c830:	0940      	lsrs	r0, r0, #5
}
    c832:	4770      	bx	lr
    c834:	40001000 	.word	0x40001000

0000c838 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    c838:	2902      	cmp	r1, #2
{
    c83a:	b510      	push	{r4, lr}
    c83c:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    c83e:	d00b      	beq.n	c858 <mayfly_enable_cb+0x20>
    c840:	4a0a      	ldr	r2, [pc, #40]	; (c86c <mayfly_enable_cb+0x34>)
    c842:	490b      	ldr	r1, [pc, #44]	; (c870 <mayfly_enable_cb+0x38>)
    c844:	480b      	ldr	r0, [pc, #44]	; (c874 <mayfly_enable_cb+0x3c>)
    c846:	2325      	movs	r3, #37	; 0x25
    c848:	f008 f96f 	bl	14b2a <printk>
    c84c:	4040      	eors	r0, r0
    c84e:	f380 8811 	msr	BASEPRI, r0
    c852:	f04f 0003 	mov.w	r0, #3
    c856:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
    c858:	200b      	movs	r0, #11
	if (enable) {
    c85a:	b11c      	cbz	r4, c864 <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
    c85c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
    c860:	f7f9 b93a 	b.w	5ad8 <arch_irq_enable>
}
    c864:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
    c868:	f7f9 b946 	b.w	5af8 <arch_irq_disable>
    c86c:	0001b87f 	.word	0x0001b87f
    c870:	0001b8cd 	.word	0x0001b8cd
    c874:	0001aebe 	.word	0x0001aebe

0000c878 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
    c878:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
    c87a:	b181      	cbz	r1, c89e <mayfly_is_enabled+0x26>
    c87c:	3901      	subs	r1, #1
    c87e:	2901      	cmp	r1, #1
    c880:	d912      	bls.n	c8a8 <mayfly_is_enabled+0x30>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
    c882:	4a0a      	ldr	r2, [pc, #40]	; (c8ac <mayfly_is_enabled+0x34>)
    c884:	490a      	ldr	r1, [pc, #40]	; (c8b0 <mayfly_is_enabled+0x38>)
    c886:	480b      	ldr	r0, [pc, #44]	; (c8b4 <mayfly_is_enabled+0x3c>)
    c888:	233f      	movs	r3, #63	; 0x3f
    c88a:	f008 f94e 	bl	14b2a <printk>
    c88e:	4040      	eors	r0, r0
    c890:	f380 8811 	msr	BASEPRI, r0
    c894:	f04f 0003 	mov.w	r0, #3
    c898:	df02      	svc	2
		break;
	}

	return 0;
}
    c89a:	2000      	movs	r0, #0
    c89c:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
    c89e:	2018      	movs	r0, #24
}
    c8a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
    c8a4:	f7f9 b93c 	b.w	5b20 <arch_irq_is_enabled>
    c8a8:	200b      	movs	r0, #11
    c8aa:	e7f9      	b.n	c8a0 <mayfly_is_enabled+0x28>
    c8ac:	0001b87f 	.word	0x0001b87f
    c8b0:	0001b96a 	.word	0x0001b96a
    c8b4:	0001aebe 	.word	0x0001aebe

0000c8b8 <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
    c8b8:	2901      	cmp	r1, #1
{
    c8ba:	b508      	push	{r3, lr}
	switch (callee_id) {
    c8bc:	d008      	beq.n	c8d0 <mayfly_pend+0x18>
    c8be:	2902      	cmp	r1, #2
    c8c0:	d006      	beq.n	c8d0 <mayfly_pend+0x18>
    c8c2:	b949      	cbnz	r1, c8d8 <mayfly_pend+0x20>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c8c4:	4b0b      	ldr	r3, [pc, #44]	; (c8f4 <mayfly_pend+0x3c>)
    c8c6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    c8ca:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	default:
		LL_ASSERT(0);
		break;
	}
}
    c8ce:	bd08      	pop	{r3, pc}
    c8d0:	4b08      	ldr	r3, [pc, #32]	; (c8f4 <mayfly_pend+0x3c>)
    c8d2:	f44f 6200 	mov.w	r2, #2048	; 0x800
    c8d6:	e7f8      	b.n	c8ca <mayfly_pend+0x12>
		LL_ASSERT(0);
    c8d8:	4a07      	ldr	r2, [pc, #28]	; (c8f8 <mayfly_pend+0x40>)
    c8da:	4908      	ldr	r1, [pc, #32]	; (c8fc <mayfly_pend+0x44>)
    c8dc:	4808      	ldr	r0, [pc, #32]	; (c900 <mayfly_pend+0x48>)
    c8de:	237b      	movs	r3, #123	; 0x7b
    c8e0:	f008 f923 	bl	14b2a <printk>
    c8e4:	4040      	eors	r0, r0
    c8e6:	f380 8811 	msr	BASEPRI, r0
    c8ea:	f04f 0003 	mov.w	r0, #3
    c8ee:	df02      	svc	2
}
    c8f0:	e7ed      	b.n	c8ce <mayfly_pend+0x16>
    c8f2:	bf00      	nop
    c8f4:	e000e100 	.word	0xe000e100
    c8f8:	0001b87f 	.word	0x0001b87f
    c8fc:	0001b96a 	.word	0x0001b96a
    c900:	0001aebe 	.word	0x0001aebe

0000c904 <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
    c904:	2803      	cmp	r0, #3
{
    c906:	b510      	push	{r4, lr}
    c908:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
    c90a:	d90b      	bls.n	c924 <hal_ticker_instance0_caller_id_get+0x20>
    c90c:	4a0e      	ldr	r2, [pc, #56]	; (c948 <hal_ticker_instance0_caller_id_get+0x44>)
    c90e:	490f      	ldr	r1, [pc, #60]	; (c94c <hal_ticker_instance0_caller_id_get+0x48>)
    c910:	480f      	ldr	r0, [pc, #60]	; (c950 <hal_ticker_instance0_caller_id_get+0x4c>)
    c912:	2338      	movs	r3, #56	; 0x38
    c914:	f008 f909 	bl	14b2a <printk>
    c918:	4040      	eors	r0, r0
    c91a:	f380 8811 	msr	BASEPRI, r0
    c91e:	f04f 0003 	mov.w	r0, #3
    c922:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
    c924:	4b0b      	ldr	r3, [pc, #44]	; (c954 <hal_ticker_instance0_caller_id_get+0x50>)
    c926:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
    c928:	b95c      	cbnz	r4, c942 <hal_ticker_instance0_caller_id_get+0x3e>
    c92a:	4a07      	ldr	r2, [pc, #28]	; (c948 <hal_ticker_instance0_caller_id_get+0x44>)
    c92c:	490a      	ldr	r1, [pc, #40]	; (c958 <hal_ticker_instance0_caller_id_get+0x54>)
    c92e:	4808      	ldr	r0, [pc, #32]	; (c950 <hal_ticker_instance0_caller_id_get+0x4c>)
    c930:	233b      	movs	r3, #59	; 0x3b
    c932:	f008 f8fa 	bl	14b2a <printk>
    c936:	4040      	eors	r0, r0
    c938:	f380 8811 	msr	BASEPRI, r0
    c93c:	f04f 0003 	mov.w	r0, #3
    c940:	df02      	svc	2

	return caller_id;
}
    c942:	4620      	mov	r0, r4
    c944:	bd10      	pop	{r4, pc}
    c946:	bf00      	nop
    c948:	0001b8ef 	.word	0x0001b8ef
    c94c:	0001b93d 	.word	0x0001b93d
    c950:	0001aebe 	.word	0x0001aebe
    c954:	0001b97f 	.word	0x0001b97f
    c958:	0001b95d 	.word	0x0001b95d

0000c95c <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
    c95c:	3801      	subs	r0, #1
{
    c95e:	b510      	push	{r4, lr}
    c960:	461c      	mov	r4, r3
    c962:	2804      	cmp	r0, #4
    c964:	d845      	bhi.n	c9f2 <hal_ticker_instance0_sched+0x96>
    c966:	e8df f000 	tbb	[pc, r0]
    c96a:	1a03      	.short	0x1a03
    c96c:	2c23      	.short	0x2c23
    c96e:	3b          	.byte	0x3b
    c96f:	00          	.byte	0x00
#if defined(CONFIG_BT_LL_SW_SPLIT)
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
    c970:	2904      	cmp	r1, #4
    c972:	d107      	bne.n	c984 <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
    c974:	4b20      	ldr	r3, [pc, #128]	; (c9f8 <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    c976:	2102      	movs	r1, #2
			m.param = instance;
    c978:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    c97a:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
    c97c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    c980:	f7fb bfc2 	b.w	8908 <mayfly_enqueue>
			LL_ASSERT(0);
    c984:	235c      	movs	r3, #92	; 0x5c
		LL_ASSERT(0);
    c986:	4a1d      	ldr	r2, [pc, #116]	; (c9fc <hal_ticker_instance0_sched+0xa0>)
    c988:	491d      	ldr	r1, [pc, #116]	; (ca00 <hal_ticker_instance0_sched+0xa4>)
    c98a:	481e      	ldr	r0, [pc, #120]	; (ca04 <hal_ticker_instance0_sched+0xa8>)
    c98c:	f008 f8cd 	bl	14b2a <printk>
    c990:	4040      	eors	r0, r0
    c992:	f380 8811 	msr	BASEPRI, r0
    c996:	f04f 0003 	mov.w	r0, #3
    c99a:	df02      	svc	2
}
    c99c:	bd10      	pop	{r4, pc}
		switch (callee_id) {
    c99e:	2903      	cmp	r1, #3
    c9a0:	d104      	bne.n	c9ac <hal_ticker_instance0_sched+0x50>
			m.param = instance;
    c9a2:	4b19      	ldr	r3, [pc, #100]	; (ca08 <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
    c9a4:	2101      	movs	r1, #1
			m.param = instance;
    c9a6:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c9a8:	4608      	mov	r0, r1
    c9aa:	e7e7      	b.n	c97c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    c9ac:	2374      	movs	r3, #116	; 0x74
    c9ae:	e7ea      	b.n	c986 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
    c9b0:	2904      	cmp	r1, #4
    c9b2:	d104      	bne.n	c9be <hal_ticker_instance0_sched+0x62>
			m.param = instance;
    c9b4:	4b15      	ldr	r3, [pc, #84]	; (ca0c <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    c9b6:	2102      	movs	r1, #2
			m.param = instance;
    c9b8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    c9ba:	2001      	movs	r0, #1
    c9bc:	e7de      	b.n	c97c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    c9be:	238b      	movs	r3, #139	; 0x8b
    c9c0:	e7e1      	b.n	c986 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
    c9c2:	2903      	cmp	r1, #3
    c9c4:	d003      	beq.n	c9ce <hal_ticker_instance0_sched+0x72>
    c9c6:	2904      	cmp	r1, #4
    c9c8:	d006      	beq.n	c9d8 <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
    c9ca:	23b1      	movs	r3, #177	; 0xb1
    c9cc:	e7db      	b.n	c986 <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
    c9ce:	4b10      	ldr	r3, [pc, #64]	; (ca10 <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c9d0:	2101      	movs	r1, #1
			m.param = instance;
    c9d2:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c9d4:	2002      	movs	r0, #2
    c9d6:	e7d1      	b.n	c97c <hal_ticker_instance0_sched+0x20>
			m.param = instance;
    c9d8:	4b0e      	ldr	r3, [pc, #56]	; (ca14 <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c9da:	2102      	movs	r1, #2
			m.param = instance;
    c9dc:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c9de:	e7e3      	b.n	c9a8 <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
    c9e0:	2904      	cmp	r1, #4
    c9e2:	d104      	bne.n	c9ee <hal_ticker_instance0_sched+0x92>
			m.param = instance;
    c9e4:	4b0c      	ldr	r3, [pc, #48]	; (ca18 <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    c9e6:	2102      	movs	r1, #2
			m.param = instance;
    c9e8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    c9ea:	2003      	movs	r0, #3
    c9ec:	e7c6      	b.n	c97c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    c9ee:	23c9      	movs	r3, #201	; 0xc9
    c9f0:	e7c9      	b.n	c986 <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
    c9f2:	23cf      	movs	r3, #207	; 0xcf
    c9f4:	e7c7      	b.n	c986 <hal_ticker_instance0_sched+0x2a>
    c9f6:	bf00      	nop
    c9f8:	2000bf80 	.word	0x2000bf80
    c9fc:	0001b8ef 	.word	0x0001b8ef
    ca00:	0001b96a 	.word	0x0001b96a
    ca04:	0001aebe 	.word	0x0001aebe
    ca08:	2000bf90 	.word	0x2000bf90
    ca0c:	2000bfa0 	.word	0x2000bfa0
    ca10:	2000bfb0 	.word	0x2000bfb0
    ca14:	2000bfc0 	.word	0x2000bfc0
    ca18:	2000bfd0 	.word	0x2000bfd0

0000ca1c <k_mutex_unlock.constprop.0>:
	return z_impl_k_mutex_unlock(mutex);
    ca1c:	4801      	ldr	r0, [pc, #4]	; (ca24 <k_mutex_unlock.constprop.0+0x8>)
    ca1e:	f007 b8c9 	b.w	13bb4 <z_impl_k_mutex_unlock>
    ca22:	bf00      	nop
    ca24:	2000378c 	.word	0x2000378c

0000ca28 <k_mutex_lock.constprop.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
    ca28:	4802      	ldr	r0, [pc, #8]	; (ca34 <k_mutex_lock.constprop.0+0xc>)
    ca2a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ca2e:	f007 b84f 	b.w	13ad0 <z_impl_k_mutex_lock>
    ca32:	bf00      	nop
    ca34:	2000378c 	.word	0x2000378c

0000ca38 <fs_init>:
	k_mutex_unlock(&mutex);
	return rc;
}

static int fs_init(struct device *dev)
{
    ca38:	b508      	push	{r3, lr}
	return z_impl_k_mutex_init(mutex);
    ca3a:	4804      	ldr	r0, [pc, #16]	; (ca4c <fs_init+0x14>)
    ca3c:	f00c f847 	bl	18ace <z_impl_k_mutex_init>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    ca40:	4b03      	ldr	r3, [pc, #12]	; (ca50 <fs_init+0x18>)
	k_mutex_init(&mutex);
	sys_dlist_init(&fs_mnt_list);
	return 0;
}
    ca42:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
    ca44:	e9c3 3300 	strd	r3, r3, [r3]
    ca48:	bd08      	pop	{r3, pc}
    ca4a:	bf00      	nop
    ca4c:	2000378c 	.word	0x2000378c
    ca50:	20003784 	.word	0x20003784

0000ca54 <fs_get_mnt_point>:
{
    ca54:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ca58:	4682      	mov	sl, r0
	size_t len, name_len = strlen(name);
    ca5a:	4608      	mov	r0, r1
{
    ca5c:	4688      	mov	r8, r1
    ca5e:	4615      	mov	r5, r2
	size_t len, name_len = strlen(name);
    ca60:	f009 fab9 	bl	15fd6 <strlen>
    ca64:	4683      	mov	fp, r0
	k_mutex_lock(&mutex, K_FOREVER);
    ca66:	f7ff ffdf 	bl	ca28 <k_mutex_lock.constprop.0>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    ca6a:	4b1b      	ldr	r3, [pc, #108]	; (cad8 <fs_get_mnt_point+0x84>)
    ca6c:	681c      	ldr	r4, [r3, #0]
    ca6e:	4699      	mov	r9, r3
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ca70:	429c      	cmp	r4, r3
    ca72:	bf08      	it	eq
    ca74:	2400      	moveq	r4, #0
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    ca76:	2300      	movs	r3, #0
    ca78:	461f      	mov	r7, r3
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    ca7a:	b95c      	cbnz	r4, ca94 <fs_get_mnt_point+0x40>
	k_mutex_unlock(&mutex);
    ca7c:	f7ff ffce 	bl	ca1c <k_mutex_unlock.constprop.0>
	if (mnt_p == NULL) {
    ca80:	b32f      	cbz	r7, cace <fs_get_mnt_point+0x7a>
	*mnt_pntp = mnt_p;
    ca82:	f8ca 7000 	str.w	r7, [sl]
	if (match_len)
    ca86:	b32d      	cbz	r5, cad4 <fs_get_mnt_point+0x80>
		*match_len = mnt_p->mountp_len;
    ca88:	69bb      	ldr	r3, [r7, #24]
    ca8a:	602b      	str	r3, [r5, #0]
	return 0;
    ca8c:	2000      	movs	r0, #0
}
    ca8e:	b003      	add	sp, #12
    ca90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		len = itr->mountp_len;
    ca94:	69a6      	ldr	r6, [r4, #24]
		if ((len < longest_match) || (len > name_len)) {
    ca96:	42b3      	cmp	r3, r6
    ca98:	d813      	bhi.n	cac2 <fs_get_mnt_point+0x6e>
    ca9a:	45b3      	cmp	fp, r6
    ca9c:	d311      	bcc.n	cac2 <fs_get_mnt_point+0x6e>
		if ((len > 1) && (name[len] != '/') && (name[len] != '\0')) {
    ca9e:	2e01      	cmp	r6, #1
    caa0:	d904      	bls.n	caac <fs_get_mnt_point+0x58>
    caa2:	f818 2006 	ldrb.w	r2, [r8, r6]
    caa6:	2a2f      	cmp	r2, #47	; 0x2f
    caa8:	d000      	beq.n	caac <fs_get_mnt_point+0x58>
    caaa:	b952      	cbnz	r2, cac2 <fs_get_mnt_point+0x6e>
		if (strncmp(name, itr->mnt_point, len) == 0) {
    caac:	68e1      	ldr	r1, [r4, #12]
    caae:	9301      	str	r3, [sp, #4]
    cab0:	4632      	mov	r2, r6
    cab2:	4640      	mov	r0, r8
    cab4:	f009 faa2 	bl	15ffc <strncmp>
    cab8:	2800      	cmp	r0, #0
    caba:	9b01      	ldr	r3, [sp, #4]
    cabc:	bf04      	itt	eq
    cabe:	4627      	moveq	r7, r4
    cac0:	4633      	moveq	r3, r6
    cac2:	f8d9 2004 	ldr.w	r2, [r9, #4]
    cac6:	4294      	cmp	r4, r2
    cac8:	d0d8      	beq.n	ca7c <fs_get_mnt_point+0x28>
    caca:	6824      	ldr	r4, [r4, #0]
    cacc:	e7d5      	b.n	ca7a <fs_get_mnt_point+0x26>
		return -ENOENT;
    cace:	f06f 0001 	mvn.w	r0, #1
    cad2:	e7dc      	b.n	ca8e <fs_get_mnt_point+0x3a>
	return 0;
    cad4:	4628      	mov	r0, r5
    cad6:	e7da      	b.n	ca8e <fs_get_mnt_point+0x3a>
    cad8:	20003784 	.word	0x20003784

0000cadc <fs_open>:
{
    cadc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cade:	4606      	mov	r6, r0
	if ((file_name == NULL) ||
    cae0:	460d      	mov	r5, r1
    cae2:	b971      	cbnz	r1, cb02 <fs_open+0x26>
    cae4:	4b1f      	ldr	r3, [pc, #124]	; (cb64 <fs_open+0x88>)
    cae6:	4920      	ldr	r1, [pc, #128]	; (cb68 <fs_open+0x8c>)
		LOG_ERR("invalid file name!!");
    cae8:	4820      	ldr	r0, [pc, #128]	; (cb6c <fs_open+0x90>)
    caea:	1ac9      	subs	r1, r1, r3
    caec:	08c9      	lsrs	r1, r1, #3
    caee:	0189      	lsls	r1, r1, #6
    caf0:	f041 0101 	orr.w	r1, r1, #1
    caf4:	f008 fba9 	bl	1524a <log_0>
		return -EINVAL;
    caf8:	f06f 0415 	mvn.w	r4, #21
}
    cafc:	4620      	mov	r0, r4
    cafe:	b002      	add	sp, #8
    cb00:	bd70      	pop	{r4, r5, r6, pc}
			(strlen(file_name) <= 1) || (file_name[0] != '/')) {
    cb02:	4608      	mov	r0, r1
    cb04:	f009 fa67 	bl	15fd6 <strlen>
	if ((file_name == NULL) ||
    cb08:	2801      	cmp	r0, #1
    cb0a:	d9eb      	bls.n	cae4 <fs_open+0x8>
			(strlen(file_name) <= 1) || (file_name[0] != '/')) {
    cb0c:	782b      	ldrb	r3, [r5, #0]
    cb0e:	2b2f      	cmp	r3, #47	; 0x2f
    cb10:	d1e8      	bne.n	cae4 <fs_open+0x8>
	rc = fs_get_mnt_point(&mp, file_name, NULL);
    cb12:	2200      	movs	r2, #0
    cb14:	4629      	mov	r1, r5
    cb16:	a801      	add	r0, sp, #4
    cb18:	f7ff ff9c 	bl	ca54 <fs_get_mnt_point>
	if (rc < 0) {
    cb1c:	1e04      	subs	r4, r0, #0
    cb1e:	da0b      	bge.n	cb38 <fs_open+0x5c>
    cb20:	4a11      	ldr	r2, [pc, #68]	; (cb68 <fs_open+0x8c>)
    cb22:	4b10      	ldr	r3, [pc, #64]	; (cb64 <fs_open+0x88>)
		LOG_ERR("%s:mount point not found!!", __func__);
    cb24:	4912      	ldr	r1, [pc, #72]	; (cb70 <fs_open+0x94>)
    cb26:	4813      	ldr	r0, [pc, #76]	; (cb74 <fs_open+0x98>)
    cb28:	1ad2      	subs	r2, r2, r3
    cb2a:	08d2      	lsrs	r2, r2, #3
    cb2c:	0192      	lsls	r2, r2, #6
    cb2e:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("file open error (%d)", rc);
    cb32:	f008 fb97 	bl	15264 <log_1>
			return rc;
    cb36:	e7e1      	b.n	cafc <fs_open+0x20>
	zfp->mp = mp;
    cb38:	9b01      	ldr	r3, [sp, #4]
    cb3a:	6073      	str	r3, [r6, #4]
	if (zfp->mp->fs->open != NULL) {
    cb3c:	69db      	ldr	r3, [r3, #28]
    cb3e:	681b      	ldr	r3, [r3, #0]
    cb40:	2b00      	cmp	r3, #0
    cb42:	d0db      	beq.n	cafc <fs_open+0x20>
		rc = zfp->mp->fs->open(zfp, file_name);
    cb44:	4629      	mov	r1, r5
    cb46:	4630      	mov	r0, r6
    cb48:	4798      	blx	r3
		if (rc < 0) {
    cb4a:	1e04      	subs	r4, r0, #0
    cb4c:	dad6      	bge.n	cafc <fs_open+0x20>
    cb4e:	4a06      	ldr	r2, [pc, #24]	; (cb68 <fs_open+0x8c>)
    cb50:	4b04      	ldr	r3, [pc, #16]	; (cb64 <fs_open+0x88>)
			LOG_ERR("file open error (%d)", rc);
    cb52:	4809      	ldr	r0, [pc, #36]	; (cb78 <fs_open+0x9c>)
    cb54:	1ad2      	subs	r2, r2, r3
    cb56:	08d2      	lsrs	r2, r2, #3
    cb58:	0192      	lsls	r2, r2, #6
    cb5a:	f042 0201 	orr.w	r2, r2, #1
    cb5e:	4621      	mov	r1, r4
    cb60:	e7e7      	b.n	cb32 <fs_open+0x56>
    cb62:	bf00      	nop
    cb64:	0001956c 	.word	0x0001956c
    cb68:	00019604 	.word	0x00019604
    cb6c:	0001b983 	.word	0x0001b983
    cb70:	0001bbb5 	.word	0x0001bbb5
    cb74:	0001b997 	.word	0x0001b997
    cb78:	0001b9b2 	.word	0x0001b9b2

0000cb7c <fs_close>:
{
    cb7c:	b538      	push	{r3, r4, r5, lr}
	if (zfp->mp->fs->close != NULL) {
    cb7e:	6843      	ldr	r3, [r0, #4]
    cb80:	69db      	ldr	r3, [r3, #28]
    cb82:	69db      	ldr	r3, [r3, #28]
{
    cb84:	4605      	mov	r5, r0
	if (zfp->mp->fs->close != NULL) {
    cb86:	b17b      	cbz	r3, cba8 <fs_close+0x2c>
		rc = zfp->mp->fs->close(zfp);
    cb88:	4798      	blx	r3
		if (rc < 0) {
    cb8a:	1e04      	subs	r4, r0, #0
    cb8c:	da0e      	bge.n	cbac <fs_close+0x30>
    cb8e:	4a09      	ldr	r2, [pc, #36]	; (cbb4 <fs_close+0x38>)
    cb90:	4b09      	ldr	r3, [pc, #36]	; (cbb8 <fs_close+0x3c>)
			LOG_ERR("file close error (%d)", rc);
    cb92:	480a      	ldr	r0, [pc, #40]	; (cbbc <fs_close+0x40>)
    cb94:	1ad2      	subs	r2, r2, r3
    cb96:	08d2      	lsrs	r2, r2, #3
    cb98:	0192      	lsls	r2, r2, #6
    cb9a:	f042 0201 	orr.w	r2, r2, #1
    cb9e:	4621      	mov	r1, r4
    cba0:	f008 fb60 	bl	15264 <log_1>
}
    cba4:	4620      	mov	r0, r4
    cba6:	bd38      	pop	{r3, r4, r5, pc}
	int rc = -EINVAL;
    cba8:	f06f 0415 	mvn.w	r4, #21
	zfp->mp = NULL;
    cbac:	2300      	movs	r3, #0
    cbae:	606b      	str	r3, [r5, #4]
	return rc;
    cbb0:	e7f8      	b.n	cba4 <fs_close+0x28>
    cbb2:	bf00      	nop
    cbb4:	00019604 	.word	0x00019604
    cbb8:	0001956c 	.word	0x0001956c
    cbbc:	0001b9c7 	.word	0x0001b9c7

0000cbc0 <fs_read>:
	if (zfp->mp->fs->read != NULL) {
    cbc0:	6843      	ldr	r3, [r0, #4]
    cbc2:	69db      	ldr	r3, [r3, #28]
    cbc4:	685b      	ldr	r3, [r3, #4]
{
    cbc6:	b510      	push	{r4, lr}
	if (zfp->mp->fs->read != NULL) {
    cbc8:	b17b      	cbz	r3, cbea <fs_read+0x2a>
		rc = zfp->mp->fs->read(zfp, ptr, size);
    cbca:	4798      	blx	r3
		if (rc < 0) {
    cbcc:	1e04      	subs	r4, r0, #0
    cbce:	da0a      	bge.n	cbe6 <fs_read+0x26>
    cbd0:	4a07      	ldr	r2, [pc, #28]	; (cbf0 <fs_read+0x30>)
    cbd2:	4b08      	ldr	r3, [pc, #32]	; (cbf4 <fs_read+0x34>)
			LOG_ERR("file read error (%d)", rc);
    cbd4:	4808      	ldr	r0, [pc, #32]	; (cbf8 <fs_read+0x38>)
    cbd6:	1ad2      	subs	r2, r2, r3
    cbd8:	08d2      	lsrs	r2, r2, #3
    cbda:	0192      	lsls	r2, r2, #6
    cbdc:	f042 0201 	orr.w	r2, r2, #1
    cbe0:	4621      	mov	r1, r4
    cbe2:	f008 fb3f 	bl	15264 <log_1>
}
    cbe6:	4620      	mov	r0, r4
    cbe8:	bd10      	pop	{r4, pc}
	int rc = -EINVAL;
    cbea:	f06f 0415 	mvn.w	r4, #21
	return rc;
    cbee:	e7fa      	b.n	cbe6 <fs_read+0x26>
    cbf0:	00019604 	.word	0x00019604
    cbf4:	0001956c 	.word	0x0001956c
    cbf8:	0001b9dd 	.word	0x0001b9dd

0000cbfc <fs_write>:
	if (zfp->mp->fs->write != NULL) {
    cbfc:	6843      	ldr	r3, [r0, #4]
    cbfe:	69db      	ldr	r3, [r3, #28]
    cc00:	689b      	ldr	r3, [r3, #8]
{
    cc02:	b510      	push	{r4, lr}
	if (zfp->mp->fs->write != NULL) {
    cc04:	b17b      	cbz	r3, cc26 <fs_write+0x2a>
		rc = zfp->mp->fs->write(zfp, ptr, size);
    cc06:	4798      	blx	r3
		if (rc < 0) {
    cc08:	1e04      	subs	r4, r0, #0
    cc0a:	da0a      	bge.n	cc22 <fs_write+0x26>
    cc0c:	4a07      	ldr	r2, [pc, #28]	; (cc2c <fs_write+0x30>)
    cc0e:	4b08      	ldr	r3, [pc, #32]	; (cc30 <fs_write+0x34>)
			LOG_ERR("file write error (%d)", rc);
    cc10:	4808      	ldr	r0, [pc, #32]	; (cc34 <fs_write+0x38>)
    cc12:	1ad2      	subs	r2, r2, r3
    cc14:	08d2      	lsrs	r2, r2, #3
    cc16:	0192      	lsls	r2, r2, #6
    cc18:	f042 0201 	orr.w	r2, r2, #1
    cc1c:	4621      	mov	r1, r4
    cc1e:	f008 fb21 	bl	15264 <log_1>
}
    cc22:	4620      	mov	r0, r4
    cc24:	bd10      	pop	{r4, pc}
	int rc = -EINVAL;
    cc26:	f06f 0415 	mvn.w	r4, #21
	return rc;
    cc2a:	e7fa      	b.n	cc22 <fs_write+0x26>
    cc2c:	00019604 	.word	0x00019604
    cc30:	0001956c 	.word	0x0001956c
    cc34:	0001b9f2 	.word	0x0001b9f2

0000cc38 <fs_seek>:
	if (zfp->mp->fs->lseek != NULL) {
    cc38:	6843      	ldr	r3, [r0, #4]
    cc3a:	69db      	ldr	r3, [r3, #28]
    cc3c:	68db      	ldr	r3, [r3, #12]
{
    cc3e:	b510      	push	{r4, lr}
	if (zfp->mp->fs->lseek != NULL) {
    cc40:	b17b      	cbz	r3, cc62 <fs_seek+0x2a>
		rc = zfp->mp->fs->lseek(zfp, offset, whence);
    cc42:	4798      	blx	r3
		if (rc < 0) {
    cc44:	1e04      	subs	r4, r0, #0
    cc46:	da0a      	bge.n	cc5e <fs_seek+0x26>
    cc48:	4a07      	ldr	r2, [pc, #28]	; (cc68 <fs_seek+0x30>)
    cc4a:	4b08      	ldr	r3, [pc, #32]	; (cc6c <fs_seek+0x34>)
			LOG_ERR("file seek error (%d)", rc);
    cc4c:	4808      	ldr	r0, [pc, #32]	; (cc70 <fs_seek+0x38>)
    cc4e:	1ad2      	subs	r2, r2, r3
    cc50:	08d2      	lsrs	r2, r2, #3
    cc52:	0192      	lsls	r2, r2, #6
    cc54:	f042 0201 	orr.w	r2, r2, #1
    cc58:	4621      	mov	r1, r4
    cc5a:	f008 fb03 	bl	15264 <log_1>
}
    cc5e:	4620      	mov	r0, r4
    cc60:	bd10      	pop	{r4, pc}
	int rc = -EINVAL;
    cc62:	f06f 0415 	mvn.w	r4, #21
	return rc;
    cc66:	e7fa      	b.n	cc5e <fs_seek+0x26>
    cc68:	00019604 	.word	0x00019604
    cc6c:	0001956c 	.word	0x0001956c
    cc70:	0001ba08 	.word	0x0001ba08

0000cc74 <fs_tell>:
	if (zfp->mp->fs->tell != NULL) {
    cc74:	6843      	ldr	r3, [r0, #4]
    cc76:	69db      	ldr	r3, [r3, #28]
    cc78:	691b      	ldr	r3, [r3, #16]
{
    cc7a:	b510      	push	{r4, lr}
	if (zfp->mp->fs->tell != NULL) {
    cc7c:	b17b      	cbz	r3, cc9e <fs_tell+0x2a>
		rc = zfp->mp->fs->tell(zfp);
    cc7e:	4798      	blx	r3
		if (rc < 0) {
    cc80:	1e04      	subs	r4, r0, #0
    cc82:	da0a      	bge.n	cc9a <fs_tell+0x26>
    cc84:	4a07      	ldr	r2, [pc, #28]	; (cca4 <fs_tell+0x30>)
    cc86:	4b08      	ldr	r3, [pc, #32]	; (cca8 <fs_tell+0x34>)
			LOG_ERR("file tell error (%d)", rc);
    cc88:	4808      	ldr	r0, [pc, #32]	; (ccac <fs_tell+0x38>)
    cc8a:	1ad2      	subs	r2, r2, r3
    cc8c:	08d2      	lsrs	r2, r2, #3
    cc8e:	0192      	lsls	r2, r2, #6
    cc90:	f042 0201 	orr.w	r2, r2, #1
    cc94:	4621      	mov	r1, r4
    cc96:	f008 fae5 	bl	15264 <log_1>
}
    cc9a:	4620      	mov	r0, r4
    cc9c:	bd10      	pop	{r4, pc}
	int rc = -EINVAL;
    cc9e:	f06f 0415 	mvn.w	r4, #21
	return rc;
    cca2:	e7fa      	b.n	cc9a <fs_tell+0x26>
    cca4:	00019604 	.word	0x00019604
    cca8:	0001956c 	.word	0x0001956c
    ccac:	0001ba1d 	.word	0x0001ba1d

0000ccb0 <fs_sync>:
	if (zfp->mp->fs->sync != NULL) {
    ccb0:	6843      	ldr	r3, [r0, #4]
    ccb2:	69db      	ldr	r3, [r3, #28]
    ccb4:	699b      	ldr	r3, [r3, #24]
{
    ccb6:	b510      	push	{r4, lr}
	if (zfp->mp->fs->sync != NULL) {
    ccb8:	b17b      	cbz	r3, ccda <fs_sync+0x2a>
		rc = zfp->mp->fs->sync(zfp);
    ccba:	4798      	blx	r3
		if (rc < 0) {
    ccbc:	1e04      	subs	r4, r0, #0
    ccbe:	da0a      	bge.n	ccd6 <fs_sync+0x26>
    ccc0:	4a07      	ldr	r2, [pc, #28]	; (cce0 <fs_sync+0x30>)
    ccc2:	4b08      	ldr	r3, [pc, #32]	; (cce4 <fs_sync+0x34>)
			LOG_ERR("file sync error (%d)", rc);
    ccc4:	4808      	ldr	r0, [pc, #32]	; (cce8 <fs_sync+0x38>)
    ccc6:	1ad2      	subs	r2, r2, r3
    ccc8:	08d2      	lsrs	r2, r2, #3
    ccca:	0192      	lsls	r2, r2, #6
    cccc:	f042 0201 	orr.w	r2, r2, #1
    ccd0:	4621      	mov	r1, r4
    ccd2:	f008 fac7 	bl	15264 <log_1>
}
    ccd6:	4620      	mov	r0, r4
    ccd8:	bd10      	pop	{r4, pc}
	int rc = -EINVAL;
    ccda:	f06f 0415 	mvn.w	r4, #21
	return rc;
    ccde:	e7fa      	b.n	ccd6 <fs_sync+0x26>
    cce0:	00019604 	.word	0x00019604
    cce4:	0001956c 	.word	0x0001956c
    cce8:	0001ba32 	.word	0x0001ba32

0000ccec <fs_opendir>:
{
    ccec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    ccee:	4606      	mov	r6, r0
	if ((abs_path == NULL) ||
    ccf0:	460d      	mov	r5, r1
    ccf2:	b971      	cbnz	r1, cd12 <fs_opendir+0x26>
    ccf4:	4b28      	ldr	r3, [pc, #160]	; (cd98 <fs_opendir+0xac>)
    ccf6:	4929      	ldr	r1, [pc, #164]	; (cd9c <fs_opendir+0xb0>)
		LOG_ERR("invalid file name!!");
    ccf8:	4829      	ldr	r0, [pc, #164]	; (cda0 <fs_opendir+0xb4>)
    ccfa:	1ac9      	subs	r1, r1, r3
    ccfc:	08c9      	lsrs	r1, r1, #3
    ccfe:	0189      	lsls	r1, r1, #6
    cd00:	f041 0101 	orr.w	r1, r1, #1
    cd04:	f008 faa1 	bl	1524a <log_0>
		return -EINVAL;
    cd08:	f06f 0415 	mvn.w	r4, #21
}
    cd0c:	4620      	mov	r0, r4
    cd0e:	b002      	add	sp, #8
    cd10:	bd70      	pop	{r4, r5, r6, pc}
			(strlen(abs_path) < 1) || (abs_path[0] != '/')) {
    cd12:	4608      	mov	r0, r1
    cd14:	f009 f95f 	bl	15fd6 <strlen>
	if ((abs_path == NULL) ||
    cd18:	2800      	cmp	r0, #0
    cd1a:	d0eb      	beq.n	ccf4 <fs_opendir+0x8>
			(strlen(abs_path) < 1) || (abs_path[0] != '/')) {
    cd1c:	782b      	ldrb	r3, [r5, #0]
    cd1e:	2b2f      	cmp	r3, #47	; 0x2f
    cd20:	d1e8      	bne.n	ccf4 <fs_opendir+0x8>
	if (strcmp(abs_path, "/") == 0) {
    cd22:	4920      	ldr	r1, [pc, #128]	; (cda4 <fs_opendir+0xb8>)
    cd24:	4628      	mov	r0, r5
    cd26:	f009 f95d 	bl	15fe4 <strcmp>
    cd2a:	4604      	mov	r4, r0
    cd2c:	b958      	cbnz	r0, cd46 <fs_opendir+0x5a>
		k_mutex_lock(&mutex, K_FOREVER);
    cd2e:	f7ff fe7b 	bl	ca28 <k_mutex_lock.constprop.0>
	return list->head == list;
    cd32:	4a1d      	ldr	r2, [pc, #116]	; (cda8 <fs_opendir+0xbc>)
		zdp->mp = NULL;
    cd34:	6074      	str	r4, [r6, #4]
    cd36:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    cd38:	4293      	cmp	r3, r2
    cd3a:	bf08      	it	eq
    cd3c:	2300      	moveq	r3, #0
		zdp->dirp = sys_dlist_peek_head(&fs_mnt_list);
    cd3e:	6033      	str	r3, [r6, #0]
		k_mutex_unlock(&mutex);
    cd40:	f7ff fe6c 	bl	ca1c <k_mutex_unlock.constprop.0>
		return 0;
    cd44:	e7e2      	b.n	cd0c <fs_opendir+0x20>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    cd46:	2200      	movs	r2, #0
    cd48:	4629      	mov	r1, r5
    cd4a:	a801      	add	r0, sp, #4
    cd4c:	f7ff fe82 	bl	ca54 <fs_get_mnt_point>
	if (rc < 0) {
    cd50:	1e04      	subs	r4, r0, #0
    cd52:	da0b      	bge.n	cd6c <fs_opendir+0x80>
    cd54:	4a11      	ldr	r2, [pc, #68]	; (cd9c <fs_opendir+0xb0>)
    cd56:	4b10      	ldr	r3, [pc, #64]	; (cd98 <fs_opendir+0xac>)
		LOG_ERR("%s:mount point not found!!", __func__);
    cd58:	4914      	ldr	r1, [pc, #80]	; (cdac <fs_opendir+0xc0>)
    cd5a:	4815      	ldr	r0, [pc, #84]	; (cdb0 <fs_opendir+0xc4>)
    cd5c:	1ad2      	subs	r2, r2, r3
    cd5e:	08d2      	lsrs	r2, r2, #3
    cd60:	0192      	lsls	r2, r2, #6
    cd62:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("directory open error (%d)", rc);
    cd66:	f008 fa7d 	bl	15264 <log_1>
    cd6a:	e7cf      	b.n	cd0c <fs_opendir+0x20>
	zdp->mp = mp;
    cd6c:	9b01      	ldr	r3, [sp, #4]
    cd6e:	6073      	str	r3, [r6, #4]
	if (zdp->mp->fs->opendir != NULL) {
    cd70:	69db      	ldr	r3, [r3, #28]
    cd72:	6a1b      	ldr	r3, [r3, #32]
    cd74:	2b00      	cmp	r3, #0
    cd76:	d0c9      	beq.n	cd0c <fs_opendir+0x20>
		rc = zdp->mp->fs->opendir(zdp, abs_path);
    cd78:	4629      	mov	r1, r5
    cd7a:	4630      	mov	r0, r6
    cd7c:	4798      	blx	r3
		if (rc < 0) {
    cd7e:	1e04      	subs	r4, r0, #0
    cd80:	dac4      	bge.n	cd0c <fs_opendir+0x20>
    cd82:	4a06      	ldr	r2, [pc, #24]	; (cd9c <fs_opendir+0xb0>)
    cd84:	4b04      	ldr	r3, [pc, #16]	; (cd98 <fs_opendir+0xac>)
			LOG_ERR("directory open error (%d)", rc);
    cd86:	480b      	ldr	r0, [pc, #44]	; (cdb4 <fs_opendir+0xc8>)
    cd88:	1ad2      	subs	r2, r2, r3
    cd8a:	08d2      	lsrs	r2, r2, #3
    cd8c:	0192      	lsls	r2, r2, #6
    cd8e:	f042 0201 	orr.w	r2, r2, #1
    cd92:	4621      	mov	r1, r4
    cd94:	e7e7      	b.n	cd66 <fs_opendir+0x7a>
    cd96:	bf00      	nop
    cd98:	0001956c 	.word	0x0001956c
    cd9c:	00019604 	.word	0x00019604
    cda0:	0001b983 	.word	0x0001b983
    cda4:	0001ba47 	.word	0x0001ba47
    cda8:	20003784 	.word	0x20003784
    cdac:	0001bbbd 	.word	0x0001bbbd
    cdb0:	0001b997 	.word	0x0001b997
    cdb4:	0001ba49 	.word	0x0001ba49

0000cdb8 <fs_readdir>:
{
    cdb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (zdp->mp) {
    cdbc:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
    cdc0:	4606      	mov	r6, r0
    cdc2:	460d      	mov	r5, r1
	if (zdp->mp) {
    cdc4:	f1b8 0f00 	cmp.w	r8, #0
    cdc8:	d023      	beq.n	ce12 <fs_readdir+0x5a>
		if (zdp->mp->fs->readdir != NULL) {
    cdca:	f8d8 301c 	ldr.w	r3, [r8, #28]
    cdce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    cdd0:	2b00      	cmp	r3, #0
    cdd2:	d052      	beq.n	ce7a <fs_readdir+0xc2>
				if ((strcmp(entry->name, ".") != 0)
    cdd4:	f8df 80dc 	ldr.w	r8, [pc, #220]	; ceb4 <fs_readdir+0xfc>
    cdd8:	1c4f      	adds	r7, r1, #1
				rc = zdp->mp->fs->readdir(zdp, entry);
    cdda:	6873      	ldr	r3, [r6, #4]
    cddc:	69db      	ldr	r3, [r3, #28]
    cdde:	4629      	mov	r1, r5
    cde0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    cde2:	4630      	mov	r0, r6
    cde4:	4798      	blx	r3
				if (rc < 0) {
    cde6:	1e04      	subs	r4, r0, #0
    cde8:	db4d      	blt.n	ce86 <fs_readdir+0xce>
				if (entry->name[0] == 0) {
    cdea:	786b      	ldrb	r3, [r5, #1]
    cdec:	b173      	cbz	r3, ce0c <fs_readdir+0x54>
				if (entry->type != FS_DIR_ENTRY_DIR) {
    cdee:	782b      	ldrb	r3, [r5, #0]
    cdf0:	2b01      	cmp	r3, #1
    cdf2:	d10b      	bne.n	ce0c <fs_readdir+0x54>
				if ((strcmp(entry->name, ".") != 0)
    cdf4:	4641      	mov	r1, r8
    cdf6:	4638      	mov	r0, r7
    cdf8:	f009 f8f4 	bl	15fe4 <strcmp>
    cdfc:	2800      	cmp	r0, #0
    cdfe:	d0ec      	beq.n	cdda <fs_readdir+0x22>
				    && (strcmp(entry->name, "..") != 0)) {
    ce00:	4927      	ldr	r1, [pc, #156]	; (cea0 <fs_readdir+0xe8>)
    ce02:	4638      	mov	r0, r7
    ce04:	f009 f8ee 	bl	15fe4 <strcmp>
    ce08:	2800      	cmp	r0, #0
    ce0a:	d0e6      	beq.n	cdda <fs_readdir+0x22>
}
    ce0c:	4620      	mov	r0, r4
    ce0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (zdp->dirp == NULL) {
    ce12:	6804      	ldr	r4, [r0, #0]
    ce14:	b90c      	cbnz	r4, ce1a <fs_readdir+0x62>
		entry->name[0] = 0;
    ce16:	704c      	strb	r4, [r1, #1]
		return 0;
    ce18:	e7f8      	b.n	ce0c <fs_readdir+0x54>
	k_mutex_lock(&mutex, K_FOREVER);
    ce1a:	f7ff fe05 	bl	ca28 <k_mutex_lock.constprop.0>
	return list->head == list;
    ce1e:	4b21      	ldr	r3, [pc, #132]	; (cea4 <fs_readdir+0xec>)
    ce20:	681f      	ldr	r7, [r3, #0]
    ce22:	4699      	mov	r9, r3
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ce24:	429f      	cmp	r7, r3
    ce26:	bf08      	it	eq
    ce28:	2700      	moveq	r7, #0
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    ce2a:	685b      	ldr	r3, [r3, #4]
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    ce2c:	b917      	cbnz	r7, ce34 <fs_readdir+0x7c>
	sys_dnode_t *node, *next = NULL;
    ce2e:	46b8      	mov	r8, r7
	bool found = false;
    ce30:	2400      	movs	r4, #0
    ce32:	e017      	b.n	ce64 <fs_readdir+0xac>
		if (node == zdp->dirp) {
    ce34:	6832      	ldr	r2, [r6, #0]
    ce36:	42ba      	cmp	r2, r7
    ce38:	d11b      	bne.n	ce72 <fs_readdir+0xba>
			entry->type = FS_DIR_ENTRY_DIR;
    ce3a:	4628      	mov	r0, r5
    ce3c:	2401      	movs	r4, #1
    ce3e:	f800 4b01 	strb.w	r4, [r0], #1
			strncpy(entry->name, mnt->mnt_point + 1,
    ce42:	68f9      	ldr	r1, [r7, #12]
    ce44:	f44f 7280 	mov.w	r2, #256	; 0x100
    ce48:	4421      	add	r1, r4
    ce4a:	f009 f8a3 	bl	15f94 <strncpy>
			entry->name[sizeof(entry->name) - 1] = 0;
    ce4e:	2300      	movs	r3, #0
    ce50:	f885 3101 	strb.w	r3, [r5, #257]	; 0x101
			entry->size = 0;
    ce54:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
	return (node == list->tail) ? NULL : node->next;
    ce58:	f8d9 3004 	ldr.w	r3, [r9, #4]
    ce5c:	429f      	cmp	r7, r3
    ce5e:	d001      	beq.n	ce64 <fs_readdir+0xac>
    ce60:	f8d7 8000 	ldr.w	r8, [r7]
	k_mutex_unlock(&mutex);
    ce64:	f7ff fdda 	bl	ca1c <k_mutex_unlock.constprop.0>
	if (!found) {
    ce68:	b154      	cbz	r4, ce80 <fs_readdir+0xc8>
	zdp->dirp = next;
    ce6a:	f8c6 8000 	str.w	r8, [r6]
	return 0;
    ce6e:	2400      	movs	r4, #0
    ce70:	e7cc      	b.n	ce0c <fs_readdir+0x54>
    ce72:	429f      	cmp	r7, r3
    ce74:	d0dc      	beq.n	ce30 <fs_readdir+0x78>
    ce76:	683f      	ldr	r7, [r7, #0]
    ce78:	e7d8      	b.n	ce2c <fs_readdir+0x74>
		int rc = -EINVAL;
    ce7a:	f06f 0415 	mvn.w	r4, #21
    ce7e:	e7c5      	b.n	ce0c <fs_readdir+0x54>
		return -ENOENT;
    ce80:	f06f 0401 	mvn.w	r4, #1
    ce84:	e7c2      	b.n	ce0c <fs_readdir+0x54>
    ce86:	4b08      	ldr	r3, [pc, #32]	; (cea8 <fs_readdir+0xf0>)
    ce88:	4a08      	ldr	r2, [pc, #32]	; (ceac <fs_readdir+0xf4>)
				LOG_ERR("directory read error (%d)", rc);
    ce8a:	4809      	ldr	r0, [pc, #36]	; (ceb0 <fs_readdir+0xf8>)
    ce8c:	1ad2      	subs	r2, r2, r3
    ce8e:	08d2      	lsrs	r2, r2, #3
    ce90:	0192      	lsls	r2, r2, #6
    ce92:	f042 0201 	orr.w	r2, r2, #1
    ce96:	4621      	mov	r1, r4
    ce98:	f008 f9e4 	bl	15264 <log_1>
    ce9c:	e7b6      	b.n	ce0c <fs_readdir+0x54>
    ce9e:	bf00      	nop
    cea0:	0001ba63 	.word	0x0001ba63
    cea4:	20003784 	.word	0x20003784
    cea8:	0001956c 	.word	0x0001956c
    ceac:	00019604 	.word	0x00019604
    ceb0:	0001ba66 	.word	0x0001ba66
    ceb4:	0001a247 	.word	0x0001a247

0000ceb8 <fs_closedir>:
{
    ceb8:	b538      	push	{r3, r4, r5, lr}
	if (zdp->mp == NULL) {
    ceba:	6844      	ldr	r4, [r0, #4]
{
    cebc:	4605      	mov	r5, r0
	if (zdp->mp == NULL) {
    cebe:	b914      	cbnz	r4, cec6 <fs_closedir+0xe>
		zdp->dirp = NULL;
    cec0:	6004      	str	r4, [r0, #0]
}
    cec2:	4620      	mov	r0, r4
    cec4:	bd38      	pop	{r3, r4, r5, pc}
	if (zdp->mp->fs->closedir != NULL) {
    cec6:	69e3      	ldr	r3, [r4, #28]
    cec8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    ceca:	b173      	cbz	r3, ceea <fs_closedir+0x32>
		rc = zdp->mp->fs->closedir(zdp);
    cecc:	4798      	blx	r3
		if (rc < 0) {
    cece:	1e04      	subs	r4, r0, #0
    ced0:	da0d      	bge.n	ceee <fs_closedir+0x36>
    ced2:	4b08      	ldr	r3, [pc, #32]	; (cef4 <fs_closedir+0x3c>)
    ced4:	4a08      	ldr	r2, [pc, #32]	; (cef8 <fs_closedir+0x40>)
			LOG_ERR("directory close error (%d)", rc);
    ced6:	4809      	ldr	r0, [pc, #36]	; (cefc <fs_closedir+0x44>)
    ced8:	1ad2      	subs	r2, r2, r3
    ceda:	08d2      	lsrs	r2, r2, #3
    cedc:	0192      	lsls	r2, r2, #6
    cede:	f042 0201 	orr.w	r2, r2, #1
    cee2:	4621      	mov	r1, r4
    cee4:	f008 f9be 	bl	15264 <log_1>
			return rc;
    cee8:	e7eb      	b.n	cec2 <fs_closedir+0xa>
	int rc = -EINVAL;
    ceea:	f06f 0415 	mvn.w	r4, #21
	zdp->mp = NULL;
    ceee:	2300      	movs	r3, #0
    cef0:	606b      	str	r3, [r5, #4]
	return rc;
    cef2:	e7e6      	b.n	cec2 <fs_closedir+0xa>
    cef4:	0001956c 	.word	0x0001956c
    cef8:	00019604 	.word	0x00019604
    cefc:	0001ba80 	.word	0x0001ba80

0000cf00 <fs_unlink>:
{
    cf00:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if ((abs_path == NULL) ||
    cf02:	4605      	mov	r5, r0
    cf04:	b970      	cbnz	r0, cf24 <fs_unlink+0x24>
    cf06:	4b1e      	ldr	r3, [pc, #120]	; (cf80 <fs_unlink+0x80>)
    cf08:	491e      	ldr	r1, [pc, #120]	; (cf84 <fs_unlink+0x84>)
		LOG_ERR("invalid file name!!");
    cf0a:	481f      	ldr	r0, [pc, #124]	; (cf88 <fs_unlink+0x88>)
    cf0c:	1ac9      	subs	r1, r1, r3
    cf0e:	08c9      	lsrs	r1, r1, #3
    cf10:	0189      	lsls	r1, r1, #6
    cf12:	f041 0101 	orr.w	r1, r1, #1
    cf16:	f008 f998 	bl	1524a <log_0>
		return -EINVAL;
    cf1a:	f06f 0415 	mvn.w	r4, #21
}
    cf1e:	4620      	mov	r0, r4
    cf20:	b003      	add	sp, #12
    cf22:	bd30      	pop	{r4, r5, pc}
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    cf24:	f009 f857 	bl	15fd6 <strlen>
	if ((abs_path == NULL) ||
    cf28:	2801      	cmp	r0, #1
    cf2a:	d9ec      	bls.n	cf06 <fs_unlink+0x6>
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    cf2c:	782b      	ldrb	r3, [r5, #0]
    cf2e:	2b2f      	cmp	r3, #47	; 0x2f
    cf30:	d1e9      	bne.n	cf06 <fs_unlink+0x6>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    cf32:	2200      	movs	r2, #0
    cf34:	4629      	mov	r1, r5
    cf36:	a801      	add	r0, sp, #4
    cf38:	f7ff fd8c 	bl	ca54 <fs_get_mnt_point>
	if (rc < 0) {
    cf3c:	1e04      	subs	r4, r0, #0
    cf3e:	da0b      	bge.n	cf58 <fs_unlink+0x58>
    cf40:	4a10      	ldr	r2, [pc, #64]	; (cf84 <fs_unlink+0x84>)
    cf42:	4b0f      	ldr	r3, [pc, #60]	; (cf80 <fs_unlink+0x80>)
		LOG_ERR("%s:mount point not found!!", __func__);
    cf44:	4911      	ldr	r1, [pc, #68]	; (cf8c <fs_unlink+0x8c>)
    cf46:	4812      	ldr	r0, [pc, #72]	; (cf90 <fs_unlink+0x90>)
    cf48:	1ad2      	subs	r2, r2, r3
    cf4a:	08d2      	lsrs	r2, r2, #3
    cf4c:	0192      	lsls	r2, r2, #6
    cf4e:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("failed to unlink path (%d)", rc);
    cf52:	f008 f987 	bl	15264 <log_1>
    cf56:	e7e2      	b.n	cf1e <fs_unlink+0x1e>
	if (mp->fs->unlink != NULL) {
    cf58:	9801      	ldr	r0, [sp, #4]
    cf5a:	69c3      	ldr	r3, [r0, #28]
    cf5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    cf5e:	2b00      	cmp	r3, #0
    cf60:	d0dd      	beq.n	cf1e <fs_unlink+0x1e>
		rc = mp->fs->unlink(mp, abs_path);
    cf62:	4629      	mov	r1, r5
    cf64:	4798      	blx	r3
		if (rc < 0) {
    cf66:	1e04      	subs	r4, r0, #0
    cf68:	dad9      	bge.n	cf1e <fs_unlink+0x1e>
    cf6a:	4a06      	ldr	r2, [pc, #24]	; (cf84 <fs_unlink+0x84>)
    cf6c:	4b04      	ldr	r3, [pc, #16]	; (cf80 <fs_unlink+0x80>)
			LOG_ERR("failed to unlink path (%d)", rc);
    cf6e:	4809      	ldr	r0, [pc, #36]	; (cf94 <fs_unlink+0x94>)
    cf70:	1ad2      	subs	r2, r2, r3
    cf72:	08d2      	lsrs	r2, r2, #3
    cf74:	0192      	lsls	r2, r2, #6
    cf76:	f042 0201 	orr.w	r2, r2, #1
    cf7a:	4621      	mov	r1, r4
    cf7c:	e7e9      	b.n	cf52 <fs_unlink+0x52>
    cf7e:	bf00      	nop
    cf80:	0001956c 	.word	0x0001956c
    cf84:	00019604 	.word	0x00019604
    cf88:	0001b983 	.word	0x0001b983
    cf8c:	0001bbc8 	.word	0x0001bbc8
    cf90:	0001b997 	.word	0x0001b997
    cf94:	0001ba9b 	.word	0x0001ba9b

0000cf98 <fs_stat>:
{
    cf98:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cf9a:	460e      	mov	r6, r1
	if ((abs_path == NULL) ||
    cf9c:	4605      	mov	r5, r0
    cf9e:	b970      	cbnz	r0, cfbe <fs_stat+0x26>
    cfa0:	4b1e      	ldr	r3, [pc, #120]	; (d01c <fs_stat+0x84>)
    cfa2:	491f      	ldr	r1, [pc, #124]	; (d020 <fs_stat+0x88>)
		LOG_ERR("invalid file name!!");
    cfa4:	481f      	ldr	r0, [pc, #124]	; (d024 <fs_stat+0x8c>)
    cfa6:	1ac9      	subs	r1, r1, r3
    cfa8:	08c9      	lsrs	r1, r1, #3
    cfaa:	0189      	lsls	r1, r1, #6
    cfac:	f041 0101 	orr.w	r1, r1, #1
    cfb0:	f008 f94b 	bl	1524a <log_0>
		return -EINVAL;
    cfb4:	f06f 0415 	mvn.w	r4, #21
}
    cfb8:	4620      	mov	r0, r4
    cfba:	b002      	add	sp, #8
    cfbc:	bd70      	pop	{r4, r5, r6, pc}
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    cfbe:	f009 f80a 	bl	15fd6 <strlen>
	if ((abs_path == NULL) ||
    cfc2:	2801      	cmp	r0, #1
    cfc4:	d9ec      	bls.n	cfa0 <fs_stat+0x8>
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    cfc6:	782b      	ldrb	r3, [r5, #0]
    cfc8:	2b2f      	cmp	r3, #47	; 0x2f
    cfca:	d1e9      	bne.n	cfa0 <fs_stat+0x8>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    cfcc:	2200      	movs	r2, #0
    cfce:	4629      	mov	r1, r5
    cfd0:	a801      	add	r0, sp, #4
    cfd2:	f7ff fd3f 	bl	ca54 <fs_get_mnt_point>
	if (rc < 0) {
    cfd6:	1e04      	subs	r4, r0, #0
    cfd8:	da0b      	bge.n	cff2 <fs_stat+0x5a>
    cfda:	4a11      	ldr	r2, [pc, #68]	; (d020 <fs_stat+0x88>)
    cfdc:	4b0f      	ldr	r3, [pc, #60]	; (d01c <fs_stat+0x84>)
		LOG_ERR("%s:mount point not found!!", __func__);
    cfde:	4912      	ldr	r1, [pc, #72]	; (d028 <fs_stat+0x90>)
    cfe0:	4812      	ldr	r0, [pc, #72]	; (d02c <fs_stat+0x94>)
    cfe2:	1ad2      	subs	r2, r2, r3
    cfe4:	08d2      	lsrs	r2, r2, #3
    cfe6:	0192      	lsls	r2, r2, #6
    cfe8:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("failed get file or dir stat (%d)", rc);
    cfec:	f008 f93a 	bl	15264 <log_1>
    cff0:	e7e2      	b.n	cfb8 <fs_stat+0x20>
	if (mp->fs->stat != NULL) {
    cff2:	9801      	ldr	r0, [sp, #4]
    cff4:	69c3      	ldr	r3, [r0, #28]
    cff6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    cff8:	2b00      	cmp	r3, #0
    cffa:	d0dd      	beq.n	cfb8 <fs_stat+0x20>
		rc = mp->fs->stat(mp, abs_path, entry);
    cffc:	4632      	mov	r2, r6
    cffe:	4629      	mov	r1, r5
    d000:	4798      	blx	r3
		if (rc < 0) {
    d002:	1e04      	subs	r4, r0, #0
    d004:	dad8      	bge.n	cfb8 <fs_stat+0x20>
    d006:	4a06      	ldr	r2, [pc, #24]	; (d020 <fs_stat+0x88>)
    d008:	4b04      	ldr	r3, [pc, #16]	; (d01c <fs_stat+0x84>)
			LOG_ERR("failed get file or dir stat (%d)", rc);
    d00a:	4809      	ldr	r0, [pc, #36]	; (d030 <fs_stat+0x98>)
    d00c:	1ad2      	subs	r2, r2, r3
    d00e:	08d2      	lsrs	r2, r2, #3
    d010:	0192      	lsls	r2, r2, #6
    d012:	f042 0201 	orr.w	r2, r2, #1
    d016:	4621      	mov	r1, r4
    d018:	e7e8      	b.n	cfec <fs_stat+0x54>
    d01a:	bf00      	nop
    d01c:	0001956c 	.word	0x0001956c
    d020:	00019604 	.word	0x00019604
    d024:	0001b983 	.word	0x0001b983
    d028:	0001bbd2 	.word	0x0001bbd2
    d02c:	0001b997 	.word	0x0001b997
    d030:	0001bab6 	.word	0x0001bab6

0000d034 <fs_statvfs>:
{
    d034:	b573      	push	{r0, r1, r4, r5, r6, lr}
    d036:	460e      	mov	r6, r1
	if ((abs_path == NULL) ||
    d038:	4605      	mov	r5, r0
    d03a:	b970      	cbnz	r0, d05a <fs_statvfs+0x26>
    d03c:	4b1e      	ldr	r3, [pc, #120]	; (d0b8 <fs_statvfs+0x84>)
    d03e:	491f      	ldr	r1, [pc, #124]	; (d0bc <fs_statvfs+0x88>)
		LOG_ERR("invalid file name!!");
    d040:	481f      	ldr	r0, [pc, #124]	; (d0c0 <fs_statvfs+0x8c>)
    d042:	1ac9      	subs	r1, r1, r3
    d044:	08c9      	lsrs	r1, r1, #3
    d046:	0189      	lsls	r1, r1, #6
    d048:	f041 0101 	orr.w	r1, r1, #1
    d04c:	f008 f8fd 	bl	1524a <log_0>
		return -EINVAL;
    d050:	f06f 0415 	mvn.w	r4, #21
}
    d054:	4620      	mov	r0, r4
    d056:	b002      	add	sp, #8
    d058:	bd70      	pop	{r4, r5, r6, pc}
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    d05a:	f008 ffbc 	bl	15fd6 <strlen>
	if ((abs_path == NULL) ||
    d05e:	2801      	cmp	r0, #1
    d060:	d9ec      	bls.n	d03c <fs_statvfs+0x8>
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    d062:	782b      	ldrb	r3, [r5, #0]
    d064:	2b2f      	cmp	r3, #47	; 0x2f
    d066:	d1e9      	bne.n	d03c <fs_statvfs+0x8>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    d068:	2200      	movs	r2, #0
    d06a:	4629      	mov	r1, r5
    d06c:	a801      	add	r0, sp, #4
    d06e:	f7ff fcf1 	bl	ca54 <fs_get_mnt_point>
	if (rc < 0) {
    d072:	1e04      	subs	r4, r0, #0
    d074:	da0b      	bge.n	d08e <fs_statvfs+0x5a>
    d076:	4a11      	ldr	r2, [pc, #68]	; (d0bc <fs_statvfs+0x88>)
    d078:	4b0f      	ldr	r3, [pc, #60]	; (d0b8 <fs_statvfs+0x84>)
		LOG_ERR("%s:mount point not found!!", __func__);
    d07a:	4912      	ldr	r1, [pc, #72]	; (d0c4 <fs_statvfs+0x90>)
    d07c:	4812      	ldr	r0, [pc, #72]	; (d0c8 <fs_statvfs+0x94>)
    d07e:	1ad2      	subs	r2, r2, r3
    d080:	08d2      	lsrs	r2, r2, #3
    d082:	0192      	lsls	r2, r2, #6
    d084:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("failed get file or dir stat (%d)", rc);
    d088:	f008 f8ec 	bl	15264 <log_1>
    d08c:	e7e2      	b.n	d054 <fs_statvfs+0x20>
	if (mp->fs->statvfs != NULL) {
    d08e:	9801      	ldr	r0, [sp, #4]
    d090:	69c3      	ldr	r3, [r0, #28]
    d092:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    d094:	2b00      	cmp	r3, #0
    d096:	d0dd      	beq.n	d054 <fs_statvfs+0x20>
		rc = mp->fs->statvfs(mp, abs_path, stat);
    d098:	4632      	mov	r2, r6
    d09a:	4629      	mov	r1, r5
    d09c:	4798      	blx	r3
		if (rc < 0) {
    d09e:	1e04      	subs	r4, r0, #0
    d0a0:	dad8      	bge.n	d054 <fs_statvfs+0x20>
    d0a2:	4a06      	ldr	r2, [pc, #24]	; (d0bc <fs_statvfs+0x88>)
    d0a4:	4b04      	ldr	r3, [pc, #16]	; (d0b8 <fs_statvfs+0x84>)
			LOG_ERR("failed get file or dir stat (%d)", rc);
    d0a6:	4809      	ldr	r0, [pc, #36]	; (d0cc <fs_statvfs+0x98>)
    d0a8:	1ad2      	subs	r2, r2, r3
    d0aa:	08d2      	lsrs	r2, r2, #3
    d0ac:	0192      	lsls	r2, r2, #6
    d0ae:	f042 0201 	orr.w	r2, r2, #1
    d0b2:	4621      	mov	r1, r4
    d0b4:	e7e8      	b.n	d088 <fs_statvfs+0x54>
    d0b6:	bf00      	nop
    d0b8:	0001956c 	.word	0x0001956c
    d0bc:	00019604 	.word	0x00019604
    d0c0:	0001b983 	.word	0x0001b983
    d0c4:	0001bbda 	.word	0x0001bbda
    d0c8:	0001b997 	.word	0x0001b997
    d0cc:	0001bab6 	.word	0x0001bab6

0000d0d0 <fs_mount>:
{
    d0d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((mp == NULL) || (mp->mnt_point == NULL)) {
    d0d2:	4604      	mov	r4, r0
    d0d4:	b108      	cbz	r0, d0da <fs_mount+0xa>
    d0d6:	68c3      	ldr	r3, [r0, #12]
    d0d8:	b96b      	cbnz	r3, d0f6 <fs_mount+0x26>
    d0da:	4b42      	ldr	r3, [pc, #264]	; (d1e4 <fs_mount+0x114>)
    d0dc:	4942      	ldr	r1, [pc, #264]	; (d1e8 <fs_mount+0x118>)
		LOG_ERR("mount point not initialized!!");
    d0de:	4843      	ldr	r0, [pc, #268]	; (d1ec <fs_mount+0x11c>)
    d0e0:	1ac9      	subs	r1, r1, r3
    d0e2:	08c9      	lsrs	r1, r1, #3
    d0e4:	0189      	lsls	r1, r1, #6
    d0e6:	f041 0101 	orr.w	r1, r1, #1
    d0ea:	f008 f8ae 	bl	1524a <log_0>
		return -EINVAL;
    d0ee:	f06f 0515 	mvn.w	r5, #21
}
    d0f2:	4628      	mov	r0, r5
    d0f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	k_mutex_lock(&mutex, K_FOREVER);
    d0f6:	f7ff fc97 	bl	ca28 <k_mutex_lock.constprop.0>
	if (mp->type >= FS_TYPE_END ||  fs_map[mp->type] == NULL) {
    d0fa:	7a23      	ldrb	r3, [r4, #8]
    d0fc:	2b01      	cmp	r3, #1
    d0fe:	d803      	bhi.n	d108 <fs_mount+0x38>
    d100:	4a3b      	ldr	r2, [pc, #236]	; (d1f0 <fs_mount+0x120>)
    d102:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
    d106:	b977      	cbnz	r7, d126 <fs_mount+0x56>
    d108:	4b36      	ldr	r3, [pc, #216]	; (d1e4 <fs_mount+0x114>)
    d10a:	4937      	ldr	r1, [pc, #220]	; (d1e8 <fs_mount+0x118>)
		LOG_ERR("requested file system not registered!!");
    d10c:	4839      	ldr	r0, [pc, #228]	; (d1f4 <fs_mount+0x124>)
    d10e:	1ac9      	subs	r1, r1, r3
    d110:	08c9      	lsrs	r1, r1, #3
    d112:	0189      	lsls	r1, r1, #6
    d114:	f041 0101 	orr.w	r1, r1, #1
    d118:	f008 f897 	bl	1524a <log_0>
		rc = -ENOENT;
    d11c:	f06f 0501 	mvn.w	r5, #1
	k_mutex_unlock(&mutex);
    d120:	f7ff fc7c 	bl	ca1c <k_mutex_unlock.constprop.0>
	return rc;
    d124:	e7e5      	b.n	d0f2 <fs_mount+0x22>
	mp->mountp_len = strlen(mp->mnt_point);
    d126:	68e0      	ldr	r0, [r4, #12]
    d128:	f008 ff55 	bl	15fd6 <strlen>
    d12c:	61a0      	str	r0, [r4, #24]
	if ((mp->mnt_point[0] != '/') ||
    d12e:	68e0      	ldr	r0, [r4, #12]
    d130:	7803      	ldrb	r3, [r0, #0]
    d132:	2b2f      	cmp	r3, #47	; 0x2f
    d134:	d00c      	beq.n	d150 <fs_mount+0x80>
    d136:	492c      	ldr	r1, [pc, #176]	; (d1e8 <fs_mount+0x118>)
    d138:	4b2a      	ldr	r3, [pc, #168]	; (d1e4 <fs_mount+0x114>)
		LOG_ERR("invalid mount point!!");
    d13a:	482f      	ldr	r0, [pc, #188]	; (d1f8 <fs_mount+0x128>)
    d13c:	1ac9      	subs	r1, r1, r3
    d13e:	08c9      	lsrs	r1, r1, #3
    d140:	0189      	lsls	r1, r1, #6
    d142:	f041 0101 	orr.w	r1, r1, #1
		LOG_ERR("fs ops functions not set!!");
    d146:	f008 f880 	bl	1524a <log_0>
		rc = -EINVAL;
    d14a:	f06f 0515 	mvn.w	r5, #21
		goto mount_err;
    d14e:	e7e7      	b.n	d120 <fs_mount+0x50>
			(strlen(mp->mnt_point) <= 1)) {
    d150:	f008 ff41 	bl	15fd6 <strlen>
	if ((mp->mnt_point[0] != '/') ||
    d154:	2801      	cmp	r0, #1
    d156:	d9ee      	bls.n	d136 <fs_mount+0x66>
	if (fs->mount == NULL) {
    d158:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d15a:	b943      	cbnz	r3, d16e <fs_mount+0x9e>
    d15c:	4922      	ldr	r1, [pc, #136]	; (d1e8 <fs_mount+0x118>)
    d15e:	4b21      	ldr	r3, [pc, #132]	; (d1e4 <fs_mount+0x114>)
		LOG_ERR("fs ops functions not set!!");
    d160:	4826      	ldr	r0, [pc, #152]	; (d1fc <fs_mount+0x12c>)
    d162:	1ac9      	subs	r1, r1, r3
    d164:	08c9      	lsrs	r1, r1, #3
    d166:	0189      	lsls	r1, r1, #6
    d168:	f041 0101 	orr.w	r1, r1, #1
    d16c:	e7eb      	b.n	d146 <fs_mount+0x76>
	return list->head == list;
    d16e:	4e24      	ldr	r6, [pc, #144]	; (d200 <fs_mount+0x130>)
    d170:	6835      	ldr	r5, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    d172:	42b5      	cmp	r5, r6
    d174:	d114      	bne.n	d1a0 <fs_mount+0xd0>
	rc = fs->mount(mp);
    d176:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d178:	4620      	mov	r0, r4
    d17a:	4798      	blx	r3
	if (rc < 0) {
    d17c:	1e05      	subs	r5, r0, #0
    d17e:	da28      	bge.n	d1d2 <fs_mount+0x102>
    d180:	4b18      	ldr	r3, [pc, #96]	; (d1e4 <fs_mount+0x114>)
    d182:	4a19      	ldr	r2, [pc, #100]	; (d1e8 <fs_mount+0x118>)
		LOG_ERR("fs mount error (%d)", rc);
    d184:	481f      	ldr	r0, [pc, #124]	; (d204 <fs_mount+0x134>)
    d186:	1ad2      	subs	r2, r2, r3
    d188:	08d2      	lsrs	r2, r2, #3
    d18a:	0192      	lsls	r2, r2, #6
    d18c:	f042 0201 	orr.w	r2, r2, #1
    d190:	4629      	mov	r1, r5
    d192:	f008 f867 	bl	15264 <log_1>
		goto mount_err;
    d196:	e7c3      	b.n	d120 <fs_mount+0x50>
	return (node == list->tail) ? NULL : node->next;
    d198:	6873      	ldr	r3, [r6, #4]
    d19a:	429d      	cmp	r5, r3
    d19c:	d0eb      	beq.n	d176 <fs_mount+0xa6>
    d19e:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    d1a0:	2d00      	cmp	r5, #0
    d1a2:	d0e8      	beq.n	d176 <fs_mount+0xa6>
		if (mp->mountp_len != itr->mountp_len) {
    d1a4:	69a2      	ldr	r2, [r4, #24]
    d1a6:	69ab      	ldr	r3, [r5, #24]
    d1a8:	429a      	cmp	r2, r3
    d1aa:	d1f5      	bne.n	d198 <fs_mount+0xc8>
		if (strncmp(mp->mnt_point, itr->mnt_point,
    d1ac:	68e9      	ldr	r1, [r5, #12]
    d1ae:	68e0      	ldr	r0, [r4, #12]
    d1b0:	f008 ff24 	bl	15ffc <strncmp>
    d1b4:	2800      	cmp	r0, #0
    d1b6:	d1ef      	bne.n	d198 <fs_mount+0xc8>
    d1b8:	4b0a      	ldr	r3, [pc, #40]	; (d1e4 <fs_mount+0x114>)
    d1ba:	490b      	ldr	r1, [pc, #44]	; (d1e8 <fs_mount+0x118>)
			LOG_ERR("mount Point already exists!!");
    d1bc:	4812      	ldr	r0, [pc, #72]	; (d208 <fs_mount+0x138>)
    d1be:	1ac9      	subs	r1, r1, r3
    d1c0:	08c9      	lsrs	r1, r1, #3
    d1c2:	0189      	lsls	r1, r1, #6
    d1c4:	f041 0101 	orr.w	r1, r1, #1
    d1c8:	f008 f83f 	bl	1524a <log_0>
			rc = -EBUSY;
    d1cc:	f06f 050f 	mvn.w	r5, #15
			goto mount_err;
    d1d0:	e7a6      	b.n	d120 <fs_mount+0x50>
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
    d1d2:	6873      	ldr	r3, [r6, #4]
    d1d4:	6063      	str	r3, [r4, #4]

	list->tail->next = node;
    d1d6:	6873      	ldr	r3, [r6, #4]
	node->next = list;
    d1d8:	6026      	str	r6, [r4, #0]
	mp->fs = fs;
    d1da:	61e7      	str	r7, [r4, #28]
	list->tail->next = node;
    d1dc:	601c      	str	r4, [r3, #0]
	list->tail = node;
    d1de:	6074      	str	r4, [r6, #4]
}
    d1e0:	e79e      	b.n	d120 <fs_mount+0x50>
    d1e2:	bf00      	nop
    d1e4:	0001956c 	.word	0x0001956c
    d1e8:	00019604 	.word	0x00019604
    d1ec:	0001bad7 	.word	0x0001bad7
    d1f0:	2000377c 	.word	0x2000377c
    d1f4:	0001baf5 	.word	0x0001baf5
    d1f8:	0001bb1c 	.word	0x0001bb1c
    d1fc:	0001bb32 	.word	0x0001bb32
    d200:	20003784 	.word	0x20003784
    d204:	0001bb6a 	.word	0x0001bb6a
    d208:	0001bb4d 	.word	0x0001bb4d

0000d20c <fs_unmount>:
{
    d20c:	b538      	push	{r3, r4, r5, lr}
	if ((mp == NULL) || (mp->mnt_point == NULL) ||
    d20e:	4604      	mov	r4, r0
    d210:	b968      	cbnz	r0, d22e <fs_unmount+0x22>
    d212:	4b21      	ldr	r3, [pc, #132]	; (d298 <fs_unmount+0x8c>)
    d214:	4921      	ldr	r1, [pc, #132]	; (d29c <fs_unmount+0x90>)
		LOG_ERR("invalid mount point!!");
    d216:	4822      	ldr	r0, [pc, #136]	; (d2a0 <fs_unmount+0x94>)
    d218:	1ac9      	subs	r1, r1, r3
    d21a:	08c9      	lsrs	r1, r1, #3
    d21c:	0189      	lsls	r1, r1, #6
    d21e:	f041 0101 	orr.w	r1, r1, #1
    d222:	f008 f812 	bl	1524a <log_0>
		return -EINVAL;
    d226:	f06f 0515 	mvn.w	r5, #21
}
    d22a:	4628      	mov	r0, r5
    d22c:	bd38      	pop	{r3, r4, r5, pc}
	if ((mp == NULL) || (mp->mnt_point == NULL) ||
    d22e:	68c0      	ldr	r0, [r0, #12]
    d230:	2800      	cmp	r0, #0
    d232:	d0ee      	beq.n	d212 <fs_unmount+0x6>
				(strlen(mp->mnt_point) <= 1)) {
    d234:	f008 fecf 	bl	15fd6 <strlen>
	if ((mp == NULL) || (mp->mnt_point == NULL) ||
    d238:	2801      	cmp	r0, #1
    d23a:	d9ea      	bls.n	d212 <fs_unmount+0x6>
	k_mutex_lock(&mutex, K_FOREVER);
    d23c:	f7ff fbf4 	bl	ca28 <k_mutex_lock.constprop.0>
	if ((mp->fs == NULL) || mp->fs->unmount == NULL) {
    d240:	69e3      	ldr	r3, [r4, #28]
    d242:	b10b      	cbz	r3, d248 <fs_unmount+0x3c>
    d244:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    d246:	b973      	cbnz	r3, d266 <fs_unmount+0x5a>
    d248:	4b13      	ldr	r3, [pc, #76]	; (d298 <fs_unmount+0x8c>)
    d24a:	4914      	ldr	r1, [pc, #80]	; (d29c <fs_unmount+0x90>)
		LOG_ERR("fs ops functions not set!!");
    d24c:	4815      	ldr	r0, [pc, #84]	; (d2a4 <fs_unmount+0x98>)
    d24e:	1ac9      	subs	r1, r1, r3
    d250:	08c9      	lsrs	r1, r1, #3
    d252:	0189      	lsls	r1, r1, #6
    d254:	f041 0101 	orr.w	r1, r1, #1
    d258:	f007 fff7 	bl	1524a <log_0>
		rc = -EINVAL;
    d25c:	f06f 0515 	mvn.w	r5, #21
	k_mutex_unlock(&mutex);
    d260:	f7ff fbdc 	bl	ca1c <k_mutex_unlock.constprop.0>
	return rc;
    d264:	e7e1      	b.n	d22a <fs_unmount+0x1e>
	rc = mp->fs->unmount(mp);
    d266:	4620      	mov	r0, r4
    d268:	4798      	blx	r3
	if (rc < 0) {
    d26a:	1e05      	subs	r5, r0, #0
    d26c:	da0b      	bge.n	d286 <fs_unmount+0x7a>
    d26e:	4b0a      	ldr	r3, [pc, #40]	; (d298 <fs_unmount+0x8c>)
    d270:	4a0a      	ldr	r2, [pc, #40]	; (d29c <fs_unmount+0x90>)
		LOG_ERR("fs unmount error (%d)", rc);
    d272:	480d      	ldr	r0, [pc, #52]	; (d2a8 <fs_unmount+0x9c>)
    d274:	1ad2      	subs	r2, r2, r3
    d276:	08d2      	lsrs	r2, r2, #3
    d278:	0192      	lsls	r2, r2, #6
    d27a:	f042 0201 	orr.w	r2, r2, #1
    d27e:	4629      	mov	r1, r5
    d280:	f007 fff0 	bl	15264 <log_1>
		goto unmount_err;
    d284:	e7ec      	b.n	d260 <fs_unmount+0x54>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    d286:	e9d4 2100 	ldrd	r2, r1, [r4]
	mp->fs = NULL;
    d28a:	2300      	movs	r3, #0
    d28c:	61e3      	str	r3, [r4, #28]
    d28e:	600a      	str	r2, [r1, #0]
	node->next->prev = node->prev;
    d290:	6051      	str	r1, [r2, #4]
	node->prev = NULL;
    d292:	e9c4 3300 	strd	r3, r3, [r4]
	sys_dnode_init(node);
}
    d296:	e7e3      	b.n	d260 <fs_unmount+0x54>
    d298:	0001956c 	.word	0x0001956c
    d29c:	00019604 	.word	0x00019604
    d2a0:	0001bb1c 	.word	0x0001bb1c
    d2a4:	0001bb32 	.word	0x0001bb32
    d2a8:	0001bb7e 	.word	0x0001bb7e

0000d2ac <fs_register>:
{
    d2ac:	b538      	push	{r3, r4, r5, lr}
    d2ae:	4604      	mov	r4, r0
    d2b0:	460d      	mov	r5, r1
	k_mutex_lock(&mutex, K_FOREVER);
    d2b2:	f7ff fbb9 	bl	ca28 <k_mutex_lock.constprop.0>
	if (type >= FS_TYPE_END) {
    d2b6:	2c01      	cmp	r4, #1
    d2b8:	d90f      	bls.n	d2da <fs_register+0x2e>
    d2ba:	4b0a      	ldr	r3, [pc, #40]	; (d2e4 <fs_register+0x38>)
    d2bc:	490a      	ldr	r1, [pc, #40]	; (d2e8 <fs_register+0x3c>)
		LOG_ERR("failed to register File system!!");
    d2be:	480b      	ldr	r0, [pc, #44]	; (d2ec <fs_register+0x40>)
    d2c0:	1ac9      	subs	r1, r1, r3
    d2c2:	08c9      	lsrs	r1, r1, #3
    d2c4:	0189      	lsls	r1, r1, #6
    d2c6:	f041 0101 	orr.w	r1, r1, #1
    d2ca:	f007 ffbe 	bl	1524a <log_0>
		rc = -EINVAL;
    d2ce:	f06f 0415 	mvn.w	r4, #21
	k_mutex_unlock(&mutex);
    d2d2:	f7ff fba3 	bl	ca1c <k_mutex_unlock.constprop.0>
}
    d2d6:	4620      	mov	r0, r4
    d2d8:	bd38      	pop	{r3, r4, r5, pc}
	fs_map[type] = fs;
    d2da:	4b05      	ldr	r3, [pc, #20]	; (d2f0 <fs_register+0x44>)
    d2dc:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
	int rc = 0;
    d2e0:	2400      	movs	r4, #0
reg_err:
    d2e2:	e7f6      	b.n	d2d2 <fs_register+0x26>
    d2e4:	0001956c 	.word	0x0001956c
    d2e8:	00019604 	.word	0x00019604
    d2ec:	0001bb94 	.word	0x0001bb94
    d2f0:	2000377c 	.word	0x2000377c

0000d2f4 <fs_impl_strip_prefix>:
const char *fs_impl_strip_prefix(const char *path,
				 const struct fs_mount_t *mp)
{
	static const char *const root = "/";

	if ((path == NULL) || (mp == NULL)) {
    d2f4:	b138      	cbz	r0, d306 <fs_impl_strip_prefix+0x12>
    d2f6:	b131      	cbz	r1, d306 <fs_impl_strip_prefix+0x12>
		return path;
	}

	path += mp->mountp_len;
    d2f8:	698b      	ldr	r3, [r1, #24]
    d2fa:	4418      	add	r0, r3
	return *path ? path : root;
    d2fc:	4b02      	ldr	r3, [pc, #8]	; (d308 <fs_impl_strip_prefix+0x14>)
    d2fe:	7802      	ldrb	r2, [r0, #0]
    d300:	2a00      	cmp	r2, #0
    d302:	bf08      	it	eq
    d304:	4618      	moveq	r0, r3
}
    d306:	4770      	bx	lr
    d308:	0001ba47 	.word	0x0001ba47

0000d30c <littlefs_init>:
};

static int littlefs_init(struct device *dev)
{
	ARG_UNUSED(dev);
	return fs_register(FS_LITTLEFS, &littlefs_fs);
    d30c:	4901      	ldr	r1, [pc, #4]	; (d314 <littlefs_init+0x8>)
    d30e:	2001      	movs	r0, #1
    d310:	f7ff bfcc 	b.w	d2ac <fs_register>
    d314:	2000bfe4 	.word	0x2000bfe4

0000d318 <release_file_data>:
{
    d318:	b510      	push	{r4, lr}
    d31a:	4604      	mov	r4, r0
	struct lfs_file_data *fdp = fp->filep;
    d31c:	6800      	ldr	r0, [r0, #0]
	if (fdp->config.buffer) {
    d31e:	6d43      	ldr	r3, [r0, #84]	; 0x54
    d320:	b113      	cbz	r3, d328 <release_file_data+0x10>
		k_mem_pool_free(&fdp->cache_block);
    d322:	3060      	adds	r0, #96	; 0x60
    d324:	f00b fbb8 	bl	18a98 <k_mem_pool_free>
	k_mem_slab_free(&file_data_pool, &fp->filep);
    d328:	4803      	ldr	r0, [pc, #12]	; (d338 <release_file_data+0x20>)
    d32a:	4621      	mov	r1, r4
    d32c:	f006 fb90 	bl	13a50 <k_mem_slab_free>
	fp->filep = NULL;
    d330:	2300      	movs	r3, #0
    d332:	6023      	str	r3, [r4, #0]
}
    d334:	bd10      	pop	{r4, pc}
    d336:	bf00      	nop
    d338:	2000c2bc 	.word	0x2000c2bc

0000d33c <lfs_to_errno>:
	if (error >= 0) {
    d33c:	2800      	cmp	r0, #0
    d33e:	da07      	bge.n	d350 <lfs_to_errno+0x14>
	switch (error) {
    d340:	3054      	adds	r0, #84	; 0x54
    d342:	2852      	cmp	r0, #82	; 0x52
    d344:	d802      	bhi.n	d34c <lfs_to_errno+0x10>
    d346:	4b03      	ldr	r3, [pc, #12]	; (d354 <lfs_to_errno+0x18>)
    d348:	5618      	ldrsb	r0, [r3, r0]
    d34a:	4770      	bx	lr
    d34c:	f06f 0004 	mvn.w	r0, #4
}
    d350:	4770      	bx	lr
    d352:	bf00      	nop
    d354:	0001bd03 	.word	0x0001bd03

0000d358 <lfs_api_prog>:
{
    d358:	b538      	push	{r3, r4, r5, lr}
	size_t offset = block * c->block_size + off;
    d35a:	69c5      	ldr	r5, [r0, #28]
	int rc = flash_area_write(fa, offset, buffer, size);
    d35c:	6800      	ldr	r0, [r0, #0]
{
    d35e:	4614      	mov	r4, r2
	int rc = flash_area_write(fa, offset, buffer, size);
    d360:	fb05 4101 	mla	r1, r5, r1, r4
{
    d364:	461a      	mov	r2, r3
	int rc = flash_area_write(fa, offset, buffer, size);
    d366:	9b04      	ldr	r3, [sp, #16]
    d368:	f008 fc1c 	bl	15ba4 <flash_area_write>
	if (error >= 0) {
    d36c:	2800      	cmp	r0, #0
    d36e:	da05      	bge.n	d37c <lfs_api_prog+0x24>
	switch (error) {
    d370:	301c      	adds	r0, #28
    d372:	281a      	cmp	r0, #26
    d374:	d804      	bhi.n	d380 <lfs_api_prog+0x28>
    d376:	4b04      	ldr	r3, [pc, #16]	; (d388 <lfs_api_prog+0x30>)
    d378:	5618      	ldrsb	r0, [r3, r0]
}
    d37a:	bd38      	pop	{r3, r4, r5, pc}
		return LFS_ERR_OK;
    d37c:	2000      	movs	r0, #0
    d37e:	e7fc      	b.n	d37a <lfs_api_prog+0x22>
	switch (error) {
    d380:	f06f 0004 	mvn.w	r0, #4
	return errno_to_lfs(rc);
    d384:	e7f9      	b.n	d37a <lfs_api_prog+0x22>
    d386:	bf00      	nop
    d388:	0001bd56 	.word	0x0001bd56

0000d38c <littlefs_unmount>:
{
    d38c:	b570      	push	{r4, r5, r6, lr}
	struct fs_littlefs *fs = mountp->fs_data;
    d38e:	6904      	ldr	r4, [r0, #16]
{
    d390:	4605      	mov	r5, r0
	fs_lock(fs);
    d392:	4620      	mov	r0, r4
    d394:	f009 fccc 	bl	16d30 <fs_lock>
	lfs_unmount(&fs->lfs);
    d398:	f104 0070 	add.w	r0, r4, #112	; 0x70
    d39c:	f00b f80e 	bl	183bc <lfs_unmount>
	fs->area = NULL;
    d3a0:	2600      	movs	r6, #0
	flash_area_close(fs->area);
    d3a2:	f8d4 00e8 	ldr.w	r0, [r4, #232]	; 0xe8
    d3a6:	f008 fbdf 	bl	15b68 <flash_area_close>
	fs->area = NULL;
    d3aa:	f8c4 60e8 	str.w	r6, [r4, #232]	; 0xe8
	k_mutex_unlock(&fs->mutex);
    d3ae:	f104 00ec 	add.w	r0, r4, #236	; 0xec
    d3b2:	f009 fcbb 	bl	16d2c <k_mutex_unlock>
    d3b6:	4c08      	ldr	r4, [pc, #32]	; (d3d8 <littlefs_unmount+0x4c>)
    d3b8:	4a08      	ldr	r2, [pc, #32]	; (d3dc <littlefs_unmount+0x50>)
	LOG_INF("%s unmounted", log_strdup(mountp->mnt_point));
    d3ba:	68e8      	ldr	r0, [r5, #12]
    d3bc:	1aa4      	subs	r4, r4, r2
    d3be:	08e4      	lsrs	r4, r4, #3
    d3c0:	f7f5 fb68 	bl	2a94 <log_strdup>
    d3c4:	01a4      	lsls	r4, r4, #6
    d3c6:	f044 0403 	orr.w	r4, r4, #3
    d3ca:	4601      	mov	r1, r0
    d3cc:	4622      	mov	r2, r4
    d3ce:	4804      	ldr	r0, [pc, #16]	; (d3e0 <littlefs_unmount+0x54>)
    d3d0:	f007 ff48 	bl	15264 <log_1>
}
    d3d4:	4630      	mov	r0, r6
    d3d6:	bd70      	pop	{r4, r5, r6, pc}
    d3d8:	0001960c 	.word	0x0001960c
    d3dc:	0001956c 	.word	0x0001956c
    d3e0:	0001bbe5 	.word	0x0001bbe5

0000d3e4 <littlefs_mount>:
{
    d3e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d3e8:	4b7b      	ldr	r3, [pc, #492]	; (d5d8 <littlefs_mount+0x1f4>)
    d3ea:	4a7c      	ldr	r2, [pc, #496]	; (d5dc <littlefs_mount+0x1f8>)
    d3ec:	b08d      	sub	sp, #52	; 0x34
    d3ee:	1ad2      	subs	r2, r2, r3
    d3f0:	08d3      	lsrs	r3, r2, #3
    d3f2:	9304      	str	r3, [sp, #16]
	LOG_INF("LittleFS version %u.%u, disk version %u.%u",
    d3f4:	019d      	lsls	r5, r3, #6
    d3f6:	4b7a      	ldr	r3, [pc, #488]	; (d5e0 <littlefs_mount+0x1fc>)
{
    d3f8:	9002      	str	r0, [sp, #8]
	unsigned int area_id = (uintptr_t)mountp->storage_dev;
    d3fa:	e9d0 4604 	ldrd	r4, r6, [r0, #16]
	LOG_INF("LittleFS version %u.%u, disk version %u.%u",
    d3fe:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    d400:	af07      	add	r7, sp, #28
    d402:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    d406:	f045 0303 	orr.w	r3, r5, #3
    d40a:	4876      	ldr	r0, [pc, #472]	; (d5e4 <littlefs_mount+0x200>)
    d40c:	2204      	movs	r2, #4
    d40e:	4639      	mov	r1, r7
    d410:	f007 ff71 	bl	152f6 <log_n>
	if (fs->area) {
    d414:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
    d418:	2b00      	cmp	r3, #0
    d41a:	f040 80d9 	bne.w	d5d0 <littlefs_mount+0x1ec>
	k_mutex_init(&fs->mutex);
    d41e:	f104 03ec 	add.w	r3, r4, #236	; 0xec
    d422:	9303      	str	r3, [sp, #12]
    d424:	9803      	ldr	r0, [sp, #12]
    d426:	f00b fb52 	bl	18ace <z_impl_k_mutex_init>
	fs_lock(fs);
    d42a:	4620      	mov	r0, r4
    d42c:	f009 fc80 	bl	16d30 <fs_lock>
	ret = flash_area_open(area_id, &fs->area);
    d430:	f104 01e8 	add.w	r1, r4, #232	; 0xe8
    d434:	b2f0      	uxtb	r0, r6
    d436:	f7f7 f951 	bl	46dc <flash_area_open>
	if ((ret < 0) || (fs->area == NULL)) {
    d43a:	2800      	cmp	r0, #0
    d43c:	db02      	blt.n	d444 <littlefs_mount+0x60>
    d43e:	f8d4 00e8 	ldr.w	r0, [r4, #232]	; 0xe8
    d442:	b958      	cbnz	r0, d45c <littlefs_mount+0x78>
		LOG_ERR("can't open flash area %d", area_id);
    d444:	4868      	ldr	r0, [pc, #416]	; (d5e8 <littlefs_mount+0x204>)
    d446:	f045 0201 	orr.w	r2, r5, #1
    d44a:	4631      	mov	r1, r6
		LOG_ERR("can't get flash device: %s", fs->area->fa_dev_name);
    d44c:	f007 ff0a 	bl	15264 <log_1>
		ret = -ENODEV;
    d450:	f06f 0612 	mvn.w	r6, #18
		fs->area = NULL;
    d454:	2300      	movs	r3, #0
    d456:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
    d45a:	e093      	b.n	d584 <littlefs_mount+0x1a0>
	dev = flash_area_get_device(fs->area);
    d45c:	f008 fbf1 	bl	15c42 <flash_area_get_device>
	if (dev == NULL) {
    d460:	4683      	mov	fp, r0
    d462:	f8d4 00e8 	ldr.w	r0, [r4, #232]	; 0xe8
    d466:	f1bb 0f00 	cmp.w	fp, #0
    d46a:	d104      	bne.n	d476 <littlefs_mount+0x92>
		LOG_ERR("can't get flash device: %s", fs->area->fa_dev_name);
    d46c:	68c1      	ldr	r1, [r0, #12]
    d46e:	485f      	ldr	r0, [pc, #380]	; (d5ec <littlefs_mount+0x208>)
    d470:	f045 0201 	orr.w	r2, r5, #1
    d474:	e7ea      	b.n	d44c <littlefs_mount+0x68>
	lfs_size_t read_size = lcp->read_size;
    d476:	f8d4 a014 	ldr.w	sl, [r4, #20]
	lfs_size_t prog_size = lcp->prog_size;
    d47a:	f8d4 9018 	ldr.w	r9, [r4, #24]
	lfs_size_t block_size = lcp->block_size;
    d47e:	69e6      	ldr	r6, [r4, #28]
		read_size = CONFIG_FS_LITTLEFS_READ_SIZE;
    d480:	f1ba 0f00 	cmp.w	sl, #0
    d484:	bf08      	it	eq
    d486:	f04f 0a10 	moveq.w	sl, #16
		prog_size = CONFIG_FS_LITTLEFS_PROG_SIZE;
    d48a:	f1b9 0f00 	cmp.w	r9, #0
    d48e:	bf08      	it	eq
    d490:	f04f 0910 	moveq.w	r9, #16
	if (block_size == 0) {
    d494:	b95e      	cbnz	r6, d4ae <littlefs_mount+0xca>
	struct get_page_ctx ctx = {
    d496:	e9cd 0607 	strd	r0, r6, [sp, #28]
	struct device *dev = flash_area_get_device(fa);
    d49a:	f008 fbd2 	bl	15c42 <flash_area_get_device>
	flash_page_foreach(dev, get_page_cb, &ctx);
    d49e:	4954      	ldr	r1, [pc, #336]	; (d5f0 <littlefs_mount+0x20c>)
    d4a0:	463a      	mov	r2, r7
    d4a2:	f00a f822 	bl	174ea <flash_page_foreach>
	return ctx.max_size;
    d4a6:	9e08      	ldr	r6, [sp, #32]
	if (block_size == 0) {
    d4a8:	2e00      	cmp	r6, #0
    d4aa:	f000 808e 	beq.w	d5ca <littlefs_mount+0x1e6>
	s32_t block_cycles = lcp->block_cycles;
    d4ae:	f8d4 8024 	ldr.w	r8, [r4, #36]	; 0x24
	if (block_cycles == 0) {
    d4b2:	f1b8 0f00 	cmp.w	r8, #0
    d4b6:	d06c      	beq.n	d592 <littlefs_mount+0x1ae>
	if (block_cycles <= 0) {
    d4b8:	dc01      	bgt.n	d4be <littlefs_mount+0xda>
		block_cycles = -1;
    d4ba:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
	lfs_size_t cache_size = lcp->cache_size;
    d4be:	6aa7      	ldr	r7, [r4, #40]	; 0x28
	lfs_size_t lookahead_size = lcp->lookahead_size;
    d4c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	LOG_INF("FS at %s:0x%x is %u 0x%x-byte blocks with %u cycle",
    d4c2:	f8db 1000 	ldr.w	r1, [fp]
    d4c6:	484b      	ldr	r0, [pc, #300]	; (d5f4 <littlefs_mount+0x210>)
    d4c8:	6809      	ldr	r1, [r1, #0]
		cache_size = CONFIG_FS_LITTLEFS_CACHE_SIZE;
    d4ca:	2f00      	cmp	r7, #0
    d4cc:	bf08      	it	eq
    d4ce:	2740      	moveq	r7, #64	; 0x40
		lookahead_size = CONFIG_FS_LITTLEFS_LOOKAHEAD_SIZE;
    d4d0:	2b00      	cmp	r3, #0
    d4d2:	bf08      	it	eq
    d4d4:	2320      	moveq	r3, #32
    d4d6:	9301      	str	r3, [sp, #4]
	lfs_size_t block_count = fs->area->fa_size / block_size;
    d4d8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
    d4dc:	689a      	ldr	r2, [r3, #8]
	LOG_INF("FS at %s:0x%x is %u 0x%x-byte blocks with %u cycle",
    d4de:	685b      	ldr	r3, [r3, #4]
	lfs_size_t block_count = fs->area->fa_size / block_size;
    d4e0:	fbb2 f2f6 	udiv	r2, r2, r6
    d4e4:	9205      	str	r2, [sp, #20]
	LOG_INF("FS at %s:0x%x is %u 0x%x-byte blocks with %u cycle",
    d4e6:	9308      	str	r3, [sp, #32]
    d4e8:	9b05      	ldr	r3, [sp, #20]
    d4ea:	9107      	str	r1, [sp, #28]
    d4ec:	f045 0203 	orr.w	r2, r5, #3
    d4f0:	e9cd 3609 	strd	r3, r6, [sp, #36]	; 0x24
    d4f4:	4693      	mov	fp, r2
    d4f6:	4613      	mov	r3, r2
    d4f8:	a907      	add	r1, sp, #28
    d4fa:	2205      	movs	r2, #5
    d4fc:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    d500:	f007 fef9 	bl	152f6 <log_n>
	LOG_INF("sizes: rd %u ; pr %u ; ca %u ; la %u",
    d504:	9b01      	ldr	r3, [sp, #4]
    d506:	483c      	ldr	r0, [pc, #240]	; (d5f8 <littlefs_mount+0x214>)
    d508:	930a      	str	r3, [sp, #40]	; 0x28
    d50a:	2204      	movs	r2, #4
    d50c:	465b      	mov	r3, fp
    d50e:	a907      	add	r1, sp, #28
    d510:	9709      	str	r7, [sp, #36]	; 0x24
    d512:	e9cd a907 	strd	sl, r9, [sp, #28]
    d516:	f007 feee 	bl	152f6 <log_n>
	lcp->context = (void *)fs->area;
    d51a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
    d51e:	6023      	str	r3, [r4, #0]
	lcp->read = lfs_api_read;
    d520:	4b36      	ldr	r3, [pc, #216]	; (d5fc <littlefs_mount+0x218>)
    d522:	6063      	str	r3, [r4, #4]
	lcp->prog = lfs_api_prog;
    d524:	4b36      	ldr	r3, [pc, #216]	; (d600 <littlefs_mount+0x21c>)
    d526:	60a3      	str	r3, [r4, #8]
	lcp->erase = lfs_api_erase;
    d528:	4b36      	ldr	r3, [pc, #216]	; (d604 <littlefs_mount+0x220>)
    d52a:	60e3      	str	r3, [r4, #12]
	lcp->sync = lfs_api_sync;
    d52c:	4b36      	ldr	r3, [pc, #216]	; (d608 <littlefs_mount+0x224>)
	lcp->cache_size = cache_size;
    d52e:	62a7      	str	r7, [r4, #40]	; 0x28
	lcp->read_size = read_size;
    d530:	e9c4 3a04 	strd	r3, sl, [r4, #16]
	lcp->block_count = block_count;
    d534:	9b05      	ldr	r3, [sp, #20]
	ret = lfs_mount(&fs->lfs, &fs->cfg);
    d536:	f104 0770 	add.w	r7, r4, #112	; 0x70
	lcp->block_cycles = block_cycles;
    d53a:	e9c4 3808 	strd	r3, r8, [r4, #32]
	lcp->lookahead_size = lookahead_size;
    d53e:	9b01      	ldr	r3, [sp, #4]
    d540:	62e3      	str	r3, [r4, #44]	; 0x2c
	lcp->block_size = block_size;
    d542:	e9c4 9606 	strd	r9, r6, [r4, #24]
	ret = lfs_mount(&fs->lfs, &fs->cfg);
    d546:	4621      	mov	r1, r4
    d548:	4638      	mov	r0, r7
    d54a:	f004 fc5b 	bl	11e04 <lfs_mount>
	if (ret < 0) {
    d54e:	1e06      	subs	r6, r0, #0
    d550:	da2d      	bge.n	d5ae <littlefs_mount+0x1ca>
		LOG_WRN("can't mount (LFS %d); formatting", ret);
    d552:	4631      	mov	r1, r6
    d554:	482d      	ldr	r0, [pc, #180]	; (d60c <littlefs_mount+0x228>)
    d556:	f045 0202 	orr.w	r2, r5, #2
    d55a:	f007 fe83 	bl	15264 <log_1>
		ret = lfs_format(&fs->lfs, &fs->cfg);
    d55e:	4621      	mov	r1, r4
    d560:	4638      	mov	r0, r7
    d562:	f005 ffef 	bl	13544 <lfs_format>
		if (ret < 0) {
    d566:	1e06      	subs	r6, r0, #0
    d568:	da16      	bge.n	d598 <littlefs_mount+0x1b4>
			LOG_ERR("format failed (LFS %d)", ret);
    d56a:	4829      	ldr	r0, [pc, #164]	; (d610 <littlefs_mount+0x22c>)
    d56c:	f045 0201 	orr.w	r2, r5, #1
    d570:	4631      	mov	r1, r6
			LOG_ERR("remount after format failed (LFS %d)", ret);
    d572:	f007 fe77 	bl	15264 <log_1>
			ret = lfs_to_errno(ret);
    d576:	4630      	mov	r0, r6
    d578:	f7ff fee0 	bl	d33c <lfs_to_errno>
	if (ret < 0) {
    d57c:	2800      	cmp	r0, #0
			ret = lfs_to_errno(ret);
    d57e:	4606      	mov	r6, r0
	if (ret < 0) {
    d580:	f6ff af68 	blt.w	d454 <littlefs_mount+0x70>
	k_mutex_unlock(&fs->mutex);
    d584:	9803      	ldr	r0, [sp, #12]
    d586:	f009 fbd1 	bl	16d2c <k_mutex_unlock>
}
    d58a:	4630      	mov	r0, r6
    d58c:	b00d      	add	sp, #52	; 0x34
    d58e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		block_cycles = CONFIG_FS_LITTLEFS_BLOCK_CYCLES;
    d592:	f44f 7800 	mov.w	r8, #512	; 0x200
    d596:	e792      	b.n	d4be <littlefs_mount+0xda>
		ret = lfs_mount(&fs->lfs, &fs->cfg);
    d598:	4621      	mov	r1, r4
    d59a:	4638      	mov	r0, r7
    d59c:	f004 fc32 	bl	11e04 <lfs_mount>
		if (ret < 0) {
    d5a0:	1e06      	subs	r6, r0, #0
    d5a2:	da04      	bge.n	d5ae <littlefs_mount+0x1ca>
			LOG_ERR("remount after format failed (LFS %d)", ret);
    d5a4:	481b      	ldr	r0, [pc, #108]	; (d614 <littlefs_mount+0x230>)
    d5a6:	f045 0201 	orr.w	r2, r5, #1
    d5aa:	4631      	mov	r1, r6
    d5ac:	e7e1      	b.n	d572 <littlefs_mount+0x18e>
	LOG_INF("%s mounted", log_strdup(mountp->mnt_point));
    d5ae:	9b04      	ldr	r3, [sp, #16]
    d5b0:	019c      	lsls	r4, r3, #6
    d5b2:	9b02      	ldr	r3, [sp, #8]
    d5b4:	68d8      	ldr	r0, [r3, #12]
    d5b6:	f7f5 fa6d 	bl	2a94 <log_strdup>
    d5ba:	f044 0403 	orr.w	r4, r4, #3
    d5be:	4601      	mov	r1, r0
    d5c0:	4622      	mov	r2, r4
    d5c2:	4815      	ldr	r0, [pc, #84]	; (d618 <littlefs_mount+0x234>)
    d5c4:	f007 fe4e 	bl	15264 <log_1>
	if (ret < 0) {
    d5c8:	e7dc      	b.n	d584 <littlefs_mount+0x1a0>
		ret = -EINVAL;
    d5ca:	f06f 0615 	mvn.w	r6, #21
    d5ce:	e741      	b.n	d454 <littlefs_mount+0x70>
		return -EBUSY;
    d5d0:	f06f 060f 	mvn.w	r6, #15
    d5d4:	e7d9      	b.n	d58a <littlefs_mount+0x1a6>
    d5d6:	bf00      	nop
    d5d8:	0001956c 	.word	0x0001956c
    d5dc:	0001960c 	.word	0x0001960c
    d5e0:	000196f0 	.word	0x000196f0
    d5e4:	0001bbf2 	.word	0x0001bbf2
    d5e8:	0001bc1d 	.word	0x0001bc1d
    d5ec:	0001bc36 	.word	0x0001bc36
    d5f0:	00016d01 	.word	0x00016d01
    d5f4:	0001bc51 	.word	0x0001bc51
    d5f8:	0001bc84 	.word	0x0001bc84
    d5fc:	0000d781 	.word	0x0000d781
    d600:	0000d359 	.word	0x0000d359
    d604:	0000d755 	.word	0x0000d755
    d608:	00016cfd 	.word	0x00016cfd
    d60c:	0001bca9 	.word	0x0001bca9
    d610:	0001bcd8 	.word	0x0001bcd8
    d614:	0001bcca 	.word	0x0001bcca
    d618:	0001bcef 	.word	0x0001bcef

0000d61c <littlefs_closedir>:
	struct fs_littlefs *fs = dp->mp->fs_data;
    d61c:	6843      	ldr	r3, [r0, #4]
{
    d61e:	b570      	push	{r4, r5, r6, lr}
	struct fs_littlefs *fs = dp->mp->fs_data;
    d620:	691e      	ldr	r6, [r3, #16]
{
    d622:	4604      	mov	r4, r0
	fs_lock(fs);
    d624:	4630      	mov	r0, r6
    d626:	f009 fb83 	bl	16d30 <fs_lock>
	int ret = lfs_dir_close(&fs->lfs, dp->dirp);
    d62a:	6821      	ldr	r1, [r4, #0]
    d62c:	f106 0070 	add.w	r0, r6, #112	; 0x70
    d630:	f00a fe97 	bl	18362 <lfs_dir_close>
    d634:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    d636:	f106 00ec 	add.w	r0, r6, #236	; 0xec
    d63a:	f009 fb77 	bl	16d2c <k_mutex_unlock>
	k_mem_slab_free(&lfs_dir_pool, &dp->dirp);
    d63e:	4804      	ldr	r0, [pc, #16]	; (d650 <littlefs_closedir+0x34>)
    d640:	4621      	mov	r1, r4
    d642:	f006 fa05 	bl	13a50 <k_mem_slab_free>
	return lfs_to_errno(ret);
    d646:	4628      	mov	r0, r5
}
    d648:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
    d64c:	f7ff be76 	b.w	d33c <lfs_to_errno>
    d650:	2000c2d8 	.word	0x2000c2d8

0000d654 <littlefs_opendir>:
	struct fs_littlefs *fs = dp->mp->fs_data;
    d654:	6843      	ldr	r3, [r0, #4]
{
    d656:	b570      	push	{r4, r5, r6, lr}
	if (k_mem_slab_alloc(&lfs_dir_pool, &dp->dirp, K_NO_WAIT) != 0) {
    d658:	2200      	movs	r2, #0
{
    d65a:	4604      	mov	r4, r0
    d65c:	460d      	mov	r5, r1
	if (k_mem_slab_alloc(&lfs_dir_pool, &dp->dirp, K_NO_WAIT) != 0) {
    d65e:	4601      	mov	r1, r0
    d660:	4815      	ldr	r0, [pc, #84]	; (d6b8 <littlefs_opendir+0x64>)
	struct fs_littlefs *fs = dp->mp->fs_data;
    d662:	691e      	ldr	r6, [r3, #16]
	if (k_mem_slab_alloc(&lfs_dir_pool, &dp->dirp, K_NO_WAIT) != 0) {
    d664:	f006 f9c8 	bl	139f8 <k_mem_slab_alloc>
    d668:	4601      	mov	r1, r0
    d66a:	bb08      	cbnz	r0, d6b0 <littlefs_opendir+0x5c>
	memset(dp->dirp, 0, sizeof(struct lfs_dir));
    d66c:	2234      	movs	r2, #52	; 0x34
    d66e:	6820      	ldr	r0, [r4, #0]
    d670:	f008 fd0e 	bl	16090 <memset>
	path = fs_impl_strip_prefix(path, dp->mp);
    d674:	6861      	ldr	r1, [r4, #4]
    d676:	4628      	mov	r0, r5
    d678:	f7ff fe3c 	bl	d2f4 <fs_impl_strip_prefix>
    d67c:	4605      	mov	r5, r0
	fs_lock(fs);
    d67e:	4630      	mov	r0, r6
    d680:	f009 fb56 	bl	16d30 <fs_lock>
	int ret = lfs_dir_open(&fs->lfs, dp->dirp, path);
    d684:	462a      	mov	r2, r5
    d686:	6821      	ldr	r1, [r4, #0]
    d688:	f106 0070 	add.w	r0, r6, #112	; 0x70
    d68c:	f004 fb2e 	bl	11cec <lfs_dir_open>
    d690:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    d692:	f106 00ec 	add.w	r0, r6, #236	; 0xec
    d696:	f009 fb49 	bl	16d2c <k_mutex_unlock>
	if (ret < 0) {
    d69a:	2d00      	cmp	r5, #0
    d69c:	da03      	bge.n	d6a6 <littlefs_opendir+0x52>
		k_mem_slab_free(&lfs_dir_pool, &dp->dirp);
    d69e:	4806      	ldr	r0, [pc, #24]	; (d6b8 <littlefs_opendir+0x64>)
    d6a0:	4621      	mov	r1, r4
    d6a2:	f006 f9d5 	bl	13a50 <k_mem_slab_free>
	return lfs_to_errno(ret);
    d6a6:	4628      	mov	r0, r5
}
    d6a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
    d6ac:	f7ff be46 	b.w	d33c <lfs_to_errno>
}
    d6b0:	f06f 000b 	mvn.w	r0, #11
    d6b4:	bd70      	pop	{r4, r5, r6, pc}
    d6b6:	bf00      	nop
    d6b8:	2000c2d8 	.word	0x2000c2d8

0000d6bc <littlefs_open>:
	struct fs_littlefs *fs = fp->mp->fs_data;
    d6bc:	6843      	ldr	r3, [r0, #4]
{
    d6be:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    d6c2:	4605      	mov	r5, r0
    d6c4:	4688      	mov	r8, r1
	ret = k_mem_slab_alloc(&file_data_pool, &fp->filep, K_NO_WAIT);
    d6c6:	2200      	movs	r2, #0
    d6c8:	4601      	mov	r1, r0
    d6ca:	4820      	ldr	r0, [pc, #128]	; (d74c <littlefs_open+0x90>)
	struct fs_littlefs *fs = fp->mp->fs_data;
    d6cc:	691f      	ldr	r7, [r3, #16]
	ret = k_mem_slab_alloc(&file_data_pool, &fp->filep, K_NO_WAIT);
    d6ce:	f006 f993 	bl	139f8 <k_mem_slab_alloc>
	if (ret != 0) {
    d6d2:	4604      	mov	r4, r0
    d6d4:	bbb0      	cbnz	r0, d744 <littlefs_open+0x88>
	struct lfs_file_data *fdp = fp->filep;
    d6d6:	682e      	ldr	r6, [r5, #0]
	memset(fdp, 0, sizeof(*fdp));
    d6d8:	4601      	mov	r1, r0
    d6da:	2268      	movs	r2, #104	; 0x68
    d6dc:	4630      	mov	r0, r6
    d6de:	f008 fcd7 	bl	16090 <memset>
	ret = k_mem_pool_alloc(&file_cache_pool, &fdp->cache_block,
    d6e2:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
    d6e6:	481a      	ldr	r0, [pc, #104]	; (d750 <littlefs_open+0x94>)
    d6e8:	6a92      	ldr	r2, [r2, #40]	; 0x28
    d6ea:	4623      	mov	r3, r4
    d6ec:	f106 0160 	add.w	r1, r6, #96	; 0x60
    d6f0:	f00b f99d 	bl	18a2e <k_mem_pool_alloc>
	if (ret != 0) {
    d6f4:	4604      	mov	r4, r0
    d6f6:	b9d0      	cbnz	r0, d72e <littlefs_open+0x72>
	fdp->config.buffer = fdp->cache_block.data;
    d6f8:	46b1      	mov	r9, r6
    d6fa:	6e33      	ldr	r3, [r6, #96]	; 0x60
    d6fc:	f849 3f54 	str.w	r3, [r9, #84]!
	path = fs_impl_strip_prefix(path, fp->mp);
    d700:	6869      	ldr	r1, [r5, #4]
    d702:	4640      	mov	r0, r8
    d704:	f7ff fdf6 	bl	d2f4 <fs_impl_strip_prefix>
    d708:	4604      	mov	r4, r0
	fs_lock(fs);
    d70a:	4638      	mov	r0, r7
    d70c:	f009 fb10 	bl	16d30 <fs_lock>
	ret = lfs_file_opencfg(&fs->lfs, &fdp->file,
    d710:	4622      	mov	r2, r4
    d712:	f8cd 9000 	str.w	r9, [sp]
    d716:	f240 1303 	movw	r3, #259	; 0x103
    d71a:	4631      	mov	r1, r6
    d71c:	f107 0070 	add.w	r0, r7, #112	; 0x70
    d720:	f005 fc5e 	bl	12fe0 <lfs_file_opencfg>
    d724:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
    d726:	f107 00ec 	add.w	r0, r7, #236	; 0xec
    d72a:	f009 faff 	bl	16d2c <k_mutex_unlock>
	if (ret < 0) {
    d72e:	2c00      	cmp	r4, #0
    d730:	da02      	bge.n	d738 <littlefs_open+0x7c>
		release_file_data(fp);
    d732:	4628      	mov	r0, r5
    d734:	f7ff fdf0 	bl	d318 <release_file_data>
	return lfs_to_errno(ret);
    d738:	4620      	mov	r0, r4
}
    d73a:	b003      	add	sp, #12
    d73c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return lfs_to_errno(ret);
    d740:	f7ff bdfc 	b.w	d33c <lfs_to_errno>
}
    d744:	b003      	add	sp, #12
    d746:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    d74a:	bf00      	nop
    d74c:	2000c2bc 	.word	0x2000c2bc
    d750:	2000bfe0 	.word	0x2000bfe0

0000d754 <lfs_api_erase>:
	int rc = flash_area_erase(fa, offset, c->block_size);
    d754:	69c2      	ldr	r2, [r0, #28]
    d756:	6800      	ldr	r0, [r0, #0]
{
    d758:	b508      	push	{r3, lr}
	int rc = flash_area_erase(fa, offset, c->block_size);
    d75a:	4351      	muls	r1, r2
    d75c:	f008 fa4b 	bl	15bf6 <flash_area_erase>
	if (error >= 0) {
    d760:	2800      	cmp	r0, #0
    d762:	da05      	bge.n	d770 <lfs_api_erase+0x1c>
	switch (error) {
    d764:	301c      	adds	r0, #28
    d766:	281a      	cmp	r0, #26
    d768:	d804      	bhi.n	d774 <lfs_api_erase+0x20>
    d76a:	4b04      	ldr	r3, [pc, #16]	; (d77c <lfs_api_erase+0x28>)
    d76c:	5618      	ldrsb	r0, [r3, r0]
}
    d76e:	bd08      	pop	{r3, pc}
		return LFS_ERR_OK;
    d770:	2000      	movs	r0, #0
    d772:	e7fc      	b.n	d76e <lfs_api_erase+0x1a>
	switch (error) {
    d774:	f06f 0004 	mvn.w	r0, #4
	return errno_to_lfs(rc);
    d778:	e7f9      	b.n	d76e <lfs_api_erase+0x1a>
    d77a:	bf00      	nop
    d77c:	0001bd56 	.word	0x0001bd56

0000d780 <lfs_api_read>:
{
    d780:	b538      	push	{r3, r4, r5, lr}
	size_t offset = block * c->block_size + off;
    d782:	69c5      	ldr	r5, [r0, #28]
	int rc = flash_area_read(fa, offset, buffer, size);
    d784:	6800      	ldr	r0, [r0, #0]
{
    d786:	4614      	mov	r4, r2
	int rc = flash_area_read(fa, offset, buffer, size);
    d788:	fb05 4101 	mla	r1, r5, r1, r4
{
    d78c:	461a      	mov	r2, r3
	int rc = flash_area_read(fa, offset, buffer, size);
    d78e:	9b04      	ldr	r3, [sp, #16]
    d790:	f008 f9eb 	bl	15b6a <flash_area_read>
	if (error >= 0) {
    d794:	2800      	cmp	r0, #0
    d796:	da05      	bge.n	d7a4 <lfs_api_read+0x24>
	switch (error) {
    d798:	301c      	adds	r0, #28
    d79a:	281a      	cmp	r0, #26
    d79c:	d804      	bhi.n	d7a8 <lfs_api_read+0x28>
    d79e:	4b04      	ldr	r3, [pc, #16]	; (d7b0 <lfs_api_read+0x30>)
    d7a0:	5618      	ldrsb	r0, [r3, r0]
}
    d7a2:	bd38      	pop	{r3, r4, r5, pc}
		return LFS_ERR_OK;
    d7a4:	2000      	movs	r0, #0
    d7a6:	e7fc      	b.n	d7a2 <lfs_api_read+0x22>
	switch (error) {
    d7a8:	f06f 0004 	mvn.w	r0, #4
	return errno_to_lfs(rc);
    d7ac:	e7f9      	b.n	d7a2 <lfs_api_read+0x22>
    d7ae:	bf00      	nop
    d7b0:	0001bd56 	.word	0x0001bd56

0000d7b4 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
    d7b4:	4b01      	ldr	r3, [pc, #4]	; (d7bc <net_buf_pool_get+0x8>)
    d7b6:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    d7ba:	4770      	bx	lr
    d7bc:	2000c3d0 	.word	0x2000c3d0

0000d7c0 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    d7c0:	7982      	ldrb	r2, [r0, #6]

	return buf - pool->__bufs;
    d7c2:	4b04      	ldr	r3, [pc, #16]	; (d7d4 <net_buf_id+0x14>)
    d7c4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    d7c8:	69db      	ldr	r3, [r3, #28]
    d7ca:	1ac0      	subs	r0, r0, r3
}
    d7cc:	4b02      	ldr	r3, [pc, #8]	; (d7d8 <net_buf_id+0x18>)
	return buf - pool->__bufs;
    d7ce:	10c0      	asrs	r0, r0, #3
}
    d7d0:	4358      	muls	r0, r3
    d7d2:	4770      	bx	lr
    d7d4:	2000c3d0 	.word	0x2000c3d0
    d7d8:	aaaaaaab 	.word	0xaaaaaaab

0000d7dc <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
    d7dc:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    d7de:	4b09      	ldr	r3, [pc, #36]	; (d804 <fixed_data_alloc+0x28>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    d7e0:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    d7e2:	eb03 1342 	add.w	r3, r3, r2, lsl #5

	*size = MIN(fixed->data_size, *size);
    d7e6:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    d7e8:	699b      	ldr	r3, [r3, #24]
    d7ea:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
    d7ec:	6823      	ldr	r3, [r4, #0]
    d7ee:	429a      	cmp	r2, r3
    d7f0:	bf94      	ite	ls
    d7f2:	600a      	strls	r2, [r1, #0]
    d7f4:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    d7f6:	f7ff ffe3 	bl	d7c0 <net_buf_id>
    d7fa:	e9d4 2300 	ldrd	r2, r3, [r4]
}
    d7fe:	fb02 3000 	mla	r0, r2, r0, r3
    d802:	bd10      	pop	{r4, pc}
    d804:	2000c3d0 	.word	0x2000c3d0

0000d808 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
    d808:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d80c:	4605      	mov	r5, r0
	u64_t end = z_timeout_end_calc(timeout);
    d80e:	4610      	mov	r0, r2
{
    d810:	9101      	str	r1, [sp, #4]
    d812:	4616      	mov	r6, r2
	u64_t end = z_timeout_end_calc(timeout);
    d814:	f00b fbdc 	bl	18fd0 <z_timeout_end_calc>
    d818:	4607      	mov	r7, r0
    d81a:	468a      	mov	sl, r1
	__asm__ volatile(
    d81c:	f04f 0320 	mov.w	r3, #32
    d820:	f3ef 8b11 	mrs	fp, BASEPRI
    d824:	f383 8811 	msr	BASEPRI, r3
    d828:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    d82c:	8a6b      	ldrh	r3, [r5, #18]
    d82e:	2b00      	cmp	r3, #0
    d830:	d052      	beq.n	d8d8 <net_buf_alloc_len+0xd0>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    d832:	8a2a      	ldrh	r2, [r5, #16]
    d834:	429a      	cmp	r2, r3
    d836:	d93d      	bls.n	d8b4 <net_buf_alloc_len+0xac>
	return z_impl_k_queue_get(queue, timeout);
    d838:	2100      	movs	r1, #0
    d83a:	4628      	mov	r0, r5
    d83c:	f00b f9e2 	bl	18c04 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    d840:	4604      	mov	r4, r0
    d842:	2800      	cmp	r0, #0
    d844:	d036      	beq.n	d8b4 <net_buf_alloc_len+0xac>
	__asm__ volatile(
    d846:	f38b 8811 	msr	BASEPRI, fp
    d84a:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    d84e:	9b01      	ldr	r3, [sp, #4]
    d850:	2b00      	cmp	r3, #0
    d852:	d050      	beq.n	d8f6 <net_buf_alloc_len+0xee>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    d854:	1c73      	adds	r3, r6, #1
    d856:	2b01      	cmp	r3, #1
    d858:	d916      	bls.n	d888 <net_buf_alloc_len+0x80>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			s64_t remaining = end - z_tick_get();
    d85a:	f006 ff4d 	bl	146f8 <z_tick_get>
    d85e:	ebb7 0800 	subs.w	r8, r7, r0
    d862:	eb6a 0901 	sbc.w	r9, sl, r1

			if (remaining <= 0) {
    d866:	f1b8 0f01 	cmp.w	r8, #1
    d86a:	f179 0300 	sbcs.w	r3, r9, #0
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
    d86e:	bfa1      	itttt	ge
    d870:	f647 70ff 	movwge	r0, #32767	; 0x7fff
    d874:	2100      	movge	r1, #0
    d876:	f44f 737a 	movge.w	r3, #1000	; 0x3e8
    d87a:	fbe3 0108 	umlalge	r0, r1, r3, r8
    d87e:	bfa6      	itte	ge
    d880:	0bc6      	lsrge	r6, r0, #15
    d882:	ea46 4641 	orrge.w	r6, r6, r1, lsl #17
				timeout = K_NO_WAIT;
    d886:	2600      	movlt	r6, #0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    d888:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
    d88a:	4f20      	ldr	r7, [pc, #128]	; (d90c <net_buf_alloc_len+0x104>)
    d88c:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    d890:	4632      	mov	r2, r6
    d892:	699b      	ldr	r3, [r3, #24]
    d894:	681b      	ldr	r3, [r3, #0]
    d896:	a901      	add	r1, sp, #4
    d898:	681b      	ldr	r3, [r3, #0]
    d89a:	4620      	mov	r0, r4
    d89c:	4798      	blx	r3
    d89e:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    d8a0:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
    d8a2:	bb48      	cbnz	r0, d8f8 <net_buf_alloc_len+0xf0>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
    d8a4:	79a0      	ldrb	r0, [r4, #6]
    d8a6:	4621      	mov	r1, r4
    d8a8:	eb07 1040 	add.w	r0, r7, r0, lsl #5
    d8ac:	f00b f980 	bl	18bb0 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    d8b0:	462c      	mov	r4, r5
}
    d8b2:	e01c      	b.n	d8ee <net_buf_alloc_len+0xe6>
		uninit_count = pool->uninit_count--;
    d8b4:	8a68      	ldrh	r0, [r5, #18]
    d8b6:	1e43      	subs	r3, r0, #1
    d8b8:	826b      	strh	r3, [r5, #18]
    d8ba:	f38b 8811 	msr	BASEPRI, fp
    d8be:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    d8c2:	8a2c      	ldrh	r4, [r5, #16]
    d8c4:	1a24      	subs	r4, r4, r0
    d8c6:	69e8      	ldr	r0, [r5, #28]
    d8c8:	2318      	movs	r3, #24
    d8ca:	fb03 0404 	mla	r4, r3, r4, r0
	return pool - _net_buf_pool_list;
    d8ce:	480f      	ldr	r0, [pc, #60]	; (d90c <net_buf_alloc_len+0x104>)
    d8d0:	1a2d      	subs	r5, r5, r0
    d8d2:	116d      	asrs	r5, r5, #5
	buf->pool_id = pool_id(pool);
    d8d4:	71a5      	strb	r5, [r4, #6]
		goto success;
    d8d6:	e7ba      	b.n	d84e <net_buf_alloc_len+0x46>
    d8d8:	f38b 8811 	msr	BASEPRI, fp
    d8dc:	f3bf 8f6f 	isb	sy
    d8e0:	4631      	mov	r1, r6
    d8e2:	4628      	mov	r0, r5
    d8e4:	f00b f98e 	bl	18c04 <z_impl_k_queue_get>
	if (!buf) {
    d8e8:	4604      	mov	r4, r0
    d8ea:	2800      	cmp	r0, #0
    d8ec:	d1af      	bne.n	d84e <net_buf_alloc_len+0x46>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
    d8ee:	4620      	mov	r0, r4
    d8f0:	b003      	add	sp, #12
    d8f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf->__buf = NULL;
    d8f6:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
    d8f8:	2300      	movs	r3, #0
	buf->ref   = 1U;
    d8fa:	2201      	movs	r2, #1
	buf->frags = NULL;
    d8fc:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
    d8fe:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
    d900:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
    d902:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
    d904:	6923      	ldr	r3, [r4, #16]
    d906:	81e2      	strh	r2, [r4, #14]
    d908:	60a3      	str	r3, [r4, #8]
	return buf;
    d90a:	e7f0      	b.n	d8ee <net_buf_alloc_len+0xe6>
    d90c:	2000c3d0 	.word	0x2000c3d0

0000d910 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    d910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d912:	4d15      	ldr	r5, [pc, #84]	; (d968 <net_buf_unref+0x58>)
    d914:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    d916:	2600      	movs	r6, #0
	while (buf) {
    d918:	b904      	cbnz	r4, d91c <net_buf_unref+0xc>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    d91a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (--buf->ref > 0) {
    d91c:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
    d91e:	6827      	ldr	r7, [r4, #0]
		if (--buf->ref > 0) {
    d920:	3b01      	subs	r3, #1
    d922:	b2db      	uxtb	r3, r3
    d924:	7123      	strb	r3, [r4, #4]
    d926:	2b00      	cmp	r3, #0
    d928:	d1f7      	bne.n	d91a <net_buf_unref+0xa>
		if (buf->__buf) {
    d92a:	6921      	ldr	r1, [r4, #16]
    d92c:	b159      	cbz	r1, d946 <net_buf_unref+0x36>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    d92e:	7963      	ldrb	r3, [r4, #5]
    d930:	079b      	lsls	r3, r3, #30
    d932:	d407      	bmi.n	d944 <net_buf_unref+0x34>
	pool->alloc->cb->unref(buf, data);
    d934:	79a3      	ldrb	r3, [r4, #6]
    d936:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    d93a:	4620      	mov	r0, r4
    d93c:	699b      	ldr	r3, [r3, #24]
    d93e:	681b      	ldr	r3, [r3, #0]
    d940:	689b      	ldr	r3, [r3, #8]
    d942:	4798      	blx	r3
			buf->__buf = NULL;
    d944:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
    d946:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
    d948:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
    d94a:	eb05 1340 	add.w	r3, r5, r0, lsl #5
		buf->frags = NULL;
    d94e:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
    d950:	695b      	ldr	r3, [r3, #20]
    d952:	b11b      	cbz	r3, d95c <net_buf_unref+0x4c>
			pool->destroy(buf);
    d954:	4620      	mov	r0, r4
    d956:	4798      	blx	r3
{
    d958:	463c      	mov	r4, r7
    d95a:	e7dd      	b.n	d918 <net_buf_unref+0x8>
	k_lifo_put(&pool->free, buf);
    d95c:	4621      	mov	r1, r4
    d95e:	eb05 1040 	add.w	r0, r5, r0, lsl #5
    d962:	f00b f925 	bl	18bb0 <k_queue_prepend>
}
    d966:	e7f7      	b.n	d958 <net_buf_unref+0x48>
    d968:	2000c3d0 	.word	0x2000c3d0

0000d96c <rand_get>:
	return random_num;
}
#endif /* CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR */

static int rand_get(u8_t *dst, size_t outlen, bool csrand)
{
    d96c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct device *dev = entropy_driver;
    d96e:	4f14      	ldr	r7, [pc, #80]	; (d9c0 <rand_get+0x54>)
{
    d970:	4606      	mov	r6, r0
	struct device *dev = entropy_driver;
    d972:	6838      	ldr	r0, [r7, #0]
{
    d974:	460d      	mov	r5, r1
    d976:	4614      	mov	r4, r2
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
    d978:	b918      	cbnz	r0, d982 <rand_get+0x16>
    d97a:	4812      	ldr	r0, [pc, #72]	; (d9c4 <rand_get+0x58>)
    d97c:	f005 fe76 	bl	1366c <z_impl_device_get_binding>
		dev = device_get_binding(DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		__ASSERT((dev != NULL),
			"Device driver for %s (DT_CHOSEN_ZEPHYR_ENTROPY_LABEL) not found. "
			"Check your build configuration!",
			DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		entropy_driver = dev;
    d980:	6038      	str	r0, [r7, #0]
	return api->get_entropy(dev, buffer, length);
    d982:	6843      	ldr	r3, [r0, #4]
    d984:	b2aa      	uxth	r2, r5
    d986:	681b      	ldr	r3, [r3, #0]
    d988:	4631      	mov	r1, r6
    d98a:	4798      	blx	r3
	}

	ret = entropy_get_entropy(dev, dst, outlen);

	if (unlikely(ret < 0)) {
    d98c:	2800      	cmp	r0, #0
    d98e:	da03      	bge.n	d998 <rand_get+0x2c>
		/* Don't try to fill the buffer in case of
		 * cryptographically secure random numbers, just
		 * propagate the driver error.
		 */
		if (csrand) {
    d990:	b91c      	cbnz	r4, d99a <rand_get+0x2e>
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		u32_t len = 0;
		u32_t blocksize = 4;
    d992:	2704      	movs	r7, #4

		while (len < outlen) {
    d994:	42a5      	cmp	r5, r4
    d996:	d802      	bhi.n	d99e <rand_get+0x32>

			len += blocksize;
		}
	}

	return 0;
    d998:	2000      	movs	r0, #0
}
    d99a:	b003      	add	sp, #12
    d99c:	bdf0      	pop	{r4, r5, r6, r7, pc}
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
    d99e:	f7f7 ff79 	bl	5894 <z_timer_cycle_get_32>
			if ((outlen-len) < sizeof(random_num)) {
    d9a2:	1b2b      	subs	r3, r5, r4
    d9a4:	2b03      	cmp	r3, #3
			random_num = k_cycle_get_32();
    d9a6:	9001      	str	r0, [sp, #4]
			if ((outlen-len) < sizeof(random_num)) {
    d9a8:	d807      	bhi.n	d9ba <rand_get+0x4e>
				(void)memcpy(&(dst[random_num]),
    d9aa:	4622      	mov	r2, r4
    d9ac:	a901      	add	r1, sp, #4
    d9ae:	4430      	add	r0, r6
    d9b0:	f008 fb43 	bl	1603a <memcpy>
    d9b4:	4627      	mov	r7, r4
			len += blocksize;
    d9b6:	443c      	add	r4, r7
    d9b8:	e7ec      	b.n	d994 <rand_get+0x28>
				*((u32_t *)&dst[len]) = random_num;
    d9ba:	5130      	str	r0, [r6, r4]
    d9bc:	e7fb      	b.n	d9b6 <rand_get+0x4a>
    d9be:	bf00      	nop
    d9c0:	20003b00 	.word	0x20003b00
    d9c4:	0001b210 	.word	0x0001b210

0000d9c8 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(struct device *port)
{
    d9c8:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    d9ca:	4b09      	ldr	r3, [pc, #36]	; (d9f0 <gpio_nrfx_init+0x28>)
    d9cc:	781a      	ldrb	r2, [r3, #0]
    d9ce:	b96a      	cbnz	r2, d9ec <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    d9d0:	2101      	movs	r1, #1
    d9d2:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    d9d4:	2006      	movs	r0, #6
    d9d6:	2105      	movs	r1, #5
    d9d8:	f7f8 f8b0 	bl	5b3c <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
    d9dc:	2006      	movs	r0, #6
    d9de:	f7f8 f87b 	bl	5ad8 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    d9e2:	4b04      	ldr	r3, [pc, #16]	; (d9f4 <gpio_nrfx_init+0x2c>)
    d9e4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    d9e8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    d9ec:	2000      	movs	r0, #0
    d9ee:	bd08      	pop	{r3, pc}
    d9f0:	200087b8 	.word	0x200087b8
    d9f4:	40006000 	.word	0x40006000

0000d9f8 <gpio_nrfx_config>:
	return port->config->config_info;
    d9f8:	6803      	ldr	r3, [r0, #0]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    d9fa:	482e      	ldr	r0, [pc, #184]	; (dab4 <gpio_nrfx_config+0xbc>)
{
    d9fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	return port->config->config_info;
    d9fe:	689e      	ldr	r6, [r3, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    da00:	4b2d      	ldr	r3, [pc, #180]	; (dab8 <gpio_nrfx_config+0xc0>)
    da02:	4013      	ands	r3, r2
    da04:	4283      	cmp	r3, r0
    da06:	d045      	beq.n	da94 <gpio_nrfx_config+0x9c>
    da08:	d80d      	bhi.n	da26 <gpio_nrfx_config+0x2e>
    da0a:	2b06      	cmp	r3, #6
    da0c:	d015      	beq.n	da3a <gpio_nrfx_config+0x42>
    da0e:	d805      	bhi.n	da1c <gpio_nrfx_config+0x24>
    da10:	b19b      	cbz	r3, da3a <gpio_nrfx_config+0x42>
    da12:	2b02      	cmp	r3, #2
    da14:	d040      	beq.n	da98 <gpio_nrfx_config+0xa0>
    da16:	f06f 0015 	mvn.w	r0, #21
    da1a:	e03a      	b.n	da92 <gpio_nrfx_config+0x9a>
    da1c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    da20:	d1f9      	bne.n	da16 <gpio_nrfx_config+0x1e>
		drive = NRF_GPIO_PIN_H0S1;
    da22:	2301      	movs	r3, #1
    da24:	e009      	b.n	da3a <gpio_nrfx_config+0x42>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    da26:	4825      	ldr	r0, [pc, #148]	; (dabc <gpio_nrfx_config+0xc4>)
    da28:	4283      	cmp	r3, r0
    da2a:	d037      	beq.n	da9c <gpio_nrfx_config+0xa4>
    da2c:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    da30:	d036      	beq.n	daa0 <gpio_nrfx_config+0xa8>
    da32:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    da36:	d1ee      	bne.n	da16 <gpio_nrfx_config+0x1e>
		drive = NRF_GPIO_PIN_S0H1;
    da38:	2302      	movs	r3, #2
	if ((flags & GPIO_PULL_UP) != 0) {
    da3a:	06d0      	lsls	r0, r2, #27
		pull = NRF_GPIO_PIN_NOPULL;
    da3c:	bf54      	ite	pl
    da3e:	f3c2 1540 	ubfxpl	r5, r2, #5, #1
		pull = NRF_GPIO_PIN_PULLUP;
    da42:	2503      	movmi	r5, #3
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    da44:	f482 7480 	eor.w	r4, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
    da48:	0597      	lsls	r7, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
    da4a:	f3c2 2040 	ubfx	r0, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    da4e:	f3c4 2400 	ubfx	r4, r4, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
    da52:	d507      	bpl.n	da64 <gpio_nrfx_config+0x6c>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    da54:	f412 6f00 	tst.w	r2, #2048	; 0x800
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    da58:	6877      	ldr	r7, [r6, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    da5a:	d023      	beq.n	daa4 <gpio_nrfx_config+0xac>
			nrf_gpio_port_out_set(reg, BIT(pin));
    da5c:	2201      	movs	r2, #1
    da5e:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    da60:	f8c7 2508 	str.w	r2, [r7, #1288]	; 0x508
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
    da64:	7a32      	ldrb	r2, [r6, #8]
    da66:	f001 011f 	and.w	r1, r1, #31
    da6a:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
    if (*p_pin < P0_PIN_NUM)
    da6e:	291f      	cmp	r1, #31
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    da70:	ea40 0244 	orr.w	r2, r0, r4, lsl #1
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    da74:	bfc6      	itte	gt
    da76:	f001 011f 	andgt.w	r1, r1, #31
        return NRF_P1;
    da7a:	4e11      	ldrgt	r6, [pc, #68]	; (dac0 <gpio_nrfx_config+0xc8>)
        return NRF_P0;
    da7c:	f04f 46a0 	movle.w	r6, #1342177280	; 0x50000000
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    da80:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    da84:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    da88:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    da8c:	f846 3021 	str.w	r3, [r6, r1, lsl #2]
	return 0;
    da90:	2000      	movs	r0, #0
}
    da92:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
    da94:	2307      	movs	r3, #7
    da96:	e7d0      	b.n	da3a <gpio_nrfx_config+0x42>
		drive = NRF_GPIO_PIN_D0S1;
    da98:	2304      	movs	r3, #4
    da9a:	e7ce      	b.n	da3a <gpio_nrfx_config+0x42>
		drive = NRF_GPIO_PIN_D0H1;
    da9c:	2305      	movs	r3, #5
    da9e:	e7cc      	b.n	da3a <gpio_nrfx_config+0x42>
		drive = NRF_GPIO_PIN_H0H1;
    daa0:	2303      	movs	r3, #3
    daa2:	e7ca      	b.n	da3a <gpio_nrfx_config+0x42>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    daa4:	0552      	lsls	r2, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
    daa6:	bf42      	ittt	mi
    daa8:	2201      	movmi	r2, #1
    daaa:	408a      	lslmi	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    daac:	f8c7 250c 	strmi.w	r2, [r7, #1292]	; 0x50c
}
    dab0:	e7d8      	b.n	da64 <gpio_nrfx_config+0x6c>
    dab2:	bf00      	nop
    dab4:	00100006 	.word	0x00100006
    dab8:	00f00006 	.word	0x00f00006
    dabc:	00400002 	.word	0x00400002
    dac0:	50000300 	.word	0x50000300

0000dac4 <nrf_gpio_cfg_sense_set>:
    if (*p_pin < P0_PIN_NUM)
    dac4:	281f      	cmp	r0, #31
        return NRF_P1;
    dac6:	bf8a      	itet	hi
    dac8:	4b07      	ldrhi	r3, [pc, #28]	; (dae8 <nrf_gpio_cfg_sense_set+0x24>)
        return NRF_P0;
    daca:	f04f 43a0 	movls.w	r3, #1342177280	; 0x50000000
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    dace:	f000 001f 	andhi.w	r0, r0, #31
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    dad2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    dad6:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
    dada:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    dade:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    dae2:	f8c0 1700 	str.w	r1, [r0, #1792]	; 0x700
}
    dae6:	4770      	bx	lr
    dae8:	50000300 	.word	0x50000300

0000daec <gpiote_pin_int_cfg>:
{
    daec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return port->config->config_info;
    daee:	6803      	ldr	r3, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
    daf0:	6886      	ldr	r6, [r0, #8]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    daf2:	689b      	ldr	r3, [r3, #8]
    daf4:	f001 041f 	and.w	r4, r1, #31
{
    daf8:	460d      	mov	r5, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    dafa:	494a      	ldr	r1, [pc, #296]	; (dc24 <gpiote_pin_int_cfg+0x138>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    dafc:	7a18      	ldrb	r0, [r3, #8]
    dafe:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
    db02:	ea44 1440 	orr.w	r4, r4, r0, lsl #5
    db06:	b2d2      	uxtb	r2, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    db08:	2300      	movs	r3, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    db0a:	f503 70a2 	add.w	r0, r3, #324	; 0x144
    db0e:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    db12:	f3c0 2005 	ubfx	r0, r0, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    db16:	4284      	cmp	r4, r0
    db18:	d16d      	bne.n	dbf6 <gpiote_pin_int_cfg+0x10a>
		    && (intenset & BIT(i))) {
    db1a:	fa22 f003 	lsr.w	r0, r2, r3
    db1e:	07c0      	lsls	r0, r0, #31
    db20:	d569      	bpl.n	dbf6 <gpiote_pin_int_cfg+0x10a>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    db22:	009a      	lsls	r2, r3, #2
    db24:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    db28:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    db2c:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
    db30:	f020 0001 	bic.w	r0, r0, #1
    db34:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    db38:	2201      	movs	r2, #1
    db3a:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
    db3e:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
    db42:	4620      	mov	r0, r4
    db44:	2100      	movs	r1, #0
    db46:	f7ff ffbd 	bl	dac4 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    db4a:	68f3      	ldr	r3, [r6, #12]
    db4c:	40eb      	lsrs	r3, r5
    db4e:	f013 0001 	ands.w	r0, r3, #1
    db52:	d04e      	beq.n	dbf2 <gpiote_pin_int_cfg+0x106>
    db54:	6933      	ldr	r3, [r6, #16]
    db56:	40eb      	lsrs	r3, r5
    db58:	f013 0001 	ands.w	r0, r3, #1
    db5c:	d049      	beq.n	dbf2 <gpiote_pin_int_cfg+0x106>
		if (data->trig_edge & BIT(pin)) {
    db5e:	69b3      	ldr	r3, [r6, #24]
    db60:	40eb      	lsrs	r3, r5
    db62:	f013 0201 	ands.w	r2, r3, #1
    db66:	d050      	beq.n	dc0a <gpiote_pin_int_cfg+0x11e>
			if (data->double_edge & BIT(pin)) {
    db68:	69f3      	ldr	r3, [r6, #28]
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    db6a:	4f2e      	ldr	r7, [pc, #184]	; (dc24 <gpiote_pin_int_cfg+0x138>)
    db6c:	40eb      	lsrs	r3, r5
    db6e:	07db      	lsls	r3, r3, #31
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    db70:	bf5f      	itttt	pl
    db72:	6971      	ldrpl	r1, [r6, #20]
    db74:	fa21 f505 	lsrpl.w	r5, r1, r5
    db78:	f005 0501 	andpl.w	r5, r5, #1
    db7c:	f1c5 0502 	rsbpl	r5, r5, #2
    db80:	bf54      	ite	pl
    db82:	b2ed      	uxtbpl	r5, r5
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    db84:	2503      	movmi	r5, #3
    db86:	2600      	movs	r6, #0
    db88:	f506 73a2 	add.w	r3, r6, #324	; 0x144
    db8c:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
    db90:	f010 0003 	ands.w	r0, r0, #3
    db94:	d133      	bne.n	dbfe <gpiote_pin_int_cfg+0x112>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    db96:	00b2      	lsls	r2, r6, #2
    db98:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    db9c:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dba0:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    dba2:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
    dba6:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
    dbaa:	f421 7140 	bic.w	r1, r1, #768	; 0x300
    dbae:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dbb2:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
    dbb6:	f404 547c 	and.w	r4, r4, #16128	; 0x3f00
    dbba:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    dbbe:	430d      	orrs	r5, r1
			nrf_gpiote_event_t evt =
    dbc0:	f106 0140 	add.w	r1, r6, #64	; 0x40
    dbc4:	0089      	lsls	r1, r1, #2
    return ((uint32_t)p_reg + event);
    dbc6:	b289      	uxth	r1, r1
    dbc8:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    dbcc:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dbd0:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    dbd4:	6008      	str	r0, [r1, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    dbd6:	6809      	ldr	r1, [r1, #0]
    dbd8:	9101      	str	r1, [sp, #4]
    (void)dummy;
    dbda:	9901      	ldr	r1, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    dbdc:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
    dbe0:	f041 0101 	orr.w	r1, r1, #1
    dbe4:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    dbe8:	2201      	movs	r2, #1
    dbea:	fa02 f606 	lsl.w	r6, r2, r6
    p_reg->INTENSET = mask;
    dbee:	f8c7 6304 	str.w	r6, [r7, #772]	; 0x304
}
    dbf2:	b003      	add	sp, #12
    dbf4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    dbf6:	3301      	adds	r3, #1
    dbf8:	2b08      	cmp	r3, #8
    dbfa:	d186      	bne.n	db0a <gpiote_pin_int_cfg+0x1e>
    dbfc:	e7a1      	b.n	db42 <gpiote_pin_int_cfg+0x56>
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    dbfe:	3601      	adds	r6, #1
    dc00:	2e08      	cmp	r6, #8
    dc02:	d1c1      	bne.n	db88 <gpiote_pin_int_cfg+0x9c>
	return -ENODEV;
    dc04:	f06f 0012 	mvn.w	r0, #18
    dc08:	e7f3      	b.n	dbf2 <gpiote_pin_int_cfg+0x106>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    dc0a:	6971      	ldr	r1, [r6, #20]
    dc0c:	40e9      	lsrs	r1, r5
    dc0e:	f001 0101 	and.w	r1, r1, #1
    dc12:	f1c1 0103 	rsb	r1, r1, #3
			nrf_gpio_cfg_sense_set(abs_pin, sense);
    dc16:	4620      	mov	r0, r4
    dc18:	b2c9      	uxtb	r1, r1
    dc1a:	f7ff ff53 	bl	dac4 <nrf_gpio_cfg_sense_set>
	int res = 0;
    dc1e:	4610      	mov	r0, r2
    dc20:	e7e7      	b.n	dbf2 <gpiote_pin_int_cfg+0x106>
    dc22:	bf00      	nop
    dc24:	40006000 	.word	0x40006000

0000dc28 <gpio_nrfx_pin_interrupt_configure>:
	if ((mode == GPIO_INT_MODE_EDGE) &&
    dc28:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
{
    dc2c:	b470      	push	{r4, r5, r6}
	struct gpio_nrfx_data *data = get_port_data(port);
    dc2e:	6884      	ldr	r4, [r0, #8]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    dc30:	d117      	bne.n	dc62 <gpio_nrfx_pin_interrupt_configure+0x3a>
	return port->config->config_info;
    dc32:	6805      	ldr	r5, [r0, #0]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    dc34:	68ad      	ldr	r5, [r5, #8]
    dc36:	7a2e      	ldrb	r6, [r5, #8]
    dc38:	f001 051f 	and.w	r5, r1, #31
    dc3c:	ea45 1546 	orr.w	r5, r5, r6, lsl #5
    if (*p_pin < P0_PIN_NUM)
    dc40:	2d1f      	cmp	r5, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    dc42:	bfc6      	itte	gt
    dc44:	f005 051f 	andgt.w	r5, r5, #31
        return NRF_P1;
    dc48:	4e1e      	ldrgt	r6, [pc, #120]	; (dcc4 <gpio_nrfx_pin_interrupt_configure+0x9c>)
        return NRF_P0;
    dc4a:	f04f 46a0 	movle.w	r6, #1342177280	; 0x50000000
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    dc4e:	f505 75e0 	add.w	r5, r5, #448	; 0x1c0
    dc52:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    dc56:	07ed      	lsls	r5, r5, #31
    dc58:	d507      	bpl.n	dc6a <gpio_nrfx_pin_interrupt_configure+0x42>
}
    dc5a:	f06f 0022 	mvn.w	r0, #34	; 0x22
    dc5e:	bc70      	pop	{r4, r5, r6}
    dc60:	4770      	bx	lr
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    dc62:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    dc66:	68e5      	ldr	r5, [r4, #12]
    dc68:	d026      	beq.n	dcb8 <gpio_nrfx_pin_interrupt_configure+0x90>
    dc6a:	68e6      	ldr	r6, [r4, #12]
    dc6c:	2501      	movs	r5, #1
    dc6e:	408d      	lsls	r5, r1
    dc70:	4335      	orrs	r5, r6
    dc72:	6926      	ldr	r6, [r4, #16]
    dc74:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    dc76:	2501      	movs	r5, #1
    dc78:	408d      	lsls	r5, r1
    dc7a:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    dc7e:	bf14      	ite	ne
    dc80:	432e      	orrne	r6, r5
    dc82:	43ae      	biceq	r6, r5
    dc84:	6126      	str	r6, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    dc86:	69a6      	ldr	r6, [r4, #24]
    dc88:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    dc8c:	69e2      	ldr	r2, [r4, #28]
    dc8e:	bf0c      	ite	eq
    dc90:	432e      	orreq	r6, r5
    dc92:	43ae      	bicne	r6, r5
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    dc94:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    dc98:	bf0c      	ite	eq
    dc9a:	432a      	orreq	r2, r5
    dc9c:	43aa      	bicne	r2, r5
    dc9e:	61e2      	str	r2, [r4, #28]
    dca0:	6962      	ldr	r2, [r4, #20]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    dca2:	61a6      	str	r6, [r4, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    dca4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    dca8:	bf0c      	ite	eq
    dcaa:	4315      	orreq	r5, r2
    dcac:	ea22 0505 	bicne.w	r5, r2, r5
    dcb0:	6165      	str	r5, [r4, #20]
}
    dcb2:	bc70      	pop	{r4, r5, r6}
	return gpiote_pin_int_cfg(port, pin);
    dcb4:	f7ff bf1a 	b.w	daec <gpiote_pin_int_cfg>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    dcb8:	2601      	movs	r6, #1
    dcba:	408e      	lsls	r6, r1
    dcbc:	ea25 0506 	bic.w	r5, r5, r6
    dcc0:	e7d7      	b.n	dc72 <gpio_nrfx_pin_interrupt_configure+0x4a>
    dcc2:	bf00      	nop
    dcc4:	50000300 	.word	0x50000300

0000dcc8 <gpiote_event_handler>:
{
    dcc8:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t fired_triggers[GPIO_COUNT] = {0};
    dcca:	2600      	movs	r6, #0
{
    dccc:	b085      	sub	sp, #20
	u32_t fired_triggers[GPIO_COUNT] = {0};
    dcce:	e9cd 6602 	strd	r6, r6, [sp, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    dcd2:	4d28      	ldr	r5, [pc, #160]	; (dd74 <gpiote_event_handler+0xac>)
    dcd4:	682c      	ldr	r4, [r5, #0]
	if (port_event) {
    dcd6:	b15c      	cbz	r4, dcf0 <gpiote_event_handler+0x28>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
    dcd8:	4827      	ldr	r0, [pc, #156]	; (dd78 <gpiote_event_handler+0xb0>)
    dcda:	f009 fa9a 	bl	17212 <check_level_trigger_pins>
		fired_triggers[0] =
    dcde:	9002      	str	r0, [sp, #8]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
    dce0:	4826      	ldr	r0, [pc, #152]	; (dd7c <gpiote_event_handler+0xb4>)
    dce2:	f009 fa96 	bl	17212 <check_level_trigger_pins>
		fired_triggers[1] =
    dce6:	9003      	str	r0, [sp, #12]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    dce8:	602e      	str	r6, [r5, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    dcea:	682b      	ldr	r3, [r5, #0]
    dcec:	9300      	str	r3, [sp, #0]
    (void)dummy;
    dcee:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
    dcf0:	4d23      	ldr	r5, [pc, #140]	; (dd80 <gpiote_event_handler+0xb8>)
{
    dcf2:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    dcf4:	2601      	movs	r6, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    dcf6:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
    dcf8:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
    dcfc:	fa06 f102 	lsl.w	r1, r6, r2
    dd00:	4219      	tst	r1, r3
    dd02:	d01d      	beq.n	dd40 <gpiote_event_handler+0x78>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    dd04:	0091      	lsls	r1, r2, #2
    dd06:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    dd0a:	f501 41c2 	add.w	r1, r1, #24832	; 0x6100
    dd0e:	680b      	ldr	r3, [r1, #0]
    dd10:	b1b3      	cbz	r3, dd40 <gpiote_event_handler+0x78>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    dd12:	f502 73a2 	add.w	r3, r2, #324	; 0x144
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    dd16:	af04      	add	r7, sp, #16
    dd18:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    dd1c:	f8c1 c000 	str.w	ip, [r1]
    dd20:	f3c3 3040 	ubfx	r0, r3, #13, #1
    dd24:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    dd28:	f3c3 2304 	ubfx	r3, r3, #8, #5
    dd2c:	f850 7c08 	ldr.w	r7, [r0, #-8]
    dd30:	fa06 f303 	lsl.w	r3, r6, r3
    dd34:	433b      	orrs	r3, r7
    dd36:	f840 3c08 	str.w	r3, [r0, #-8]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    dd3a:	680b      	ldr	r3, [r1, #0]
    dd3c:	9301      	str	r3, [sp, #4]
    (void)dummy;
    dd3e:	9b01      	ldr	r3, [sp, #4]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    dd40:	3201      	adds	r2, #1
    dd42:	2a08      	cmp	r2, #8
    dd44:	d1d8      	bne.n	dcf8 <gpiote_event_handler+0x30>
	if (fired_triggers[0]) {
    dd46:	9902      	ldr	r1, [sp, #8]
    dd48:	b111      	cbz	r1, dd50 <gpiote_event_handler+0x88>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p0), fired_triggers[0]);
    dd4a:	480b      	ldr	r0, [pc, #44]	; (dd78 <gpiote_event_handler+0xb0>)
    dd4c:	f009 fa45 	bl	171da <fire_callbacks>
	if (fired_triggers[1]) {
    dd50:	9903      	ldr	r1, [sp, #12]
    dd52:	b111      	cbz	r1, dd5a <gpiote_event_handler+0x92>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p1), fired_triggers[1]);
    dd54:	4809      	ldr	r0, [pc, #36]	; (dd7c <gpiote_event_handler+0xb4>)
    dd56:	f009 fa40 	bl	171da <fire_callbacks>
	if (port_event) {
    dd5a:	b144      	cbz	r4, dd6e <gpiote_event_handler+0xa6>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
    dd5c:	4806      	ldr	r0, [pc, #24]	; (dd78 <gpiote_event_handler+0xb0>)
    dd5e:	f009 fa8b 	bl	17278 <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
    dd62:	4806      	ldr	r0, [pc, #24]	; (dd7c <gpiote_event_handler+0xb4>)
}
    dd64:	b005      	add	sp, #20
    dd66:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
    dd6a:	f009 ba85 	b.w	17278 <cfg_level_pins>
}
    dd6e:	b005      	add	sp, #20
    dd70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dd72:	bf00      	nop
    dd74:	4000617c 	.word	0x4000617c
    dd78:	2000c208 	.word	0x2000c208
    dd7c:	2000c214 	.word	0x2000c214
    dd80:	40006000 	.word	0x40006000

0000dd84 <spi_1_init>:
#ifdef CONFIG_SPI_0_NRF_SPI
SPI_NRFX_SPI_DEVICE(0);
#endif

#ifdef CONFIG_SPI_1_NRF_SPI
SPI_NRFX_SPI_DEVICE(1);
    dd84:	b510      	push	{r4, lr}
    dd86:	4604      	mov	r4, r0
    dd88:	2200      	movs	r2, #0
    dd8a:	2101      	movs	r1, #1
    dd8c:	2004      	movs	r0, #4
    dd8e:	f7f7 fed5 	bl	5b3c <z_arm_irq_priority_set>
	return dev->config->config_info;
    dd92:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
    dd94:	4a0e      	ldr	r2, [pc, #56]	; (ddd0 <spi_1_init+0x4c>)
	return dev->config->config_info;
    dd96:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spi_init(&get_dev_config(dev)->spi,
    dd98:	4623      	mov	r3, r4
    dd9a:	f100 0108 	add.w	r1, r0, #8
    dd9e:	f001 fecf 	bl	fb40 <nrfx_spi_init>
	if (result != NRFX_SUCCESS) {
    dda2:	4b0c      	ldr	r3, [pc, #48]	; (ddd4 <spi_1_init+0x50>)
    dda4:	4298      	cmp	r0, r3
    dda6:	d00e      	beq.n	ddc6 <spi_1_init+0x42>
    dda8:	4b0b      	ldr	r3, [pc, #44]	; (ddd8 <spi_1_init+0x54>)
    ddaa:	4a0c      	ldr	r2, [pc, #48]	; (dddc <spi_1_init+0x58>)
		LOG_ERR("Failed to initialize device: %s",
    ddac:	480c      	ldr	r0, [pc, #48]	; (dde0 <spi_1_init+0x5c>)
    ddae:	1ad2      	subs	r2, r2, r3
    ddb0:	08d2      	lsrs	r2, r2, #3
    ddb2:	6823      	ldr	r3, [r4, #0]
    ddb4:	0192      	lsls	r2, r2, #6
    ddb6:	6819      	ldr	r1, [r3, #0]
    ddb8:	f042 0201 	orr.w	r2, r2, #1
    ddbc:	f007 fa52 	bl	15264 <log_1>
		return -EBUSY;
    ddc0:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPI_DEVICE(1);
    ddc4:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
    ddc6:	68a0      	ldr	r0, [r4, #8]
    ddc8:	f009 fac0 	bl	1734c <spi_context_unlock_unconditionally>
	return 0;
    ddcc:	2000      	movs	r0, #0
SPI_NRFX_SPI_DEVICE(1);
    ddce:	e7f9      	b.n	ddc4 <spi_1_init+0x40>
    ddd0:	0000de65 	.word	0x0000de65
    ddd4:	0bad0000 	.word	0x0bad0000
    ddd8:	0001956c 	.word	0x0001956c
    dddc:	0001964c 	.word	0x0001964c
    dde0:	0001bd80 	.word	0x0001bd80

0000dde4 <transfer_next_chunk>:
{
    dde4:	b530      	push	{r4, r5, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    dde6:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    dde8:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    ddea:	6d6b      	ldr	r3, [r5, #84]	; 0x54
{
    ddec:	b085      	sub	sp, #20
    ddee:	b982      	cbnz	r2, de12 <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
    ddf0:	bb7b      	cbnz	r3, de52 <transfer_next_chunk+0x6e>
	int error = 0;
    ddf2:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
    ddf4:	2200      	movs	r2, #0
    ddf6:	4611      	mov	r1, r2
    ddf8:	4628      	mov	r0, r5
    ddfa:	f009 fa7d 	bl	172f8 <_spi_context_cs_control.isra.0>
	ctx->sync_status = status;
    ddfe:	636c      	str	r4, [r5, #52]	; 0x34
	z_impl_k_sem_give(sem);
    de00:	f105 001c 	add.w	r0, r5, #28
    de04:	f006 fa72 	bl	142ec <z_impl_k_sem_give>
	dev_data->busy = false;
    de08:	2300      	movs	r3, #0
    de0a:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
    de0e:	b005      	add	sp, #20
    de10:	bd30      	pop	{r4, r5, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    de12:	4611      	mov	r1, r2
    de14:	b113      	cbz	r3, de1c <transfer_next_chunk+0x38>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
    de16:	429a      	cmp	r2, r3
    de18:	bf28      	it	cs
    de1a:	4619      	movcs	r1, r3
		xfer.p_tx_buffer = ctx->tx_buf;
    de1c:	6cac      	ldr	r4, [r5, #72]	; 0x48
		dev_data->chunk_len = chunk_len;
    de1e:	65a9      	str	r1, [r5, #88]	; 0x58
		xfer.p_tx_buffer = ctx->tx_buf;
    de20:	9400      	str	r4, [sp, #0]
	return !!(ctx->tx_buf && ctx->tx_len);
    de22:	b1c4      	cbz	r4, de56 <transfer_next_chunk+0x72>
    de24:	2a00      	cmp	r2, #0
    de26:	bf18      	it	ne
    de28:	460a      	movne	r2, r1
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    de2a:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    de2c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    de2e:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    de30:	b19a      	cbz	r2, de5a <transfer_next_chunk+0x76>
    de32:	2b00      	cmp	r3, #0
    de34:	bf18      	it	ne
    de36:	460b      	movne	r3, r1
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    de38:	9303      	str	r3, [sp, #12]
	return dev->config->config_info;
    de3a:	6803      	ldr	r3, [r0, #0]
		result = nrfx_spi_xfer(&get_dev_config(dev)->spi, &xfer, 0);
    de3c:	2200      	movs	r2, #0
    de3e:	6898      	ldr	r0, [r3, #8]
    de40:	4669      	mov	r1, sp
    de42:	f001 ff35 	bl	fcb0 <nrfx_spi_xfer>
		if (result == NRFX_SUCCESS) {
    de46:	4b06      	ldr	r3, [pc, #24]	; (de60 <transfer_next_chunk+0x7c>)
    de48:	4298      	cmp	r0, r3
    de4a:	d0e0      	beq.n	de0e <transfer_next_chunk+0x2a>
		error = -EIO;
    de4c:	f06f 0404 	mvn.w	r4, #4
    de50:	e7d0      	b.n	ddf4 <transfer_next_chunk+0x10>
    de52:	4619      	mov	r1, r3
    de54:	e7e2      	b.n	de1c <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    de56:	4622      	mov	r2, r4
    de58:	e7e7      	b.n	de2a <transfer_next_chunk+0x46>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    de5a:	4613      	mov	r3, r2
    de5c:	e7ec      	b.n	de38 <transfer_next_chunk+0x54>
    de5e:	bf00      	nop
    de60:	0bad0000 	.word	0x0bad0000

0000de64 <event_handler>:
{
    de64:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    de66:	7803      	ldrb	r3, [r0, #0]
{
    de68:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    de6a:	2b00      	cmp	r3, #0
    de6c:	d14f      	bne.n	df0e <event_handler+0xaa>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    de6e:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
    de70:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    de72:	b163      	cbz	r3, de8e <event_handler+0x2a>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
    de74:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
    de76:	429a      	cmp	r2, r3
    de78:	d91d      	bls.n	deb6 <event_handler+0x52>
    de7a:	4925      	ldr	r1, [pc, #148]	; (df10 <event_handler+0xac>)
    de7c:	4b25      	ldr	r3, [pc, #148]	; (df14 <event_handler+0xb0>)
		LOG_ERR("Update exceeds current buffer");
    de7e:	4826      	ldr	r0, [pc, #152]	; (df18 <event_handler+0xb4>)
    de80:	1a5b      	subs	r3, r3, r1
    de82:	08db      	lsrs	r3, r3, #3
    de84:	019b      	lsls	r3, r3, #6
    de86:	f043 0101 	orr.w	r1, r3, #1
    de8a:	f007 f9de 	bl	1524a <log_0>
	if (!ctx->rx_len) {
    de8e:	6d63      	ldr	r3, [r4, #84]	; 0x54
    de90:	b163      	cbz	r3, deac <event_handler+0x48>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    de92:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
    de94:	429a      	cmp	r2, r3
    de96:	d924      	bls.n	dee2 <event_handler+0x7e>
    de98:	491d      	ldr	r1, [pc, #116]	; (df10 <event_handler+0xac>)
    de9a:	4b1e      	ldr	r3, [pc, #120]	; (df14 <event_handler+0xb0>)
		LOG_ERR("Update exceeds current buffer");
    de9c:	481e      	ldr	r0, [pc, #120]	; (df18 <event_handler+0xb4>)
    de9e:	1a5b      	subs	r3, r3, r1
    dea0:	08db      	lsrs	r3, r3, #3
    dea2:	019b      	lsls	r3, r3, #6
    dea4:	f043 0101 	orr.w	r1, r3, #1
    dea8:	f007 f9cf 	bl	1524a <log_0>
		transfer_next_chunk(dev);
    deac:	4628      	mov	r0, r5
}
    deae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
    deb2:	f7ff bf97 	b.w	dde4 <transfer_next_chunk>
	ctx->tx_len -= len;
    deb6:	1a9b      	subs	r3, r3, r2
    deb8:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
    deba:	b963      	cbnz	r3, ded6 <event_handler+0x72>
		ctx->tx_count--;
    debc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    debe:	3b01      	subs	r3, #1
    dec0:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
    dec2:	b163      	cbz	r3, dede <event_handler+0x7a>
			ctx->current_tx++;
    dec4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    dec6:	f103 0208 	add.w	r2, r3, #8
    deca:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    decc:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
    dece:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    ded0:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
    ded2:	64e3      	str	r3, [r4, #76]	; 0x4c
    ded4:	e7db      	b.n	de8e <event_handler+0x2a>
	} else if (ctx->tx_buf) {
    ded6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    ded8:	2b00      	cmp	r3, #0
    deda:	d0d8      	beq.n	de8e <event_handler+0x2a>
		ctx->tx_buf += dfs * len;
    dedc:	4413      	add	r3, r2
    dede:	64a3      	str	r3, [r4, #72]	; 0x48
    dee0:	e7d5      	b.n	de8e <event_handler+0x2a>
	ctx->rx_len -= len;
    dee2:	1a9b      	subs	r3, r3, r2
    dee4:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
    dee6:	b963      	cbnz	r3, df02 <event_handler+0x9e>
		ctx->rx_count--;
    dee8:	6c63      	ldr	r3, [r4, #68]	; 0x44
    deea:	3b01      	subs	r3, #1
    deec:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
    deee:	b163      	cbz	r3, df0a <event_handler+0xa6>
			ctx->current_rx++;
    def0:	6c23      	ldr	r3, [r4, #64]	; 0x40
    def2:	f103 0208 	add.w	r2, r3, #8
    def6:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    def8:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
    defa:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    defc:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
    defe:	6563      	str	r3, [r4, #84]	; 0x54
    df00:	e7d4      	b.n	deac <event_handler+0x48>
	} else if (ctx->rx_buf) {
    df02:	6d23      	ldr	r3, [r4, #80]	; 0x50
    df04:	2b00      	cmp	r3, #0
    df06:	d0d1      	beq.n	deac <event_handler+0x48>
		ctx->rx_buf += dfs * len;
    df08:	4413      	add	r3, r2
    df0a:	6523      	str	r3, [r4, #80]	; 0x50
    df0c:	e7ce      	b.n	deac <event_handler+0x48>
}
    df0e:	bd38      	pop	{r3, r4, r5, pc}
    df10:	0001956c 	.word	0x0001956c
    df14:	0001964c 	.word	0x0001964c
    df18:	0001bda0 	.word	0x0001bda0

0000df1c <spi_nrfx_transceive>:
{
    df1c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    df20:	6884      	ldr	r4, [r0, #8]
{
    df22:	4680      	mov	r8, r0
    df24:	460f      	mov	r7, r1
    df26:	4616      	mov	r6, r2
    df28:	461d      	mov	r5, r3
	k_sem_take(&ctx->lock, K_FOREVER);
    df2a:	f104 0a04 	add.w	sl, r4, #4
	return z_impl_k_sem_take(sem, timeout);
    df2e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    df32:	4650      	mov	r0, sl
    df34:	f006 fa00 	bl	14338 <z_impl_k_sem_take>
	struct spi_context *ctx = &get_dev_data(dev)->ctx;
    df38:	f8d8 9008 	ldr.w	r9, [r8, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
    df3c:	f8d9 3000 	ldr.w	r3, [r9]
    df40:	429f      	cmp	r7, r3
    df42:	f000 80a6 	beq.w	e092 <spi_nrfx_transceive+0x176>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    df46:	88bb      	ldrh	r3, [r7, #4]
	const nrfx_spi_t *spi = &get_dev_config(dev)->spi;
    df48:	f8d8 1000 	ldr.w	r1, [r8]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    df4c:	07d8      	lsls	r0, r3, #31
    df4e:	d513      	bpl.n	df78 <spi_nrfx_transceive+0x5c>
    df50:	4a7b      	ldr	r2, [pc, #492]	; (e140 <spi_nrfx_transceive+0x224>)
    df52:	4b7c      	ldr	r3, [pc, #496]	; (e144 <spi_nrfx_transceive+0x228>)
		LOG_ERR("Slave mode is not supported on %s",
    df54:	6809      	ldr	r1, [r1, #0]
    df56:	487c      	ldr	r0, [pc, #496]	; (e148 <spi_nrfx_transceive+0x22c>)
    df58:	1ad2      	subs	r2, r2, r3
    df5a:	08d2      	lsrs	r2, r2, #3
    df5c:	0192      	lsls	r2, r2, #6
    df5e:	f042 0201 	orr.w	r2, r2, #1
    df62:	f007 f97f 	bl	15264 <log_1>
		return -EINVAL;
    df66:	f06f 0415 	mvn.w	r4, #21
	z_impl_k_sem_give(sem);
    df6a:	4650      	mov	r0, sl
    df6c:	f006 f9be 	bl	142ec <z_impl_k_sem_give>
}
    df70:	4620      	mov	r0, r4
    df72:	b003      	add	sp, #12
    df74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
    df78:	071a      	lsls	r2, r3, #28
    df7a:	d50a      	bpl.n	df92 <spi_nrfx_transceive+0x76>
    df7c:	4970      	ldr	r1, [pc, #448]	; (e140 <spi_nrfx_transceive+0x224>)
    df7e:	4b71      	ldr	r3, [pc, #452]	; (e144 <spi_nrfx_transceive+0x228>)
		LOG_ERR("Loopback mode is not supported");
    df80:	4872      	ldr	r0, [pc, #456]	; (e14c <spi_nrfx_transceive+0x230>)
    df82:	1ac9      	subs	r1, r1, r3
    df84:	08c9      	lsrs	r1, r1, #3
    df86:	0189      	lsls	r1, r1, #6
    df88:	f041 0101 	orr.w	r1, r1, #1
		LOG_ERR("Word sizes other than 8 bits"
    df8c:	f007 f95d 	bl	1524a <log_0>
    df90:	e7e9      	b.n	df66 <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    df92:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
    df96:	d008      	beq.n	dfaa <spi_nrfx_transceive+0x8e>
    df98:	4969      	ldr	r1, [pc, #420]	; (e140 <spi_nrfx_transceive+0x224>)
    df9a:	4b6a      	ldr	r3, [pc, #424]	; (e144 <spi_nrfx_transceive+0x228>)
		LOG_ERR("Only single line mode is supported");
    df9c:	486c      	ldr	r0, [pc, #432]	; (e150 <spi_nrfx_transceive+0x234>)
    df9e:	1ac9      	subs	r1, r1, r3
    dfa0:	08c9      	lsrs	r1, r1, #3
    dfa2:	0189      	lsls	r1, r1, #6
    dfa4:	f041 0101 	orr.w	r1, r1, #1
    dfa8:	e7f0      	b.n	df8c <spi_nrfx_transceive+0x70>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    dfaa:	f3c3 1345 	ubfx	r3, r3, #5, #6
    dfae:	2b08      	cmp	r3, #8
    dfb0:	d008      	beq.n	dfc4 <spi_nrfx_transceive+0xa8>
    dfb2:	4963      	ldr	r1, [pc, #396]	; (e140 <spi_nrfx_transceive+0x224>)
    dfb4:	4b63      	ldr	r3, [pc, #396]	; (e144 <spi_nrfx_transceive+0x228>)
		LOG_ERR("Word sizes other than 8 bits"
    dfb6:	4867      	ldr	r0, [pc, #412]	; (e154 <spi_nrfx_transceive+0x238>)
    dfb8:	1ac9      	subs	r1, r1, r3
    dfba:	08c9      	lsrs	r1, r1, #3
    dfbc:	0189      	lsls	r1, r1, #6
    dfbe:	f041 0101 	orr.w	r1, r1, #1
    dfc2:	e7e3      	b.n	df8c <spi_nrfx_transceive+0x70>
	if (spi_cfg->frequency < 125000) {
    dfc4:	683a      	ldr	r2, [r7, #0]
    dfc6:	4b64      	ldr	r3, [pc, #400]	; (e158 <spi_nrfx_transceive+0x23c>)
    dfc8:	429a      	cmp	r2, r3
    dfca:	d808      	bhi.n	dfde <spi_nrfx_transceive+0xc2>
    dfcc:	495c      	ldr	r1, [pc, #368]	; (e140 <spi_nrfx_transceive+0x224>)
    dfce:	4b5d      	ldr	r3, [pc, #372]	; (e144 <spi_nrfx_transceive+0x228>)
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    dfd0:	4862      	ldr	r0, [pc, #392]	; (e15c <spi_nrfx_transceive+0x240>)
    dfd2:	1ac9      	subs	r1, r1, r3
    dfd4:	08c9      	lsrs	r1, r1, #3
    dfd6:	0189      	lsls	r1, r1, #6
    dfd8:	f041 0101 	orr.w	r1, r1, #1
    dfdc:	e7d6      	b.n	df8c <spi_nrfx_transceive+0x70>
	return dev->config->config_info;
    dfde:	688b      	ldr	r3, [r1, #8]
    dfe0:	9300      	str	r3, [sp, #0]
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
    dfe2:	68bb      	ldr	r3, [r7, #8]
	ctx->config = spi_cfg;
    dfe4:	f8c9 7000 	str.w	r7, [r9]
    dfe8:	2b00      	cmp	r3, #0
    dfea:	d07a      	beq.n	e0e2 <spi_nrfx_transceive+0x1c6>
    dfec:	6818      	ldr	r0, [r3, #0]
    dfee:	2800      	cmp	r0, #0
    dff0:	d077      	beq.n	e0e2 <spi_nrfx_transceive+0x1c6>
				   ctx->config->cs->gpio_pin, GPIO_OUTPUT);
    dff2:	6859      	ldr	r1, [r3, #4]
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config->config_info;
	struct gpio_driver_data *data =
    dff4:	f8d0 b008 	ldr.w	fp, [r0, #8]
	return api->pin_configure(port, pin, flags);
    dff8:	6843      	ldr	r3, [r0, #4]
    dffa:	b2c9      	uxtb	r1, r1
    dffc:	681b      	ldr	r3, [r3, #0]
    dffe:	9101      	str	r1, [sp, #4]
    e000:	f44f 7200 	mov.w	r2, #512	; 0x200
    e004:	4798      	blx	r3
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
    e006:	b948      	cbnz	r0, e01c <spi_nrfx_transceive+0x100>
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    e008:	9901      	ldr	r1, [sp, #4]
    e00a:	2301      	movs	r3, #1
    e00c:	fa03 f101 	lsl.w	r1, r3, r1
    e010:	f8db 3000 	ldr.w	r3, [fp]
    e014:	ea23 0301 	bic.w	r3, r3, r1
    e018:	f8cb 3000 	str.w	r3, [fp]
		gpio_pin_set(ctx->config->cs->gpio_dev,
    e01c:	f8d9 2000 	ldr.w	r2, [r9]
    e020:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    e022:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_set(ctx->config->cs->gpio_dev,
    e026:	7919      	ldrb	r1, [r3, #4]
    e028:	6818      	ldr	r0, [r3, #0]
    e02a:	43d2      	mvns	r2, r2
    e02c:	0fd2      	lsrs	r2, r2, #31
    e02e:	f009 f953 	bl	172d8 <gpio_pin_set>
	nrf_spi_configure(spi->p_reg,
    e032:	9b00      	ldr	r3, [sp, #0]
    e034:	6819      	ldr	r1, [r3, #0]
    e036:	88bb      	ldrh	r3, [r7, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    e038:	0798      	lsls	r0, r3, #30
    e03a:	f003 0204 	and.w	r2, r3, #4
    e03e:	d55b      	bpl.n	e0f8 <spi_nrfx_transceive+0x1dc>
			return NRF_SPI_MODE_2;
    e040:	2a00      	cmp	r2, #0
    e042:	bf14      	ite	ne
    e044:	2203      	movne	r2, #3
    e046:	2202      	moveq	r2, #2
                                         nrf_spi_mode_t      spi_mode,
                                         nrf_spi_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
    e048:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
    e04a:	f3c3 1300 	ubfx	r3, r3, #4, #1
    e04e:	d057      	beq.n	e100 <spi_nrfx_transceive+0x1e4>
    e050:	2a03      	cmp	r2, #3
    e052:	d058      	beq.n	e106 <spi_nrfx_transceive+0x1ea>
    e054:	2a01      	cmp	r2, #1
    e056:	d101      	bne.n	e05c <spi_nrfx_transceive+0x140>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
        break;

    case NRF_SPI_MODE_1:
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    e058:	f043 0302 	orr.w	r3, r3, #2
	if (frequency < 250000) {
    e05c:	4a40      	ldr	r2, [pc, #256]	; (e160 <spi_nrfx_transceive+0x244>)
    case NRF_SPI_MODE_3:
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    e05e:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	nrf_spi_frequency_set(spi->p_reg,
    e062:	683b      	ldr	r3, [r7, #0]
	if (frequency < 250000) {
    e064:	4293      	cmp	r3, r2
    e066:	d951      	bls.n	e10c <spi_nrfx_transceive+0x1f0>
	} else if (frequency < 500000) {
    e068:	4a3e      	ldr	r2, [pc, #248]	; (e164 <spi_nrfx_transceive+0x248>)
    e06a:	4293      	cmp	r3, r2
    e06c:	d951      	bls.n	e112 <spi_nrfx_transceive+0x1f6>
	} else if (frequency < 1000000) {
    e06e:	4a3e      	ldr	r2, [pc, #248]	; (e168 <spi_nrfx_transceive+0x24c>)
    e070:	4293      	cmp	r3, r2
    e072:	d951      	bls.n	e118 <spi_nrfx_transceive+0x1fc>
	} else if (frequency < 2000000) {
    e074:	4a3d      	ldr	r2, [pc, #244]	; (e16c <spi_nrfx_transceive+0x250>)
    e076:	4293      	cmp	r3, r2
    e078:	d951      	bls.n	e11e <spi_nrfx_transceive+0x202>
	} else if (frequency < 4000000) {
    e07a:	4a3d      	ldr	r2, [pc, #244]	; (e170 <spi_nrfx_transceive+0x254>)
    e07c:	4293      	cmp	r3, r2
    e07e:	d951      	bls.n	e124 <spi_nrfx_transceive+0x208>
		return NRF_SPI_FREQ_8M;
    e080:	4a3c      	ldr	r2, [pc, #240]	; (e174 <spi_nrfx_transceive+0x258>)
    e082:	4293      	cmp	r3, r2
    e084:	bf34      	ite	cc
    e086:	f04f 4380 	movcc.w	r3, #1073741824	; 0x40000000
    e08a:	f04f 4300 	movcs.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
    e08e:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
    e092:	2301      	movs	r3, #1
    e094:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
    e098:	2e00      	cmp	r6, #0
    e09a:	d046      	beq.n	e12a <spi_nrfx_transceive+0x20e>
		ctx->current_tx = tx_bufs->buffers;
    e09c:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
    e09e:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
    e0a0:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
    e0a2:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    e0a4:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
    e0a6:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    e0a8:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
    e0aa:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
    e0ac:	2d00      	cmp	r5, #0
    e0ae:	d041      	beq.n	e134 <spi_nrfx_transceive+0x218>
		ctx->current_rx = rx_bufs->buffers;
    e0b0:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
    e0b2:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
    e0b4:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
    e0b6:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    e0b8:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
    e0ba:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    e0bc:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
    e0be:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
    e0c0:	2200      	movs	r2, #0
    e0c2:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
    e0c4:	2101      	movs	r1, #1
    e0c6:	4620      	mov	r0, r4
    e0c8:	f009 f916 	bl	172f8 <_spi_context_cs_control.isra.0>
		transfer_next_chunk(dev);
    e0cc:	4640      	mov	r0, r8
    e0ce:	f7ff fe89 	bl	dde4 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
    e0d2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e0d6:	f104 001c 	add.w	r0, r4, #28
    e0da:	f006 f92d 	bl	14338 <z_impl_k_sem_take>
	status = ctx->sync_status;
    e0de:	6b64      	ldr	r4, [r4, #52]	; 0x34
	return status;
    e0e0:	e743      	b.n	df6a <spi_nrfx_transceive+0x4e>
    e0e2:	4b18      	ldr	r3, [pc, #96]	; (e144 <spi_nrfx_transceive+0x228>)
    e0e4:	4916      	ldr	r1, [pc, #88]	; (e140 <spi_nrfx_transceive+0x224>)
		LOG_INF("CS control inhibited (no GPIO device)");
    e0e6:	4824      	ldr	r0, [pc, #144]	; (e178 <spi_nrfx_transceive+0x25c>)
    e0e8:	1ac9      	subs	r1, r1, r3
    e0ea:	08c9      	lsrs	r1, r1, #3
    e0ec:	0189      	lsls	r1, r1, #6
    e0ee:	f041 0103 	orr.w	r1, r1, #3
    e0f2:	f007 f8aa 	bl	1524a <log_0>
    e0f6:	e79c      	b.n	e032 <spi_nrfx_transceive+0x116>
			return NRF_SPI_MODE_0;
    e0f8:	3a00      	subs	r2, #0
    e0fa:	bf18      	it	ne
    e0fc:	2201      	movne	r2, #1
    e0fe:	e7a3      	b.n	e048 <spi_nrfx_transceive+0x12c>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    e100:	f043 0304 	orr.w	r3, r3, #4
        break;
    e104:	e7aa      	b.n	e05c <spi_nrfx_transceive+0x140>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    e106:	f043 0306 	orr.w	r3, r3, #6
        break;
    e10a:	e7a7      	b.n	e05c <spi_nrfx_transceive+0x140>
		return NRF_SPI_FREQ_125K;
    e10c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    e110:	e7bd      	b.n	e08e <spi_nrfx_transceive+0x172>
		return NRF_SPI_FREQ_250K;
    e112:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    e116:	e7ba      	b.n	e08e <spi_nrfx_transceive+0x172>
		return NRF_SPI_FREQ_500K;
    e118:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    e11c:	e7b7      	b.n	e08e <spi_nrfx_transceive+0x172>
		return NRF_SPI_FREQ_1M;
    e11e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    e122:	e7b4      	b.n	e08e <spi_nrfx_transceive+0x172>
		return NRF_SPI_FREQ_2M;
    e124:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    e128:	e7b1      	b.n	e08e <spi_nrfx_transceive+0x172>
		ctx->tx_count = 0;
    e12a:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
    e12e:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
    e132:	e7bb      	b.n	e0ac <spi_nrfx_transceive+0x190>
		ctx->rx_count = 0;
    e134:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
    e138:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
    e13c:	e7c0      	b.n	e0c0 <spi_nrfx_transceive+0x1a4>
    e13e:	bf00      	nop
    e140:	0001964c 	.word	0x0001964c
    e144:	0001956c 	.word	0x0001956c
    e148:	0001bdbe 	.word	0x0001bdbe
    e14c:	0001bde0 	.word	0x0001bde0
    e150:	0001bdff 	.word	0x0001bdff
    e154:	0001be22 	.word	0x0001be22
    e158:	0001e847 	.word	0x0001e847
    e15c:	0001be51 	.word	0x0001be51
    e160:	0003d08f 	.word	0x0003d08f
    e164:	0007a11f 	.word	0x0007a11f
    e168:	000f423f 	.word	0x000f423f
    e16c:	001e847f 	.word	0x001e847f
    e170:	003d08ff 	.word	0x003d08ff
    e174:	007a1200 	.word	0x007a1200
    e178:	0001be82 	.word	0x0001be82

0000e17c <spi_3_init>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
    e17c:	b510      	push	{r4, lr}
    e17e:	4604      	mov	r4, r0
    e180:	2200      	movs	r2, #0
    e182:	2101      	movs	r1, #1
    e184:	202f      	movs	r0, #47	; 0x2f
    e186:	f7f7 fcd9 	bl	5b3c <z_arm_irq_priority_set>
	return dev->config->config_info;
    e18a:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
    e18c:	4a0e      	ldr	r2, [pc, #56]	; (e1c8 <spi_3_init+0x4c>)
	return dev->config->config_info;
    e18e:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
    e190:	4623      	mov	r3, r4
    e192:	f100 010c 	add.w	r1, r0, #12
    e196:	f001 fe65 	bl	fe64 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
    e19a:	4b0c      	ldr	r3, [pc, #48]	; (e1cc <spi_3_init+0x50>)
    e19c:	4298      	cmp	r0, r3
    e19e:	d00e      	beq.n	e1be <spi_3_init+0x42>
    e1a0:	4b0b      	ldr	r3, [pc, #44]	; (e1d0 <spi_3_init+0x54>)
    e1a2:	4a0c      	ldr	r2, [pc, #48]	; (e1d4 <spi_3_init+0x58>)
		LOG_ERR("Failed to initialize device: %s",
    e1a4:	480c      	ldr	r0, [pc, #48]	; (e1d8 <spi_3_init+0x5c>)
    e1a6:	1ad2      	subs	r2, r2, r3
    e1a8:	08d2      	lsrs	r2, r2, #3
    e1aa:	6823      	ldr	r3, [r4, #0]
    e1ac:	0192      	lsls	r2, r2, #6
    e1ae:	6819      	ldr	r1, [r3, #0]
    e1b0:	f042 0201 	orr.w	r2, r2, #1
    e1b4:	f007 f856 	bl	15264 <log_1>
		return -EBUSY;
    e1b8:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPIM_DEVICE(3);
    e1bc:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
    e1be:	68a0      	ldr	r0, [r4, #8]
    e1c0:	f009 f91e 	bl	17400 <spi_context_unlock_unconditionally>
	return 0;
    e1c4:	2000      	movs	r0, #0
SPI_NRFX_SPIM_DEVICE(3);
    e1c6:	e7f9      	b.n	e1bc <spi_3_init+0x40>
    e1c8:	0000e265 	.word	0x0000e265
    e1cc:	0bad0000 	.word	0x0bad0000
    e1d0:	0001956c 	.word	0x0001956c
    e1d4:	00019654 	.word	0x00019654
    e1d8:	0001bd80 	.word	0x0001bd80

0000e1dc <transfer_next_chunk>:
{
    e1dc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    e1de:	6885      	ldr	r5, [r0, #8]
	if (!ctx->tx_len) {
    e1e0:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    e1e2:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    e1e4:	b98a      	cbnz	r2, e20a <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
    e1e6:	2b00      	cmp	r3, #0
    e1e8:	d133      	bne.n	e252 <transfer_next_chunk+0x76>
	int error = 0;
    e1ea:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
    e1ec:	2200      	movs	r2, #0
    e1ee:	4611      	mov	r1, r2
    e1f0:	4628      	mov	r0, r5
    e1f2:	f009 f8db 	bl	173ac <_spi_context_cs_control.isra.0>
	ctx->sync_status = status;
    e1f6:	636c      	str	r4, [r5, #52]	; 0x34
	z_impl_k_sem_give(sem);
    e1f8:	f105 001c 	add.w	r0, r5, #28
    e1fc:	f006 f876 	bl	142ec <z_impl_k_sem_give>
	dev_data->busy = false;
    e200:	2300      	movs	r3, #0
    e202:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
    e206:	b004      	add	sp, #16
    e208:	bd70      	pop	{r4, r5, r6, pc}
	} else if (!ctx->rx_len) {
    e20a:	4611      	mov	r1, r2
    e20c:	b113      	cbz	r3, e214 <transfer_next_chunk+0x38>
	} else if (ctx->tx_len < ctx->rx_len) {
    e20e:	429a      	cmp	r2, r3
    e210:	bf28      	it	cs
    e212:	4619      	movcs	r1, r3
	return dev->config->config_info;
    e214:	6800      	ldr	r0, [r0, #0]
		const u8_t *tx_buf = ctx->tx_buf;
    e216:	6cac      	ldr	r4, [r5, #72]	; 0x48
	return dev->config->config_info;
    e218:	6880      	ldr	r0, [r0, #8]
		xfer.p_tx_buffer = tx_buf;
    e21a:	9400      	str	r4, [sp, #0]
    e21c:	6886      	ldr	r6, [r0, #8]
    e21e:	42b1      	cmp	r1, r6
    e220:	bf28      	it	cs
    e222:	4631      	movcs	r1, r6
		dev_data->chunk_len = chunk_len;
    e224:	65a9      	str	r1, [r5, #88]	; 0x58
	return !!(ctx->tx_buf && ctx->tx_len);
    e226:	b1b4      	cbz	r4, e256 <transfer_next_chunk+0x7a>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    e228:	2a00      	cmp	r2, #0
    e22a:	bf18      	it	ne
    e22c:	460a      	movne	r2, r1
    e22e:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    e230:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    e232:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    e234:	b18a      	cbz	r2, e25a <transfer_next_chunk+0x7e>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    e236:	2b00      	cmp	r3, #0
    e238:	bf18      	it	ne
    e23a:	460b      	movne	r3, r1
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    e23c:	2200      	movs	r2, #0
    e23e:	4669      	mov	r1, sp
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    e240:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    e242:	f001 fecd 	bl	ffe0 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
    e246:	4b06      	ldr	r3, [pc, #24]	; (e260 <transfer_next_chunk+0x84>)
    e248:	4298      	cmp	r0, r3
    e24a:	d0dc      	beq.n	e206 <transfer_next_chunk+0x2a>
			error = -EIO;
    e24c:	f06f 0404 	mvn.w	r4, #4
    e250:	e7cc      	b.n	e1ec <transfer_next_chunk+0x10>
    e252:	4619      	mov	r1, r3
    e254:	e7de      	b.n	e214 <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    e256:	4622      	mov	r2, r4
    e258:	e7e9      	b.n	e22e <transfer_next_chunk+0x52>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    e25a:	4613      	mov	r3, r2
    e25c:	e7ee      	b.n	e23c <transfer_next_chunk+0x60>
    e25e:	bf00      	nop
    e260:	0bad0000 	.word	0x0bad0000

0000e264 <event_handler>:
{
    e264:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
    e266:	7803      	ldrb	r3, [r0, #0]
{
    e268:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
    e26a:	2b00      	cmp	r3, #0
    e26c:	d14f      	bne.n	e30e <event_handler+0xaa>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    e26e:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
    e270:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    e272:	b163      	cbz	r3, e28e <event_handler+0x2a>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
    e274:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
    e276:	429a      	cmp	r2, r3
    e278:	d91d      	bls.n	e2b6 <event_handler+0x52>
    e27a:	4925      	ldr	r1, [pc, #148]	; (e310 <event_handler+0xac>)
    e27c:	4b25      	ldr	r3, [pc, #148]	; (e314 <event_handler+0xb0>)
		LOG_ERR("Update exceeds current buffer");
    e27e:	4826      	ldr	r0, [pc, #152]	; (e318 <event_handler+0xb4>)
    e280:	1a5b      	subs	r3, r3, r1
    e282:	08db      	lsrs	r3, r3, #3
    e284:	019b      	lsls	r3, r3, #6
    e286:	f043 0101 	orr.w	r1, r3, #1
    e28a:	f006 ffde 	bl	1524a <log_0>
	if (!ctx->rx_len) {
    e28e:	6d63      	ldr	r3, [r4, #84]	; 0x54
    e290:	b163      	cbz	r3, e2ac <event_handler+0x48>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    e292:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
    e294:	429a      	cmp	r2, r3
    e296:	d924      	bls.n	e2e2 <event_handler+0x7e>
    e298:	491d      	ldr	r1, [pc, #116]	; (e310 <event_handler+0xac>)
    e29a:	4b1e      	ldr	r3, [pc, #120]	; (e314 <event_handler+0xb0>)
		LOG_ERR("Update exceeds current buffer");
    e29c:	481e      	ldr	r0, [pc, #120]	; (e318 <event_handler+0xb4>)
    e29e:	1a5b      	subs	r3, r3, r1
    e2a0:	08db      	lsrs	r3, r3, #3
    e2a2:	019b      	lsls	r3, r3, #6
    e2a4:	f043 0101 	orr.w	r1, r3, #1
    e2a8:	f006 ffcf 	bl	1524a <log_0>
		transfer_next_chunk(dev);
    e2ac:	4628      	mov	r0, r5
}
    e2ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
    e2b2:	f7ff bf93 	b.w	e1dc <transfer_next_chunk>
	ctx->tx_len -= len;
    e2b6:	1a9b      	subs	r3, r3, r2
    e2b8:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
    e2ba:	b963      	cbnz	r3, e2d6 <event_handler+0x72>
		ctx->tx_count--;
    e2bc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    e2be:	3b01      	subs	r3, #1
    e2c0:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
    e2c2:	b163      	cbz	r3, e2de <event_handler+0x7a>
			ctx->current_tx++;
    e2c4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    e2c6:	f103 0208 	add.w	r2, r3, #8
    e2ca:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    e2cc:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
    e2ce:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    e2d0:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
    e2d2:	64e3      	str	r3, [r4, #76]	; 0x4c
    e2d4:	e7db      	b.n	e28e <event_handler+0x2a>
	} else if (ctx->tx_buf) {
    e2d6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    e2d8:	2b00      	cmp	r3, #0
    e2da:	d0d8      	beq.n	e28e <event_handler+0x2a>
		ctx->tx_buf += dfs * len;
    e2dc:	4413      	add	r3, r2
    e2de:	64a3      	str	r3, [r4, #72]	; 0x48
    e2e0:	e7d5      	b.n	e28e <event_handler+0x2a>
	ctx->rx_len -= len;
    e2e2:	1a9b      	subs	r3, r3, r2
    e2e4:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
    e2e6:	b963      	cbnz	r3, e302 <event_handler+0x9e>
		ctx->rx_count--;
    e2e8:	6c63      	ldr	r3, [r4, #68]	; 0x44
    e2ea:	3b01      	subs	r3, #1
    e2ec:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
    e2ee:	b163      	cbz	r3, e30a <event_handler+0xa6>
			ctx->current_rx++;
    e2f0:	6c23      	ldr	r3, [r4, #64]	; 0x40
    e2f2:	f103 0208 	add.w	r2, r3, #8
    e2f6:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    e2f8:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
    e2fa:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    e2fc:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
    e2fe:	6563      	str	r3, [r4, #84]	; 0x54
    e300:	e7d4      	b.n	e2ac <event_handler+0x48>
	} else if (ctx->rx_buf) {
    e302:	6d23      	ldr	r3, [r4, #80]	; 0x50
    e304:	2b00      	cmp	r3, #0
    e306:	d0d1      	beq.n	e2ac <event_handler+0x48>
		ctx->rx_buf += dfs * len;
    e308:	4413      	add	r3, r2
    e30a:	6523      	str	r3, [r4, #80]	; 0x50
    e30c:	e7ce      	b.n	e2ac <event_handler+0x48>
}
    e30e:	bd38      	pop	{r3, r4, r5, pc}
    e310:	0001956c 	.word	0x0001956c
    e314:	00019654 	.word	0x00019654
    e318:	0001bda0 	.word	0x0001bda0

0000e31c <spi_nrfx_transceive>:
{
    e31c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    e320:	6884      	ldr	r4, [r0, #8]
{
    e322:	4680      	mov	r8, r0
    e324:	460f      	mov	r7, r1
    e326:	4616      	mov	r6, r2
    e328:	461d      	mov	r5, r3
	k_sem_take(&ctx->lock, K_FOREVER);
    e32a:	f104 0a04 	add.w	sl, r4, #4
	return z_impl_k_sem_take(sem, timeout);
    e32e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e332:	4650      	mov	r0, sl
    e334:	f006 f800 	bl	14338 <z_impl_k_sem_take>
	struct spi_context *ctx = &get_dev_data(dev)->ctx;
    e338:	f8d8 9008 	ldr.w	r9, [r8, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
    e33c:	f8d9 3000 	ldr.w	r3, [r9]
    e340:	429f      	cmp	r7, r3
    e342:	f000 80ad 	beq.w	e4a0 <spi_nrfx_transceive+0x184>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    e346:	88bb      	ldrh	r3, [r7, #4]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
    e348:	f8d8 1000 	ldr.w	r1, [r8]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    e34c:	07d8      	lsls	r0, r3, #31
    e34e:	d513      	bpl.n	e378 <spi_nrfx_transceive+0x5c>
    e350:	4a81      	ldr	r2, [pc, #516]	; (e558 <spi_nrfx_transceive+0x23c>)
    e352:	4b82      	ldr	r3, [pc, #520]	; (e55c <spi_nrfx_transceive+0x240>)
		LOG_ERR("Slave mode is not supported on %s",
    e354:	6809      	ldr	r1, [r1, #0]
    e356:	4882      	ldr	r0, [pc, #520]	; (e560 <spi_nrfx_transceive+0x244>)
    e358:	1ad2      	subs	r2, r2, r3
    e35a:	08d2      	lsrs	r2, r2, #3
    e35c:	0192      	lsls	r2, r2, #6
    e35e:	f042 0201 	orr.w	r2, r2, #1
    e362:	f006 ff7f 	bl	15264 <log_1>
		return -EINVAL;
    e366:	f06f 0415 	mvn.w	r4, #21
	z_impl_k_sem_give(sem);
    e36a:	4650      	mov	r0, sl
    e36c:	f005 ffbe 	bl	142ec <z_impl_k_sem_give>
}
    e370:	4620      	mov	r0, r4
    e372:	b003      	add	sp, #12
    e374:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
    e378:	071a      	lsls	r2, r3, #28
    e37a:	d50a      	bpl.n	e392 <spi_nrfx_transceive+0x76>
    e37c:	4976      	ldr	r1, [pc, #472]	; (e558 <spi_nrfx_transceive+0x23c>)
    e37e:	4b77      	ldr	r3, [pc, #476]	; (e55c <spi_nrfx_transceive+0x240>)
		LOG_ERR("Loopback mode is not supported");
    e380:	4878      	ldr	r0, [pc, #480]	; (e564 <spi_nrfx_transceive+0x248>)
    e382:	1ac9      	subs	r1, r1, r3
    e384:	08c9      	lsrs	r1, r1, #3
    e386:	0189      	lsls	r1, r1, #6
    e388:	f041 0101 	orr.w	r1, r1, #1
		LOG_ERR("Word sizes other than 8 bits"
    e38c:	f006 ff5d 	bl	1524a <log_0>
    e390:	e7e9      	b.n	e366 <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    e392:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
    e396:	d008      	beq.n	e3aa <spi_nrfx_transceive+0x8e>
    e398:	496f      	ldr	r1, [pc, #444]	; (e558 <spi_nrfx_transceive+0x23c>)
    e39a:	4b70      	ldr	r3, [pc, #448]	; (e55c <spi_nrfx_transceive+0x240>)
		LOG_ERR("Only single line mode is supported");
    e39c:	4872      	ldr	r0, [pc, #456]	; (e568 <spi_nrfx_transceive+0x24c>)
    e39e:	1ac9      	subs	r1, r1, r3
    e3a0:	08c9      	lsrs	r1, r1, #3
    e3a2:	0189      	lsls	r1, r1, #6
    e3a4:	f041 0101 	orr.w	r1, r1, #1
    e3a8:	e7f0      	b.n	e38c <spi_nrfx_transceive+0x70>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    e3aa:	f3c3 1345 	ubfx	r3, r3, #5, #6
    e3ae:	2b08      	cmp	r3, #8
    e3b0:	d008      	beq.n	e3c4 <spi_nrfx_transceive+0xa8>
    e3b2:	4969      	ldr	r1, [pc, #420]	; (e558 <spi_nrfx_transceive+0x23c>)
    e3b4:	4b69      	ldr	r3, [pc, #420]	; (e55c <spi_nrfx_transceive+0x240>)
		LOG_ERR("Word sizes other than 8 bits"
    e3b6:	486d      	ldr	r0, [pc, #436]	; (e56c <spi_nrfx_transceive+0x250>)
    e3b8:	1ac9      	subs	r1, r1, r3
    e3ba:	08c9      	lsrs	r1, r1, #3
    e3bc:	0189      	lsls	r1, r1, #6
    e3be:	f041 0101 	orr.w	r1, r1, #1
    e3c2:	e7e3      	b.n	e38c <spi_nrfx_transceive+0x70>
	if (spi_cfg->frequency < 125000) {
    e3c4:	683a      	ldr	r2, [r7, #0]
    e3c6:	4b6a      	ldr	r3, [pc, #424]	; (e570 <spi_nrfx_transceive+0x254>)
    e3c8:	429a      	cmp	r2, r3
    e3ca:	d808      	bhi.n	e3de <spi_nrfx_transceive+0xc2>
    e3cc:	4962      	ldr	r1, [pc, #392]	; (e558 <spi_nrfx_transceive+0x23c>)
    e3ce:	4b63      	ldr	r3, [pc, #396]	; (e55c <spi_nrfx_transceive+0x240>)
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    e3d0:	4868      	ldr	r0, [pc, #416]	; (e574 <spi_nrfx_transceive+0x258>)
    e3d2:	1ac9      	subs	r1, r1, r3
    e3d4:	08c9      	lsrs	r1, r1, #3
    e3d6:	0189      	lsls	r1, r1, #6
    e3d8:	f041 0101 	orr.w	r1, r1, #1
    e3dc:	e7d6      	b.n	e38c <spi_nrfx_transceive+0x70>
	return dev->config->config_info;
    e3de:	688b      	ldr	r3, [r1, #8]
    e3e0:	9300      	str	r3, [sp, #0]
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
    e3e2:	68bb      	ldr	r3, [r7, #8]
	ctx->config = spi_cfg;
    e3e4:	f8c9 7000 	str.w	r7, [r9]
    e3e8:	2b00      	cmp	r3, #0
    e3ea:	f000 8081 	beq.w	e4f0 <spi_nrfx_transceive+0x1d4>
    e3ee:	6818      	ldr	r0, [r3, #0]
    e3f0:	2800      	cmp	r0, #0
    e3f2:	d07d      	beq.n	e4f0 <spi_nrfx_transceive+0x1d4>
				   ctx->config->cs->gpio_pin, GPIO_OUTPUT);
    e3f4:	6859      	ldr	r1, [r3, #4]
	struct gpio_driver_data *data =
    e3f6:	f8d0 b008 	ldr.w	fp, [r0, #8]
	return api->pin_configure(port, pin, flags);
    e3fa:	6843      	ldr	r3, [r0, #4]
    e3fc:	b2c9      	uxtb	r1, r1
    e3fe:	681b      	ldr	r3, [r3, #0]
    e400:	9101      	str	r1, [sp, #4]
    e402:	f44f 7200 	mov.w	r2, #512	; 0x200
    e406:	4798      	blx	r3
	if (ret != 0) {
    e408:	b948      	cbnz	r0, e41e <spi_nrfx_transceive+0x102>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    e40a:	9901      	ldr	r1, [sp, #4]
    e40c:	2301      	movs	r3, #1
    e40e:	fa03 f101 	lsl.w	r1, r3, r1
    e412:	f8db 3000 	ldr.w	r3, [fp]
    e416:	ea23 0301 	bic.w	r3, r3, r1
    e41a:	f8cb 3000 	str.w	r3, [fp]
		gpio_pin_set(ctx->config->cs->gpio_dev,
    e41e:	f8d9 2000 	ldr.w	r2, [r9]
    e422:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    e424:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_set(ctx->config->cs->gpio_dev,
    e428:	7919      	ldrb	r1, [r3, #4]
    e42a:	6818      	ldr	r0, [r3, #0]
    e42c:	43d2      	mvns	r2, r2
    e42e:	0fd2      	lsrs	r2, r2, #31
    e430:	f008 ffac 	bl	1738c <gpio_pin_set>
	nrf_spim_configure(spim->p_reg,
    e434:	9b00      	ldr	r3, [sp, #0]
    e436:	6819      	ldr	r1, [r3, #0]
    e438:	88bb      	ldrh	r3, [r7, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    e43a:	0798      	lsls	r0, r3, #30
    e43c:	f003 0204 	and.w	r2, r3, #4
    e440:	d561      	bpl.n	e506 <spi_nrfx_transceive+0x1ea>
			return NRF_SPIM_MODE_2;
    e442:	2a00      	cmp	r2, #0
    e444:	bf14      	ite	ne
    e446:	2203      	movne	r2, #3
    e448:	2202      	moveq	r2, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
    e44a:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
    e44c:	f3c3 1300 	ubfx	r3, r3, #4, #1
    e450:	d05d      	beq.n	e50e <spi_nrfx_transceive+0x1f2>
    e452:	2a03      	cmp	r2, #3
    e454:	d05e      	beq.n	e514 <spi_nrfx_transceive+0x1f8>
    e456:	2a01      	cmp	r2, #1
    e458:	d101      	bne.n	e45e <spi_nrfx_transceive+0x142>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
    e45a:	f043 0302 	orr.w	r3, r3, #2
	if (frequency < 250000) {
    e45e:	4a46      	ldr	r2, [pc, #280]	; (e578 <spi_nrfx_transceive+0x25c>)
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    e460:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	nrf_spim_frequency_set(spim->p_reg,
    e464:	683b      	ldr	r3, [r7, #0]
	if (frequency < 250000) {
    e466:	4293      	cmp	r3, r2
    e468:	d957      	bls.n	e51a <spi_nrfx_transceive+0x1fe>
	} else if (frequency < 500000) {
    e46a:	4a44      	ldr	r2, [pc, #272]	; (e57c <spi_nrfx_transceive+0x260>)
    e46c:	4293      	cmp	r3, r2
    e46e:	d957      	bls.n	e520 <spi_nrfx_transceive+0x204>
	} else if (frequency < 1000000) {
    e470:	4a43      	ldr	r2, [pc, #268]	; (e580 <spi_nrfx_transceive+0x264>)
    e472:	4293      	cmp	r3, r2
    e474:	d957      	bls.n	e526 <spi_nrfx_transceive+0x20a>
	} else if (frequency < 2000000) {
    e476:	4a43      	ldr	r2, [pc, #268]	; (e584 <spi_nrfx_transceive+0x268>)
    e478:	4293      	cmp	r3, r2
    e47a:	d957      	bls.n	e52c <spi_nrfx_transceive+0x210>
	} else if (frequency < 4000000) {
    e47c:	4a42      	ldr	r2, [pc, #264]	; (e588 <spi_nrfx_transceive+0x26c>)
    e47e:	4293      	cmp	r3, r2
    e480:	d957      	bls.n	e532 <spi_nrfx_transceive+0x216>
	} else if (frequency < 8000000) {
    e482:	4a42      	ldr	r2, [pc, #264]	; (e58c <spi_nrfx_transceive+0x270>)
    e484:	4293      	cmp	r3, r2
    e486:	d357      	bcc.n	e538 <spi_nrfx_transceive+0x21c>
	} else if (frequency < 16000000) {
    e488:	4a41      	ldr	r2, [pc, #260]	; (e590 <spi_nrfx_transceive+0x274>)
    e48a:	4293      	cmp	r3, r2
    e48c:	d357      	bcc.n	e53e <spi_nrfx_transceive+0x222>
		return NRF_SPIM_FREQ_32M;
    e48e:	4a41      	ldr	r2, [pc, #260]	; (e594 <spi_nrfx_transceive+0x278>)
    e490:	4293      	cmp	r3, r2
    e492:	bf34      	ite	cc
    e494:	f04f 6320 	movcc.w	r3, #167772160	; 0xa000000
    e498:	f04f 53a0 	movcs.w	r3, #335544320	; 0x14000000
    p_reg->FREQUENCY = (uint32_t)frequency;
    e49c:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
    e4a0:	2301      	movs	r3, #1
    e4a2:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
    e4a6:	2e00      	cmp	r6, #0
    e4a8:	d04c      	beq.n	e544 <spi_nrfx_transceive+0x228>
		ctx->current_tx = tx_bufs->buffers;
    e4aa:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
    e4ac:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
    e4ae:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
    e4b0:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    e4b2:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
    e4b4:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    e4b6:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
    e4b8:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
    e4ba:	2d00      	cmp	r5, #0
    e4bc:	d047      	beq.n	e54e <spi_nrfx_transceive+0x232>
		ctx->current_rx = rx_bufs->buffers;
    e4be:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
    e4c0:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
    e4c2:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
    e4c4:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    e4c6:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
    e4c8:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    e4ca:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
    e4cc:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
    e4ce:	2200      	movs	r2, #0
    e4d0:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
    e4d2:	2101      	movs	r1, #1
    e4d4:	4620      	mov	r0, r4
    e4d6:	f008 ff69 	bl	173ac <_spi_context_cs_control.isra.0>
		transfer_next_chunk(dev);
    e4da:	4640      	mov	r0, r8
    e4dc:	f7ff fe7e 	bl	e1dc <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
    e4e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e4e4:	f104 001c 	add.w	r0, r4, #28
    e4e8:	f005 ff26 	bl	14338 <z_impl_k_sem_take>
	status = ctx->sync_status;
    e4ec:	6b64      	ldr	r4, [r4, #52]	; 0x34
	return status;
    e4ee:	e73c      	b.n	e36a <spi_nrfx_transceive+0x4e>
    e4f0:	4b1a      	ldr	r3, [pc, #104]	; (e55c <spi_nrfx_transceive+0x240>)
    e4f2:	4919      	ldr	r1, [pc, #100]	; (e558 <spi_nrfx_transceive+0x23c>)
		LOG_INF("CS control inhibited (no GPIO device)");
    e4f4:	4828      	ldr	r0, [pc, #160]	; (e598 <spi_nrfx_transceive+0x27c>)
    e4f6:	1ac9      	subs	r1, r1, r3
    e4f8:	08c9      	lsrs	r1, r1, #3
    e4fa:	0189      	lsls	r1, r1, #6
    e4fc:	f041 0103 	orr.w	r1, r1, #3
    e500:	f006 fea3 	bl	1524a <log_0>
    e504:	e796      	b.n	e434 <spi_nrfx_transceive+0x118>
			return NRF_SPIM_MODE_0;
    e506:	3a00      	subs	r2, #0
    e508:	bf18      	it	ne
    e50a:	2201      	movne	r2, #1
    e50c:	e79d      	b.n	e44a <spi_nrfx_transceive+0x12e>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    e50e:	f043 0304 	orr.w	r3, r3, #4
        break;
    e512:	e7a4      	b.n	e45e <spi_nrfx_transceive+0x142>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    e514:	f043 0306 	orr.w	r3, r3, #6
        break;
    e518:	e7a1      	b.n	e45e <spi_nrfx_transceive+0x142>
		return NRF_SPIM_FREQ_125K;
    e51a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    e51e:	e7bd      	b.n	e49c <spi_nrfx_transceive+0x180>
		return NRF_SPIM_FREQ_250K;
    e520:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    e524:	e7ba      	b.n	e49c <spi_nrfx_transceive+0x180>
		return NRF_SPIM_FREQ_500K;
    e526:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    e52a:	e7b7      	b.n	e49c <spi_nrfx_transceive+0x180>
		return NRF_SPIM_FREQ_1M;
    e52c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    e530:	e7b4      	b.n	e49c <spi_nrfx_transceive+0x180>
		return NRF_SPIM_FREQ_2M;
    e532:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    e536:	e7b1      	b.n	e49c <spi_nrfx_transceive+0x180>
		return NRF_SPIM_FREQ_4M;
    e538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    e53c:	e7ae      	b.n	e49c <spi_nrfx_transceive+0x180>
		return NRF_SPIM_FREQ_8M;
    e53e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    e542:	e7ab      	b.n	e49c <spi_nrfx_transceive+0x180>
		ctx->tx_count = 0;
    e544:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
    e548:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
    e54c:	e7b5      	b.n	e4ba <spi_nrfx_transceive+0x19e>
		ctx->rx_count = 0;
    e54e:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
    e552:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
    e556:	e7ba      	b.n	e4ce <spi_nrfx_transceive+0x1b2>
    e558:	00019654 	.word	0x00019654
    e55c:	0001956c 	.word	0x0001956c
    e560:	0001bdbe 	.word	0x0001bdbe
    e564:	0001bde0 	.word	0x0001bde0
    e568:	0001bdff 	.word	0x0001bdff
    e56c:	0001be22 	.word	0x0001be22
    e570:	0001e847 	.word	0x0001e847
    e574:	0001be51 	.word	0x0001be51
    e578:	0003d08f 	.word	0x0003d08f
    e57c:	0007a11f 	.word	0x0007a11f
    e580:	000f423f 	.word	0x000f423f
    e584:	001e847f 	.word	0x001e847f
    e588:	003d08ff 	.word	0x003d08ff
    e58c:	007a1200 	.word	0x007a1200
    e590:	00f42400 	.word	0x00f42400
    e594:	01e84800 	.word	0x01e84800
    e598:	0001be82 	.word	0x0001be82

0000e59c <qspi_nor_pages_layout>:

static void qspi_nor_pages_layout(struct device *dev,
				  const struct flash_pages_layout **layout,
				  size_t *layout_size)
{
	*layout = &dev_layout;
    e59c:	4b02      	ldr	r3, [pc, #8]	; (e5a8 <qspi_nor_pages_layout+0xc>)
    e59e:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
    e5a0:	2301      	movs	r3, #1
    e5a2:	6013      	str	r3, [r2, #0]
}
    e5a4:	4770      	bx	lr
    e5a6:	bf00      	nop
    e5a8:	00019990 	.word	0x00019990

0000e5ac <qspi_wait_for_completion>:
	if (res == NRFX_SUCCESS) {
    e5ac:	4b05      	ldr	r3, [pc, #20]	; (e5c4 <qspi_wait_for_completion+0x18>)
	struct qspi_nor_data *dev_data = get_dev_data(dev);
    e5ae:	6880      	ldr	r0, [r0, #8]
	if (res == NRFX_SUCCESS) {
    e5b0:	4299      	cmp	r1, r3
    e5b2:	d104      	bne.n	e5be <qspi_wait_for_completion+0x12>
    e5b4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e5b8:	3018      	adds	r0, #24
    e5ba:	f005 bebd 	b.w	14338 <z_impl_k_sem_take>
	z_impl_k_sem_give(sem);
    e5be:	f005 be95 	b.w	142ec <z_impl_k_sem_give>
    e5c2:	bf00      	nop
    e5c4:	0bad0000 	.word	0x0bad0000

0000e5c8 <qspi_nor_erase>:
	const struct qspi_nor_config *params = dev->config->config_info;
    e5c8:	6803      	ldr	r3, [r0, #0]
{
    e5ca:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct qspi_nor_config *params = dev->config->config_info;
    e5ce:	f8d3 a008 	ldr.w	sl, [r3, #8]
	if (driver_data->write_protection) {
    e5d2:	6883      	ldr	r3, [r0, #8]
    e5d4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
{
    e5d8:	4680      	mov	r8, r0
    e5da:	4614      	mov	r4, r2
	if (driver_data->write_protection) {
    e5dc:	2b00      	cmp	r3, #0
    e5de:	d172      	bne.n	e6c6 <qspi_nor_erase+0xfe>
	if (addr >= params->size ||
    e5e0:	f8da 3004 	ldr.w	r3, [sl, #4]
    e5e4:	428b      	cmp	r3, r1
    e5e6:	460d      	mov	r5, r1
    e5e8:	d906      	bls.n	e5f8 <qspi_nor_erase+0x30>
    e5ea:	2900      	cmp	r1, #0
    e5ec:	db04      	blt.n	e5f8 <qspi_nor_erase+0x30>
	    addr < 0 ||
    e5ee:	4293      	cmp	r3, r2
    e5f0:	d302      	bcc.n	e5f8 <qspi_nor_erase+0x30>
	    (addr) + size > params->size) {
    e5f2:	188a      	adds	r2, r1, r2
	    size > params->size ||
    e5f4:	4293      	cmp	r3, r2
    e5f6:	d20d      	bcs.n	e614 <qspi_nor_erase+0x4c>
    e5f8:	4a34      	ldr	r2, [pc, #208]	; (e6cc <qspi_nor_erase+0x104>)
    e5fa:	4b35      	ldr	r3, [pc, #212]	; (e6d0 <qspi_nor_erase+0x108>)
		LOG_ERR("erase error: address or size "
    e5fc:	4835      	ldr	r0, [pc, #212]	; (e6d4 <qspi_nor_erase+0x10c>)
    e5fe:	1a9b      	subs	r3, r3, r2
    e600:	08db      	lsrs	r3, r3, #3
    e602:	019b      	lsls	r3, r3, #6
    e604:	f043 0301 	orr.w	r3, r3, #1
    e608:	4622      	mov	r2, r4
    e60a:	f006 fe3f 	bl	1528c <log_2>
		return -EINVAL;
    e60e:	f06f 0715 	mvn.w	r7, #21
    e612:	e026      	b.n	e662 <qspi_nor_erase+0x9a>
	if (!size) {
    e614:	2c00      	cmp	r4, #0
    e616:	d0fa      	beq.n	e60e <qspi_nor_erase+0x46>
    e618:	4e2d      	ldr	r6, [pc, #180]	; (e6d0 <qspi_nor_erase+0x108>)
    e61a:	4b2c      	ldr	r3, [pc, #176]	; (e6cc <qspi_nor_erase+0x104>)
			LOG_ERR("unsupported at 0x%lx size %zu", (long)addr, size);
    e61c:	f8df b0c0 	ldr.w	fp, [pc, #192]	; e6e0 <qspi_nor_erase+0x118>
    e620:	1af6      	subs	r6, r6, r3
    e622:	08f6      	lsrs	r6, r6, #3
    e624:	ea4f 1986 	mov.w	r9, r6, lsl #6
	int rv = -EIO;
    e628:	f06f 0704 	mvn.w	r7, #4
			LOG_ERR("unsupported at 0x%lx size %zu", (long)addr, size);
    e62c:	f049 0901 	orr.w	r9, r9, #1
		qspi_lock(dev);
    e630:	4640      	mov	r0, r8
    e632:	f008 ff05 	bl	17440 <qspi_lock>
		if (size == params->size) {
    e636:	f8da 3004 	ldr.w	r3, [sl, #4]
    e63a:	42a3      	cmp	r3, r4
    e63c:	d115      	bne.n	e66a <qspi_nor_erase+0xa2>
			res = nrfx_qspi_chip_erase();
    e63e:	f001 fa43 	bl	fac8 <nrfx_qspi_chip_erase>
    e642:	4623      	mov	r3, r4
    e644:	4601      	mov	r1, r0
		qspi_wait_for_completion(dev, res);
    e646:	4640      	mov	r0, r8
    e648:	e9cd 1300 	strd	r1, r3, [sp]
    e64c:	f7ff ffae 	bl	e5ac <qspi_wait_for_completion>
		if (res == NRFX_SUCCESS) {
    e650:	4a21      	ldr	r2, [pc, #132]	; (e6d8 <qspi_nor_erase+0x110>)
    e652:	9900      	ldr	r1, [sp, #0]
    e654:	4291      	cmp	r1, r2
    e656:	d12d      	bne.n	e6b4 <qspi_nor_erase+0xec>
			addr += adj;
    e658:	9b01      	ldr	r3, [sp, #4]
	while (size) {
    e65a:	1ae4      	subs	r4, r4, r3
			addr += adj;
    e65c:	441d      	add	r5, r3
	while (size) {
    e65e:	d1e7      	bne.n	e630 <qspi_nor_erase+0x68>
	return 0;
    e660:	4627      	mov	r7, r4
}
    e662:	4638      	mov	r0, r7
    e664:	b003      	add	sp, #12
    e666:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ((size >= QSPI_BLOCK_SIZE) &&
    e66a:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
    e66e:	d309      	bcc.n	e684 <qspi_nor_erase+0xbc>
			   QSPI_IS_BLOCK_ALIGNED(addr)) {
    e670:	b2ab      	uxth	r3, r5
		} else if ((size >= QSPI_BLOCK_SIZE) &&
    e672:	b953      	cbnz	r3, e68a <qspi_nor_erase+0xc2>
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_64KB, addr);
    e674:	4629      	mov	r1, r5
    e676:	2001      	movs	r0, #1
    e678:	f001 fa16 	bl	faa8 <nrfx_qspi_erase>
			adj = QSPI_BLOCK_SIZE;
    e67c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_64KB, addr);
    e680:	4601      	mov	r1, r0
			adj = QSPI_BLOCK_SIZE;
    e682:	e7e0      	b.n	e646 <qspi_nor_erase+0x7e>
		} else if ((size >= QSPI_SECTOR_SIZE) &&
    e684:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    e688:	d309      	bcc.n	e69e <qspi_nor_erase+0xd6>
			   QSPI_IS_SECTOR_ALIGNED(addr)) {
    e68a:	f3c5 000b 	ubfx	r0, r5, #0, #12
		} else if ((size >= QSPI_SECTOR_SIZE) &&
    e68e:	b930      	cbnz	r0, e69e <qspi_nor_erase+0xd6>
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_4KB, addr);
    e690:	4629      	mov	r1, r5
    e692:	f001 fa09 	bl	faa8 <nrfx_qspi_erase>
			adj = QSPI_SECTOR_SIZE;
    e696:	f44f 5380 	mov.w	r3, #4096	; 0x1000
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_4KB, addr);
    e69a:	4601      	mov	r1, r0
			adj = QSPI_SECTOR_SIZE;
    e69c:	e7d3      	b.n	e646 <qspi_nor_erase+0x7e>
			LOG_ERR("unsupported at 0x%lx size %zu", (long)addr, size);
    e69e:	464b      	mov	r3, r9
    e6a0:	4629      	mov	r1, r5
    e6a2:	4622      	mov	r2, r4
    e6a4:	4658      	mov	r0, fp
    e6a6:	f006 fdf1 	bl	1528c <log_2>
		u32_t adj = 0;
    e6aa:	2300      	movs	r3, #0
		nrfx_err_t res = !NRFX_SUCCESS;
    e6ac:	4619      	mov	r1, r3
			rv = -EINVAL;
    e6ae:	f06f 0715 	mvn.w	r7, #21
    e6b2:	e7c8      	b.n	e646 <qspi_nor_erase+0x7e>
			LOG_ERR("erase error at 0x%lx size %zu", (long)addr, size);
    e6b4:	01b3      	lsls	r3, r6, #6
    e6b6:	4809      	ldr	r0, [pc, #36]	; (e6dc <qspi_nor_erase+0x114>)
    e6b8:	f043 0301 	orr.w	r3, r3, #1
    e6bc:	4622      	mov	r2, r4
    e6be:	4629      	mov	r1, r5
    e6c0:	f006 fde4 	bl	1528c <log_2>
			return rv;
    e6c4:	e7cd      	b.n	e662 <qspi_nor_erase+0x9a>
		return -EACCES;
    e6c6:	f06f 070c 	mvn.w	r7, #12
    e6ca:	e7ca      	b.n	e662 <qspi_nor_erase+0x9a>
    e6cc:	0001956c 	.word	0x0001956c
    e6d0:	0001963c 	.word	0x0001963c
    e6d4:	0001becf 	.word	0x0001becf
    e6d8:	0bad0000 	.word	0x0bad0000
    e6dc:	0001bf37 	.word	0x0001bf37
    e6e0:	0001bf19 	.word	0x0001bf19

0000e6e4 <qspi_nor_write>:
{
    e6e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e6e6:	4606      	mov	r6, r0
    e6e8:	460d      	mov	r5, r1
    e6ea:	461c      	mov	r4, r3
	if (!src) {
    e6ec:	4617      	mov	r7, r2
    e6ee:	b302      	cbz	r2, e732 <qspi_nor_write+0x4e>
	if (((size % 4U) != 0) || (size == 0)) {
    e6f0:	079a      	lsls	r2, r3, #30
    e6f2:	d11e      	bne.n	e732 <qspi_nor_write+0x4e>
    e6f4:	b1eb      	cbz	r3, e732 <qspi_nor_write+0x4e>
	if ((addr % 4U) != 0) {
    e6f6:	078b      	lsls	r3, r1, #30
    e6f8:	d11b      	bne.n	e732 <qspi_nor_write+0x4e>
	if (driver_data->write_protection) {
    e6fa:	6882      	ldr	r2, [r0, #8]
	const struct qspi_nor_config *params = dev->config->config_info;
    e6fc:	6803      	ldr	r3, [r0, #0]
	if (driver_data->write_protection) {
    e6fe:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
	const struct qspi_nor_config *params = dev->config->config_info;
    e702:	689b      	ldr	r3, [r3, #8]
	if (driver_data->write_protection) {
    e704:	bb6a      	cbnz	r2, e762 <qspi_nor_write+0x7e>
	if (addr >= params->size ||
    e706:	685b      	ldr	r3, [r3, #4]
    e708:	4299      	cmp	r1, r3
    e70a:	d206      	bcs.n	e71a <qspi_nor_write+0x36>
    e70c:	2900      	cmp	r1, #0
    e70e:	db04      	blt.n	e71a <qspi_nor_write+0x36>
	    addr < 0 ||
    e710:	42a3      	cmp	r3, r4
    e712:	d302      	bcc.n	e71a <qspi_nor_write+0x36>
	    (addr) + size > params->size) {
    e714:	190a      	adds	r2, r1, r4
	    size > params->size ||
    e716:	4293      	cmp	r3, r2
    e718:	d20e      	bcs.n	e738 <qspi_nor_write+0x54>
    e71a:	4a15      	ldr	r2, [pc, #84]	; (e770 <qspi_nor_write+0x8c>)
    e71c:	4b15      	ldr	r3, [pc, #84]	; (e774 <qspi_nor_write+0x90>)
		LOG_ERR("write error: address or size "
    e71e:	4816      	ldr	r0, [pc, #88]	; (e778 <qspi_nor_write+0x94>)
    e720:	1a9b      	subs	r3, r3, r2
    e722:	08db      	lsrs	r3, r3, #3
    e724:	019b      	lsls	r3, r3, #6
    e726:	f043 0301 	orr.w	r3, r3, #1
    e72a:	4622      	mov	r2, r4
    e72c:	4629      	mov	r1, r5
    e72e:	f006 fdad 	bl	1528c <log_2>
		return -EINVAL;
    e732:	f06f 0015 	mvn.w	r0, #21
    e736:	e013      	b.n	e760 <qspi_nor_write+0x7c>
	qspi_lock(dev);
    e738:	f008 fe82 	bl	17440 <qspi_lock>
	nrfx_err_t res = nrfx_qspi_write(src, size, addr);
    e73c:	4621      	mov	r1, r4
    e73e:	462a      	mov	r2, r5
    e740:	4638      	mov	r0, r7
    e742:	f001 f981 	bl	fa48 <nrfx_qspi_write>
    e746:	4604      	mov	r4, r0
	qspi_wait_for_completion(dev, res);
    e748:	4601      	mov	r1, r0
    e74a:	4630      	mov	r0, r6
    e74c:	f7ff ff2e 	bl	e5ac <qspi_wait_for_completion>
	switch (res) {
    e750:	f104 4074 	add.w	r0, r4, #4093640704	; 0xf4000000
    e754:	f500 00a6 	add.w	r0, r0, #5439488	; 0x530000
    e758:	280a      	cmp	r0, #10
    e75a:	d805      	bhi.n	e768 <qspi_nor_write+0x84>
    e75c:	4b07      	ldr	r3, [pc, #28]	; (e77c <qspi_nor_write+0x98>)
    e75e:	5618      	ldrsb	r0, [r3, r0]
}
    e760:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EACCES;
    e762:	f06f 000c 	mvn.w	r0, #12
    e766:	e7fb      	b.n	e760 <qspi_nor_write+0x7c>
	qspi_wait_for_completion(dev, res);
    e768:	f06f 000f 	mvn.w	r0, #15
    e76c:	e7f8      	b.n	e760 <qspi_nor_write+0x7c>
    e76e:	bf00      	nop
    e770:	0001956c 	.word	0x0001956c
    e774:	0001963c 	.word	0x0001963c
    e778:	0001bf55 	.word	0x0001bf55
    e77c:	0001c027 	.word	0x0001c027

0000e780 <qspi_nor_read>:
{
    e780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e782:	4606      	mov	r6, r0
    e784:	460d      	mov	r5, r1
    e786:	461c      	mov	r4, r3
	if (!dest) {
    e788:	4617      	mov	r7, r2
    e78a:	b1e2      	cbz	r2, e7c6 <qspi_nor_read+0x46>
	if (((size % 4U) != 0) || (size == 0)) {
    e78c:	079a      	lsls	r2, r3, #30
    e78e:	d11a      	bne.n	e7c6 <qspi_nor_read+0x46>
    e790:	b1cb      	cbz	r3, e7c6 <qspi_nor_read+0x46>
	if ((addr % 4U) != 0) {
    e792:	078b      	lsls	r3, r1, #30
    e794:	d117      	bne.n	e7c6 <qspi_nor_read+0x46>
	const struct qspi_nor_config *params = dev->config->config_info;
    e796:	6803      	ldr	r3, [r0, #0]
	if (addr >= params->size ||
    e798:	689b      	ldr	r3, [r3, #8]
    e79a:	685b      	ldr	r3, [r3, #4]
    e79c:	4299      	cmp	r1, r3
    e79e:	d206      	bcs.n	e7ae <qspi_nor_read+0x2e>
    e7a0:	2900      	cmp	r1, #0
    e7a2:	db04      	blt.n	e7ae <qspi_nor_read+0x2e>
	    addr < 0 ||
    e7a4:	42a3      	cmp	r3, r4
    e7a6:	d302      	bcc.n	e7ae <qspi_nor_read+0x2e>
	    (addr) + size > params->size) {
    e7a8:	190a      	adds	r2, r1, r4
	    size > params->size ||
    e7aa:	4293      	cmp	r3, r2
    e7ac:	d20e      	bcs.n	e7cc <qspi_nor_read+0x4c>
    e7ae:	4a13      	ldr	r2, [pc, #76]	; (e7fc <qspi_nor_read+0x7c>)
    e7b0:	4b13      	ldr	r3, [pc, #76]	; (e800 <qspi_nor_read+0x80>)
		LOG_ERR("read error: address or size "
    e7b2:	4814      	ldr	r0, [pc, #80]	; (e804 <qspi_nor_read+0x84>)
    e7b4:	1a9b      	subs	r3, r3, r2
    e7b6:	08db      	lsrs	r3, r3, #3
    e7b8:	019b      	lsls	r3, r3, #6
    e7ba:	f043 0301 	orr.w	r3, r3, #1
    e7be:	4622      	mov	r2, r4
    e7c0:	4629      	mov	r1, r5
    e7c2:	f006 fd63 	bl	1528c <log_2>
		return -EINVAL;
    e7c6:	f06f 0015 	mvn.w	r0, #21
    e7ca:	e013      	b.n	e7f4 <qspi_nor_read+0x74>
	qspi_lock(dev);
    e7cc:	f008 fe38 	bl	17440 <qspi_lock>
	nrfx_err_t res = nrfx_qspi_read(dest, size, addr);
    e7d0:	4621      	mov	r1, r4
    e7d2:	462a      	mov	r2, r5
    e7d4:	4638      	mov	r0, r7
    e7d6:	f001 f94f 	bl	fa78 <nrfx_qspi_read>
    e7da:	4604      	mov	r4, r0
	qspi_wait_for_completion(dev, res);
    e7dc:	4601      	mov	r1, r0
    e7de:	4630      	mov	r0, r6
    e7e0:	f7ff fee4 	bl	e5ac <qspi_wait_for_completion>
	switch (res) {
    e7e4:	f104 4074 	add.w	r0, r4, #4093640704	; 0xf4000000
    e7e8:	f500 00a6 	add.w	r0, r0, #5439488	; 0x530000
    e7ec:	280a      	cmp	r0, #10
    e7ee:	d802      	bhi.n	e7f6 <qspi_nor_read+0x76>
    e7f0:	4b05      	ldr	r3, [pc, #20]	; (e808 <qspi_nor_read+0x88>)
    e7f2:	5618      	ldrsb	r0, [r3, r0]
}
    e7f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	qspi_wait_for_completion(dev, res);
    e7f6:	f06f 000f 	mvn.w	r0, #15
    e7fa:	e7fb      	b.n	e7f4 <qspi_nor_read+0x74>
    e7fc:	0001956c 	.word	0x0001956c
    e800:	0001963c 	.word	0x0001963c
    e804:	0001bf9f 	.word	0x0001bf9f
    e808:	0001c027 	.word	0x0001c027

0000e80c <qspi_send_cmd>:
{
    e80c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e80e:	460c      	mov	r4, r1
    e810:	4605      	mov	r5, r0
	qspi_lock(dev);
    e812:	f008 fe15 	bl	17440 <qspi_lock>
	nrf_qspi_cinstr_conf_t cinstr_cfg = {
    e816:	2300      	movs	r3, #0
    e818:	f88d 3004 	strb.w	r3, [sp, #4]
    e81c:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
    e820:	7823      	ldrb	r3, [r4, #0]
    e822:	f88d 3000 	strb.w	r3, [sp]
    e826:	2301      	movs	r3, #1
    e828:	f88d 3005 	strb.w	r3, [sp, #5]
	cinstr_cfg.length = sizeof(cmd->op_code);
    e82c:	f88d 3001 	strb.w	r3, [sp, #1]
	nrf_qspi_cinstr_conf_t cinstr_cfg = {
    e830:	f240 1301 	movw	r3, #257	; 0x101
    e834:	f8ad 3002 	strh.w	r3, [sp, #2]
	if ((cmd->tx_buf != 0) && (cmd->rx_buf != 0)) {
    e838:	b1d9      	cbz	r1, e872 <qspi_send_cmd+0x66>
    e83a:	790b      	ldrb	r3, [r1, #4]
    e83c:	b10a      	cbz	r2, e842 <qspi_send_cmd+0x36>
		cinstr_cfg.length += cmd->tx_buf->len + cmd->rx_buf->len;
    e83e:	6850      	ldr	r0, [r2, #4]
    e840:	4403      	add	r3, r0
		cinstr_cfg.length += cmd->rx_buf->len;
    e842:	3301      	adds	r3, #1
    e844:	f88d 3001 	strb.w	r3, [sp, #1]
	int res = nrfx_qspi_cinstr_xfer(&cinstr_cfg, cmd->tx_buf->buf,
    e848:	6812      	ldr	r2, [r2, #0]
    e84a:	6809      	ldr	r1, [r1, #0]
    e84c:	4668      	mov	r0, sp
    e84e:	f001 f8bb 	bl	f9c8 <nrfx_qspi_cinstr_xfer>
    e852:	4604      	mov	r4, r0
	k_sem_give(&dev_data->sem);
    e854:	68a8      	ldr	r0, [r5, #8]
    e856:	f005 fd49 	bl	142ec <z_impl_k_sem_give>
	switch (res) {
    e85a:	f104 4074 	add.w	r0, r4, #4093640704	; 0xf4000000
    e85e:	f500 00a6 	add.w	r0, r0, #5439488	; 0x530000
    e862:	280a      	cmp	r0, #10
    e864:	bf9a      	itte	ls
    e866:	4b05      	ldrls	r3, [pc, #20]	; (e87c <qspi_send_cmd+0x70>)
    e868:	5618      	ldrsbls	r0, [r3, r0]
    e86a:	f06f 000f 	mvnhi.w	r0, #15
}
    e86e:	b003      	add	sp, #12
    e870:	bd30      	pop	{r4, r5, pc}
	} else if ((cmd->tx_buf == 0) && (cmd->rx_buf != 0)) {
    e872:	2a00      	cmp	r2, #0
    e874:	d0e8      	beq.n	e848 <qspi_send_cmd+0x3c>
		cinstr_cfg.length += cmd->rx_buf->len;
    e876:	6853      	ldr	r3, [r2, #4]
    e878:	e7e3      	b.n	e842 <qspi_send_cmd+0x36>
    e87a:	bf00      	nop
    e87c:	0001c027 	.word	0x0001c027

0000e880 <qspi_nor_init>:
{
    e880:	b570      	push	{r4, r5, r6, lr}
    e882:	4606      	mov	r6, r0
    e884:	b08c      	sub	sp, #48	; 0x30
	IRQ_CONNECT(DT_IRQN(QSPI_NODE), DT_IRQ(QSPI_NODE, priority),
    e886:	2200      	movs	r2, #0
    e888:	2101      	movs	r1, #1
    e88a:	2029      	movs	r0, #41	; 0x29
    e88c:	f7f7 f956 	bl	5b3c <z_arm_irq_priority_set>
	const struct qspi_nor_config *params = dev->config->config_info;
    e890:	6833      	ldr	r3, [r6, #0]
	initstruct->pins.sck_pin = DT_PROP(QSPI_NODE, sck_pin);
    e892:	4a41      	ldr	r2, [pc, #260]	; (e998 <qspi_nor_init+0x118>)
	const struct qspi_nor_config *params = dev->config->config_info;
    e894:	689c      	ldr	r4, [r3, #8]
	nrfx_err_t res = nrfx_qspi_init(&QSPIconfig, qspi_handler, dev);
    e896:	4941      	ldr	r1, [pc, #260]	; (e99c <qspi_nor_init+0x11c>)
	initstruct->pins.sck_pin = DT_PROP(QSPI_NODE, sck_pin);
    e898:	2300      	movs	r3, #0
    e89a:	e9cd 3206 	strd	r3, r2, [sp, #24]
	initstruct->pins.io2_pin = QSPI_PROP_AT(io_pins, 2);
    e89e:	f241 7216 	movw	r2, #5910	; 0x1716
	initstruct->prot_if.addrmode =
    e8a2:	e9cd 2308 	strd	r2, r3, [sp, #32]
	nrfx_err_t res = nrfx_qspi_init(&QSPIconfig, qspi_handler, dev);
    e8a6:	a806      	add	r0, sp, #24
	initstruct->phy_if.spi_mode = qspi_get_mode(DT_INST_PROP(0, cpol),
    e8a8:	f44f 7340 	mov.w	r3, #768	; 0x300
	nrfx_err_t res = nrfx_qspi_init(&QSPIconfig, qspi_handler, dev);
    e8ac:	4632      	mov	r2, r6
	initstruct->phy_if.spi_mode = qspi_get_mode(DT_INST_PROP(0, cpol),
    e8ae:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	nrfx_err_t res = nrfx_qspi_init(&QSPIconfig, qspi_handler, dev);
    e8b2:	f001 f80d 	bl	f8d0 <nrfx_qspi_init>
	if (res == NRFX_SUCCESS) {
    e8b6:	4b3a      	ldr	r3, [pc, #232]	; (e9a0 <qspi_nor_init+0x120>)
    e8b8:	4298      	cmp	r0, r3
	nrfx_err_t res = nrfx_qspi_init(&QSPIconfig, qspi_handler, dev);
    e8ba:	4605      	mov	r5, r0
	if (res == NRFX_SUCCESS) {
    e8bc:	d12a      	bne.n	e914 <qspi_nor_init+0x94>
	switch (lines) {
    e8be:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    e8c2:	3b02      	subs	r3, #2
    e8c4:	2b01      	cmp	r3, #1
    e8c6:	d904      	bls.n	e8d2 <qspi_nor_init+0x52>
	switch (lines) {
    e8c8:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    e8cc:	3b03      	subs	r3, #3
    e8ce:	2b01      	cmp	r3, #1
    e8d0:	d820      	bhi.n	e914 <qspi_nor_init+0x94>
			struct qspi_cmd cmd = { .op_code = SPI_NOR_CMD_WREN };
    e8d2:	2300      	movs	r3, #0
    e8d4:	e9cd 3303 	strd	r3, r3, [sp, #12]
    e8d8:	9305      	str	r3, [sp, #20]
			if (qspi_send_cmd(dev, &cmd) != 0) {
    e8da:	a903      	add	r1, sp, #12
			struct qspi_cmd cmd = { .op_code = SPI_NOR_CMD_WREN };
    e8dc:	2306      	movs	r3, #6
			if (qspi_send_cmd(dev, &cmd) != 0) {
    e8de:	4630      	mov	r0, r6
			struct qspi_cmd cmd = { .op_code = SPI_NOR_CMD_WREN };
    e8e0:	f88d 300c 	strb.w	r3, [sp, #12]
			if (qspi_send_cmd(dev, &cmd) != 0) {
    e8e4:	f7ff ff92 	bl	e80c <qspi_send_cmd>
    e8e8:	b980      	cbnz	r0, e90c <qspi_nor_init+0x8c>
			u8_t tx = BIT(CONFIG_NORDIC_QSPI_NOR_QE_BIT);
    e8ea:	2340      	movs	r3, #64	; 0x40
    e8ec:	f88d 3000 	strb.w	r3, [sp]
			const struct qspi_buf tx_buff = { .buf = &tx, .len = sizeof(tx), };
    e8f0:	2301      	movs	r3, #1
    e8f2:	9302      	str	r3, [sp, #8]
			cmd.op_code = SPI_NOR_CMD_WRSR;
    e8f4:	f88d 300c 	strb.w	r3, [sp, #12]
			cmd.tx_buf = &tx_buff;
    e8f8:	ab01      	add	r3, sp, #4
			cmd.rx_buf = NULL;
    e8fa:	e9cd 3004 	strd	r3, r0, [sp, #16]
			if (qspi_send_cmd(dev, &cmd) != 0) {
    e8fe:	a903      	add	r1, sp, #12
    e900:	4630      	mov	r0, r6
			const struct qspi_buf tx_buff = { .buf = &tx, .len = sizeof(tx), };
    e902:	f8cd d004 	str.w	sp, [sp, #4]
			if (qspi_send_cmd(dev, &cmd) != 0) {
    e906:	f7ff ff81 	bl	e80c <qspi_send_cmd>
    e90a:	b118      	cbz	r0, e914 <qspi_nor_init+0x94>
	if (ret != 0) {
    e90c:	f06f 0004 	mvn.w	r0, #4
}
    e910:	b00c      	add	sp, #48	; 0x30
    e912:	bd70      	pop	{r4, r5, r6, pc}
	switch (res) {
    e914:	f105 4374 	add.w	r3, r5, #4093640704	; 0xf4000000
    e918:	f503 03a6 	add.w	r3, r3, #5439488	; 0x530000
    e91c:	2b0a      	cmp	r3, #10
    e91e:	d902      	bls.n	e926 <qspi_nor_init+0xa6>
	if (ret != 0) {
    e920:	f06f 000f 	mvn.w	r0, #15
    e924:	e7f4      	b.n	e910 <qspi_nor_init+0x90>
    e926:	4a1f      	ldr	r2, [pc, #124]	; (e9a4 <qspi_nor_init+0x124>)
    e928:	56d0      	ldrsb	r0, [r2, r3]
    e92a:	2800      	cmp	r0, #0
    e92c:	d1f0      	bne.n	e910 <qspi_nor_init+0x90>
	const struct qspi_cmd cmd = {
    e92e:	239f      	movs	r3, #159	; 0x9f
	const struct qspi_buf q_rx_buf = {
    e930:	2503      	movs	r5, #3
	const struct qspi_cmd cmd = {
    e932:	f88d 300c 	strb.w	r3, [sp, #12]
    e936:	9004      	str	r0, [sp, #16]
    e938:	ab01      	add	r3, sp, #4
	if (qspi_send_cmd(dev, &cmd) != 0) {
    e93a:	a903      	add	r1, sp, #12
    e93c:	4630      	mov	r0, r6
	const struct qspi_buf q_rx_buf = {
    e93e:	f8cd d004 	str.w	sp, [sp, #4]
    e942:	9502      	str	r5, [sp, #8]
	const struct qspi_cmd cmd = {
    e944:	9305      	str	r3, [sp, #20]
	if (qspi_send_cmd(dev, &cmd) != 0) {
    e946:	f7ff ff61 	bl	e80c <qspi_send_cmd>
    e94a:	bb08      	cbnz	r0, e990 <qspi_nor_init+0x110>
	if (memcmp(flash_id->id, rx_b, QSPI_NOR_MAX_ID_LEN) != 0) {
    e94c:	462a      	mov	r2, r5
    e94e:	4669      	mov	r1, sp
    e950:	4620      	mov	r0, r4
    e952:	f007 fb62 	bl	1601a <memcmp>
    e956:	2800      	cmp	r0, #0
    e958:	d0da      	beq.n	e910 <qspi_nor_init+0x90>
    e95a:	4a13      	ldr	r2, [pc, #76]	; (e9a8 <qspi_nor_init+0x128>)
    e95c:	4b13      	ldr	r3, [pc, #76]	; (e9ac <qspi_nor_init+0x12c>)
		LOG_ERR("flash id error. Extected: [%d %d %d], got: [%d %d %d]",
    e95e:	4814      	ldr	r0, [pc, #80]	; (e9b0 <qspi_nor_init+0x130>)
    e960:	1a9b      	subs	r3, r3, r2
    e962:	7822      	ldrb	r2, [r4, #0]
    e964:	9206      	str	r2, [sp, #24]
    e966:	7862      	ldrb	r2, [r4, #1]
    e968:	9207      	str	r2, [sp, #28]
    e96a:	78a2      	ldrb	r2, [r4, #2]
    e96c:	9208      	str	r2, [sp, #32]
    e96e:	f89d 2000 	ldrb.w	r2, [sp]
    e972:	9209      	str	r2, [sp, #36]	; 0x24
    e974:	40eb      	lsrs	r3, r5
    e976:	f89d 2001 	ldrb.w	r2, [sp, #1]
    e97a:	920a      	str	r2, [sp, #40]	; 0x28
    e97c:	019b      	lsls	r3, r3, #6
    e97e:	f89d 2002 	ldrb.w	r2, [sp, #2]
    e982:	920b      	str	r2, [sp, #44]	; 0x2c
    e984:	f043 0301 	orr.w	r3, r3, #1
    e988:	2206      	movs	r2, #6
    e98a:	a906      	add	r1, sp, #24
    e98c:	f006 fcb3 	bl	152f6 <log_n>
		return -ENODEV;
    e990:	f06f 0012 	mvn.w	r0, #18
	return qspi_nor_configure(dev);
    e994:	e7bc      	b.n	e910 <qspi_nor_init+0x90>
    e996:	bf00      	nop
    e998:	15141113 	.word	0x15141113
    e99c:	0001744b 	.word	0x0001744b
    e9a0:	0bad0000 	.word	0x0bad0000
    e9a4:	0001c027 	.word	0x0001c027
    e9a8:	0001956c 	.word	0x0001956c
    e9ac:	0001963c 	.word	0x0001963c
    e9b0:	0001bfe8 	.word	0x0001bfe8

0000e9b4 <flash_nrf_pages_layout>:
	*layout = &dev_layout;
    e9b4:	4b02      	ldr	r3, [pc, #8]	; (e9c0 <flash_nrf_pages_layout+0xc>)
    e9b6:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
    e9b8:	2301      	movs	r3, #1
    e9ba:	6013      	str	r3, [r2, #0]
}
    e9bc:	4770      	bx	lr
    e9be:	bf00      	nop
    e9c0:	20003b44 	.word	0x20003b44

0000e9c4 <nrf_flash_init>:
{
    e9c4:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
    e9c6:	2201      	movs	r2, #1
    e9c8:	4611      	mov	r1, r2
    e9ca:	4808      	ldr	r0, [pc, #32]	; (e9ec <nrf_flash_init+0x28>)
    e9cc:	f00a fa9d 	bl	18f0a <z_impl_k_sem_init>
    e9d0:	2201      	movs	r2, #1
    e9d2:	2100      	movs	r1, #0
    e9d4:	4806      	ldr	r0, [pc, #24]	; (e9f0 <nrf_flash_init+0x2c>)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
    e9d6:	4c07      	ldr	r4, [pc, #28]	; (e9f4 <nrf_flash_init+0x30>)
    e9d8:	f00a fa97 	bl	18f0a <z_impl_k_sem_init>
    e9dc:	f008 ff00 	bl	177e0 <nrfx_nvmc_flash_page_count_get>
    e9e0:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
    e9e2:	f008 fef9 	bl	177d8 <nrfx_nvmc_flash_page_size_get>
    e9e6:	6060      	str	r0, [r4, #4]
}
    e9e8:	2000      	movs	r0, #0
    e9ea:	bd10      	pop	{r4, pc}
    e9ec:	20003b4c 	.word	0x20003b4c
    e9f0:	20003b64 	.word	0x20003b64
    e9f4:	20003b44 	.word	0x20003b44

0000e9f8 <time_slot_callback_work>:
{
    e9f8:	b530      	push	{r4, r5, lr}
    e9fa:	461d      	mov	r5, r3
    e9fc:	b085      	sub	sp, #20
	if (op_desc->handler(op_desc->context) == FLASH_OP_DONE) {
    e9fe:	e9d3 3000 	ldrd	r3, r0, [r3]
    ea02:	4798      	blx	r3
    ea04:	4604      	mov	r4, r0
    ea06:	b990      	cbnz	r0, ea2e <time_slot_callback_work+0x36>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    ea08:	f10d 010f 	add.w	r1, sp, #15
    ea0c:	f10d 000e 	add.w	r0, sp, #14
    ea10:	f007 ff64 	bl	168dc <ll_timeslice_ticker_id_get>
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
    ea14:	f89d 200f 	ldrb.w	r2, [sp, #15]
    ea18:	f89d 000e 	ldrb.w	r0, [sp, #14]
    ea1c:	9400      	str	r4, [sp, #0]
    ea1e:	4623      	mov	r3, r4
    ea20:	4621      	mov	r1, r4
    ea22:	f7fa fd53 	bl	94cc <ticker_stop>
		((struct flash_op_desc *)context)->result = 0;
    ea26:	60ac      	str	r4, [r5, #8]
	z_impl_k_sem_give(sem);
    ea28:	4802      	ldr	r0, [pc, #8]	; (ea34 <time_slot_callback_work+0x3c>)
    ea2a:	f005 fc5f 	bl	142ec <z_impl_k_sem_give>
}
    ea2e:	b005      	add	sp, #20
    ea30:	bd30      	pop	{r4, r5, pc}
    ea32:	bf00      	nop
    ea34:	20003b64 	.word	0x20003b64

0000ea38 <flash_nrf_erase>:
{
    ea38:	b5f0      	push	{r4, r5, r6, r7, lr}
    ea3a:	b08b      	sub	sp, #44	; 0x2c
    ea3c:	460e      	mov	r6, r1
    ea3e:	4615      	mov	r5, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    ea40:	f008 feca 	bl	177d8 <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
    ea44:	4629      	mov	r1, r5
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    ea46:	4607      	mov	r7, r0
	if (is_regular_addr_valid(addr, size)) {
    ea48:	4630      	mov	r0, r6
    ea4a:	f008 fd25 	bl	17498 <is_regular_addr_valid>
    ea4e:	2800      	cmp	r0, #0
    ea50:	d03d      	beq.n	eace <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6e>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
    ea52:	fbb6 f3f7 	udiv	r3, r6, r7
    ea56:	fb07 6313 	mls	r3, r7, r3, r6
    ea5a:	2b00      	cmp	r3, #0
    ea5c:	d137      	bne.n	eace <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6e>
    ea5e:	fbb5 f4f7 	udiv	r4, r5, r7
    ea62:	fb07 5414 	mls	r4, r7, r4, r5
    ea66:	bb94      	cbnz	r4, eace <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6e>
		if (!n_pages) {
    ea68:	42af      	cmp	r7, r5
    ea6a:	d824      	bhi.n	eab6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x56>
	return z_impl_k_sem_take(sem, timeout);
    ea6c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ea70:	4818      	ldr	r0, [pc, #96]	; (ead4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x74>)
    ea72:	f005 fc61 	bl	14338 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
    ea76:	4620      	mov	r0, r4
    ea78:	f7fa fc74 	bl	9364 <ticker_is_initialized>
    ea7c:	ab04      	add	r3, sp, #16
    ea7e:	4601      	mov	r1, r0
    ea80:	b1e0      	cbz	r0, eabc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5c>
	struct flash_context context = {
    ea82:	2210      	movs	r2, #16
    ea84:	4621      	mov	r1, r4
    ea86:	4618      	mov	r0, r3
    ea88:	f007 fb02 	bl	16090 <memset>
    ea8c:	2201      	movs	r2, #1
    ea8e:	f88d 201c 	strb.w	r2, [sp, #28]
    ea92:	4a11      	ldr	r2, [pc, #68]	; (ead8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78>)
    ea94:	9208      	str	r2, [sp, #32]
    ea96:	f2a2 62a4 	subw	r2, r2, #1700	; 0x6a4
    ea9a:	9209      	str	r2, [sp, #36]	; 0x24
	struct flash_op_desc flash_op_desc = {
    ea9c:	4a0f      	ldr	r2, [pc, #60]	; (eadc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7c>)
    ea9e:	9403      	str	r4, [sp, #12]
    eaa0:	e9cd 2001 	strd	r2, r0, [sp, #4]
	return work_in_time_slice(&flash_op_desc);
    eaa4:	a801      	add	r0, sp, #4
	struct flash_context context = {
    eaa6:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return work_in_time_slice(&flash_op_desc);
    eaaa:	f7f2 fa99 	bl	fe0 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_PARTIAL_ERASE)
		.flash_addr_next = addr
#endif
	};

	return	erase_op(&context);
    eaae:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
    eab0:	4808      	ldr	r0, [pc, #32]	; (ead4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x74>)
    eab2:	f005 fc1b 	bl	142ec <z_impl_k_sem_give>
}
    eab6:	4620      	mov	r0, r4
    eab8:	b00b      	add	sp, #44	; 0x2c
    eaba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
    eabc:	2218      	movs	r2, #24
    eabe:	4618      	mov	r0, r3
    eac0:	f007 fae6 	bl	16090 <memset>
    eac4:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return	erase_op(&context);
    eac8:	f7f2 fa42 	bl	f50 <erase_op>
    eacc:	e7ef      	b.n	eaae <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4e>
		return -EINVAL;
    eace:	f06f 0415 	mvn.w	r4, #21
    ead2:	e7f0      	b.n	eab6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x56>
    ead4:	20003b4c 	.word	0x20003b4c
    ead8:	00016508 	.word	0x00016508
    eadc:	00000f51 	.word	0x00000f51

0000eae0 <time_slot_delay>:
{
    eae0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eae4:	b08c      	sub	sp, #48	; 0x30
	err = ticker_start(instance_index, /* Radio instance ticker */
    eae6:	2400      	movs	r4, #0
{
    eae8:	4690      	mov	r8, r2
    eaea:	461d      	mov	r5, r3
    eaec:	4606      	mov	r6, r0
    eaee:	460f      	mov	r7, r1
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    eaf0:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
    eaf4:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
    eaf8:	f007 fef0 	bl	168dc <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index, /* Radio instance ticker */
    eafc:	4633      	mov	r3, r6
    eafe:	e9cd 4407 	strd	r4, r4, [sp, #28]
    eb02:	e9cd 8505 	strd	r8, r5, [sp, #20]
    eb06:	e9cd 4403 	strd	r4, r4, [sp, #12]
    eb0a:	e9cd 4401 	strd	r4, r4, [sp, #4]
    eb0e:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
    eb12:	9700      	str	r7, [sp, #0]
    eb14:	4622      	mov	r2, r4
    eb16:	4621      	mov	r1, r4
    eb18:	f007 fe70 	bl	167fc <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    eb1c:	f030 0302 	bics.w	r3, r0, #2
    eb20:	d00e      	beq.n	eb40 <time_slot_delay+0x60>
		((struct flash_op_desc *)context)->result = -ECANCELED;
    eb22:	f06f 0347 	mvn.w	r3, #71	; 0x47
    eb26:	60ab      	str	r3, [r5, #8]
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
    eb28:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    eb2c:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
    eb30:	9400      	str	r4, [sp, #0]
    eb32:	4623      	mov	r3, r4
    eb34:	4621      	mov	r1, r4
    eb36:	f7fa fcc9 	bl	94cc <ticker_stop>
    eb3a:	4803      	ldr	r0, [pc, #12]	; (eb48 <time_slot_delay+0x68>)
    eb3c:	f005 fbd6 	bl	142ec <z_impl_k_sem_give>
}
    eb40:	b00c      	add	sp, #48	; 0x30
    eb42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    eb46:	bf00      	nop
    eb48:	20003b64 	.word	0x20003b64

0000eb4c <time_slot_callback_prepare>:
	time_slot_delay(ticks_at_expire,
    eb4c:	4a01      	ldr	r2, [pc, #4]	; (eb54 <time_slot_callback_prepare+0x8>)
    eb4e:	2131      	movs	r1, #49	; 0x31
    eb50:	f7ff bfc6 	b.w	eae0 <time_slot_delay>
    eb54:	0000eb59 	.word	0x0000eb59

0000eb58 <time_slot_callback_abort>:
{
    eb58:	b570      	push	{r4, r5, r6, lr}
    eb5a:	4604      	mov	r4, r0
    eb5c:	461d      	mov	r5, r3
	ll_radio_state_abort();
    eb5e:	f7fb fc6b 	bl	a438 <ll_radio_state_abort>
	time_slot_delay(ticks_at_expire,
    eb62:	462b      	mov	r3, r5
    eb64:	4620      	mov	r0, r4
    eb66:	4a03      	ldr	r2, [pc, #12]	; (eb74 <time_slot_callback_abort+0x1c>)
}
    eb68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	time_slot_delay(ticks_at_expire,
    eb6c:	2106      	movs	r1, #6
    eb6e:	f7ff bfb7 	b.w	eae0 <time_slot_delay>
    eb72:	bf00      	nop
    eb74:	0000e9f9 	.word	0x0000e9f9

0000eb78 <flash_nrf_write>:
{
    eb78:	b5f0      	push	{r4, r5, r6, r7, lr}
    eb7a:	460d      	mov	r5, r1
    eb7c:	b08b      	sub	sp, #44	; 0x2c
	if (is_regular_addr_valid(addr, len)) {
    eb7e:	4619      	mov	r1, r3
    eb80:	4628      	mov	r0, r5
{
    eb82:	4617      	mov	r7, r2
    eb84:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
    eb86:	f008 fc87 	bl	17498 <is_regular_addr_valid>
    eb8a:	b398      	cbz	r0, ebf4 <flash_nrf_write+0x7c>
	if (!is_aligned_32(addr) || (len % sizeof(u32_t))) {
    eb8c:	ea45 0604 	orr.w	r6, r5, r4
    eb90:	f016 0603 	ands.w	r6, r6, #3
    eb94:	d12e      	bne.n	ebf4 <flash_nrf_write+0x7c>
	if (!len) {
    eb96:	b30c      	cbz	r4, ebdc <flash_nrf_write+0x64>
	return z_impl_k_sem_take(sem, timeout);
    eb98:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    eb9c:	4817      	ldr	r0, [pc, #92]	; (ebfc <flash_nrf_write+0x84>)
    eb9e:	f005 fbcb 	bl	14338 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
    eba2:	4630      	mov	r0, r6
    eba4:	f7fa fbde 	bl	9364 <ticker_is_initialized>
    eba8:	4603      	mov	r3, r0
    ebaa:	a804      	add	r0, sp, #16
    ebac:	b1cb      	cbz	r3, ebe2 <flash_nrf_write+0x6a>
	struct flash_context context = {
    ebae:	2301      	movs	r3, #1
    ebb0:	f88d 301c 	strb.w	r3, [sp, #28]
    ebb4:	f641 524c 	movw	r2, #7500	; 0x1d4c
    ebb8:	f241 63a8 	movw	r3, #5800	; 0x16a8
    ebbc:	e9cd 2308 	strd	r2, r3, [sp, #32]
	struct flash_op_desc flash_op_desc = {
    ebc0:	4b0f      	ldr	r3, [pc, #60]	; (ec00 <flash_nrf_write+0x88>)
	struct flash_context context = {
    ebc2:	9406      	str	r4, [sp, #24]
	struct flash_op_desc flash_op_desc = {
    ebc4:	e9cd 3001 	strd	r3, r0, [sp, #4]
	return  work_in_time_slice(&flash_op_desc);
    ebc8:	a801      	add	r0, sp, #4
	struct flash_context context = {
    ebca:	e9cd 7504 	strd	r7, r5, [sp, #16]
	struct flash_op_desc flash_op_desc = {
    ebce:	9603      	str	r6, [sp, #12]
	return  work_in_time_slice(&flash_op_desc);
    ebd0:	f7f2 fa06 	bl	fe0 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return write_op(&context);
    ebd4:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
    ebd6:	4809      	ldr	r0, [pc, #36]	; (ebfc <flash_nrf_write+0x84>)
    ebd8:	f005 fb88 	bl	142ec <z_impl_k_sem_give>
}
    ebdc:	4620      	mov	r0, r4
    ebde:	b00b      	add	sp, #44	; 0x2c
    ebe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
    ebe2:	e9cd 3307 	strd	r3, r3, [sp, #28]
    ebe6:	e9cd 7504 	strd	r7, r5, [sp, #16]
    ebea:	9309      	str	r3, [sp, #36]	; 0x24
    ebec:	9406      	str	r4, [sp, #24]
	return write_op(&context);
    ebee:	f7f2 fa6f 	bl	10d0 <write_op>
    ebf2:	e7ef      	b.n	ebd4 <flash_nrf_write+0x5c>
		return -EINVAL;
    ebf4:	f06f 0415 	mvn.w	r4, #21
    ebf8:	e7f0      	b.n	ebdc <flash_nrf_write+0x64>
    ebfa:	bf00      	nop
    ebfc:	20003b4c 	.word	0x20003b4c
    ec00:	000010d1 	.word	0x000010d1

0000ec04 <event_txdrdy_check>:
#endif
}

NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ec04:	4b05      	ldr	r3, [pc, #20]	; (ec1c <event_txdrdy_check+0x18>)
    ec06:	681b      	ldr	r3, [r3, #0]

static bool event_txdrdy_check(void)
{
	return (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_TXDRDY)
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
		|| uart_sw_event_txdrdy
    ec08:	b92b      	cbnz	r3, ec16 <event_txdrdy_check+0x12>
    ec0a:	4b05      	ldr	r3, [pc, #20]	; (ec20 <event_txdrdy_check+0x1c>)
    ec0c:	7818      	ldrb	r0, [r3, #0]
    ec0e:	3800      	subs	r0, #0
    ec10:	bf18      	it	ne
    ec12:	2001      	movne	r0, #1
    ec14:	4770      	bx	lr
    ec16:	2001      	movs	r0, #1
#endif
	       );
}
    ec18:	4770      	bx	lr
    ec1a:	bf00      	nop
    ec1c:	4000211c 	.word	0x4000211c
    ec20:	200087b9 	.word	0x200087b9

0000ec24 <uart_nrfx_err_check>:
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
{
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    ec24:	4b02      	ldr	r3, [pc, #8]	; (ec30 <uart_nrfx_err_check+0xc>)
    ec26:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    ec2a:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
/** Console I/O function */
static int uart_nrfx_err_check(struct device *dev)
{
	/* register bitfields maps to the defines in uart.h */
	return nrf_uart_errorsrc_get_and_clear(uart0_addr);
}
    ec2e:	4770      	bx	lr
    ec30:	40002000 	.word	0x40002000

0000ec34 <uart_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
    ec34:	4b02      	ldr	r3, [pc, #8]	; (ec40 <uart_nrfx_irq_rx_enable+0xc>)
    ec36:	2204      	movs	r2, #4
    ec38:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven receiver enabling function */
static void uart_nrfx_irq_rx_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    ec3c:	4770      	bx	lr
    ec3e:	bf00      	nop
    ec40:	40002000 	.word	0x40002000

0000ec44 <uart_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
    ec44:	4b02      	ldr	r3, [pc, #8]	; (ec50 <uart_nrfx_irq_rx_disable+0xc>)
    ec46:	2204      	movs	r2, #4
    ec48:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven receiver disabling function */
static void uart_nrfx_irq_rx_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    ec4c:	4770      	bx	lr
    ec4e:	bf00      	nop
    ec50:	40002000 	.word	0x40002000

0000ec54 <uart_nrfx_irq_rx_ready>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ec54:	4b02      	ldr	r3, [pc, #8]	; (ec60 <uart_nrfx_irq_rx_ready+0xc>)
    ec56:	6818      	ldr	r0, [r3, #0]

/** Interrupt driven receiver ready function */
static int uart_nrfx_irq_rx_ready(struct device *dev)
{
	return nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY);
}
    ec58:	3800      	subs	r0, #0
    ec5a:	bf18      	it	ne
    ec5c:	2001      	movne	r0, #1
    ec5e:	4770      	bx	lr
    ec60:	40002108 	.word	0x40002108

0000ec64 <uart_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
    ec64:	4b02      	ldr	r3, [pc, #8]	; (ec70 <uart_nrfx_irq_err_enable+0xc>)
    ec66:	f44f 7200 	mov.w	r2, #512	; 0x200
    ec6a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven error enabling function */
static void uart_nrfx_irq_err_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    ec6e:	4770      	bx	lr
    ec70:	40002000 	.word	0x40002000

0000ec74 <uart_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
    ec74:	4b02      	ldr	r3, [pc, #8]	; (ec80 <uart_nrfx_irq_err_disable+0xc>)
    ec76:	f44f 7200 	mov.w	r2, #512	; 0x200
    ec7a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven error disabling function */
static void uart_nrfx_irq_err_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    ec7e:	4770      	bx	lr
    ec80:	40002000 	.word	0x40002000

0000ec84 <uart_nrfx_irq_callback_set>:
static void uart_nrfx_irq_callback_set(struct device *dev,
				       uart_irq_callback_user_data_t cb,
				       void *cb_data)
{
	(void)dev;
	irq_callback = cb;
    ec84:	4b02      	ldr	r3, [pc, #8]	; (ec90 <uart_nrfx_irq_callback_set+0xc>)
    ec86:	6019      	str	r1, [r3, #0]
	irq_cb_data = cb_data;
    ec88:	4b02      	ldr	r3, [pc, #8]	; (ec94 <uart_nrfx_irq_callback_set+0x10>)
    ec8a:	601a      	str	r2, [r3, #0]
}
    ec8c:	4770      	bx	lr
    ec8e:	bf00      	nop
    ec90:	20003b7c 	.word	0x20003b7c
    ec94:	20003b80 	.word	0x20003b80

0000ec98 <uart_nrfx_irq_tx_disable>:
    ec98:	4b03      	ldr	r3, [pc, #12]	; (eca8 <uart_nrfx_irq_tx_disable+0x10>)
    ec9a:	2280      	movs	r2, #128	; 0x80
    ec9c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->TXD = txd;
}

NRF_STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    eca0:	2201      	movs	r2, #1
    eca2:	60da      	str	r2, [r3, #12]
	device_busy_clear(dev);
    eca4:	f009 be45 	b.w	18932 <device_busy_clear>
    eca8:	40002000 	.word	0x40002000

0000ecac <uart_nrfx_irq_tx_enable>:
{
    ecac:	b508      	push	{r3, lr}
	device_busy_set(dev);
    ecae:	f009 fe3f 	bl	18930 <device_busy_set>
    ecb2:	4b0d      	ldr	r3, [pc, #52]	; (ece8 <uart_nrfx_irq_tx_enable+0x3c>)
    ecb4:	2201      	movs	r2, #1
    ecb6:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
    ecb8:	2280      	movs	r2, #128	; 0x80
    ecba:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	__asm__ volatile(
    ecbe:	f04f 0220 	mov.w	r2, #32
    ecc2:	f3ef 8311 	mrs	r3, BASEPRI
    ecc6:	f382 8811 	msr	BASEPRI, r2
    ecca:	f3bf 8f6f 	isb	sy
	if (uart_sw_event_txdrdy) {
    ecce:	4a07      	ldr	r2, [pc, #28]	; (ecec <uart_nrfx_irq_tx_enable+0x40>)
    ecd0:	7812      	ldrb	r2, [r2, #0]
    ecd2:	b11a      	cbz	r2, ecdc <uart_nrfx_irq_tx_enable+0x30>
    ecd4:	4a06      	ldr	r2, [pc, #24]	; (ecf0 <uart_nrfx_irq_tx_enable+0x44>)
    ecd6:	2104      	movs	r1, #4
    ecd8:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
	__asm__ volatile(
    ecdc:	f383 8811 	msr	BASEPRI, r3
    ece0:	f3bf 8f6f 	isb	sy
}
    ece4:	bd08      	pop	{r3, pc}
    ece6:	bf00      	nop
    ece8:	40002008 	.word	0x40002008
    ecec:	200087b9 	.word	0x200087b9
    ecf0:	e000e100 	.word	0xe000e100

0000ecf4 <uart_nrfx_irq_is_pending>:
{
    ecf4:	b508      	push	{r3, lr}
    return p_reg->INTENSET & mask;
    ecf6:	4b0c      	ldr	r3, [pc, #48]	; (ed28 <uart_nrfx_irq_is_pending+0x34>)
    ecf8:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
		||
    ecfc:	f012 0f80 	tst.w	r2, #128	; 0x80
    ed00:	461a      	mov	r2, r3
    ed02:	d105      	bne.n	ed10 <uart_nrfx_irq_is_pending+0x1c>
    ed04:	f8d2 0304 	ldr.w	r0, [r2, #772]	; 0x304
    ed08:	f010 0004 	ands.w	r0, r0, #4
    ed0c:	d106      	bne.n	ed1c <uart_nrfx_irq_is_pending+0x28>
}
    ed0e:	bd08      	pop	{r3, pc}
		 event_txdrdy_check())
    ed10:	f7ff ff78 	bl	ec04 <event_txdrdy_check>
					   NRF_UART_INT_MASK_TXDRDY) &&
    ed14:	2800      	cmp	r0, #0
    ed16:	d0f5      	beq.n	ed04 <uart_nrfx_irq_is_pending+0x10>
		||
    ed18:	2001      	movs	r0, #1
    ed1a:	e7f8      	b.n	ed0e <uart_nrfx_irq_is_pending+0x1a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ed1c:	4b03      	ldr	r3, [pc, #12]	; (ed2c <uart_nrfx_irq_is_pending+0x38>)
    ed1e:	6818      	ldr	r0, [r3, #0]
					   NRF_UART_INT_MASK_RXDRDY) &&
    ed20:	3800      	subs	r0, #0
    ed22:	bf18      	it	ne
    ed24:	2001      	movne	r0, #1
    ed26:	e7f2      	b.n	ed0e <uart_nrfx_irq_is_pending+0x1a>
    ed28:	40002000 	.word	0x40002000
    ed2c:	40002108 	.word	0x40002108

0000ed30 <uart_nrfx_configure>:
{
    ed30:	b570      	push	{r4, r5, r6, lr}
	switch (cfg->stop_bits) {
    ed32:	794b      	ldrb	r3, [r1, #5]
    ed34:	2b01      	cmp	r3, #1
    ed36:	d028      	beq.n	ed8a <uart_nrfx_configure+0x5a>
    ed38:	2b03      	cmp	r3, #3
    ed3a:	d123      	bne.n	ed84 <uart_nrfx_configure+0x54>
		uart_cfg.stop = NRF_UART_STOP_TWO;
    ed3c:	2610      	movs	r6, #16
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    ed3e:	798b      	ldrb	r3, [r1, #6]
    ed40:	2b03      	cmp	r3, #3
    ed42:	d11f      	bne.n	ed84 <uart_nrfx_configure+0x54>
	switch (cfg->flow_ctrl) {
    ed44:	79cc      	ldrb	r4, [r1, #7]
    ed46:	b12c      	cbz	r4, ed54 <uart_nrfx_configure+0x24>
    ed48:	2c01      	cmp	r4, #1
    ed4a:	d11b      	bne.n	ed84 <uart_nrfx_configure+0x54>
	return dev->config->config_info;
    ed4c:	6803      	ldr	r3, [r0, #0]
		if (get_dev_config(dev)->rts_cts_pins_set) {
    ed4e:	689b      	ldr	r3, [r3, #8]
    ed50:	781b      	ldrb	r3, [r3, #0]
    ed52:	b1bb      	cbz	r3, ed84 <uart_nrfx_configure+0x54>
	switch (cfg->parity) {
    ed54:	790a      	ldrb	r2, [r1, #4]
    ed56:	b112      	cbz	r2, ed5e <uart_nrfx_configure+0x2e>
    ed58:	2a02      	cmp	r2, #2
    ed5a:	d113      	bne.n	ed84 <uart_nrfx_configure+0x54>
		uart_cfg.parity = NRF_UART_PARITY_INCLUDED;
    ed5c:	220e      	movs	r2, #14
	if (baudrate_set(dev, cfg->baudrate) != 0) {
    ed5e:	680b      	ldr	r3, [r1, #0]
	switch (baudrate) {
    ed60:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    ed64:	d062      	beq.n	ee2c <uart_nrfx_configure+0xfc>
    ed66:	d82d      	bhi.n	edc4 <uart_nrfx_configure+0x94>
    ed68:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    ed6c:	d060      	beq.n	ee30 <uart_nrfx_configure+0x100>
    ed6e:	d816      	bhi.n	ed9e <uart_nrfx_configure+0x6e>
    ed70:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    ed74:	d05e      	beq.n	ee34 <uart_nrfx_configure+0x104>
    ed76:	d80a      	bhi.n	ed8e <uart_nrfx_configure+0x5e>
    ed78:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    ed7c:	d05d      	beq.n	ee3a <uart_nrfx_configure+0x10a>
    ed7e:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    ed82:	d05d      	beq.n	ee40 <uart_nrfx_configure+0x110>
    ed84:	f06f 0022 	mvn.w	r0, #34	; 0x22
    ed88:	e04f      	b.n	ee2a <uart_nrfx_configure+0xfa>
	switch (cfg->stop_bits) {
    ed8a:	2600      	movs	r6, #0
    ed8c:	e7d7      	b.n	ed3e <uart_nrfx_configure+0xe>
	switch (baudrate) {
    ed8e:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    ed92:	d058      	beq.n	ee46 <uart_nrfx_configure+0x116>
    ed94:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    ed98:	d1f4      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
    ed9a:	4b35      	ldr	r3, [pc, #212]	; (ee70 <uart_nrfx_configure+0x140>)
    ed9c:	e039      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    ed9e:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    eda2:	d053      	beq.n	ee4c <uart_nrfx_configure+0x11c>
    eda4:	d807      	bhi.n	edb6 <uart_nrfx_configure+0x86>
    eda6:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    edaa:	d051      	beq.n	ee50 <uart_nrfx_configure+0x120>
    edac:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    edb0:	d1e8      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
    edb2:	4b30      	ldr	r3, [pc, #192]	; (ee74 <uart_nrfx_configure+0x144>)
    edb4:	e02d      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    edb6:	f647 2512 	movw	r5, #31250	; 0x7a12
    edba:	42ab      	cmp	r3, r5
    edbc:	d1e2      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
    edbe:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    edc2:	e026      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    edc4:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    edc8:	d045      	beq.n	ee56 <uart_nrfx_configure+0x126>
    edca:	d811      	bhi.n	edf0 <uart_nrfx_configure+0xc0>
    edcc:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    edd0:	d043      	beq.n	ee5a <uart_nrfx_configure+0x12a>
    edd2:	d808      	bhi.n	ede6 <uart_nrfx_configure+0xb6>
    edd4:	f64d 25c0 	movw	r5, #56000	; 0xdac0
    edd8:	42ab      	cmp	r3, r5
    edda:	d040      	beq.n	ee5e <uart_nrfx_configure+0x12e>
    eddc:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    ede0:	d1d0      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
    ede2:	4b25      	ldr	r3, [pc, #148]	; (ee78 <uart_nrfx_configure+0x148>)
    ede4:	e015      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    ede6:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    edea:	d1cb      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
    edec:	4b23      	ldr	r3, [pc, #140]	; (ee7c <uart_nrfx_configure+0x14c>)
    edee:	e010      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    edf0:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    edf4:	d036      	beq.n	ee64 <uart_nrfx_configure+0x134>
    edf6:	d807      	bhi.n	ee08 <uart_nrfx_configure+0xd8>
    edf8:	4d21      	ldr	r5, [pc, #132]	; (ee80 <uart_nrfx_configure+0x150>)
    edfa:	42ab      	cmp	r3, r5
    edfc:	d034      	beq.n	ee68 <uart_nrfx_configure+0x138>
    edfe:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    ee02:	d1bf      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
    ee04:	4b1f      	ldr	r3, [pc, #124]	; (ee84 <uart_nrfx_configure+0x154>)
    ee06:	e004      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    ee08:	4d1f      	ldr	r5, [pc, #124]	; (ee88 <uart_nrfx_configure+0x158>)
    ee0a:	42ab      	cmp	r3, r5
    ee0c:	d1ba      	bne.n	ed84 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
    ee0e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    ee12:	4d1e      	ldr	r5, [pc, #120]	; (ee8c <uart_nrfx_configure+0x15c>)
                    | (uint32_t)p_cfg->hwfc;
    ee14:	4334      	orrs	r4, r6
    ee16:	4322      	orrs	r2, r4
    p_reg->BAUDRATE = baudrate;
    ee18:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    ee1c:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
	get_dev_data(dev)->uart_config = *cfg;
    ee20:	6883      	ldr	r3, [r0, #8]
    ee22:	c903      	ldmia	r1, {r0, r1}
    ee24:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
    ee28:	2000      	movs	r0, #0
}
    ee2a:	bd70      	pop	{r4, r5, r6, pc}
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
    ee2c:	4b18      	ldr	r3, [pc, #96]	; (ee90 <uart_nrfx_configure+0x160>)
    ee2e:	e7f0      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
    ee30:	4b18      	ldr	r3, [pc, #96]	; (ee94 <uart_nrfx_configure+0x164>)
    ee32:	e7ee      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
    ee34:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    ee38:	e7eb      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = 0x00014000;
    ee3a:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    ee3e:	e7e8      	b.n	ee12 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
    ee40:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    ee44:	e7e5      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
    ee46:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    ee4a:	e7e2      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
    ee4c:	4b12      	ldr	r3, [pc, #72]	; (ee98 <uart_nrfx_configure+0x168>)
    ee4e:	e7e0      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
    ee50:	f44f 136c 	mov.w	r3, #3866624	; 0x3b0000
    ee54:	e7dd      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
    ee56:	4b11      	ldr	r3, [pc, #68]	; (ee9c <uart_nrfx_configure+0x16c>)
    ee58:	e7db      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
    ee5a:	4b11      	ldr	r3, [pc, #68]	; (eea0 <uart_nrfx_configure+0x170>)
    ee5c:	e7d9      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
    ee5e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    ee62:	e7d6      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
    ee64:	4b0f      	ldr	r3, [pc, #60]	; (eea4 <uart_nrfx_configure+0x174>)
    ee66:	e7d4      	b.n	ee12 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
    ee68:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    ee6c:	e7d1      	b.n	ee12 <uart_nrfx_configure+0xe2>
    ee6e:	bf00      	nop
    ee70:	0013b000 	.word	0x0013b000
    ee74:	004ea000 	.word	0x004ea000
    ee78:	00ebf000 	.word	0x00ebf000
    ee7c:	01d7e000 	.word	0x01d7e000
    ee80:	0003d090 	.word	0x0003d090
    ee84:	075f7000 	.word	0x075f7000
    ee88:	000f4240 	.word	0x000f4240
    ee8c:	40002000 	.word	0x40002000
    ee90:	009d5000 	.word	0x009d5000
    ee94:	00275000 	.word	0x00275000
    ee98:	0075f000 	.word	0x0075f000
    ee9c:	03afb000 	.word	0x03afb000
    eea0:	013a9000 	.word	0x013a9000
    eea4:	0ebed000 	.word	0x0ebed000

0000eea8 <uart_nrfx_isr>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    eea8:	4b08      	ldr	r3, [pc, #32]	; (eecc <uart_nrfx_isr+0x24>)
    eeaa:	681a      	ldr	r2, [r3, #0]
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_nrfx_isr(void *arg)
{
    eeac:	b082      	sub	sp, #8
	ARG_UNUSED(arg);

	if (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_ERROR)) {
    eeae:	b122      	cbz	r2, eeba <uart_nrfx_isr+0x12>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    eeb0:	2200      	movs	r2, #0
    eeb2:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    eeb4:	681b      	ldr	r3, [r3, #0]
    eeb6:	9301      	str	r3, [sp, #4]
    (void)dummy;
    eeb8:	9b01      	ldr	r3, [sp, #4]
		nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_ERROR);
	}

	if (irq_callback) {
    eeba:	4b05      	ldr	r3, [pc, #20]	; (eed0 <uart_nrfx_isr+0x28>)
    eebc:	681b      	ldr	r3, [r3, #0]
    eebe:	b11b      	cbz	r3, eec8 <uart_nrfx_isr+0x20>
		irq_callback(irq_cb_data);
    eec0:	4a04      	ldr	r2, [pc, #16]	; (eed4 <uart_nrfx_isr+0x2c>)
    eec2:	6810      	ldr	r0, [r2, #0]
	}
}
    eec4:	b002      	add	sp, #8
		irq_callback(irq_cb_data);
    eec6:	4718      	bx	r3
}
    eec8:	b002      	add	sp, #8
    eeca:	4770      	bx	lr
    eecc:	40002124 	.word	0x40002124
    eed0:	20003b7c 	.word	0x20003b7c
    eed4:	20003b80 	.word	0x20003b80

0000eed8 <uart_nrfx_fifo_read>:
{
    eed8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while ((size - num_rx > 0) &&
    eeda:	2300      	movs	r3, #0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    eedc:	4c09      	ldr	r4, [pc, #36]	; (ef04 <uart_nrfx_fifo_read+0x2c>)
    return p_reg->RXD;
    eede:	4f0a      	ldr	r7, [pc, #40]	; (ef08 <uart_nrfx_fifo_read+0x30>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    eee0:	461e      	mov	r6, r3
    eee2:	b2d8      	uxtb	r0, r3
    eee4:	1a15      	subs	r5, r2, r0
    eee6:	2d00      	cmp	r5, #0
    eee8:	dd02      	ble.n	eef0 <uart_nrfx_fifo_read+0x18>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    eeea:	6825      	ldr	r5, [r4, #0]
    eeec:	3301      	adds	r3, #1
    eeee:	b90d      	cbnz	r5, eef4 <uart_nrfx_fifo_read+0x1c>
}
    eef0:	b003      	add	sp, #12
    eef2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    eef4:	6026      	str	r6, [r4, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    eef6:	6825      	ldr	r5, [r4, #0]
    eef8:	9501      	str	r5, [sp, #4]
    (void)dummy;
    eefa:	9d01      	ldr	r5, [sp, #4]
    return p_reg->RXD;
    eefc:	f8d7 5518 	ldr.w	r5, [r7, #1304]	; 0x518
    ef00:	540d      	strb	r5, [r1, r0]
    ef02:	e7ee      	b.n	eee2 <uart_nrfx_fifo_read+0xa>
    ef04:	40002108 	.word	0x40002108
    ef08:	40002000 	.word	0x40002000

0000ef0c <uart_nrfx_poll_out>:
{
    ef0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ef0e:	460e      	mov	r6, r1
	if (!k_is_in_isr()) {
    ef10:	f00a f80b 	bl	18f2a <k_is_in_isr>
    ef14:	4d1c      	ldr	r5, [pc, #112]	; (ef88 <uart_nrfx_poll_out+0x7c>)
    ef16:	b9b8      	cbnz	r0, ef48 <uart_nrfx_poll_out+0x3c>
    ef18:	2464      	movs	r4, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    ef1a:	2701      	movs	r7, #1
    ef1c:	f3bf 8f5b 	dmb	ish
    ef20:	e855 3f00 	ldrex	r3, [r5]
    ef24:	2b00      	cmp	r3, #0
    ef26:	d103      	bne.n	ef30 <uart_nrfx_poll_out+0x24>
    ef28:	e845 7200 	strex	r2, r7, [r5]
    ef2c:	2a00      	cmp	r2, #0
    ef2e:	d1f7      	bne.n	ef20 <uart_nrfx_poll_out+0x14>
    ef30:	f3bf 8f5b 	dmb	ish
		while (atomic_cas((atomic_t *) lock,
    ef34:	d00a      	beq.n	ef4c <uart_nrfx_poll_out+0x40>
	return z_impl_k_sleep(timeout);
    ef36:	2001      	movs	r0, #1
    ef38:	3c01      	subs	r4, #1
    ef3a:	f005 f9a9 	bl	14290 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
    ef3e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    ef42:	d1eb      	bne.n	ef1c <uart_nrfx_poll_out+0x10>
}
    ef44:	b003      	add	sp, #12
    ef46:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*lock = 1;
    ef48:	2301      	movs	r3, #1
    ef4a:	602b      	str	r3, [r5, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ef4c:	4a0f      	ldr	r2, [pc, #60]	; (ef8c <uart_nrfx_poll_out+0x80>)
    ef4e:	2300      	movs	r3, #0
    ef50:	6013      	str	r3, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    ef52:	6812      	ldr	r2, [r2, #0]
    ef54:	9201      	str	r2, [sp, #4]
    (void)dummy;
    ef56:	9a01      	ldr	r2, [sp, #4]
	uart_sw_event_txdrdy = 0U;
    ef58:	4a0d      	ldr	r2, [pc, #52]	; (ef90 <uart_nrfx_poll_out+0x84>)
    ef5a:	7013      	strb	r3, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ef5c:	4b0d      	ldr	r3, [pc, #52]	; (ef94 <uart_nrfx_poll_out+0x88>)
    ef5e:	2201      	movs	r2, #1
    ef60:	601a      	str	r2, [r3, #0]
    p_reg->TXD = txd;
    ef62:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    ef66:	f8c3 6514 	str.w	r6, [r3, #1300]	; 0x514
	NRFX_WAIT_FOR(event_txdrdy_check(), 1000, 1, res);
    ef6a:	f7ff fe4b 	bl	ec04 <event_txdrdy_check>
    ef6e:	b920      	cbnz	r0, ef7a <uart_nrfx_poll_out+0x6e>
    ef70:	2001      	movs	r0, #1
    ef72:	f008 fc29 	bl	177c8 <nrfx_busy_wait>
    ef76:	3c01      	subs	r4, #1
    ef78:	d1f7      	bne.n	ef6a <uart_nrfx_poll_out+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ef7a:	4b07      	ldr	r3, [pc, #28]	; (ef98 <uart_nrfx_poll_out+0x8c>)
    ef7c:	2201      	movs	r2, #1
    ef7e:	601a      	str	r2, [r3, #0]
	*lock = 0;
    ef80:	2300      	movs	r3, #0
    ef82:	602b      	str	r3, [r5, #0]
    ef84:	e7de      	b.n	ef44 <uart_nrfx_poll_out+0x38>
    ef86:	bf00      	nop
    ef88:	20003b84 	.word	0x20003b84
    ef8c:	4000211c 	.word	0x4000211c
    ef90:	200087b9 	.word	0x200087b9
    ef94:	40002008 	.word	0x40002008
    ef98:	4000200c 	.word	0x4000200c

0000ef9c <uart_nrfx_poll_in>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ef9c:	4b08      	ldr	r3, [pc, #32]	; (efc0 <uart_nrfx_poll_in+0x24>)
    ef9e:	681a      	ldr	r2, [r3, #0]
{
    efa0:	b082      	sub	sp, #8
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
    efa2:	b152      	cbz	r2, efba <uart_nrfx_poll_in+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    efa4:	2000      	movs	r0, #0
    efa6:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    efa8:	681b      	ldr	r3, [r3, #0]
    efaa:	9301      	str	r3, [sp, #4]
    (void)dummy;
    efac:	9b01      	ldr	r3, [sp, #4]
    return p_reg->RXD;
    efae:	4b05      	ldr	r3, [pc, #20]	; (efc4 <uart_nrfx_poll_in+0x28>)
    efb0:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
    efb4:	700b      	strb	r3, [r1, #0]
}
    efb6:	b002      	add	sp, #8
    efb8:	4770      	bx	lr
		return -1;
    efba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    efbe:	e7fa      	b.n	efb6 <uart_nrfx_poll_in+0x1a>
    efc0:	40002108 	.word	0x40002108
    efc4:	40002000 	.word	0x40002000

0000efc8 <uart_nrfx_fifo_fill>:
{
    efc8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    efcc:	4e0d      	ldr	r6, [pc, #52]	; (f004 <uart_nrfx_fifo_fill+0x3c>)
	uart_sw_event_txdrdy = 0U;
    efce:	4f0e      	ldr	r7, [pc, #56]	; (f008 <uart_nrfx_fifo_fill+0x40>)
    p_reg->TXD = txd;
    efd0:	f8df 8038 	ldr.w	r8, [pc, #56]	; f00c <uart_nrfx_fifo_fill+0x44>
	while ((len - num_tx > 0) &&
    efd4:	2400      	movs	r4, #0
    efd6:	b2e5      	uxtb	r5, r4
    efd8:	1b53      	subs	r3, r2, r5
    efda:	2b00      	cmp	r3, #0
    efdc:	dd03      	ble.n	efe6 <uart_nrfx_fifo_fill+0x1e>
	       event_txdrdy_check()) {
    efde:	f7ff fe11 	bl	ec04 <event_txdrdy_check>
    efe2:	3401      	adds	r4, #1
	while ((len - num_tx > 0) &&
    efe4:	b918      	cbnz	r0, efee <uart_nrfx_fifo_fill+0x26>
}
    efe6:	4628      	mov	r0, r5
    efe8:	b002      	add	sp, #8
    efea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    efee:	2300      	movs	r3, #0
    eff0:	6033      	str	r3, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    eff2:	6830      	ldr	r0, [r6, #0]
    eff4:	9001      	str	r0, [sp, #4]
    (void)dummy;
    eff6:	9801      	ldr	r0, [sp, #4]
	uart_sw_event_txdrdy = 0U;
    eff8:	703b      	strb	r3, [r7, #0]
    p_reg->TXD = txd;
    effa:	5d4b      	ldrb	r3, [r1, r5]
    effc:	f8c8 351c 	str.w	r3, [r8, #1308]	; 0x51c
}
    f000:	e7e9      	b.n	efd6 <uart_nrfx_fifo_fill+0xe>
    f002:	bf00      	nop
    f004:	4000211c 	.word	0x4000211c
    f008:	200087b9 	.word	0x200087b9
    f00c:	40002000 	.word	0x40002000

0000f010 <uart_nrfx_init>:
    p_reg->OUTSET = set_mask;
    f010:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(struct device *dev)
{
    f014:	b537      	push	{r0, r1, r2, r4, r5, lr}
    p_reg->PSEL.RXD = pselrxd;
    f016:	4d1c      	ldr	r5, [pc, #112]	; (f088 <uart_nrfx_init+0x78>)
    f018:	2240      	movs	r2, #64	; 0x40
    f01a:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    f01e:	2103      	movs	r1, #3
    f020:	2200      	movs	r2, #0
    f022:	2408      	movs	r4, #8
    f024:	f8c3 1718 	str.w	r1, [r3, #1816]	; 0x718
    f028:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720
    f02c:	f8c5 4514 	str.w	r4, [r5, #1300]	; 0x514
    p_reg->PSEL.TXD = pseltxd;
    f030:	2406      	movs	r4, #6
    f032:	f8c5 450c 	str.w	r4, [r5, #1292]	; 0x50c
    p_reg->OUTSET = set_mask;
    f036:	2420      	movs	r4, #32
    f038:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    f03c:	f8c3 1714 	str.w	r1, [r3, #1812]	; 0x714
    f040:	f8c3 271c 	str.w	r2, [r3, #1820]	; 0x71c
    p_reg->PSEL.RTS = pselrts;
    f044:	2305      	movs	r3, #5
    f046:	f8c5 3508 	str.w	r3, [r5, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    f04a:	2307      	movs	r3, #7

	nrf_uart_hwfc_pins_set(uart0_addr, RTS_PIN, CTS_PIN);
#endif

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    f04c:	6881      	ldr	r1, [r0, #8]
    f04e:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
    f052:	f7ff fe6d 	bl	ed30 <uart_nrfx_configure>
	if (err) {
    f056:	4604      	mov	r4, r0
    f058:	b990      	cbnz	r0, f080 <uart_nrfx_init+0x70>
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
    f05a:	2304      	movs	r3, #4
    f05c:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f060:	4b0a      	ldr	r3, [pc, #40]	; (f08c <uart_nrfx_init+0x7c>)
    f062:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    f064:	681b      	ldr	r3, [r3, #0]
    f066:	9301      	str	r3, [sp, #4]
    (void)dummy;
    f068:	9b01      	ldr	r3, [sp, #4]

#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
	/* Simulate that the TXDRDY event is set, so that the transmitter status
	 * is indicated correctly.
	 */
	uart_sw_event_txdrdy = 1U;
    f06a:	4b09      	ldr	r3, [pc, #36]	; (f090 <uart_nrfx_init+0x80>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f06c:	2101      	movs	r1, #1
    f06e:	6029      	str	r1, [r5, #0]
#endif

#if defined(CONFIG_UART_0_ASYNC) || defined(CONFIG_UART_0_INTERRUPT_DRIVEN)

	IRQ_CONNECT(IRQN,
    f070:	4602      	mov	r2, r0
    f072:	2002      	movs	r0, #2
	uart_sw_event_txdrdy = 1U;
    f074:	7019      	strb	r1, [r3, #0]
	IRQ_CONNECT(IRQN,
    f076:	f7f6 fd61 	bl	5b3c <z_arm_irq_priority_set>
		    IRQ_PRIO,
		    uart_nrfx_isr,
		    DEVICE_GET(uart_nrfx_uart0),
		    0);
	irq_enable(IRQN);
    f07a:	2002      	movs	r0, #2
    f07c:	f7f6 fd2c 	bl	5ad8 <arch_irq_enable>
#if	HW_FLOW_CONTROL
	k_delayed_work_init(&uart0_cb.tx_timeout_work, tx_timeout);
#endif
#endif
	return 0;
}
    f080:	4620      	mov	r0, r4
    f082:	b003      	add	sp, #12
    f084:	bd30      	pop	{r4, r5, pc}
    f086:	bf00      	nop
    f088:	40002000 	.word	0x40002000
    f08c:	40002108 	.word	0x40002108
    f090:	200087b9 	.word	0x200087b9

0000f094 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
    f094:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    f096:	794b      	ldrb	r3, [r1, #5]
    f098:	2b01      	cmp	r3, #1
    f09a:	d02b      	beq.n	f0f4 <uarte_nrfx_configure+0x60>
    f09c:	2b03      	cmp	r3, #3
    f09e:	d126      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    f0a0:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    f0a2:	798b      	ldrb	r3, [r1, #6]
    f0a4:	2b03      	cmp	r3, #3
    f0a6:	d122      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    f0a8:	79cc      	ldrb	r4, [r1, #7]
    f0aa:	b12c      	cbz	r4, f0b8 <uarte_nrfx_configure+0x24>
    f0ac:	2c01      	cmp	r4, #1
    f0ae:	d11e      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
	return dev->config->config_info;
    f0b0:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    f0b2:	689b      	ldr	r3, [r3, #8]
    f0b4:	791b      	ldrb	r3, [r3, #4]
    f0b6:	b1d3      	cbz	r3, f0ee <uarte_nrfx_configure+0x5a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    f0b8:	790a      	ldrb	r2, [r1, #4]
    f0ba:	b112      	cbz	r2, f0c2 <uarte_nrfx_configure+0x2e>
    f0bc:	2a02      	cmp	r2, #2
    f0be:	d116      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    f0c0:	220e      	movs	r2, #14
	return dev->config->config_info;
    f0c2:	6805      	ldr	r5, [r0, #0]
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    f0c4:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    f0c6:	68ad      	ldr	r5, [r5, #8]
	switch (baudrate) {
    f0c8:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    f0cc:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
    f0ce:	d064      	beq.n	f19a <uarte_nrfx_configure+0x106>
    f0d0:	d82d      	bhi.n	f12e <uarte_nrfx_configure+0x9a>
    f0d2:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    f0d6:	d063      	beq.n	f1a0 <uarte_nrfx_configure+0x10c>
    f0d8:	d816      	bhi.n	f108 <uarte_nrfx_configure+0x74>
    f0da:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    f0de:	d061      	beq.n	f1a4 <uarte_nrfx_configure+0x110>
    f0e0:	d80a      	bhi.n	f0f8 <uarte_nrfx_configure+0x64>
    f0e2:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    f0e6:	d060      	beq.n	f1aa <uarte_nrfx_configure+0x116>
    f0e8:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    f0ec:	d060      	beq.n	f1b0 <uarte_nrfx_configure+0x11c>
    f0ee:	f06f 0022 	mvn.w	r0, #34	; 0x22
    f0f2:	e051      	b.n	f198 <uarte_nrfx_configure+0x104>
	switch (cfg->stop_bits) {
    f0f4:	2600      	movs	r6, #0
    f0f6:	e7d4      	b.n	f0a2 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    f0f8:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    f0fc:	d05b      	beq.n	f1b6 <uarte_nrfx_configure+0x122>
    f0fe:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    f102:	d1f4      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    f104:	4b36      	ldr	r3, [pc, #216]	; (f1e0 <uarte_nrfx_configure+0x14c>)
    f106:	e03c      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f108:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    f10c:	d056      	beq.n	f1bc <uarte_nrfx_configure+0x128>
    f10e:	d807      	bhi.n	f120 <uarte_nrfx_configure+0x8c>
    f110:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    f114:	d054      	beq.n	f1c0 <uarte_nrfx_configure+0x12c>
    f116:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    f11a:	d1e8      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    f11c:	4b31      	ldr	r3, [pc, #196]	; (f1e4 <uarte_nrfx_configure+0x150>)
    f11e:	e030      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f120:	f647 2712 	movw	r7, #31250	; 0x7a12
    f124:	42bb      	cmp	r3, r7
    f126:	d1e2      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    f128:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    f12c:	e029      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f12e:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    f132:	d047      	beq.n	f1c4 <uarte_nrfx_configure+0x130>
    f134:	d813      	bhi.n	f15e <uarte_nrfx_configure+0xca>
    f136:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    f13a:	d046      	beq.n	f1ca <uarte_nrfx_configure+0x136>
    f13c:	d809      	bhi.n	f152 <uarte_nrfx_configure+0xbe>
    f13e:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    f142:	42bb      	cmp	r3, r7
    f144:	d043      	beq.n	f1ce <uarte_nrfx_configure+0x13a>
    f146:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    f14a:	d1d0      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    f14c:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    f150:	e017      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f152:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    f156:	d1ca      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    f158:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    f15c:	e011      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f15e:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    f162:	d037      	beq.n	f1d4 <uarte_nrfx_configure+0x140>
    f164:	d808      	bhi.n	f178 <uarte_nrfx_configure+0xe4>
    f166:	4f20      	ldr	r7, [pc, #128]	; (f1e8 <uarte_nrfx_configure+0x154>)
    f168:	42bb      	cmp	r3, r7
    f16a:	d036      	beq.n	f1da <uarte_nrfx_configure+0x146>
    f16c:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    f170:	d1bd      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    f172:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    f176:	e004      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f178:	4f1c      	ldr	r7, [pc, #112]	; (f1ec <uarte_nrfx_configure+0x158>)
    f17a:	42bb      	cmp	r3, r7
    f17c:	d1b7      	bne.n	f0ee <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    f17e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    f182:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    f186:	6883      	ldr	r3, [r0, #8]
    f188:	c903      	ldmia	r1, {r0, r1}
                    | (uint32_t)p_cfg->hwfc;
    f18a:	4334      	orrs	r4, r6
    f18c:	4322      	orrs	r2, r4
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    f18e:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    f192:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    f196:	2000      	movs	r0, #0
}
    f198:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    f19a:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    f19e:	e7f0      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    f1a0:	4b13      	ldr	r3, [pc, #76]	; (f1f0 <uarte_nrfx_configure+0x15c>)
    f1a2:	e7ee      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    f1a4:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    f1a8:	e7eb      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = 0x00014000;
    f1aa:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    f1ae:	e7e8      	b.n	f182 <uarte_nrfx_configure+0xee>
	switch (baudrate) {
    f1b0:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    f1b4:	e7e5      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    f1b6:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    f1ba:	e7e2      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    f1bc:	4b0d      	ldr	r3, [pc, #52]	; (f1f4 <uarte_nrfx_configure+0x160>)
    f1be:	e7e0      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    f1c0:	4b0d      	ldr	r3, [pc, #52]	; (f1f8 <uarte_nrfx_configure+0x164>)
    f1c2:	e7de      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    f1c4:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    f1c8:	e7db      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    f1ca:	4b0c      	ldr	r3, [pc, #48]	; (f1fc <uarte_nrfx_configure+0x168>)
    f1cc:	e7d9      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    f1ce:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    f1d2:	e7d6      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    f1d4:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    f1d8:	e7d3      	b.n	f182 <uarte_nrfx_configure+0xee>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    f1da:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    f1de:	e7d0      	b.n	f182 <uarte_nrfx_configure+0xee>
    f1e0:	0013b000 	.word	0x0013b000
    f1e4:	004ea000 	.word	0x004ea000
    f1e8:	0003d090 	.word	0x0003d090
    f1ec:	000f4240 	.word	0x000f4240
    f1f0:	00275000 	.word	0x00275000
    f1f4:	0075c000 	.word	0x0075c000
    f1f8:	003af000 	.word	0x003af000
    f1fc:	013a9000 	.word	0x013a9000

0000f200 <uarte_1_init>:
#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
#endif

#ifdef CONFIG_UART_1_NRF_UARTE
UART_NRF_UARTE_DEVICE(1);
    f200:	b570      	push	{r4, r5, r6, lr}
    f202:	2200      	movs	r2, #0
    f204:	4605      	mov	r5, r0
    f206:	2101      	movs	r1, #1
    f208:	2028      	movs	r0, #40	; 0x28
    f20a:	f7f6 fc97 	bl	5b3c <z_arm_irq_priority_set>
    f20e:	2028      	movs	r0, #40	; 0x28
    f210:	f7f6 fc62 	bl	5ad8 <arch_irq_enable>
	return dev->config->config_info;
    f214:	682b      	ldr	r3, [r5, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    f216:	68ae      	ldr	r6, [r5, #8]
	return config->uarte_regs;
    f218:	689b      	ldr	r3, [r3, #8]
    f21a:	681c      	ldr	r4, [r3, #0]
    p_reg->OUTSET = set_mask;
    f21c:	4b17      	ldr	r3, [pc, #92]	; (f27c <uarte_1_init+0x7c>)
    f21e:	2204      	movs	r2, #4
    f220:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    f224:	2203      	movs	r2, #3
    f226:	f8c3 2708 	str.w	r2, [r3, #1800]	; 0x708
    f22a:	2200      	movs	r2, #0
    f22c:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
    p_reg->PSEL.TXD = pseltxd;
    f230:	2322      	movs	r3, #34	; 0x22
    f232:	f8c4 350c 	str.w	r3, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    f236:	2321      	movs	r3, #33	; 0x21
    f238:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    f23c:	4631      	mov	r1, r6
    f23e:	4628      	mov	r0, r5
    f240:	f7ff ff28 	bl	f094 <uarte_nrfx_configure>
	if (err) {
    f244:	4602      	mov	r2, r0
    f246:	b9b8      	cbnz	r0, f278 <uarte_1_init+0x78>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    f248:	2308      	movs	r3, #8
    f24a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
    f24e:	f44f 7188 	mov.w	r1, #272	; 0x110
    f252:	4620      	mov	r0, r4
    f254:	f008 f983 	bl	1755e <nrf_uarte_event_clear>
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
    f258:	68b1      	ldr	r1, [r6, #8]
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    f25a:	f106 0310 	add.w	r3, r6, #16

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    f25e:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    f262:	6889      	ldr	r1, [r1, #8]
    p_reg->RXD.MAXCNT = length;
    f264:	2301      	movs	r3, #1
    f266:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f26a:	6023      	str	r3, [r4, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    f26c:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    f270:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f274:	60a3      	str	r3, [r4, #8]
    f276:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(1);
    f278:	4610      	mov	r0, r2
    f27a:	bd70      	pop	{r4, r5, r6, pc}
    f27c:	50000300 	.word	0x50000300

0000f280 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
    f280:	b5f0      	push	{r4, r5, r6, r7, lr}
    f282:	4603      	mov	r3, r0
	u32_t last  = rngp->last;
    f284:	7884      	ldrb	r4, [r0, #2]
	u32_t mask  = rngp->mask;
    f286:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
    f288:	f04f 0520 	mov.w	r5, #32
    f28c:	f3ef 8011 	mrs	r0, BASEPRI
    f290:	f385 8811 	msr	BASEPRI, r5
    f294:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
    f298:	781e      	ldrb	r6, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
    f29a:	f893 e001 	ldrb.w	lr, [r3, #1]

	available = (last - first) & mask;
    f29e:	1ba4      	subs	r4, r4, r6
    f2a0:	403c      	ands	r4, r7
	if (available < len) {
    f2a2:	42a2      	cmp	r2, r4
		len = available;
    f2a4:	bf88      	it	hi
    f2a6:	b2a2      	uxthhi	r2, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
    f2a8:	eb06 0c02 	add.w	ip, r6, r2
    f2ac:	ea07 0c0c 	and.w	ip, r7, ip
	first = rngp->first_alloc;
    f2b0:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
    f2b2:	f883 c000 	strb.w	ip, [r3]
	__asm__ volatile(
    f2b6:	f380 8811 	msr	BASEPRI, r0
    f2ba:	f3bf 8f6f 	isb	sy
    f2be:	440a      	add	r2, r1
	u8_t *dst   = buf;
    f2c0:	4608      	mov	r0, r1
	irq_unlock(key);

	while (likely(len--)) {
    f2c2:	4282      	cmp	r2, r0
    f2c4:	d119      	bne.n	f2fa <rng_pool_get+0x7a>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
    f2c6:	4576      	cmp	r6, lr
    f2c8:	d10d      	bne.n	f2e6 <rng_pool_get+0x66>
	__asm__ volatile(
    f2ca:	f04f 0520 	mov.w	r5, #32
    f2ce:	f3ef 8211 	mrs	r2, BASEPRI
    f2d2:	f385 8811 	msr	BASEPRI, r5
    f2d6:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
    f2da:	781d      	ldrb	r5, [r3, #0]
    f2dc:	705d      	strb	r5, [r3, #1]
	__asm__ volatile(
    f2de:	f382 8811 	msr	BASEPRI, r2
    f2e2:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
    f2e6:	1a41      	subs	r1, r0, r1
	available = available - len;
	if (available <= rngp->threshold) {
    f2e8:	791b      	ldrb	r3, [r3, #4]
	len = dst - buf;
    f2ea:	b288      	uxth	r0, r1
	available = available - len;
    f2ec:	1a21      	subs	r1, r4, r0
	if (available <= rngp->threshold) {
    f2ee:	428b      	cmp	r3, r1
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)rng_task);
}

NRF_STATIC_INLINE void nrf_rng_task_trigger(NRF_RNG_Type * p_reg, nrf_rng_task_t rng_task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    f2f0:	bf22      	ittt	cs
    f2f2:	4b06      	ldrcs	r3, [pc, #24]	; (f30c <rng_pool_get+0x8c>)
    f2f4:	2201      	movcs	r2, #1
    f2f6:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
    f2f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
    f2fa:	eb03 0c05 	add.w	ip, r3, r5
		first = (first + 1) & mask;
    f2fe:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
    f300:	f89c c005 	ldrb.w	ip, [ip, #5]
    f304:	f800 cb01 	strb.w	ip, [r0], #1
		first = (first + 1) & mask;
    f308:	403d      	ands	r5, r7
    f30a:	e7da      	b.n	f2c2 <rng_pool_get+0x42>
    f30c:	4000d000 	.word	0x4000d000

0000f310 <entropy_nrf5_get_entropy>:
		k_sem_give(&entropy_nrf5_data.sem_sync);
	}
}

static int entropy_nrf5_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
    f310:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
    f314:	4f11      	ldr	r7, [pc, #68]	; (f35c <entropy_nrf5_get_entropy+0x4c>)
    f316:	460d      	mov	r5, r1
    f318:	4614      	mov	r4, r2

	while (len) {
		u16_t bytes;

		k_sem_take(&entropy_nrf5_data.sem_lock, K_FOREVER);
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    f31a:	f107 0845 	add.w	r8, r7, #69	; 0x45
    f31e:	f107 0918 	add.w	r9, r7, #24
	while (len) {
    f322:	b914      	cbnz	r4, f32a <entropy_nrf5_get_entropy+0x1a>
		len -= bytes;
		buf += bytes;
	}

	return 0;
}
    f324:	4620      	mov	r0, r4
    f326:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f32a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    f32e:	4638      	mov	r0, r7
    f330:	f005 f802 	bl	14338 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    f334:	4622      	mov	r2, r4
    f336:	4629      	mov	r1, r5
    f338:	4640      	mov	r0, r8
    f33a:	f7ff ffa1 	bl	f280 <rng_pool_get>
    f33e:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
    f340:	4638      	mov	r0, r7
    f342:	f004 ffd3 	bl	142ec <z_impl_k_sem_give>
		if (bytes == 0U) {
    f346:	b92e      	cbnz	r6, f354 <entropy_nrf5_get_entropy+0x44>
	return z_impl_k_sem_take(sem, timeout);
    f348:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    f34c:	4648      	mov	r0, r9
    f34e:	f004 fff3 	bl	14338 <z_impl_k_sem_take>
			continue;
    f352:	e7e6      	b.n	f322 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
    f354:	1ba4      	subs	r4, r4, r6
    f356:	b2a4      	uxth	r4, r4
		buf += bytes;
    f358:	4435      	add	r5, r6
    f35a:	e7e2      	b.n	f322 <entropy_nrf5_get_entropy+0x12>
    f35c:	20003b88 	.word	0x20003b88

0000f360 <random_byte_get>:
{
    f360:	b082      	sub	sp, #8
	__asm__ volatile(
    f362:	f04f 0320 	mov.w	r3, #32
    f366:	f3ef 8211 	mrs	r2, BASEPRI
    f36a:	f383 8811 	msr	BASEPRI, r3
    f36e:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    f372:	4b0a      	ldr	r3, [pc, #40]	; (f39c <random_byte_get+0x3c>)
    f374:	6819      	ldr	r1, [r3, #0]
	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
    f376:	b171      	cbz	r1, f396 <random_byte_get+0x36>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
    f378:	4909      	ldr	r1, [pc, #36]	; (f3a0 <random_byte_get+0x40>)
    f37a:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    f37e:	2100      	movs	r1, #0
    f380:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    f382:	681b      	ldr	r3, [r3, #0]
    f384:	9301      	str	r3, [sp, #4]
    (void)dummy;
    f386:	9b01      	ldr	r3, [sp, #4]
		retval = nrf_rng_random_value_get(NRF_RNG);
    f388:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
    f38a:	f382 8811 	msr	BASEPRI, r2
    f38e:	f3bf 8f6f 	isb	sy
}
    f392:	b002      	add	sp, #8
    f394:	4770      	bx	lr
	int retval = -EAGAIN;
    f396:	f06f 000a 	mvn.w	r0, #10
    f39a:	e7f6      	b.n	f38a <random_byte_get+0x2a>
    f39c:	4000d100 	.word	0x4000d100
    f3a0:	4000d000 	.word	0x4000d000

0000f3a4 <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    f3a4:	43db      	mvns	r3, r3
{
    f3a6:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    f3aa:	f013 0501 	ands.w	r5, r3, #1
{
    f3ae:	460e      	mov	r6, r1
    f3b0:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    f3b2:	d005      	beq.n	f3c0 <entropy_nrf5_get_entropy_isr+0x1c>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
    f3b4:	4820      	ldr	r0, [pc, #128]	; (f438 <entropy_nrf5_get_entropy_isr+0x94>)
    f3b6:	f7ff ff63 	bl	f280 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
    f3ba:	b002      	add	sp, #8
    f3bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
    f3c0:	2a00      	cmp	r2, #0
    f3c2:	d032      	beq.n	f42a <entropy_nrf5_get_entropy_isr+0x86>
	__asm__ volatile(
    f3c4:	f04f 0320 	mov.w	r3, #32
    f3c8:	f3ef 8711 	mrs	r7, BASEPRI
    f3cc:	f383 8811 	msr	BASEPRI, r3
    f3d0:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
    f3d4:	200d      	movs	r0, #13
    f3d6:	f7f6 fba3 	bl	5b20 <arch_irq_is_enabled>
    f3da:	4680      	mov	r8, r0
		irq_disable(IRQN);
    f3dc:	200d      	movs	r0, #13
    f3de:	f7f6 fb8b 	bl	5af8 <arch_irq_disable>
	__asm__ volatile(
    f3e2:	f387 8811 	msr	BASEPRI, r7
    f3e6:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    f3ea:	4f14      	ldr	r7, [pc, #80]	; (f43c <entropy_nrf5_get_entropy_isr+0x98>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    f3ec:	f8df 9054 	ldr.w	r9, [pc, #84]	; f444 <entropy_nrf5_get_entropy_isr+0xa0>
    f3f0:	603d      	str	r5, [r7, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    f3f2:	683a      	ldr	r2, [r7, #0]
    f3f4:	9201      	str	r2, [sp, #4]
    (void)dummy;
    f3f6:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    f3f8:	4a11      	ldr	r2, [pc, #68]	; (f440 <entropy_nrf5_get_entropy_isr+0x9c>)
    f3fa:	2101      	movs	r1, #1
    f3fc:	6011      	str	r1, [r2, #0]
}
    f3fe:	4625      	mov	r5, r4
    f400:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    f404:	683b      	ldr	r3, [r7, #0]
			while (!nrf_rng_event_check(NRF_RNG,
    f406:	b193      	cbz	r3, f42e <entropy_nrf5_get_entropy_isr+0x8a>
			byte = random_byte_get();
    f408:	f7ff ffaa 	bl	f360 <random_byte_get>
			if (byte < 0) {
    f40c:	2800      	cmp	r0, #0
    f40e:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    f412:	dbf7      	blt.n	f404 <entropy_nrf5_get_entropy_isr+0x60>
    f414:	3d01      	subs	r5, #1
    f416:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
    f418:	5570      	strb	r0, [r6, r5]
		} while (len);
    f41a:	2d00      	cmp	r5, #0
    f41c:	d1f2      	bne.n	f404 <entropy_nrf5_get_entropy_isr+0x60>
		if (irq_enabled) {
    f41e:	f1b8 0f00 	cmp.w	r8, #0
    f422:	d002      	beq.n	f42a <entropy_nrf5_get_entropy_isr+0x86>
			irq_enable(IRQN);
    f424:	200d      	movs	r0, #13
    f426:	f7f6 fb57 	bl	5ad8 <arch_irq_enable>
	return cnt;
    f42a:	4620      	mov	r0, r4
    f42c:	e7c5      	b.n	f3ba <entropy_nrf5_get_entropy_isr+0x16>
				__WFE();
    f42e:	bf20      	wfe
				__SEV();
    f430:	bf40      	sev
				__WFE();
    f432:	bf20      	wfe
    f434:	e7e6      	b.n	f404 <entropy_nrf5_get_entropy_isr+0x60>
    f436:	bf00      	nop
    f438:	20003bb8 	.word	0x20003bb8
    f43c:	4000d100 	.word	0x4000d100
    f440:	4000d000 	.word	0x4000d000
    f444:	e000e100 	.word	0xe000e100

0000f448 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
    f448:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
    f44a:	4c1a      	ldr	r4, [pc, #104]	; (f4b4 <entropy_nrf5_init+0x6c>)
    f44c:	2201      	movs	r2, #1
    f44e:	4611      	mov	r1, r2
    f450:	4620      	mov	r0, r4
    f452:	f009 fd5a 	bl	18f0a <z_impl_k_sem_init>
    f456:	2201      	movs	r2, #1
    f458:	2100      	movs	r1, #0
    f45a:	f104 0018 	add.w	r0, r4, #24
    f45e:	f009 fd54 	bl	18f0a <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
    f462:	f240 4307 	movw	r3, #1031	; 0x407
    f466:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
    f46a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    f46e:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
    f470:	230c      	movs	r3, #12
    f472:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
    f476:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
    f478:	4b0f      	ldr	r3, [pc, #60]	; (f4b8 <entropy_nrf5_init+0x70>)
    f47a:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
    f47e:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
    f482:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
    f486:	f042 0201 	orr.w	r2, r2, #1
    f48a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    f48e:	4a0b      	ldr	r2, [pc, #44]	; (f4bc <entropy_nrf5_init+0x74>)
    f490:	6015      	str	r5, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    f492:	6812      	ldr	r2, [r2, #0]
    f494:	9201      	str	r2, [sp, #4]
    p_reg->INTENSET = mask;
    f496:	2101      	movs	r1, #1
    (void)dummy;
    f498:	9a01      	ldr	r2, [sp, #4]
    p_reg->INTENSET = mask;
    f49a:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
    f49e:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    f4a0:	6019      	str	r1, [r3, #0]
    f4a2:	200d      	movs	r0, #13
    f4a4:	f7f6 fb4a 	bl	5b3c <z_arm_irq_priority_set>
	irq_enable(IRQN);
    f4a8:	200d      	movs	r0, #13
    f4aa:	f7f6 fb15 	bl	5ad8 <arch_irq_enable>

	return 0;
}
    f4ae:	4628      	mov	r0, r5
    f4b0:	b003      	add	sp, #12
    f4b2:	bd30      	pop	{r4, r5, pc}
    f4b4:	20003b88 	.word	0x20003b88
    f4b8:	4000d000 	.word	0x4000d000
    f4bc:	4000d100 	.word	0x4000d100

0000f4c0 <isr>:
{
    f4c0:	b510      	push	{r4, lr}
	byte = random_byte_get();
    f4c2:	f7ff ff4d 	bl	f360 <random_byte_get>
	if (byte < 0) {
    f4c6:	2800      	cmp	r0, #0
    f4c8:	db20      	blt.n	f50c <isr+0x4c>
	u8_t last  = rngp->last;
    f4ca:	4b17      	ldr	r3, [pc, #92]	; (f528 <isr+0x68>)
    f4cc:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
    f4d0:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
    f4d4:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
    f4d8:	1a51      	subs	r1, r2, r1
    f4da:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
    f4de:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
    f4e0:	d10d      	bne.n	f4fe <isr+0x3e>
	u8_t last  = rngp->last;
    f4e2:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
    f4e6:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
    f4ea:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
    f4ee:	1a51      	subs	r1, r2, r1
    f4f0:	ea34 0101 	bics.w	r1, r4, r1
    f4f4:	d10b      	bne.n	f50e <isr+0x4e>
    f4f6:	4b0d      	ldr	r3, [pc, #52]	; (f52c <isr+0x6c>)
    f4f8:	2201      	movs	r2, #1
    f4fa:	601a      	str	r2, [r3, #0]
}
    f4fc:	e00e      	b.n	f51c <isr+0x5c>
	rngp->buffer[last] = byte;
    f4fe:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    f500:	3201      	adds	r2, #1
    f502:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    f504:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
    f508:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
    f50c:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
    f50e:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    f510:	3201      	adds	r2, #1
    f512:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    f514:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
    f518:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
    f51c:	4804      	ldr	r0, [pc, #16]	; (f530 <isr+0x70>)
}
    f51e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f522:	f004 bee3 	b.w	142ec <z_impl_k_sem_give>
    f526:	bf00      	nop
    f528:	20003b88 	.word	0x20003b88
    f52c:	4000d004 	.word	0x4000d004
    f530:	20003ba0 	.word	0x20003ba0

0000f534 <nrf52_errata_136>:
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    f534:	4b0a      	ldr	r3, [pc, #40]	; (f560 <nrf52_errata_136+0x2c>)
    f536:	681b      	ldr	r3, [r3, #0]
    f538:	1c5a      	adds	r2, r3, #1
            {
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    f53a:	bf05      	ittet	eq
    f53c:	4b09      	ldreq	r3, [pc, #36]	; (f564 <nrf52_errata_136+0x30>)
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    f53e:	4a0a      	ldreq	r2, [pc, #40]	; (f568 <nrf52_errata_136+0x34>)
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
    f540:	4a0a      	ldrne	r2, [pc, #40]	; (f56c <nrf52_errata_136+0x38>)
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    f542:	6810      	ldreq	r0, [r2, #0]
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    f544:	bf0a      	itet	eq
    f546:	781b      	ldrbeq	r3, [r3, #0]
                var2 = *(uint32_t *)0x10000134ul;
    f548:	6810      	ldrne	r0, [r2, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    f54a:	f3c0 1003 	ubfxeq	r0, r0, #4, #4
                        return true;
                }
            }
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    f54e:	2b08      	cmp	r3, #8
    f550:	d104      	bne.n	f55c <nrf52_errata_136+0x28>
            {
                switch(var2)
    f552:	2803      	cmp	r0, #3
    f554:	bf8c      	ite	hi
    f556:	2000      	movhi	r0, #0
    f558:	2001      	movls	r0, #1
    f55a:	4770      	bx	lr
                    case 0x00ul:
                        return true;
                }
            }
        #endif
        return false;
    f55c:	2000      	movs	r0, #0
    #endif
}
    f55e:	4770      	bx	lr
    f560:	10000130 	.word	0x10000130
    f564:	f0000fe0 	.word	0xf0000fe0
    f568:	f0000fe8 	.word	0xf0000fe8
    f56c:	10000134 	.word	0x10000134

0000f570 <nrf52_errata_103>:
{
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    f570:	4b06      	ldr	r3, [pc, #24]	; (f58c <nrf52_errata_103+0x1c>)
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    f572:	681b      	ldr	r3, [r3, #0]
    f574:	2b08      	cmp	r3, #8
    f576:	d106      	bne.n	f586 <nrf52_errata_103+0x16>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    f578:	4b05      	ldr	r3, [pc, #20]	; (f590 <nrf52_errata_103+0x20>)
    f57a:	681b      	ldr	r3, [r3, #0]
            {
                switch(var2)
    f57c:	2b03      	cmp	r3, #3
    f57e:	d802      	bhi.n	f586 <nrf52_errata_103+0x16>
    f580:	4a04      	ldr	r2, [pc, #16]	; (f594 <nrf52_errata_103+0x24>)
    f582:	5cd0      	ldrb	r0, [r2, r3]
    f584:	4770      	bx	lr
                    case 0x03ul:
                        return false;
                }
            }
        #endif
        return false;
    f586:	2000      	movs	r0, #0
    #endif
}
    f588:	4770      	bx	lr
    f58a:	bf00      	nop
    f58c:	10000130 	.word	0x10000130
    f590:	10000134 	.word	0x10000134
    f594:	0001c04a 	.word	0x0001c04a

0000f598 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
    f598:	b508      	push	{r3, lr}
        NRF_P1->PIN_CNF[9]  = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_36()){
    f59a:	f7ff ffcb 	bl	f534 <nrf52_errata_136>
    f59e:	b140      	cbz	r0, f5b2 <SystemInit+0x1a>
        NRF_CLOCK->EVENTS_DONE = 0;
    f5a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    f5a4:	2200      	movs	r2, #0
    f5a6:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    f5aa:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
    f5ae:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }
    
    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_66()){
    f5b2:	f7ff ffbf 	bl	f534 <nrf52_errata_136>
    f5b6:	2800      	cmp	r0, #0
    f5b8:	d046      	beq.n	f648 <SystemInit+0xb0>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    f5ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f5be:	4b58      	ldr	r3, [pc, #352]	; (f720 <SystemInit+0x188>)
    f5c0:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    f5c4:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    f5c8:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    f5cc:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    f5d0:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    f5d4:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    f5d8:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    f5dc:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    f5e0:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    f5e4:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    f5e8:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    f5ec:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    f5f0:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    f5f4:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    f5f8:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    f5fc:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    f600:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    f604:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    f608:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    f60c:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    f610:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    f614:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    f618:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    f61c:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    f620:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    f624:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    f628:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    f62c:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    f630:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    f634:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    f638:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    f63c:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    f640:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    f644:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }
    
    /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_98()){
    f648:	f7ff ff92 	bl	f570 <nrf52_errata_103>
    f64c:	b110      	cbz	r0, f654 <SystemInit+0xbc>
        *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
    f64e:	4b35      	ldr	r3, [pc, #212]	; (f724 <SystemInit+0x18c>)
    f650:	4a35      	ldr	r2, [pc, #212]	; (f728 <SystemInit+0x190>)
    f652:	601a      	str	r2, [r3, #0]
    }
    
    /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_103()){
    f654:	f7ff ff8c 	bl	f570 <nrf52_errata_103>
    f658:	b118      	cbz	r0, f662 <SystemInit+0xca>
        NRF_CCM->MAXPACKETSIZE = 0xFBul;
    f65a:	4b34      	ldr	r3, [pc, #208]	; (f72c <SystemInit+0x194>)
    f65c:	22fb      	movs	r2, #251	; 0xfb
    f65e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    }
    
    /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_115()){
    f662:	f7ff ff85 	bl	f570 <nrf52_errata_103>
    f666:	b148      	cbz	r0, f67c <SystemInit+0xe4>
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
    f668:	4931      	ldr	r1, [pc, #196]	; (f730 <SystemInit+0x198>)
    f66a:	4b32      	ldr	r3, [pc, #200]	; (f734 <SystemInit+0x19c>)
    f66c:	680a      	ldr	r2, [r1, #0]
    f66e:	681b      	ldr	r3, [r3, #0]
    f670:	f022 020f 	bic.w	r2, r2, #15
    f674:	f003 030f 	and.w	r3, r3, #15
    f678:	4313      	orrs	r3, r2
    f67a:	600b      	str	r3, [r1, #0]
    }
    
    /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_120()){
    f67c:	f7ff ff78 	bl	f570 <nrf52_errata_103>
    f680:	b118      	cbz	r0, f68a <SystemInit+0xf2>
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
    f682:	4b2d      	ldr	r3, [pc, #180]	; (f738 <SystemInit+0x1a0>)
    f684:	f44f 7200 	mov.w	r2, #512	; 0x200
    f688:	601a      	str	r2, [r3, #0]
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_136()){
    f68a:	f7ff ff53 	bl	f534 <nrf52_errata_136>
    f68e:	b148      	cbz	r0, f6a4 <SystemInit+0x10c>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    f690:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    f694:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    f698:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    f69a:	bf44      	itt	mi
    f69c:	f06f 0201 	mvnmi.w	r2, #1
    f6a0:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    f6a4:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    f6a8:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    f6ac:	2a00      	cmp	r2, #0
    f6ae:	db03      	blt.n	f6b8 <SystemInit+0x120>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    f6b0:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    f6b4:	2b00      	cmp	r3, #0
    f6b6:	da2f      	bge.n	f718 <SystemInit+0x180>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    f6b8:	4b20      	ldr	r3, [pc, #128]	; (f73c <SystemInit+0x1a4>)
    f6ba:	2201      	movs	r2, #1
    f6bc:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    f6c0:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    f6c4:	2a00      	cmp	r2, #0
    f6c6:	d0fb      	beq.n	f6c0 <SystemInit+0x128>
            NRF_UICR->PSELRESET[0] = 18;
    f6c8:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
    f6cc:	2112      	movs	r1, #18
    f6ce:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    f6d2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    f6d6:	2a00      	cmp	r2, #0
    f6d8:	d0fb      	beq.n	f6d2 <SystemInit+0x13a>
            NRF_UICR->PSELRESET[1] = 18;
    f6da:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    f6de:	2212      	movs	r2, #18
    f6e0:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    f6e4:	4b15      	ldr	r3, [pc, #84]	; (f73c <SystemInit+0x1a4>)
    f6e6:	461a      	mov	r2, r3
    f6e8:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
    f6ec:	2900      	cmp	r1, #0
    f6ee:	d0fb      	beq.n	f6e8 <SystemInit+0x150>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    f6f0:	2100      	movs	r1, #0
    f6f2:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    f6f6:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    f6fa:	2b00      	cmp	r3, #0
    f6fc:	d0fb      	beq.n	f6f6 <SystemInit+0x15e>
  __ASM volatile ("dsb 0xF":::"memory");
    f6fe:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    f702:	490f      	ldr	r1, [pc, #60]	; (f740 <SystemInit+0x1a8>)
    f704:	4b0f      	ldr	r3, [pc, #60]	; (f744 <SystemInit+0x1ac>)
    f706:	68ca      	ldr	r2, [r1, #12]
    f708:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    f70c:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    f70e:	60cb      	str	r3, [r1, #12]
    f710:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    f714:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    f716:	e7fd      	b.n	f714 <SystemInit+0x17c>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    f718:	4b0b      	ldr	r3, [pc, #44]	; (f748 <SystemInit+0x1b0>)
    f71a:	4a0c      	ldr	r2, [pc, #48]	; (f74c <SystemInit+0x1b4>)
    f71c:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    f71e:	bd08      	pop	{r3, pc}
    f720:	4000c000 	.word	0x4000c000
    f724:	4000568c 	.word	0x4000568c
    f728:	00038148 	.word	0x00038148
    f72c:	4000f000 	.word	0x4000f000
    f730:	40000ee4 	.word	0x40000ee4
    f734:	10000258 	.word	0x10000258
    f738:	40029640 	.word	0x40029640
    f73c:	4001e000 	.word	0x4001e000
    f740:	e000ed00 	.word	0xe000ed00
    f744:	05fa0004 	.word	0x05fa0004
    f748:	2000c14c 	.word	0x2000c14c
    f74c:	03d09000 	.word	0x03d09000

0000f750 <nrfx_nvmc_page_erase>:
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
    f750:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f754:	691a      	ldr	r2, [r3, #16]


static bool is_page_aligned_check(uint32_t addr)
{
    /* If the modulo operation returns '0', then the address is aligned. */
    return !(addr % flash_page_size_get());
    f756:	fbb0 f3f2 	udiv	r3, r0, r2
    f75a:	fb02 0313 	mls	r3, r2, r3, r0

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());

    if (!is_page_aligned_check(addr))
    f75e:	b973      	cbnz	r3, f77e <nrfx_nvmc_page_erase+0x2e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
    f760:	4b08      	ldr	r3, [pc, #32]	; (f784 <nrfx_nvmc_page_erase+0x34>)
    f762:	2202      	movs	r2, #2
    f764:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
    f768:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    f76c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    f770:	07d2      	lsls	r2, r2, #31
    f772:	d5fb      	bpl.n	f76c <nrfx_nvmc_page_erase+0x1c>
    p_reg->CONFIG = (uint32_t)mode;
    f774:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
    f776:	4804      	ldr	r0, [pc, #16]	; (f788 <nrfx_nvmc_page_erase+0x38>)
    f778:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    f77c:	4770      	bx	lr
        return NRFX_ERROR_INVALID_ADDR;
    f77e:	4803      	ldr	r0, [pc, #12]	; (f78c <nrfx_nvmc_page_erase+0x3c>)
}
    f780:	4770      	bx	lr
    f782:	bf00      	nop
    f784:	4001e000 	.word	0x4001e000
    f788:	0bad0000 	.word	0x0bad0000
    f78c:	0bad000a 	.word	0x0bad000a

0000f790 <nrfx_nvmc_word_write>:
    f790:	4b07      	ldr	r3, [pc, #28]	; (f7b0 <nrfx_nvmc_word_write+0x20>)
    f792:	2201      	movs	r2, #1
    f794:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    f798:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    f79c:	07d2      	lsls	r2, r2, #31
    f79e:	d5fb      	bpl.n	f798 <nrfx_nvmc_word_write+0x8>
    *(volatile uint32_t *)addr = value;
    f7a0:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
    f7a2:	f3bf 8f5f 	dmb	sy
    p_reg->CONFIG = (uint32_t)mode;
    f7a6:	2200      	movs	r2, #0
    f7a8:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nvmc_write_mode_set();

    nvmc_word_write(addr, value);

    nvmc_readonly_mode_set();
}
    f7ac:	4770      	bx	lr
    f7ae:	bf00      	nop
    f7b0:	4001e000 	.word	0x4001e000

0000f7b4 <qspi_ready_wait>:

    return true;
}

static nrfx_err_t qspi_ready_wait(void)
{
    f7b4:	b538      	push	{r3, r4, r5, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
}

NRF_STATIC_INLINE bool nrf_qspi_event_check(NRF_QSPI_Type const * p_reg, nrf_qspi_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f7b6:	4d06      	ldr	r5, [pc, #24]	; (f7d0 <qspi_ready_wait+0x1c>)
    f7b8:	2464      	movs	r4, #100	; 0x64
    f7ba:	682b      	ldr	r3, [r5, #0]
    bool result;
    NRFX_WAIT_FOR(nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY),
    f7bc:	b933      	cbnz	r3, f7cc <qspi_ready_wait+0x18>
    f7be:	200a      	movs	r0, #10
    f7c0:	f008 f802 	bl	177c8 <nrfx_busy_wait>
    f7c4:	3c01      	subs	r4, #1
    f7c6:	d1f8      	bne.n	f7ba <qspi_ready_wait+0x6>
                                       QSPI_DEF_WAIT_ATTEMPTS,
                                       QSPI_DEF_WAIT_TIME_US,
                                       result);
    if (!result)
    {
        return NRFX_ERROR_TIMEOUT;
    f7c8:	4802      	ldr	r0, [pc, #8]	; (f7d4 <qspi_ready_wait+0x20>)
    }

    return NRFX_SUCCESS;
}
    f7ca:	bd38      	pop	{r3, r4, r5, pc}
    return NRFX_SUCCESS;
    f7cc:	4802      	ldr	r0, [pc, #8]	; (f7d8 <qspi_ready_wait+0x24>)
    f7ce:	e7fc      	b.n	f7ca <qspi_ready_wait+0x16>
    f7d0:	40029100 	.word	0x40029100
    f7d4:	0bad0007 	.word	0x0bad0007
    f7d8:	0bad0000 	.word	0x0bad0000

0000f7dc <qspi_task_perform>:
    if (m_cb.is_busy)
    f7dc:	4a0e      	ldr	r2, [pc, #56]	; (f818 <qspi_task_perform+0x3c>)
    f7de:	7953      	ldrb	r3, [r2, #5]
{
    f7e0:	b510      	push	{r4, lr}
    if (m_cb.is_busy)
    f7e2:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    f7e6:	b9a3      	cbnz	r3, f812 <qspi_task_perform+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f7e8:	4b0c      	ldr	r3, [pc, #48]	; (f81c <qspi_task_perform+0x40>)
    f7ea:	6019      	str	r1, [r3, #0]
    if (m_cb.handler)
    f7ec:	6811      	ldr	r1, [r2, #0]
    f7ee:	b121      	cbz	r1, f7fa <qspi_task_perform+0x1e>
        m_cb.is_busy = true;
    f7f0:	2401      	movs	r4, #1
    f7f2:	7154      	strb	r4, [r2, #5]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_qspi_int_enable(NRF_QSPI_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    f7f4:	4a0a      	ldr	r2, [pc, #40]	; (f820 <qspi_task_perform+0x44>)
    f7f6:	f8c2 4304 	str.w	r4, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f7fa:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    f7fe:	f500 3024 	add.w	r0, r0, #167936	; 0x29000
    f802:	2201      	movs	r2, #1
    f804:	6002      	str	r2, [r0, #0]
    if (m_cb.handler == NULL)
    f806:	b911      	cbnz	r1, f80e <qspi_task_perform+0x32>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f808:	681a      	ldr	r2, [r3, #0]
        while (!nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY))
    f80a:	2a00      	cmp	r2, #0
    f80c:	d0fc      	beq.n	f808 <qspi_task_perform+0x2c>
    return NRFX_SUCCESS;
    f80e:	4805      	ldr	r0, [pc, #20]	; (f824 <qspi_task_perform+0x48>)
    f810:	e000      	b.n	f814 <qspi_task_perform+0x38>
        return NRFX_ERROR_BUSY;
    f812:	4805      	ldr	r0, [pc, #20]	; (f828 <qspi_task_perform+0x4c>)
}
    f814:	bd10      	pop	{r4, pc}
    f816:	bf00      	nop
    f818:	20003bdc 	.word	0x20003bdc
    f81c:	40029100 	.word	0x40029100
    f820:	40029000 	.word	0x40029000
    f824:	0bad0000 	.word	0x0bad0000
    f828:	0bad000b 	.word	0x0bad000b

0000f82c <nrf_qspi_cinstrdata_get.constprop.0>:
                                               nrf_qspi_cinstr_len_t length,
                                               void *                p_rx_data)
{
    uint8_t *p_rx_data_8 = (uint8_t *) p_rx_data;

    uint32_t reg1 = p_reg->CINSTRDAT1;
    f82c:	4b0e      	ldr	r3, [pc, #56]	; (f868 <nrf_qspi_cinstrdata_get.constprop.0+0x3c>)
    f82e:	3802      	subs	r0, #2
    f830:	f8d3 263c 	ldr.w	r2, [r3, #1596]	; 0x63c
    uint32_t reg0 = p_reg->CINSTRDAT0;
    f834:	f8d3 3638 	ldr.w	r3, [r3, #1592]	; 0x638
    switch (length)
    f838:	2807      	cmp	r0, #7
    f83a:	d813      	bhi.n	f864 <nrf_qspi_cinstrdata_get.constprop.0+0x38>
    f83c:	e8df f000 	tbb	[pc, r0]
    f840:	0b0d0f11 	.word	0x0b0d0f11
    f844:	0406080a 	.word	0x0406080a
    {
        case NRF_QSPI_CINSTR_LEN_9B:
            p_rx_data_8[7] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE7_Pos);
    f848:	0e10      	lsrs	r0, r2, #24
    f84a:	71c8      	strb	r0, [r1, #7]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_8B:
            p_rx_data_8[6] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE6_Pos);
    f84c:	0c10      	lsrs	r0, r2, #16
    f84e:	7188      	strb	r0, [r1, #6]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_7B:
            p_rx_data_8[5] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE5_Pos);
    f850:	0a10      	lsrs	r0, r2, #8
    f852:	7148      	strb	r0, [r1, #5]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_6B:
            p_rx_data_8[4] = (uint8_t)(reg1);
    f854:	710a      	strb	r2, [r1, #4]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_5B:
            p_rx_data_8[3] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE3_Pos);
    f856:	0e1a      	lsrs	r2, r3, #24
    f858:	70ca      	strb	r2, [r1, #3]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_4B:
            p_rx_data_8[2] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE2_Pos);
    f85a:	0c1a      	lsrs	r2, r3, #16
    f85c:	708a      	strb	r2, [r1, #2]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_3B:
            p_rx_data_8[1] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE1_Pos);
    f85e:	0a1a      	lsrs	r2, r3, #8
    f860:	704a      	strb	r2, [r1, #1]
            /* fall-through */
        case NRF_QSPI_CINSTR_LEN_2B:
            p_rx_data_8[0] = (uint8_t)(reg0);
    f862:	700b      	strb	r3, [r1, #0]
            /* Send only opcode. Case to avoid compiler warnings. */
            break;
        default:
            break;
    }
}
    f864:	4770      	bx	lr
    f866:	bf00      	nop
    f868:	40029000 	.word	0x40029000

0000f86c <nrf_qspi_cinstrdata_set.constprop.0>:
    switch (length)
    f86c:	3802      	subs	r0, #2
    f86e:	2807      	cmp	r0, #7
    f870:	d81f      	bhi.n	f8b2 <nrf_qspi_cinstrdata_set.constprop.0+0x46>
    f872:	e8df f000 	tbb	[pc, r0]
    f876:	2729      	.short	0x2729
    f878:	21231125 	.word	0x21231125
    f87c:	041f      	.short	0x041f
            reg |= ((uint32_t)p_tx_data_8[7]) << QSPI_CINSTRDAT1_BYTE7_Pos;
    f87e:	79cb      	ldrb	r3, [r1, #7]
    f880:	061b      	lsls	r3, r3, #24
            reg |= ((uint32_t)p_tx_data_8[6]) << QSPI_CINSTRDAT1_BYTE6_Pos;
    f882:	798a      	ldrb	r2, [r1, #6]
    f884:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            reg |= ((uint32_t)p_tx_data_8[5]) << QSPI_CINSTRDAT1_BYTE5_Pos;
    f888:	794a      	ldrb	r2, [r1, #5]
    f88a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            reg |= ((uint32_t)p_tx_data_8[4]);
    f88e:	790a      	ldrb	r2, [r1, #4]
    f890:	4313      	orrs	r3, r2
            p_reg->CINSTRDAT1 = reg;
    f892:	4a0e      	ldr	r2, [pc, #56]	; (f8cc <nrf_qspi_cinstrdata_set.constprop.0+0x60>)
    f894:	f8c2 363c 	str.w	r3, [r2, #1596]	; 0x63c
            reg |= ((uint32_t)p_tx_data_8[3]) << QSPI_CINSTRDAT0_BYTE3_Pos;
    f898:	78cb      	ldrb	r3, [r1, #3]
    f89a:	061b      	lsls	r3, r3, #24
            reg |= ((uint32_t)p_tx_data_8[2]) << QSPI_CINSTRDAT0_BYTE2_Pos;
    f89c:	788a      	ldrb	r2, [r1, #2]
    f89e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            reg |= ((uint32_t)p_tx_data_8[1]) << QSPI_CINSTRDAT0_BYTE1_Pos;
    f8a2:	784a      	ldrb	r2, [r1, #1]
    f8a4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            reg |= ((uint32_t)p_tx_data_8[0]);
    f8a8:	780a      	ldrb	r2, [r1, #0]
    f8aa:	4313      	orrs	r3, r2
            p_reg->CINSTRDAT0 = reg;
    f8ac:	4a07      	ldr	r2, [pc, #28]	; (f8cc <nrf_qspi_cinstrdata_set.constprop.0+0x60>)
    f8ae:	f8c2 3638 	str.w	r3, [r2, #1592]	; 0x638
}
    f8b2:	4770      	bx	lr
NRF_STATIC_INLINE void nrf_qspi_cinstrdata_set(NRF_QSPI_Type *       p_reg,
    f8b4:	2300      	movs	r3, #0
    f8b6:	e7e4      	b.n	f882 <nrf_qspi_cinstrdata_set.constprop.0+0x16>
    f8b8:	2300      	movs	r3, #0
    f8ba:	e7e5      	b.n	f888 <nrf_qspi_cinstrdata_set.constprop.0+0x1c>
    f8bc:	2300      	movs	r3, #0
    f8be:	e7e6      	b.n	f88e <nrf_qspi_cinstrdata_set.constprop.0+0x22>
    f8c0:	2300      	movs	r3, #0
    f8c2:	e7eb      	b.n	f89c <nrf_qspi_cinstrdata_set.constprop.0+0x30>
    f8c4:	2300      	movs	r3, #0
    f8c6:	e7ec      	b.n	f8a2 <nrf_qspi_cinstrdata_set.constprop.0+0x36>
    f8c8:	2300      	movs	r3, #0
    f8ca:	e7ed      	b.n	f8a8 <nrf_qspi_cinstrdata_set.constprop.0+0x3c>
    f8cc:	40029000 	.word	0x40029000

0000f8d0 <nrfx_qspi_init>:

nrfx_err_t nrfx_qspi_init(nrfx_qspi_config_t const * p_config,
                          nrfx_qspi_handler_t        handler,
                          void *                     p_context)
{
    f8d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    NRFX_ASSERT(p_config);
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    f8d2:	4d38      	ldr	r5, [pc, #224]	; (f9b4 <nrfx_qspi_init+0xe4>)
    f8d4:	792e      	ldrb	r6, [r5, #4]
    f8d6:	2e00      	cmp	r6, #0
    f8d8:	d167      	bne.n	f9aa <nrfx_qspi_init+0xda>
    if ((p_config->sck_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    f8da:	f890 e004 	ldrb.w	lr, [r0, #4]
    f8de:	f1be 0fff 	cmp.w	lr, #255	; 0xff
    f8e2:	d064      	beq.n	f9ae <nrfx_qspi_init+0xde>
        (p_config->csn_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    f8e4:	f890 c005 	ldrb.w	ip, [r0, #5]
    if ((p_config->sck_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    f8e8:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    f8ec:	d05f      	beq.n	f9ae <nrfx_qspi_init+0xde>
        (p_config->io0_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    f8ee:	7987      	ldrb	r7, [r0, #6]
        (p_config->csn_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    f8f0:	2fff      	cmp	r7, #255	; 0xff
    f8f2:	d05c      	beq.n	f9ae <nrfx_qspi_init+0xde>
        (p_config->io1_pin == NRF_QSPI_PIN_NOT_CONNECTED))
    f8f4:	79c4      	ldrb	r4, [r0, #7]
        (p_config->io0_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    f8f6:	2cff      	cmp	r4, #255	; 0xff
    f8f8:	d059      	beq.n	f9ae <nrfx_qspi_init+0xde>
    p_reg->PSEL.SCK = NRF_QSPI_PIN_VAL(p_pins->sck_pin);
    f8fa:	4b2f      	ldr	r3, [pc, #188]	; (f9b8 <nrfx_qspi_init+0xe8>)
    f8fc:	f8c3 e524 	str.w	lr, [r3, #1316]	; 0x524
    p_reg->PSEL.CSN = NRF_QSPI_PIN_VAL(p_pins->csn_pin);
    f900:	f8c3 c528 	str.w	ip, [r3, #1320]	; 0x528
    p_reg->PSEL.IO0 = NRF_QSPI_PIN_VAL(p_pins->io0_pin);
    f904:	f8c3 7530 	str.w	r7, [r3, #1328]	; 0x530
    p_reg->PSEL.IO1 = NRF_QSPI_PIN_VAL(p_pins->io1_pin);
    f908:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
    p_reg->PSEL.IO2 = NRF_QSPI_PIN_VAL(p_pins->io2_pin);
    f90c:	7a04      	ldrb	r4, [r0, #8]
    f90e:	2cff      	cmp	r4, #255	; 0xff
    f910:	bf08      	it	eq
    f912:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
    f916:	f8c3 4538 	str.w	r4, [r3, #1336]	; 0x538
    p_reg->PSEL.IO3 = NRF_QSPI_PIN_VAL(p_pins->io3_pin);
    f91a:	7a44      	ldrb	r4, [r0, #9]
    f91c:	2cff      	cmp	r4, #255	; 0xff
    f91e:	bf08      	it	eq
    f920:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
    f924:	f8c3 453c 	str.w	r4, [r3, #1340]	; 0x53c
    if (!qspi_pins_configure(&p_config->pins))
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    nrf_qspi_xip_offset_set(NRF_QSPI, p_config->xip_offset);
    f928:	6804      	ldr	r4, [r0, #0]
    p_reg->XIPOFFSET = xip_offset;
    f92a:	f8c3 4540 	str.w	r4, [r3, #1344]	; 0x540
    config |= ((uint32_t)p_config->addrmode)   << QSPI_IFCONFIG0_ADDRMODE_Pos;
    f92e:	7b04      	ldrb	r4, [r0, #12]
    config |= ((uint32_t)p_config->writeoc)    << QSPI_IFCONFIG0_WRITEOC_Pos;
    f930:	f890 c00b 	ldrb.w	ip, [r0, #11]
    uint32_t config = p_config->readoc;
    f934:	7a87      	ldrb	r7, [r0, #10]
    config |= ((uint32_t)p_config->addrmode)   << QSPI_IFCONFIG0_ADDRMODE_Pos;
    f936:	01a4      	lsls	r4, r4, #6
    f938:	ea44 04cc 	orr.w	r4, r4, ip, lsl #3
    f93c:	433c      	orrs	r4, r7
    config |= (p_config->dpmconfig ? 1U : 0U ) << QSPI_IFCONFIG0_DPMENABLE_Pos;
    f93e:	7b47      	ldrb	r7, [r0, #13]
    f940:	2f00      	cmp	r7, #0
    f942:	bf14      	ite	ne
    f944:	2780      	movne	r7, #128	; 0x80
    f946:	2700      	moveq	r7, #0
    f948:	433c      	orrs	r4, r7
    p_reg->IFCONFIG0 = config;
    f94a:	f8c3 4544 	str.w	r4, [r3, #1348]	; 0x544
    uint32_t config = p_reg->IFCONFIG1 & 0x00FFFF00;
    f94e:	f8d3 4600 	ldr.w	r4, [r3, #1536]	; 0x600
    config |= p_config->sck_delay;
    f952:	7b87      	ldrb	r7, [r0, #14]
    config |= ((uint32_t)(p_config->spi_mode)) << QSPI_IFCONFIG1_SPIMODE_Pos;
    f954:	f890 c010 	ldrb.w	ip, [r0, #16]
    uint32_t config = p_reg->IFCONFIG1 & 0x00FFFF00;
    f958:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    f95c:	f024 04ff 	bic.w	r4, r4, #255	; 0xff
    f960:	433c      	orrs	r4, r7
    config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
    f962:	7bc7      	ldrb	r7, [r0, #15]
    config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
    f964:	7c40      	ldrb	r0, [r0, #17]
    config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
    f966:	2f00      	cmp	r7, #0
    config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
    f968:	ea44 644c 	orr.w	r4, r4, ip, lsl #25
    config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
    f96c:	bf14      	ite	ne
    f96e:	f04f 7780 	movne.w	r7, #16777216	; 0x1000000
    f972:	2700      	moveq	r7, #0
    config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
    f974:	ea44 7400 	orr.w	r4, r4, r0, lsl #28
    f978:	433c      	orrs	r4, r7
    p_reg->IFCONFIG1 = config;
    f97a:	f8c3 4600 	str.w	r4, [r3, #1536]	; 0x600
    nrf_qspi_ifconfig0_set(NRF_QSPI, &p_config->prot_if);
    nrf_qspi_ifconfig1_set(NRF_QSPI, &p_config->phy_if);

    m_cb.is_busy = false;
    f97e:	716e      	strb	r6, [r5, #5]
    p_reg->INTENCLR = mask;
    f980:	2601      	movs	r6, #1
    m_cb.handler = handler;
    f982:	6029      	str	r1, [r5, #0]
    m_cb.p_context = p_context;
    f984:	60aa      	str	r2, [r5, #8]
    f986:	461c      	mov	r4, r3
    f988:	f8c3 6308 	str.w	r6, [r3, #776]	; 0x308

    /* QSPI interrupt is disabled because the device should be enabled in polling mode (wait for activate
       task event ready)*/
    nrf_qspi_int_disable(NRF_QSPI, NRF_QSPI_INT_READY_MASK);

    if (handler)
    f98c:	b111      	cbz	r1, f994 <nrfx_qspi_init+0xc4>
    {
        NRFX_IRQ_PRIORITY_SET(QSPI_IRQn, p_config->irq_priority);
        NRFX_IRQ_ENABLE(QSPI_IRQn);
    f98e:	2029      	movs	r0, #41	; 0x29
    f990:	f7f6 f8a2 	bl	5ad8 <arch_irq_enable>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f994:	4b09      	ldr	r3, [pc, #36]	; (f9bc <nrfx_qspi_init+0xec>)
    }

    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    f996:	712e      	strb	r6, [r5, #4]
    f998:	2200      	movs	r2, #0
    p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Enabled << QSPI_ENABLE_ENABLE_Pos);
    f99a:	f8c4 6500 	str.w	r6, [r4, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f99e:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f9a0:	6026      	str	r6, [r4, #0]
    nrf_qspi_task_trigger(NRF_QSPI, NRF_QSPI_TASK_ACTIVATE);

    // Waiting for the peripheral to activate

    return qspi_ready_wait();
}
    f9a2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    return qspi_ready_wait();
    f9a6:	f7ff bf05 	b.w	f7b4 <qspi_ready_wait>
        return NRFX_ERROR_INVALID_STATE;
    f9aa:	4805      	ldr	r0, [pc, #20]	; (f9c0 <nrfx_qspi_init+0xf0>)
}
    f9ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NRFX_ERROR_INVALID_PARAM;
    f9ae:	4805      	ldr	r0, [pc, #20]	; (f9c4 <nrfx_qspi_init+0xf4>)
    f9b0:	e7fc      	b.n	f9ac <nrfx_qspi_init+0xdc>
    f9b2:	bf00      	nop
    f9b4:	20003bdc 	.word	0x20003bdc
    f9b8:	40029000 	.word	0x40029000
    f9bc:	40029100 	.word	0x40029100
    f9c0:	0bad0005 	.word	0x0bad0005
    f9c4:	0bad0004 	.word	0x0bad0004

0000f9c8 <nrfx_qspi_cinstr_xfer>:

nrfx_err_t nrfx_qspi_cinstr_xfer(nrf_qspi_cinstr_conf_t const * p_config,
                                 void const *                   p_tx_buffer,
                                 void *                         p_rx_buffer)
{
    f9c8:	b570      	push	{r4, r5, r6, lr}
    f9ca:	4614      	mov	r4, r2
    NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);

    if (m_cb.is_busy)
    f9cc:	4a18      	ldr	r2, [pc, #96]	; (fa30 <nrfx_qspi_cinstr_xfer+0x68>)
    f9ce:	7952      	ldrb	r2, [r2, #5]
{
    f9d0:	4606      	mov	r6, r0
    if (m_cb.is_busy)
    f9d2:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    f9d6:	bb4a      	cbnz	r2, fa2c <nrfx_qspi_cinstr_xfer+0x64>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f9d8:	4d16      	ldr	r5, [pc, #88]	; (fa34 <nrfx_qspi_cinstr_xfer+0x6c>)
    f9da:	6028      	str	r0, [r5, #0]

    nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);
    /* In some cases, only opcode should be sent. To prevent execution, set function code is
     * surrounded by an if.
     */
    if (p_tx_buffer)
    f9dc:	b111      	cbz	r1, f9e4 <nrfx_qspi_cinstr_xfer+0x1c>
    {
        nrf_qspi_cinstrdata_set(NRF_QSPI, p_config->length, p_tx_buffer);
    f9de:	7870      	ldrb	r0, [r6, #1]
    f9e0:	f7ff ff44 	bl	f86c <nrf_qspi_cinstrdata_set.constprop.0>
    p_reg->INTENCLR = mask;
    f9e4:	4a14      	ldr	r2, [pc, #80]	; (fa38 <nrfx_qspi_cinstr_xfer+0x70>)
    f9e6:	2301      	movs	r3, #1
    f9e8:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
NRF_STATIC_INLINE void nrf_qspi_cinstr_transfer_start(NRF_QSPI_Type *                p_reg,
                                                      nrf_qspi_cinstr_conf_t const * p_config)
{
    p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
                         ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
    f9ec:	78b3      	ldrb	r3, [r6, #2]
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
    f9ee:	7871      	ldrb	r1, [r6, #1]
                         ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
    f9f0:	031b      	lsls	r3, r3, #12
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
    f9f2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
    f9f6:	7831      	ldrb	r1, [r6, #0]
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
    f9f8:	430b      	orrs	r3, r1
                         ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
    f9fa:	78f1      	ldrb	r1, [r6, #3]
                         ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
    f9fc:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
                         ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
    fa00:	7931      	ldrb	r1, [r6, #4]
                         ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
    fa02:	ea43 3381 	orr.w	r3, r3, r1, lsl #14
                         ((uint32_t)p_config->wren      << QSPI_CINSTRCONF_WREN_Pos));
    fa06:	7971      	ldrb	r1, [r6, #5]
                         ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
    fa08:	ea43 33c1 	orr.w	r3, r3, r1, lsl #15
    p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
    fa0c:	f8c2 3634 	str.w	r3, [r2, #1588]	; 0x634

    nrf_qspi_int_disable(NRF_QSPI, NRF_QSPI_INT_READY_MASK);

    nrf_qspi_cinstr_transfer_start(NRF_QSPI, p_config);

    if (qspi_ready_wait() == NRFX_ERROR_TIMEOUT)
    fa10:	f7ff fed0 	bl	f7b4 <qspi_ready_wait>
    fa14:	4b09      	ldr	r3, [pc, #36]	; (fa3c <nrfx_qspi_cinstr_xfer+0x74>)
    fa16:	4298      	cmp	r0, r3
    fa18:	d009      	beq.n	fa2e <nrfx_qspi_cinstr_xfer+0x66>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    fa1a:	2300      	movs	r3, #0
    fa1c:	602b      	str	r3, [r5, #0]

        return NRFX_ERROR_TIMEOUT;
    }
    nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);

    if (p_rx_buffer)
    fa1e:	b11c      	cbz	r4, fa28 <nrfx_qspi_cinstr_xfer+0x60>
    {
        nrf_qspi_cinstrdata_get(NRF_QSPI, p_config->length, p_rx_buffer);
    fa20:	7870      	ldrb	r0, [r6, #1]
    fa22:	4621      	mov	r1, r4
    fa24:	f7ff ff02 	bl	f82c <nrf_qspi_cinstrdata_get.constprop.0>
    }

    return NRFX_SUCCESS;
    fa28:	4805      	ldr	r0, [pc, #20]	; (fa40 <nrfx_qspi_cinstr_xfer+0x78>)
    fa2a:	e000      	b.n	fa2e <nrfx_qspi_cinstr_xfer+0x66>
        return NRFX_ERROR_BUSY;
    fa2c:	4805      	ldr	r0, [pc, #20]	; (fa44 <nrfx_qspi_cinstr_xfer+0x7c>)
}
    fa2e:	bd70      	pop	{r4, r5, r6, pc}
    fa30:	20003bdc 	.word	0x20003bdc
    fa34:	40029100 	.word	0x40029100
    fa38:	40029000 	.word	0x40029000
    fa3c:	0bad0007 	.word	0x0bad0007
    fa40:	0bad0000 	.word	0x0bad0000
    fa44:	0bad000b 	.word	0x0bad000b

0000fa48 <nrfx_qspi_write>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    fa48:	f000 4360 	and.w	r3, r0, #3758096384	; 0xe0000000
                           uint32_t     dst_address)
{
    NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);
    NRFX_ASSERT(p_tx_buffer != NULL);

    if (!nrfx_is_in_ram(p_tx_buffer) || !nrfx_is_word_aligned(p_tx_buffer))
    fa4c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    fa50:	d10b      	bne.n	fa6a <nrfx_qspi_write+0x22>
    fa52:	0783      	lsls	r3, r0, #30
    fa54:	d109      	bne.n	fa6a <nrfx_qspi_write+0x22>
    p_reg->WRITE.DST = dest_addr;
    fa56:	4b06      	ldr	r3, [pc, #24]	; (fa70 <nrfx_qspi_write+0x28>)
    fa58:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    p_reg->WRITE.SRC = (uint32_t) p_buffer;
    fa5c:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
    p_reg->WRITE.CNT = length;
    fa60:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    {
        return NRFX_ERROR_INVALID_ADDR;
    }

    nrf_qspi_write_buffer_set(NRF_QSPI, p_tx_buffer, tx_buffer_length, dst_address);
    return qspi_task_perform(NRF_QSPI_TASK_WRITESTART);
    fa64:	2008      	movs	r0, #8
    fa66:	f7ff beb9 	b.w	f7dc <qspi_task_perform>
        return NRFX_ERROR_INVALID_ADDR;
    fa6a:	4802      	ldr	r0, [pc, #8]	; (fa74 <nrfx_qspi_write+0x2c>)
}
    fa6c:	4770      	bx	lr
    fa6e:	bf00      	nop
    fa70:	40029000 	.word	0x40029000
    fa74:	0bad000a 	.word	0x0bad000a

0000fa78 <nrfx_qspi_read>:
    fa78:	f000 4360 	and.w	r3, r0, #3758096384	; 0xe0000000
                          uint32_t src_address)
{
    NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);
    NRFX_ASSERT(p_rx_buffer != NULL);

    if (!nrfx_is_in_ram(p_rx_buffer) || !nrfx_is_word_aligned(p_rx_buffer))
    fa7c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    fa80:	d10b      	bne.n	fa9a <nrfx_qspi_read+0x22>
    fa82:	0783      	lsls	r3, r0, #30
    fa84:	d109      	bne.n	fa9a <nrfx_qspi_read+0x22>
    p_reg->READ.SRC = src_addr;
    fa86:	4b06      	ldr	r3, [pc, #24]	; (faa0 <nrfx_qspi_read+0x28>)
    fa88:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    p_reg->READ.DST = (uint32_t) p_buffer;
    fa8c:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    p_reg->READ.CNT = length;
    fa90:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
    {
        return NRFX_ERROR_INVALID_ADDR;
    }

    nrf_qspi_read_buffer_set(NRF_QSPI, p_rx_buffer, rx_buffer_length, src_address);
    return qspi_task_perform(NRF_QSPI_TASK_READSTART);
    fa94:	2004      	movs	r0, #4
    fa96:	f7ff bea1 	b.w	f7dc <qspi_task_perform>
        return NRFX_ERROR_INVALID_ADDR;
    fa9a:	4802      	ldr	r0, [pc, #8]	; (faa4 <nrfx_qspi_read+0x2c>)
}
    fa9c:	4770      	bx	lr
    fa9e:	bf00      	nop
    faa0:	40029000 	.word	0x40029000
    faa4:	0bad000a 	.word	0x0bad000a

0000faa8 <nrfx_qspi_erase>:
nrfx_err_t nrfx_qspi_erase(nrf_qspi_erase_len_t length,
                           uint32_t             start_address)
{
    NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);

    if (!nrfx_is_word_aligned((void const *)start_address))
    faa8:	078b      	lsls	r3, r1, #30
    faaa:	d107      	bne.n	fabc <nrfx_qspi_erase+0x14>
    p_reg->ERASE.PTR = erase_addr;
    faac:	4b04      	ldr	r3, [pc, #16]	; (fac0 <nrfx_qspi_erase+0x18>)
    faae:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
    p_reg->ERASE.LEN = len;
    fab2:	f8c3 0520 	str.w	r0, [r3, #1312]	; 0x520
    {
        return NRFX_ERROR_INVALID_ADDR;
    }

    nrf_qspi_erase_ptr_set(NRF_QSPI, start_address, length);
    return qspi_task_perform(NRF_QSPI_TASK_ERASESTART);
    fab6:	200c      	movs	r0, #12
    fab8:	f7ff be90 	b.w	f7dc <qspi_task_perform>
}
    fabc:	4801      	ldr	r0, [pc, #4]	; (fac4 <nrfx_qspi_erase+0x1c>)
    fabe:	4770      	bx	lr
    fac0:	40029000 	.word	0x40029000
    fac4:	0bad000a 	.word	0x0bad000a

0000fac8 <nrfx_qspi_chip_erase>:
    p_reg->ERASE.PTR = erase_addr;
    fac8:	4b04      	ldr	r3, [pc, #16]	; (fadc <nrfx_qspi_chip_erase+0x14>)
    faca:	2200      	movs	r2, #0
    facc:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ERASE.LEN = len;
    fad0:	2202      	movs	r2, #2
    fad2:	f8c3 2520 	str.w	r2, [r3, #1312]	; 0x520
    return qspi_task_perform(NRF_QSPI_TASK_ERASESTART);
    fad6:	200c      	movs	r0, #12
    fad8:	f7ff be80 	b.w	f7dc <qspi_task_perform>
    fadc:	40029000 	.word	0x40029000

0000fae0 <nrfx_qspi_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    fae0:	4a05      	ldr	r2, [pc, #20]	; (faf8 <nrfx_qspi_irq_handler+0x18>)
    fae2:	6813      	ldr	r3, [r2, #0]
#endif

void nrfx_qspi_irq_handler(void)
{
    // Catch Event ready interrupts
    if (nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY))
    fae4:	b133      	cbz	r3, faf4 <nrfx_qspi_irq_handler+0x14>
    {
        m_cb.is_busy = false;
    fae6:	4b05      	ldr	r3, [pc, #20]	; (fafc <nrfx_qspi_irq_handler+0x1c>)
    fae8:	2000      	movs	r0, #0
    faea:	7158      	strb	r0, [r3, #5]
        nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);
        m_cb.handler(NRFX_QSPI_EVENT_DONE, m_cb.p_context);
    faec:	6899      	ldr	r1, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    faee:	6010      	str	r0, [r2, #0]
    faf0:	681a      	ldr	r2, [r3, #0]
    faf2:	4710      	bx	r2
    }
}
    faf4:	4770      	bx	lr
    faf6:	bf00      	nop
    faf8:	40029100 	.word	0x40029100
    fafc:	20003bdc 	.word	0x20003bdc

0000fb00 <nrf_gpio_pin_clear>:
    if (*p_pin < P0_PIN_NUM)
    fb00:	281f      	cmp	r0, #31
        return NRF_P1;
    fb02:	bf86      	itte	hi
    fb04:	4a05      	ldrhi	r2, [pc, #20]	; (fb1c <nrf_gpio_pin_clear+0x1c>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fb06:	f000 001f 	andhi.w	r0, r0, #31
        return NRF_P0;
    fb0a:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    fb0e:	2301      	movs	r3, #1
    fb10:	fa03 f000 	lsl.w	r0, r3, r0
    p_reg->OUTCLR = clr_mask;
    fb14:	f8c2 050c 	str.w	r0, [r2, #1292]	; 0x50c
}
    fb18:	4770      	bx	lr
    fb1a:	bf00      	nop
    fb1c:	50000300 	.word	0x50000300

0000fb20 <nrf_gpio_pin_set>:
    if (*p_pin < P0_PIN_NUM)
    fb20:	281f      	cmp	r0, #31
        return NRF_P1;
    fb22:	bf86      	itte	hi
    fb24:	4a05      	ldrhi	r2, [pc, #20]	; (fb3c <nrf_gpio_pin_set+0x1c>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fb26:	f000 001f 	andhi.w	r0, r0, #31
        return NRF_P0;
    fb2a:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    fb2e:	2301      	movs	r3, #1
    fb30:	fa03 f000 	lsl.w	r0, r3, r0
    p_reg->OUTSET = set_mask;
    fb34:	f8c2 0508 	str.w	r0, [r2, #1288]	; 0x508
}
    fb38:	4770      	bx	lr
    fb3a:	bf00      	nop
    fb3c:	50000300 	.word	0x50000300

0000fb40 <nrfx_spi_init>:

nrfx_err_t nrfx_spi_init(nrfx_spi_t const *        p_instance,
                         nrfx_spi_config_t const * p_config,
                         nrfx_spi_evt_handler_t    handler,
                         void *                    p_context)
{
    fb40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_ASSERT(p_config);
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    fb44:	7906      	ldrb	r6, [r0, #4]
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    fb46:	4c56      	ldr	r4, [pc, #344]	; (fca0 <nrfx_spi_init+0x160>)
{
    fb48:	4607      	mov	r7, r0
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    fb4a:	202c      	movs	r0, #44	; 0x2c
    fb4c:	4370      	muls	r0, r6
    fb4e:	1825      	adds	r5, r4, r0
    fb50:	f895 c01c 	ldrb.w	ip, [r5, #28]
    fb54:	f1bc 0f00 	cmp.w	ip, #0
    fb58:	f040 80a0 	bne.w	fc9c <nrfx_spi_init+0x15c>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
    fb5c:	5022      	str	r2, [r4, r0]
    p_cb->p_context = p_context;
    fb5e:	606b      	str	r3, [r5, #4]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPI_MODE_1)
    fb60:	7b0b      	ldrb	r3, [r1, #12]
    fb62:	7808      	ldrb	r0, [r1, #0]
    fb64:	2b01      	cmp	r3, #1
    fb66:	f200 808a 	bhi.w	fc7e <nrfx_spi_init+0x13e>
    {
        nrf_gpio_pin_clear(p_config->sck_pin);
    fb6a:	f7ff ffc9 	bl	fb00 <nrf_gpio_pin_clear>
    }
    else
    {
        nrf_gpio_pin_set(p_config->sck_pin);
    }
    nrf_gpio_cfg(p_config->sck_pin,
    fb6e:	780b      	ldrb	r3, [r1, #0]
    if (*p_pin < P0_PIN_NUM)
    fb70:	2b1f      	cmp	r3, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fb72:	bf86      	itte	hi
    fb74:	f003 031f 	andhi.w	r3, r3, #31
        return NRF_P1;
    fb78:	4a4a      	ldrhi	r2, [pc, #296]	; (fca4 <nrfx_spi_init+0x164>)
        return NRF_P0;
    fb7a:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fb7e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    fb82:	2001      	movs	r0, #1
    fb84:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
    fb88:	784d      	ldrb	r5, [r1, #1]
    fb8a:	2dff      	cmp	r5, #255	; 0xff
    fb8c:	d07a      	beq.n	fc84 <nrfx_spi_init+0x144>
    {
        mosi_pin = p_config->mosi_pin;
        nrf_gpio_pin_clear(mosi_pin);
    fb8e:	4628      	mov	r0, r5
    fb90:	f7ff ffb6 	bl	fb00 <nrf_gpio_pin_clear>
    if (*p_pin < P0_PIN_NUM)
    fb94:	2d1f      	cmp	r5, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fb96:	bf8b      	itete	hi
    fb98:	f005 031f 	andhi.w	r3, r5, #31
        return NRF_P1;
    fb9c:	462b      	movls	r3, r5
    fb9e:	4a41      	ldrhi	r2, [pc, #260]	; (fca4 <nrfx_spi_init+0x164>)
        return NRF_P0;
    fba0:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fba4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    fba8:	2003      	movs	r0, #3
    fbaa:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    else
    {
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    fbae:	788b      	ldrb	r3, [r1, #2]
    fbb0:	2bff      	cmp	r3, #255	; 0xff
    fbb2:	d06a      	beq.n	fc8a <nrfx_spi_init+0x14a>
    if (*p_pin < P0_PIN_NUM)
    fbb4:	2b1f      	cmp	r3, #31
    {
        miso_pin = p_config->miso_pin;
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
    fbb6:	7b88      	ldrb	r0, [r1, #14]
        return NRF_P1;
    fbb8:	bf87      	ittee	hi
    fbba:	f8df c0e8 	ldrhi.w	ip, [pc, #232]	; fca4 <nrfx_spi_init+0x164>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fbbe:	f003 021f 	andhi.w	r2, r3, #31
    fbc2:	461a      	movls	r2, r3
        return NRF_P0;
    fbc4:	f04f 4ca0 	movls.w	ip, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fbc8:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    fbcc:	0080      	lsls	r0, r0, #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fbce:	f84c 0022 	str.w	r0, [ip, r2, lsl #2]
        miso_pin = p_config->miso_pin;
    fbd2:	4698      	mov	r8, r3
    }
    else
    {
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    }
    m_cb[p_instance->drv_inst_idx].miso_pin = p_config->miso_pin;
    fbd4:	793a      	ldrb	r2, [r7, #4]
    fbd6:	202c      	movs	r0, #44	; 0x2c
    fbd8:	fb00 4202 	mla	r2, r0, r2, r4
    fbdc:	77d3      	strb	r3, [r2, #31]
    // - Slave Select (optional) - output with initial value 1 (inactive).
    if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
    fbde:	78c8      	ldrb	r0, [r1, #3]
    fbe0:	28ff      	cmp	r0, #255	; 0xff
    fbe2:	d00e      	beq.n	fc02 <nrfx_spi_init+0xc2>
    {
        nrf_gpio_pin_set(p_config->ss_pin);
    fbe4:	f7ff ff9c 	bl	fb20 <nrf_gpio_pin_set>
        nrf_gpio_cfg_output(p_config->ss_pin);
    fbe8:	78cb      	ldrb	r3, [r1, #3]
    if (*p_pin < P0_PIN_NUM)
    fbea:	2b1f      	cmp	r3, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fbec:	bf86      	itte	hi
    fbee:	f003 031f 	andhi.w	r3, r3, #31
        return NRF_P1;
    fbf2:	4a2c      	ldrhi	r2, [pc, #176]	; (fca4 <nrfx_spi_init+0x164>)
        return NRF_P0;
    fbf4:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fbf8:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    fbfc:	2003      	movs	r0, #3
    fbfe:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    }
    m_cb[p_instance->drv_inst_idx].ss_pin = p_config->ss_pin;
    fc02:	793a      	ldrb	r2, [r7, #4]
    fc04:	78c8      	ldrb	r0, [r1, #3]
    fc06:	232c      	movs	r3, #44	; 0x2c
    fc08:	fb03 4302 	mla	r3, r3, r2, r4
    fc0c:	7798      	strb	r0, [r3, #30]

    NRF_SPI_Type * p_spi = p_instance->p_reg;
    fc0e:	6838      	ldr	r0, [r7, #0]
    nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
    fc10:	780b      	ldrb	r3, [r1, #0]
    p_reg->PSEL.SCK = sck_pin;
    fc12:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
    fc16:	688b      	ldr	r3, [r1, #8]
    p_reg->PSEL.MOSI = mosi_pin;
    fc18:	f8c0 550c 	str.w	r5, [r0, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
    fc1c:	f8c0 8510 	str.w	r8, [r0, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
    fc20:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    fc24:	7b4b      	ldrb	r3, [r1, #13]
    nrf_spi_frequency_set(p_spi, p_config->frequency);
    nrf_spi_configure(p_spi, p_config->mode, p_config->bit_order);
    fc26:	7b0d      	ldrb	r5, [r1, #12]
    fc28:	3b00      	subs	r3, #0
    fc2a:	bf18      	it	ne
    fc2c:	2301      	movne	r3, #1
    switch (spi_mode)
    fc2e:	2d02      	cmp	r5, #2
    fc30:	d02e      	beq.n	fc90 <nrfx_spi_init+0x150>
    fc32:	2d03      	cmp	r5, #3
    fc34:	d02f      	beq.n	fc96 <nrfx_spi_init+0x156>
    fc36:	2d01      	cmp	r5, #1
    fc38:	d101      	bne.n	fc3e <nrfx_spi_init+0xfe>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    fc3a:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
    fc3e:	f8c0 3554 	str.w	r3, [r0, #1364]	; 0x554

    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
    fc42:	232c      	movs	r3, #44	; 0x2c
    fc44:	fb03 4202 	mla	r2, r3, r2, r4

    if (p_cb->handler)
    fc48:	4373      	muls	r3, r6
    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
    fc4a:	7949      	ldrb	r1, [r1, #5]
    if (p_cb->handler)
    fc4c:	58e3      	ldr	r3, [r4, r3]
    m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
    fc4e:	f882 1020 	strb.w	r1, [r2, #32]
    if (p_cb->handler)
    fc52:	b113      	cbz	r3, fc5a <nrfx_spi_init+0x11a>
    p_reg->INTENSET = mask;
    fc54:	2204      	movs	r2, #4
    fc56:	f8c0 2304 	str.w	r2, [r0, #772]	; 0x304
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
    fc5a:	2201      	movs	r2, #1
    fc5c:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
        nrf_spi_int_enable(p_spi, NRF_SPI_INT_READY_MASK);
    }

    nrf_spi_enable(p_spi);

    if (p_cb->handler)
    fc60:	b11b      	cbz	r3, fc6a <nrfx_spi_init+0x12a>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    fc62:	f340 3007 	sbfx	r0, r0, #12, #8
    fc66:	f7f5 ff37 	bl	5ad8 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
    fc6a:	232c      	movs	r3, #44	; 0x2c
    fc6c:	fb03 4406 	mla	r4, r3, r6, r4
    fc70:	2300      	movs	r3, #0
    fc72:	7763      	strb	r3, [r4, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    fc74:	480c      	ldr	r0, [pc, #48]	; (fca8 <nrfx_spi_init+0x168>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    fc76:	2301      	movs	r3, #1
    fc78:	7723      	strb	r3, [r4, #28]
}
    fc7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        nrf_gpio_pin_set(p_config->sck_pin);
    fc7e:	f7ff ff4f 	bl	fb20 <nrf_gpio_pin_set>
    fc82:	e774      	b.n	fb6e <nrfx_spi_init+0x2e>
        mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
    fc84:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    fc88:	e791      	b.n	fbae <nrfx_spi_init+0x6e>
        miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
    fc8a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    fc8e:	e7a1      	b.n	fbd4 <nrfx_spi_init+0x94>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    fc90:	f043 0304 	orr.w	r3, r3, #4
        break;
    fc94:	e7d3      	b.n	fc3e <nrfx_spi_init+0xfe>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    fc96:	f043 0306 	orr.w	r3, r3, #6
        break;
    fc9a:	e7d0      	b.n	fc3e <nrfx_spi_init+0xfe>
        return err_code;
    fc9c:	4803      	ldr	r0, [pc, #12]	; (fcac <nrfx_spi_init+0x16c>)
    fc9e:	e7ec      	b.n	fc7a <nrfx_spi_init+0x13a>
    fca0:	20003be8 	.word	0x20003be8
    fca4:	50000300 	.word	0x50000300
    fca8:	0bad0000 	.word	0x0bad0000
    fcac:	0bad0005 	.word	0x0bad0005

0000fcb0 <nrfx_spi_xfer>:
}

nrfx_err_t nrfx_spi_xfer(nrfx_spi_t const *           p_instance,
                         nrfx_spi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
    fcb0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    fcb4:	7906      	ldrb	r6, [r0, #4]
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    fcb6:	4c3c      	ldr	r4, [pc, #240]	; (fda8 <nrfx_spi_xfer+0xf8>)
    fcb8:	232c      	movs	r3, #44	; 0x2c
    fcba:	4373      	muls	r3, r6
{
    fcbc:	4690      	mov	r8, r2
    if (p_cb->transfer_in_progress)
    fcbe:	18e2      	adds	r2, r4, r3
{
    fcc0:	460f      	mov	r7, r1
    if (p_cb->transfer_in_progress)
    fcc2:	7f51      	ldrb	r1, [r2, #29]
{
    fcc4:	4681      	mov	r9, r0
    if (p_cb->transfer_in_progress)
    fcc6:	2900      	cmp	r1, #0
    fcc8:	d16b      	bne.n	fda2 <nrfx_spi_xfer+0xf2>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler)
    fcca:	58e3      	ldr	r3, [r4, r3]
    fccc:	b10b      	cbz	r3, fcd2 <nrfx_spi_xfer+0x22>
        {
            p_cb->transfer_in_progress = true;
    fcce:	2301      	movs	r3, #1
    fcd0:	7753      	strb	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
    fcd2:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    fcd6:	252c      	movs	r5, #44	; 0x2c
    fcd8:	fb05 4506 	mla	r5, r5, r6, r4
    fcdc:	f105 0c0c 	add.w	ip, r5, #12
    fce0:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    p_cb->abort = false;

    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    fce4:	7fa8      	ldrb	r0, [r5, #30]
    p_cb->abort = false;
    fce6:	2300      	movs	r3, #0
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    fce8:	28ff      	cmp	r0, #255	; 0xff
    p_cb->abort = false;
    fcea:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    fcee:	d001      	beq.n	fcf4 <nrfx_spi_xfer+0x44>
    {
        nrf_gpio_pin_clear(p_cb->ss_pin);
    fcf0:	f7ff ff06 	bl	fb00 <nrf_gpio_pin_clear>
    }
    if (flags)
    fcf4:	232c      	movs	r3, #44	; 0x2c
    fcf6:	f1b8 0f00 	cmp.w	r8, #0
    fcfa:	d007      	beq.n	fd0c <nrfx_spi_xfer+0x5c>
    {
        p_cb->transfer_in_progress = false;
    fcfc:	fb03 4306 	mla	r3, r3, r6, r4
    fd00:	2200      	movs	r2, #0
        err_code = NRFX_ERROR_NOT_SUPPORTED;
    fd02:	482a      	ldr	r0, [pc, #168]	; (fdac <nrfx_spi_xfer+0xfc>)
        p_cb->transfer_in_progress = false;
    fd04:	775a      	strb	r2, [r3, #29]
    }
    NRFX_LOG_INFO("Function: %s, error code: %s.",
                  __func__,
                  NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    fd06:	b003      	add	sp, #12
    fd08:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        spi_xfer(p_instance->p_reg, p_cb, p_xfer_desc);
    fd0c:	f8d9 5000 	ldr.w	r5, [r9]
    p_reg->INTENCLR = mask;
    fd10:	2204      	movs	r2, #4
    fd12:	f8c5 2308 	str.w	r2, [r5, #776]	; 0x308
    p_cb->bytes_transferred = 0;
    fd16:	fb03 4306 	mla	r3, r3, r6, r4
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    fd1a:	f8c5 8108 	str.w	r8, [r5, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    fd1e:	f8d5 2108 	ldr.w	r2, [r5, #264]	; 0x108
    fd22:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
    fd26:	9200      	str	r2, [sp, #0]
    (void)dummy;
    fd28:	9a00      	ldr	r2, [sp, #0]
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
    fd2a:	687a      	ldr	r2, [r7, #4]
    nrf_spi_txd_set(p_spi,
    fd2c:	b19a      	cbz	r2, fd56 <nrfx_spi_xfer+0xa6>
    fd2e:	683b      	ldr	r3, [r7, #0]
    fd30:	781b      	ldrb	r3, [r3, #0]
    p_reg->TXD = data;
    fd32:	f8c5 351c 	str.w	r3, [r5, #1308]	; 0x51c
    if (p_xfer_desc->tx_length > 1)
    fd36:	2a01      	cmp	r2, #1
    fd38:	d910      	bls.n	fd5c <nrfx_spi_xfer+0xac>
        nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
    fd3a:	683b      	ldr	r3, [r7, #0]
    fd3c:	785b      	ldrb	r3, [r3, #1]
    fd3e:	f8c5 351c 	str.w	r3, [r5, #1308]	; 0x51c
    if (p_cb->handler)
    fd42:	212c      	movs	r1, #44	; 0x2c
    fd44:	fb01 f306 	mul.w	r3, r1, r6
    fd48:	58e7      	ldr	r7, [r4, r3]
    fd4a:	b187      	cbz	r7, fd6e <nrfx_spi_xfer+0xbe>
    p_reg->INTENSET = mask;
    fd4c:	2304      	movs	r3, #4
    fd4e:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    nrfx_err_t err_code = NRFX_SUCCESS;
    fd52:	4817      	ldr	r0, [pc, #92]	; (fdb0 <nrfx_spi_xfer+0x100>)
    fd54:	e7d7      	b.n	fd06 <nrfx_spi_xfer+0x56>
    nrf_spi_txd_set(p_spi,
    fd56:	f893 3020 	ldrb.w	r3, [r3, #32]
    fd5a:	e7ea      	b.n	fd32 <nrfx_spi_xfer+0x82>
    else if (p_xfer_desc->rx_length > 1)
    fd5c:	68fb      	ldr	r3, [r7, #12]
    fd5e:	2b01      	cmp	r3, #1
    fd60:	d9ef      	bls.n	fd42 <nrfx_spi_xfer+0x92>
        nrf_spi_txd_set(p_spi, p_cb->orc);
    fd62:	232c      	movs	r3, #44	; 0x2c
    fd64:	fb03 4306 	mla	r3, r3, r6, r4
    p_reg->TXD = data;
    fd68:	f893 3020 	ldrb.w	r3, [r3, #32]
    fd6c:	e7e7      	b.n	fd3e <nrfx_spi_xfer+0x8e>
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    fd6e:	fb06 4101 	mla	r1, r6, r1, r4
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    fd72:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
            while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
    fd76:	2b00      	cmp	r3, #0
    fd78:	d0fb      	beq.n	fd72 <nrfx_spi_xfer+0xc2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    fd7a:	f8c5 7108 	str.w	r7, [r5, #264]	; 0x108
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    fd7e:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
    fd82:	9301      	str	r3, [sp, #4]
        } while (transfer_byte(p_spi, p_cb));
    fd84:	4628      	mov	r0, r5
    (void)dummy;
    fd86:	9b01      	ldr	r3, [sp, #4]
    fd88:	f007 fd2e 	bl	177e8 <transfer_byte>
    fd8c:	2800      	cmp	r0, #0
    fd8e:	d1f0      	bne.n	fd72 <nrfx_spi_xfer+0xc2>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    fd90:	232c      	movs	r3, #44	; 0x2c
    fd92:	fb03 4406 	mla	r4, r3, r6, r4
    fd96:	7fa0      	ldrb	r0, [r4, #30]
    fd98:	28ff      	cmp	r0, #255	; 0xff
    fd9a:	d0da      	beq.n	fd52 <nrfx_spi_xfer+0xa2>
            nrf_gpio_pin_set(p_cb->ss_pin);
    fd9c:	f7ff fec0 	bl	fb20 <nrf_gpio_pin_set>
    fda0:	e7d7      	b.n	fd52 <nrfx_spi_xfer+0xa2>
        return err_code;
    fda2:	4804      	ldr	r0, [pc, #16]	; (fdb4 <nrfx_spi_xfer+0x104>)
    fda4:	e7af      	b.n	fd06 <nrfx_spi_xfer+0x56>
    fda6:	bf00      	nop
    fda8:	20003be8 	.word	0x20003be8
    fdac:	0bad0003 	.word	0x0bad0003
    fdb0:	0bad0000 	.word	0x0bad0000
    fdb4:	0bad000b 	.word	0x0bad000b

0000fdb8 <nrfx_spi_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPI1_ENABLED)
void nrfx_spi_1_irq_handler(void)
{
    fdb8:	b507      	push	{r0, r1, r2, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    fdba:	4b0f      	ldr	r3, [pc, #60]	; (fdf8 <nrfx_spi_1_irq_handler+0x40>)
    if (!transfer_byte(p_spi, p_cb))
    fdbc:	490f      	ldr	r1, [pc, #60]	; (fdfc <nrfx_spi_1_irq_handler+0x44>)
    fdbe:	2200      	movs	r2, #0
    fdc0:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    fdc2:	681b      	ldr	r3, [r3, #0]
    fdc4:	9301      	str	r3, [sp, #4]
    fdc6:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
    (void)dummy;
    fdca:	9b01      	ldr	r3, [sp, #4]
    fdcc:	f007 fd0c 	bl	177e8 <transfer_byte>
    fdd0:	b970      	cbnz	r0, fdf0 <nrfx_spi_1_irq_handler+0x38>
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    fdd2:	7f88      	ldrb	r0, [r1, #30]
    fdd4:	28ff      	cmp	r0, #255	; 0xff
    fdd6:	d001      	beq.n	fddc <nrfx_spi_1_irq_handler+0x24>
        nrf_gpio_pin_set(p_cb->ss_pin);
    fdd8:	f7ff fea2 	bl	fb20 <nrf_gpio_pin_set>
    p_cb->transfer_in_progress = false;
    fddc:	2300      	movs	r3, #0
    fdde:	774b      	strb	r3, [r1, #29]
    p_cb->evt.type = NRFX_SPI_EVENT_DONE;
    fde0:	720b      	strb	r3, [r1, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    fde2:	e9d1 3100 	ldrd	r3, r1, [r1]
    fde6:	4806      	ldr	r0, [pc, #24]	; (fe00 <nrfx_spi_1_irq_handler+0x48>)
    irq_handler(NRF_SPI1, &m_cb[NRFX_SPI1_INST_IDX]);
}
    fde8:	b003      	add	sp, #12
    fdea:	f85d eb04 	ldr.w	lr, [sp], #4
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    fdee:	4718      	bx	r3
}
    fdf0:	b003      	add	sp, #12
    fdf2:	f85d fb04 	ldr.w	pc, [sp], #4
    fdf6:	bf00      	nop
    fdf8:	40004108 	.word	0x40004108
    fdfc:	20003be8 	.word	0x20003be8
    fe00:	20003bf0 	.word	0x20003bf0

0000fe04 <nrf_gpio_pin_clear>:
    if (*p_pin < P0_PIN_NUM)
    fe04:	281f      	cmp	r0, #31
        return NRF_P1;
    fe06:	bf86      	itte	hi
    fe08:	4a05      	ldrhi	r2, [pc, #20]	; (fe20 <nrf_gpio_pin_clear+0x1c>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fe0a:	f000 001f 	andhi.w	r0, r0, #31
        return NRF_P0;
    fe0e:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    fe12:	2301      	movs	r3, #1
    fe14:	fa03 f000 	lsl.w	r0, r3, r0
    p_reg->OUTCLR = clr_mask;
    fe18:	f8c2 050c 	str.w	r0, [r2, #1292]	; 0x50c
}
    fe1c:	4770      	bx	lr
    fe1e:	bf00      	nop
    fe20:	50000300 	.word	0x50000300

0000fe24 <nrf_gpio_cfg_output>:
    if (*p_pin < P0_PIN_NUM)
    fe24:	281f      	cmp	r0, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fe26:	bf86      	itte	hi
    fe28:	f000 001f 	andhi.w	r0, r0, #31
        return NRF_P1;
    fe2c:	4b04      	ldrhi	r3, [pc, #16]	; (fe40 <nrf_gpio_cfg_output+0x1c>)
        return NRF_P0;
    fe2e:	f04f 43a0 	movls.w	r3, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fe32:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
    fe36:	2203      	movs	r2, #3
    fe38:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
    fe3c:	4770      	bx	lr
    fe3e:	bf00      	nop
    fe40:	50000300 	.word	0x50000300

0000fe44 <nrf_gpio_pin_set>:
    if (*p_pin < P0_PIN_NUM)
    fe44:	281f      	cmp	r0, #31
        return NRF_P1;
    fe46:	bf86      	itte	hi
    fe48:	4a05      	ldrhi	r2, [pc, #20]	; (fe60 <nrf_gpio_pin_set+0x1c>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fe4a:	f000 001f 	andhi.w	r0, r0, #31
        return NRF_P0;
    fe4e:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    fe52:	2301      	movs	r3, #1
    fe54:	fa03 f000 	lsl.w	r0, r3, r0
    p_reg->OUTSET = set_mask;
    fe58:	f8c2 0508 	str.w	r0, [r2, #1288]	; 0x508
}
    fe5c:	4770      	bx	lr
    fe5e:	bf00      	nop
    fe60:	50000300 	.word	0x50000300

0000fe64 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
    fe64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_ASSERT(p_config);
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    fe68:	4d58      	ldr	r5, [pc, #352]	; (ffcc <nrfx_spim_init+0x168>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    fe6a:	7904      	ldrb	r4, [r0, #4]
{
    fe6c:	4607      	mov	r7, r0
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    fe6e:	2024      	movs	r0, #36	; 0x24
    fe70:	fb00 5004 	mla	r0, r0, r4, r5
    fe74:	7f00      	ldrb	r0, [r0, #28]
    fe76:	2800      	cmp	r0, #0
    fe78:	f040 80a4 	bne.w	ffc4 <nrfx_spim_init+0x160>
        return err_code;
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Check if SPIM instance supports the extended features.
    if (
    fe7c:	2c00      	cmp	r4, #0
    fe7e:	f040 80a3 	bne.w	ffc8 <nrfx_spim_init+0x164>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif

    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    fe82:	683c      	ldr	r4, [r7, #0]
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
    p_cb->p_context = p_context;
    fe84:	e9c5 2300 	strd	r2, r3, [r5]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPIM_MODE_1)
    fe88:	7b0b      	ldrb	r3, [r1, #12]
    fe8a:	7808      	ldrb	r0, [r1, #0]
    fe8c:	2b01      	cmp	r3, #1
    fe8e:	f200 8087 	bhi.w	ffa0 <nrfx_spim_init+0x13c>
    {
        nrf_gpio_pin_clear(p_config->sck_pin);
    fe92:	f7ff ffb7 	bl	fe04 <nrf_gpio_pin_clear>
    }
    else
    {
        nrf_gpio_pin_set(p_config->sck_pin);
    }
    nrf_gpio_cfg(p_config->sck_pin,
    fe96:	780b      	ldrb	r3, [r1, #0]
    if (*p_pin < P0_PIN_NUM)
    fe98:	2b1f      	cmp	r3, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fe9a:	bf86      	itte	hi
    fe9c:	f003 031f 	andhi.w	r3, r3, #31
        return NRF_P1;
    fea0:	4a4b      	ldrhi	r2, [pc, #300]	; (ffd0 <nrfx_spim_init+0x16c>)
        return NRF_P0;
    fea2:	f04f 42a0 	movls.w	r2, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fea6:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    feaa:	2001      	movs	r0, #1
    feac:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
    feb0:	784e      	ldrb	r6, [r1, #1]
    feb2:	2eff      	cmp	r6, #255	; 0xff
    feb4:	d077      	beq.n	ffa6 <nrfx_spim_init+0x142>
    {
        mosi_pin = p_config->mosi_pin;
        nrf_gpio_pin_clear(mosi_pin);
    feb6:	4630      	mov	r0, r6
    feb8:	f7ff ffa4 	bl	fe04 <nrf_gpio_pin_clear>
        nrf_gpio_cfg_output(mosi_pin);
    febc:	4630      	mov	r0, r6
    febe:	f7ff ffb1 	bl	fe24 <nrf_gpio_cfg_output>
    else
    {
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
    fec2:	788b      	ldrb	r3, [r1, #2]
    fec4:	2bff      	cmp	r3, #255	; 0xff
    fec6:	d071      	beq.n	ffac <nrfx_spim_init+0x148>
    if (*p_pin < P0_PIN_NUM)
    fec8:	2b1f      	cmp	r3, #31
    {
        miso_pin = p_config->miso_pin;
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
    feca:	7b88      	ldrb	r0, [r1, #14]
        return NRF_P1;
    fecc:	bf87      	ittee	hi
    fece:	f8df c100 	ldrhi.w	ip, [pc, #256]	; ffd0 <nrfx_spim_init+0x16c>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    fed2:	f003 021f 	andhi.w	r2, r3, #31
    fed6:	461a      	movls	r2, r3
        return NRF_P0;
    fed8:	f04f 4ca0 	movls.w	ip, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fedc:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    fee0:	0080      	lsls	r0, r0, #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fee2:	f84c 0022 	str.w	r0, [ip, r2, lsl #2]
        miso_pin = p_config->miso_pin;
    fee6:	4698      	mov	r8, r3
    }
    else
    {
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    }
    p_cb->miso_pin = p_config->miso_pin;
    fee8:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
    // - Slave Select (optional) - output with initial value 1 (inactive).

    // 'p_cb->ss_pin' variable is used during transfers to check if SS pin should be toggled,
    // so this field needs to be initialized even if the pin is not used.
    p_cb->ss_pin = p_config->ss_pin;
    feec:	78c8      	ldrb	r0, [r1, #3]
    feee:	f885 0020 	strb.w	r0, [r5, #32]

    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    fef2:	28ff      	cmp	r0, #255	; 0xff
    fef4:	d015      	beq.n	ff22 <nrfx_spim_init+0xbe>
    {
        if (p_config->ss_active_high)
    fef6:	790b      	ldrb	r3, [r1, #4]
    fef8:	2b00      	cmp	r3, #0
    fefa:	d05a      	beq.n	ffb2 <nrfx_spim_init+0x14e>
        {
            nrf_gpio_pin_clear(p_config->ss_pin);
    fefc:	f7ff ff82 	bl	fe04 <nrf_gpio_pin_clear>
        }
        else
        {
            nrf_gpio_pin_set(p_config->ss_pin);
        }
        nrf_gpio_cfg_output(p_config->ss_pin);
    ff00:	78c8      	ldrb	r0, [r1, #3]
    ff02:	f7ff ff8f 	bl	fe24 <nrf_gpio_cfg_output>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (p_config->use_hw_ss)
    ff06:	7c4a      	ldrb	r2, [r1, #17]
    ff08:	790b      	ldrb	r3, [r1, #4]
    ff0a:	b14a      	cbz	r2, ff20 <nrfx_spim_init+0xbc>
        {
            p_cb->use_hw_ss = p_config->use_hw_ss;
    ff0c:	2201      	movs	r2, #1
    ff0e:	77aa      	strb	r2, [r5, #30]
            nrf_spim_csn_configure(p_spim,
    ff10:	78c8      	ldrb	r0, [r1, #3]
    ff12:	7c8a      	ldrb	r2, [r1, #18]
    p_reg->PSEL.CSN = pin;
    ff14:	f8c4 0514 	str.w	r0, [r4, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
    ff18:	f8c4 3568 	str.w	r3, [r4, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
    ff1c:	f8c4 2564 	str.w	r2, [r4, #1380]	; 0x564
                                   (p_config->ss_active_high == true ?
                                        NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
                                   p_config->ss_duration);
        }
#endif
        p_cb->ss_active_high = p_config->ss_active_high;
    ff20:	77eb      	strb	r3, [r5, #31]
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // - DCX (optional) - output.
    if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
    ff22:	7bc8      	ldrb	r0, [r1, #15]
    ff24:	28ff      	cmp	r0, #255	; 0xff
    ff26:	d007      	beq.n	ff38 <nrfx_spim_init+0xd4>
    {
        nrf_gpio_pin_set(p_config->dcx_pin);
    ff28:	f7ff ff8c 	bl	fe44 <nrf_gpio_pin_set>
        nrf_gpio_cfg_output(p_config->dcx_pin);
    ff2c:	7bc8      	ldrb	r0, [r1, #15]
    ff2e:	f7ff ff79 	bl	fe24 <nrf_gpio_cfg_output>
        nrf_spim_dcx_pin_set(p_spim, p_config->dcx_pin);
    ff32:	7bcb      	ldrb	r3, [r1, #15]
    p_reg->PSELDCX = dcx_pin;
    ff34:	f8c4 356c 	str.w	r3, [r4, #1388]	; 0x56c
    }

    // Change rx delay
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
    ff38:	7c0b      	ldrb	r3, [r1, #16]
    p_reg->IFTIMING.RXDELAY = rxdelay;
    ff3a:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
#endif


    nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
    ff3e:	780b      	ldrb	r3, [r1, #0]
    p_reg->PSEL.SCK  = sck_pin;
    ff40:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
    ff44:	688b      	ldr	r3, [r1, #8]
    p_reg->PSEL.MOSI = mosi_pin;
    ff46:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
    ff4a:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
    ff4e:	f8c4 3524 	str.w	r3, [r4, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    ff52:	7b4b      	ldrb	r3, [r1, #13]
    nrf_spim_frequency_set(p_spim, p_config->frequency);
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
    ff54:	7b0a      	ldrb	r2, [r1, #12]
    ff56:	3b00      	subs	r3, #0
    ff58:	bf18      	it	ne
    ff5a:	2301      	movne	r3, #1
    switch (spi_mode)
    ff5c:	2a02      	cmp	r2, #2
    ff5e:	d02b      	beq.n	ffb8 <nrfx_spim_init+0x154>
    ff60:	2a03      	cmp	r2, #3
    ff62:	d02c      	beq.n	ffbe <nrfx_spim_init+0x15a>
    ff64:	2a01      	cmp	r2, #1
    ff66:	d101      	bne.n	ff6c <nrfx_spim_init+0x108>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
    ff68:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
    ff6c:	f8c4 3554 	str.w	r3, [r4, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
    ff70:	798b      	ldrb	r3, [r1, #6]
    ff72:	f8c4 35c0 	str.w	r3, [r4, #1472]	; 0x5c0

    nrf_spim_orc_set(p_spim, p_config->orc);

    if (p_cb->handler)
    ff76:	682b      	ldr	r3, [r5, #0]
    ff78:	b113      	cbz	r3, ff80 <nrfx_spim_init+0x11c>
    p_reg->INTENSET = mask;
    ff7a:	2240      	movs	r2, #64	; 0x40
    ff7c:	f8c4 2304 	str.w	r2, [r4, #772]	; 0x304
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
    ff80:	2207      	movs	r2, #7
    ff82:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
        nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
    }

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
    ff86:	b123      	cbz	r3, ff92 <nrfx_spim_init+0x12e>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
    ff88:	6838      	ldr	r0, [r7, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    ff8a:	f340 3007 	sbfx	r0, r0, #12, #8
    ff8e:	f7f5 fda3 	bl	5ad8 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
    ff92:	2300      	movs	r3, #0
    ff94:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    ff96:	480f      	ldr	r0, [pc, #60]	; (ffd4 <nrfx_spim_init+0x170>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    ff98:	2301      	movs	r3, #1
    ff9a:	772b      	strb	r3, [r5, #28]
}
    ff9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        nrf_gpio_pin_set(p_config->sck_pin);
    ffa0:	f7ff ff50 	bl	fe44 <nrf_gpio_pin_set>
    ffa4:	e777      	b.n	fe96 <nrfx_spim_init+0x32>
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    ffa6:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    ffaa:	e78a      	b.n	fec2 <nrfx_spim_init+0x5e>
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    ffac:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    ffb0:	e79a      	b.n	fee8 <nrfx_spim_init+0x84>
            nrf_gpio_pin_set(p_config->ss_pin);
    ffb2:	f7ff ff47 	bl	fe44 <nrf_gpio_pin_set>
    ffb6:	e7a3      	b.n	ff00 <nrfx_spim_init+0x9c>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    ffb8:	f043 0304 	orr.w	r3, r3, #4
        break;
    ffbc:	e7d6      	b.n	ff6c <nrfx_spim_init+0x108>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    ffbe:	f043 0306 	orr.w	r3, r3, #6
        break;
    ffc2:	e7d3      	b.n	ff6c <nrfx_spim_init+0x108>
        return err_code;
    ffc4:	4804      	ldr	r0, [pc, #16]	; (ffd8 <nrfx_spim_init+0x174>)
    ffc6:	e7e9      	b.n	ff9c <nrfx_spim_init+0x138>
        return err_code;
    ffc8:	4804      	ldr	r0, [pc, #16]	; (ffdc <nrfx_spim_init+0x178>)
    ffca:	e7e7      	b.n	ff9c <nrfx_spim_init+0x138>
    ffcc:	20003c14 	.word	0x20003c14
    ffd0:	50000300 	.word	0x50000300
    ffd4:	0bad0000 	.word	0x0bad0000
    ffd8:	0bad0005 	.word	0x0bad0005
    ffdc:	0bad0003 	.word	0x0bad0003

0000ffe0 <nrfx_spim_xfer>:
}

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
    ffe0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    ffe4:	7906      	ldrb	r6, [r0, #4]
                                     p_xfer_desc->rx_length,
                                     p_xfer_desc->tx_length));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    ffe6:	4f45      	ldr	r7, [pc, #276]	; (100fc <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xfd>)
    ffe8:	2324      	movs	r3, #36	; 0x24
    ffea:	4373      	muls	r3, r6
{
    ffec:	4615      	mov	r5, r2
    if (p_cb->transfer_in_progress)
    ffee:	18fa      	adds	r2, r7, r3
{
    fff0:	460c      	mov	r4, r1
    if (p_cb->transfer_in_progress)
    fff2:	7f51      	ldrb	r1, [r2, #29]
{
    fff4:	4680      	mov	r8, r0
    if (p_cb->transfer_in_progress)
    fff6:	2900      	cmp	r1, #0
    fff8:	d17d      	bne.n	100f6 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xf7>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
    fffa:	58fb      	ldr	r3, [r7, r3]
    fffc:	b123      	cbz	r3, 10008 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x9>
    fffe:	f015 0f14 	tst.w	r5, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   10002:	bf04      	itt	eq
   10004:	2301      	moveq	r3, #1
   10006:	7753      	strbeq	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   10008:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   1000c:	f04f 0c24 	mov.w	ip, #36	; 0x24
   10010:	fb0c 7c06 	mla	ip, ip, r6, r7
   10014:	f10c 0e0c 	add.w	lr, ip, #12
   10018:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}

    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   1001c:	f89c 0020 	ldrb.w	r0, [ip, #32]
   10020:	28ff      	cmp	r0, #255	; 0xff
   10022:	d007      	beq.n	10034 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x35>
    {
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (!p_cb->use_hw_ss)
   10024:	f89c 301e 	ldrb.w	r3, [ip, #30]
   10028:	b923      	cbnz	r3, 10034 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x35>
#endif
        {
            if (p_cb->ss_active_high)
   1002a:	f89c 301f 	ldrb.w	r3, [ip, #31]
   1002e:	b1c3      	cbz	r3, 10062 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x63>
            {
                nrf_gpio_pin_set(p_cb->ss_pin);
   10030:	f7ff ff08 	bl	fe44 <nrf_gpio_pin_set>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   10034:	6821      	ldr	r1, [r4, #0]
   10036:	b121      	cbz	r1, 10042 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x43>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   10038:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
   1003c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   10040:	d106      	bne.n	10050 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x51>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   10042:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   10044:	b182      	cbz	r2, 10068 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x69>
   10046:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   1004a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   1004e:	d00b      	beq.n	10068 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x69>
        p_cb->transfer_in_progress = false;
   10050:	2324      	movs	r3, #36	; 0x24
   10052:	fb03 7606 	mla	r6, r3, r6, r7
        return err_code;
   10056:	482a      	ldr	r0, [pc, #168]	; (10100 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x101>)
        p_cb->transfer_in_progress = false;
   10058:	2300      	movs	r3, #0
   1005a:	7773      	strb	r3, [r6, #29]
            }
        }
    }

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
}
   1005c:	b002      	add	sp, #8
   1005e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                nrf_gpio_pin_clear(p_cb->ss_pin);
   10062:	f7ff fecf 	bl	fe04 <nrf_gpio_pin_clear>
   10066:	e7e5      	b.n	10034 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x35>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   10068:	f8d8 3000 	ldr.w	r3, [r8]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   1006c:	6860      	ldr	r0, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1006e:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   10072:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   10076:	68e1      	ldr	r1, [r4, #12]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   10078:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1007c:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
   1007e:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   10082:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   10086:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   1008a:	9201      	str	r2, [sp, #4]
    (void)dummy;
   1008c:	9a01      	ldr	r2, [sp, #4]
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   1008e:	f015 0201 	ands.w	r2, r5, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   10092:	bf18      	it	ne
   10094:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   10096:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   1009a:	f015 0202 	ands.w	r2, r5, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   1009e:	bf18      	it	ne
   100a0:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   100a2:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   100a6:	072a      	lsls	r2, r5, #28
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   100a8:	bf5c      	itt	pl
   100aa:	2201      	movpl	r2, #1
   100ac:	611a      	strpl	r2, [r3, #16]
    if (!p_cb->handler)
   100ae:	2224      	movs	r2, #36	; 0x24
   100b0:	4372      	muls	r2, r6
   100b2:	58ba      	ldr	r2, [r7, r2]
   100b4:	b9aa      	cbnz	r2, 100e2 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xe3>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   100b6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
   100ba:	2a00      	cmp	r2, #0
   100bc:	d0fb      	beq.n	100b6 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xb7>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   100be:	2324      	movs	r3, #36	; 0x24
   100c0:	fb03 7606 	mla	r6, r3, r6, r7
   100c4:	f896 0020 	ldrb.w	r0, [r6, #32]
   100c8:	28ff      	cmp	r0, #255	; 0xff
   100ca:	d005      	beq.n	100d8 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xd9>
            if (!p_cb->use_hw_ss)
   100cc:	7fb3      	ldrb	r3, [r6, #30]
   100ce:	b91b      	cbnz	r3, 100d8 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xd9>
                if (p_cb->ss_active_high)
   100d0:	7ff3      	ldrb	r3, [r6, #31]
   100d2:	b11b      	cbz	r3, 100dc <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xdd>
                    nrf_gpio_pin_clear(p_cb->ss_pin);
   100d4:	f7ff fe96 	bl	fe04 <nrf_gpio_pin_clear>
    return err_code;
   100d8:	480a      	ldr	r0, [pc, #40]	; (10104 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x105>)
   100da:	e7bf      	b.n	1005c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x5d>
                    nrf_gpio_pin_set(p_cb->ss_pin);
   100dc:	f7ff feb2 	bl	fe44 <nrf_gpio_pin_set>
   100e0:	e7fa      	b.n	100d8 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xd9>
    if (!enable)
   100e2:	f015 0f04 	tst.w	r5, #4
   100e6:	f04f 0240 	mov.w	r2, #64	; 0x40
    p_reg->INTENCLR = mask;
   100ea:	bf14      	ite	ne
   100ec:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
   100f0:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
   100f4:	e7f0      	b.n	100d8 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xd9>
        return err_code;
   100f6:	4804      	ldr	r0, [pc, #16]	; (10108 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x109>)
   100f8:	e7b0      	b.n	1005c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x5d>
   100fa:	bf00      	nop
   100fc:	20003c14 	.word	0x20003c14
   10100:	0bad000a 	.word	0x0bad000a
   10104:	0bad0000 	.word	0x0bad0000
   10108:	0bad000b 	.word	0x0bad000b

0001010c <nrfx_spim_3_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1010c:	4b12      	ldr	r3, [pc, #72]	; (10158 <nrfx_spim_3_irq_handler+0x4c>)
   1010e:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
}
#endif

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
   10112:	b507      	push	{r0, r1, r2, lr}
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   10114:	b1eb      	cbz	r3, 10152 <nrfx_spim_3_irq_handler+0x46>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   10116:	4b11      	ldr	r3, [pc, #68]	; (1015c <nrfx_spim_3_irq_handler+0x50>)
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   10118:	4911      	ldr	r1, [pc, #68]	; (10160 <nrfx_spim_3_irq_handler+0x54>)
   1011a:	2200      	movs	r2, #0
   1011c:	601a      	str	r2, [r3, #0]
   1011e:	f891 0020 	ldrb.w	r0, [r1, #32]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   10122:	681b      	ldr	r3, [r3, #0]
   10124:	9301      	str	r3, [sp, #4]
   10126:	28ff      	cmp	r0, #255	; 0xff
    (void)dummy;
   10128:	9b01      	ldr	r3, [sp, #4]
   1012a:	d005      	beq.n	10138 <nrfx_spim_3_irq_handler+0x2c>
        if (!p_cb->use_hw_ss)
   1012c:	7f8b      	ldrb	r3, [r1, #30]
   1012e:	b91b      	cbnz	r3, 10138 <nrfx_spim_3_irq_handler+0x2c>
            if (p_cb->ss_active_high)
   10130:	7fcb      	ldrb	r3, [r1, #31]
   10132:	b15b      	cbz	r3, 1014c <nrfx_spim_3_irq_handler+0x40>
                nrf_gpio_pin_clear(p_cb->ss_pin);
   10134:	f7ff fe66 	bl	fe04 <nrf_gpio_pin_clear>
    p_cb->transfer_in_progress = false;
   10138:	2300      	movs	r3, #0
   1013a:	774b      	strb	r3, [r1, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   1013c:	720b      	strb	r3, [r1, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   1013e:	e9d1 3100 	ldrd	r3, r1, [r1]
   10142:	4808      	ldr	r0, [pc, #32]	; (10164 <nrfx_spim_3_irq_handler+0x58>)
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   10144:	b003      	add	sp, #12
   10146:	f85d eb04 	ldr.w	lr, [sp], #4
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   1014a:	4718      	bx	r3
                nrf_gpio_pin_set(p_cb->ss_pin);
   1014c:	f7ff fe7a 	bl	fe44 <nrf_gpio_pin_set>
   10150:	e7f2      	b.n	10138 <nrfx_spim_3_irq_handler+0x2c>
}
   10152:	b003      	add	sp, #12
   10154:	f85d fb04 	ldr.w	pc, [sp], #4
   10158:	4002f000 	.word	0x4002f000
   1015c:	4002f118 	.word	0x4002f118
   10160:	20003c14 	.word	0x20003c14
   10164:	20003c1c 	.word	0x20003c1c

00010168 <nrfx_systick_delay_ticks>:
    SysTick->LOAD = val;
}

NRF_STATIC_INLINE uint32_t nrf_systick_val_get(void)
{
    return SysTick->VAL;
   10168:	4a04      	ldr	r2, [pc, #16]	; (1017c <nrfx_systick_delay_ticks+0x14>)
   1016a:	6891      	ldr	r1, [r2, #8]
   1016c:	6893      	ldr	r3, [r2, #8]
void nrfx_systick_delay_ticks(uint32_t ticks)
{
    NRFX_ASSERT(ticks <= NRFX_SYSTICK_TICKS_MAX);

    const uint32_t start = nrf_systick_val_get();
    while ((NRF_SYSTICK_VAL_MASK & (start - nrf_systick_val_get())) < ticks)
   1016e:	1acb      	subs	r3, r1, r3
   10170:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   10174:	4283      	cmp	r3, r0
   10176:	d3f9      	bcc.n	1016c <nrfx_systick_delay_ticks+0x4>
    {
        /* Nothing to do */
    }
}
   10178:	4770      	bx	lr
   1017a:	bf00      	nop
   1017c:	e000e010 	.word	0xe000e010

00010180 <nrfx_systick_delay_us>:
    return us * ((SystemCoreClock) / NRFX_SYSTICK_US);
   10180:	4b03      	ldr	r3, [pc, #12]	; (10190 <nrfx_systick_delay_us+0x10>)
   10182:	4a04      	ldr	r2, [pc, #16]	; (10194 <nrfx_systick_delay_us+0x14>)
   10184:	681b      	ldr	r3, [r3, #0]
   10186:	fbb3 f3f2 	udiv	r3, r3, r2

void nrfx_systick_delay_us(uint32_t us)
{
    NRFX_SYSTICK_ASSERT_TIMEOUT(us);
    nrfx_systick_delay_ticks(nrfx_systick_us_tick(us));
   1018a:	4358      	muls	r0, r3
   1018c:	f7ff bfec 	b.w	10168 <nrfx_systick_delay_ticks>
   10190:	2000c14c 	.word	0x2000c14c
   10194:	000f4240 	.word	0x000f4240

00010198 <nrf52_errata_104>:
{
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   10198:	4b06      	ldr	r3, [pc, #24]	; (101b4 <nrf52_errata_104+0x1c>)
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
   1019a:	681b      	ldr	r3, [r3, #0]
   1019c:	2b08      	cmp	r3, #8
   1019e:	d106      	bne.n	101ae <nrf52_errata_104+0x16>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   101a0:	4b05      	ldr	r3, [pc, #20]	; (101b8 <nrf52_errata_104+0x20>)
   101a2:	681b      	ldr	r3, [r3, #0]
            {
                switch(var2)
   101a4:	2b03      	cmp	r3, #3
   101a6:	d802      	bhi.n	101ae <nrf52_errata_104+0x16>
   101a8:	4a04      	ldr	r2, [pc, #16]	; (101bc <nrf52_errata_104+0x24>)
   101aa:	5cd0      	ldrb	r0, [r2, r3]
   101ac:	4770      	bx	lr
                    case 0x03ul:
                        return false;
                }
            }
        #endif
        return false;
   101ae:	2000      	movs	r0, #0
    #endif
}
   101b0:	4770      	bx	lr
   101b2:	bf00      	nop
   101b4:	10000130 	.word	0x10000130
   101b8:	10000134 	.word	0x10000134
   101bc:	0001c04e 	.word	0x0001c04e

000101c0 <nrf52_errata_166>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   101c0:	4b06      	ldr	r3, [pc, #24]	; (101dc <nrf52_errata_166+0x1c>)
   101c2:	6818      	ldr	r0, [r3, #0]
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   101c4:	3b04      	subs	r3, #4
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
   101c6:	681b      	ldr	r3, [r3, #0]
   101c8:	2b08      	cmp	r3, #8
   101ca:	d104      	bne.n	101d6 <nrf52_errata_166+0x16>
            {
                switch(var2)
   101cc:	2803      	cmp	r0, #3
   101ce:	bf8c      	ite	hi
   101d0:	2000      	movhi	r0, #0
   101d2:	2001      	movls	r0, #1
   101d4:	4770      	bx	lr
                    case 0x03ul:
                        return true;
                }
            }
        #endif
        return false;
   101d6:	2000      	movs	r0, #0
    #endif
}
   101d8:	4770      	bx	lr
   101da:	bf00      	nop
   101dc:	10000134 	.word	0x10000134

000101e0 <ep_state_access>:
 * @param ep Endpoint number.
 */
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
{
    NRFX_USBD_ASSERT_EP_VALID(ep);
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
   101e0:	4b05      	ldr	r3, [pc, #20]	; (101f8 <ep_state_access+0x18>)
   101e2:	f010 0f80 	tst.w	r0, #128	; 0x80
   101e6:	f1a3 0290 	sub.w	r2, r3, #144	; 0x90
   101ea:	bf08      	it	eq
   101ec:	4613      	moveq	r3, r2
        NRF_USBD_EP_NR_GET(ep));
   101ee:	f000 000f 	and.w	r0, r0, #15
}
   101f2:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   101f6:	4770      	bx	lr
   101f8:	20003da8 	.word	0x20003da8

000101fc <usbd_dma_pending_clear>:
 *
 * Internal function to clear the flag informing about EasyDMA transfer pending.
 * This function is called always just after the finished EasyDMA transfer is detected.
 */
static inline void usbd_dma_pending_clear(void)
{
   101fc:	b508      	push	{r3, lr}
}

/* Errata: USBD cannot receive tasks during DMA. **/
static inline bool nrfx_usbd_errata_199(void)
{
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_199();
   101fe:	f7ff ffdf 	bl	101c0 <nrf52_errata_166>
    if (nrfx_usbd_errata_199())
   10202:	b110      	cbz	r0, 1020a <usbd_dma_pending_clear+0xe>
    {
        *((volatile uint32_t *)0x40027C1C) = 0x00000000;
   10204:	4b03      	ldr	r3, [pc, #12]	; (10214 <usbd_dma_pending_clear+0x18>)
   10206:	2200      	movs	r2, #0
   10208:	601a      	str	r2, [r3, #0]
    }
    m_dma_pending = false;
   1020a:	4b03      	ldr	r3, [pc, #12]	; (10218 <usbd_dma_pending_clear+0x1c>)
   1020c:	2200      	movs	r2, #0
   1020e:	701a      	strb	r2, [r3, #0]
}
   10210:	bd08      	pop	{r3, pc}
   10212:	bf00      	nop
   10214:	40027c1c 	.word	0x40027c1c
   10218:	200087db 	.word	0x200087db

0001021c <ev_usbreset_handler>:
 * Interrupt runtimes that would be vectorized using @ref m_isr.
 * @{
 */

static void ev_usbreset_handler(void)
{
   1021c:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
   1021e:	4a09      	ldr	r2, [pc, #36]	; (10244 <ev_usbreset_handler+0x28>)
   10220:	2300      	movs	r3, #0
   10222:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   10224:	4a08      	ldr	r2, [pc, #32]	; (10248 <ev_usbreset_handler+0x2c>)

    const nrfx_usbd_evt_t evt = {
   10226:	f8ad 3005 	strh.w	r3, [sp, #5]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   1022a:	7013      	strb	r3, [r2, #0]
    const nrfx_usbd_evt_t evt = {
   1022c:	f88d 3007 	strb.w	r3, [sp, #7]
   10230:	2301      	movs	r3, #1
   10232:	f88d 3004 	strb.w	r3, [sp, #4]
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
   10236:	4b05      	ldr	r3, [pc, #20]	; (1024c <ev_usbreset_handler+0x30>)
   10238:	a801      	add	r0, sp, #4
   1023a:	681b      	ldr	r3, [r3, #0]
   1023c:	4798      	blx	r3
}
   1023e:	b003      	add	sp, #12
   10240:	f85d fb04 	ldr.w	pc, [sp], #4
   10244:	200087da 	.word	0x200087da
   10248:	200087dd 	.word	0x200087dd
   1024c:	20003e38 	.word	0x20003e38

00010250 <nrfx_usbd_feeder_flash>:
{
   10250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t tx_size  = p_transfer->size;
   10252:	684d      	ldr	r5, [r1, #4]
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   10254:	4f0b      	ldr	r7, [pc, #44]	; (10284 <nrfx_usbd_feeder_flash+0x34>)
   10256:	4295      	cmp	r5, r2
   10258:	bf28      	it	cs
   1025a:	4615      	movcs	r5, r2
{
   1025c:	460c      	mov	r4, r1
   1025e:	4606      	mov	r6, r0
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   10260:	462a      	mov	r2, r5
   10262:	6809      	ldr	r1, [r1, #0]
   10264:	4638      	mov	r0, r7
   10266:	f005 fee8 	bl	1603a <memcpy>
    p_transfer->size -= tx_size;
   1026a:	6860      	ldr	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   1026c:	6822      	ldr	r2, [r4, #0]
    p_transfer->size -= tx_size;
   1026e:	1b40      	subs	r0, r0, r5
    p_next->size = tx_size;
   10270:	e9c6 7500 	strd	r7, r5, [r6]
    p_transfer->p_data.addr += tx_size;
   10274:	442a      	add	r2, r5
    p_transfer->size -= tx_size;
   10276:	6060      	str	r0, [r4, #4]
}
   10278:	3800      	subs	r0, #0
    p_transfer->p_data.addr += tx_size;
   1027a:	6022      	str	r2, [r4, #0]
}
   1027c:	bf18      	it	ne
   1027e:	2001      	movne	r0, #1
   10280:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10282:	bf00      	nop
   10284:	20003e40 	.word	0x20003e40

00010288 <nrfx_usbd_feeder_flash_zlp>:
{
   10288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t tx_size  = p_transfer->size;
   1028a:	684c      	ldr	r4, [r1, #4]
    if (tx_size > ep_size)
   1028c:	4294      	cmp	r4, r2
   1028e:	bf28      	it	cs
   10290:	4614      	movcs	r4, r2
{
   10292:	4606      	mov	r6, r0
   10294:	460d      	mov	r5, r1
    if (tx_size != 0)
   10296:	b18c      	cbz	r4, 102bc <nrfx_usbd_feeder_flash_zlp+0x34>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   10298:	4f09      	ldr	r7, [pc, #36]	; (102c0 <nrfx_usbd_feeder_flash_zlp+0x38>)
   1029a:	6809      	ldr	r1, [r1, #0]
   1029c:	4622      	mov	r2, r4
   1029e:	4638      	mov	r0, r7
   102a0:	f005 fecb 	bl	1603a <memcpy>
        p_next->p_data.tx = p_buffer;
   102a4:	6037      	str	r7, [r6, #0]
    p_transfer->size -= tx_size;
   102a6:	686b      	ldr	r3, [r5, #4]
    p_next->size = tx_size;
   102a8:	6074      	str	r4, [r6, #4]
    p_transfer->size -= tx_size;
   102aa:	1b1b      	subs	r3, r3, r4
   102ac:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
   102ae:	682b      	ldr	r3, [r5, #0]
}
   102b0:	1e20      	subs	r0, r4, #0
    p_transfer->p_data.addr += tx_size;
   102b2:	4423      	add	r3, r4
   102b4:	602b      	str	r3, [r5, #0]
}
   102b6:	bf18      	it	ne
   102b8:	2001      	movne	r0, #1
   102ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        p_next->p_data.tx = NULL;
   102bc:	6004      	str	r4, [r0, #0]
   102be:	e7f2      	b.n	102a6 <nrfx_usbd_feeder_flash_zlp+0x1e>
   102c0:	20003e40 	.word	0x20003e40

000102c4 <ev_usbevent_handler>:
    return p_reg->EVENTCAUSE;
   102c4:	4b21      	ldr	r3, [pc, #132]	; (1034c <ev_usbevent_handler+0x88>)
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
   102c6:	b513      	push	{r0, r1, r4, lr}
   102c8:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    p_reg->EVENTCAUSE = flags;
   102cc:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
   102d0:	05e1      	lsls	r1, r4, #23
    (void) p_reg->EVENTCAUSE;
   102d2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   102d6:	d50e      	bpl.n	102f6 <ev_usbevent_handler+0x32>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
   102d8:	4b1d      	ldr	r3, [pc, #116]	; (10350 <ev_usbevent_handler+0x8c>)
   102da:	2201      	movs	r2, #1
   102dc:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   102de:	2300      	movs	r3, #0
   102e0:	f8ad 3005 	strh.w	r3, [sp, #5]
   102e4:	f88d 3007 	strb.w	r3, [sp, #7]
   102e8:	2302      	movs	r3, #2
   102ea:	f88d 3004 	strb.w	r3, [sp, #4]
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
   102ee:	4b19      	ldr	r3, [pc, #100]	; (10354 <ev_usbevent_handler+0x90>)
   102f0:	a801      	add	r0, sp, #4
   102f2:	681b      	ldr	r3, [r3, #0]
   102f4:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   102f6:	05a2      	lsls	r2, r4, #22
   102f8:	d50d      	bpl.n	10316 <ev_usbevent_handler+0x52>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
   102fa:	4a15      	ldr	r2, [pc, #84]	; (10350 <ev_usbevent_handler+0x8c>)
   102fc:	2300      	movs	r3, #0
   102fe:	7013      	strb	r3, [r2, #0]
        const nrfx_usbd_evt_t evt = {
   10300:	f8ad 3005 	strh.w	r3, [sp, #5]
   10304:	f88d 3007 	strb.w	r3, [sp, #7]
   10308:	2303      	movs	r3, #3
   1030a:	f88d 3004 	strb.w	r3, [sp, #4]
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
   1030e:	4b11      	ldr	r3, [pc, #68]	; (10354 <ev_usbevent_handler+0x90>)
   10310:	a801      	add	r0, sp, #4
   10312:	681b      	ldr	r3, [r3, #0]
   10314:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
   10316:	0563      	lsls	r3, r4, #21
   10318:	d516      	bpl.n	10348 <ev_usbevent_handler+0x84>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
   1031a:	4a0d      	ldr	r2, [pc, #52]	; (10350 <ev_usbevent_handler+0x8c>)
   1031c:	7813      	ldrb	r3, [r2, #0]
   1031e:	b19b      	cbz	r3, 10348 <ev_usbevent_handler+0x84>
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check(NRF_USBD));
            m_bus_suspend = false;
   10320:	2300      	movs	r3, #0
   10322:	7013      	strb	r3, [r2, #0]
    p_reg->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
   10324:	4a09      	ldr	r2, [pc, #36]	; (1034c <ev_usbevent_handler+0x88>)
   10326:	2101      	movs	r1, #1
   10328:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   1032c:	6591      	str	r1, [r2, #88]	; 0x58
   1032e:	3258      	adds	r2, #88	; 0x58
            nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_DRIVEDPDM);

            const nrfx_usbd_evt_t evt = {
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
   10330:	a801      	add	r0, sp, #4
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10332:	6812      	ldr	r2, [r2, #0]
            const nrfx_usbd_evt_t evt = {
   10334:	f8ad 3005 	strh.w	r3, [sp, #5]
   10338:	f88d 3007 	strb.w	r3, [sp, #7]
   1033c:	2304      	movs	r3, #4
   1033e:	f88d 3004 	strb.w	r3, [sp, #4]
            m_event_handler(&evt);
   10342:	4b04      	ldr	r3, [pc, #16]	; (10354 <ev_usbevent_handler+0x90>)
   10344:	681b      	ldr	r3, [r3, #0]
   10346:	4798      	blx	r3
        }
    }
}
   10348:	b002      	add	sp, #8
   1034a:	bd10      	pop	{r4, pc}
   1034c:	40027000 	.word	0x40027000
   10350:	200087da 	.word	0x200087da
   10354:	20003e38 	.word	0x20003e38

00010358 <ev_sof_handler>:
{
   10358:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
   1035a:	2300      	movs	r3, #0
   1035c:	f88d 3004 	strb.w	r3, [sp, #4]
    return p_reg->FRAMECNTR;
   10360:	4b0b      	ldr	r3, [pc, #44]	; (10390 <ev_sof_handler+0x38>)
   10362:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
   10366:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = p_reg->SIZE.ISOOUT;
   1036a:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
   1036e:	4a09      	ldr	r2, [pc, #36]	; (10394 <ev_sof_handler+0x3c>)
    if (size_isoout == 0)
   10370:	2b00      	cmp	r3, #0
   10372:	6813      	ldr	r3, [r2, #0]
        iso_ready_mask |= (1U << ep2bit(NRFX_USBD_EPOUT8));
   10374:	bf0c      	ite	eq
   10376:	f44f 7180 	moveq.w	r1, #256	; 0x100
   1037a:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
    m_ep_ready |= iso_ready_mask;
   1037e:	430b      	orrs	r3, r1
   10380:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
   10382:	4b05      	ldr	r3, [pc, #20]	; (10398 <ev_sof_handler+0x40>)
   10384:	a801      	add	r0, sp, #4
   10386:	681b      	ldr	r3, [r3, #0]
   10388:	4798      	blx	r3
}
   1038a:	b003      	add	sp, #12
   1038c:	f85d fb04 	ldr.w	pc, [sp], #4
   10390:	40027000 	.word	0x40027000
   10394:	20003d14 	.word	0x20003d14
   10398:	20003e38 	.word	0x20003e38

0001039c <atomic_and.constprop.0>:
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1039c:	4b07      	ldr	r3, [pc, #28]	; (103bc <atomic_and.constprop.0+0x20>)
}
   1039e:	f3bf 8f5b 	dmb	ish
   103a2:	4602      	mov	r2, r0
   103a4:	e853 0f00 	ldrex	r0, [r3]
   103a8:	ea00 0102 	and.w	r1, r0, r2
   103ac:	e843 1c00 	strex	ip, r1, [r3]
   103b0:	f1bc 0f00 	cmp.w	ip, #0
   103b4:	d1f6      	bne.n	103a4 <atomic_and.constprop.0+0x8>
   103b6:	f3bf 8f5b 	dmb	ish
   103ba:	4770      	bx	lr
   103bc:	20003ca4 	.word	0x20003ca4

000103c0 <nrf_usbd_ep0in_dma_handler>:
{
   103c0:	b508      	push	{r3, lr}
    usbd_dma_pending_clear();
   103c2:	f7ff ff1b 	bl	101fc <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   103c6:	4b08      	ldr	r3, [pc, #32]	; (103e8 <nrf_usbd_ep0in_dma_handler+0x28>)
   103c8:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
   103cc:	2a03      	cmp	r2, #3
   103ce:	d105      	bne.n	103dc <nrf_usbd_ep0in_dma_handler+0x1c>
}
   103d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   103d4:	f06f 0001 	mvn.w	r0, #1
   103d8:	f7ff bfe0 	b.w	1039c <atomic_and.constprop.0>
    else if (p_state->handler.feeder == NULL)
   103dc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   103e0:	2b00      	cmp	r3, #0
   103e2:	d0f5      	beq.n	103d0 <nrf_usbd_ep0in_dma_handler+0x10>
}
   103e4:	bd08      	pop	{r3, pc}
   103e6:	bf00      	nop
   103e8:	20003d18 	.word	0x20003d18

000103ec <usbd_ep_data_handler>:
    m_ep_ready |= (1U << bitpos);
   103ec:	2201      	movs	r2, #1
{
   103ee:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_ep_ready |= (1U << bitpos);
   103f0:	fa02 f501 	lsl.w	r5, r2, r1
   103f4:	491c      	ldr	r1, [pc, #112]	; (10468 <usbd_ep_data_handler+0x7c>)
   103f6:	4e1d      	ldr	r6, [pc, #116]	; (1046c <usbd_ep_data_handler+0x80>)
   103f8:	680b      	ldr	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   103fa:	f010 0f80 	tst.w	r0, #128	; 0x80
    m_ep_ready |= (1U << bitpos);
   103fe:	ea43 0305 	orr.w	r3, r3, r5
{
   10402:	4604      	mov	r4, r0
    m_ep_ready |= (1U << bitpos);
   10404:	600b      	str	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   10406:	d024      	beq.n	10452 <usbd_ep_data_handler+0x66>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   10408:	f000 020f 	and.w	r2, r0, #15
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   1040c:	4b18      	ldr	r3, [pc, #96]	; (10470 <usbd_ep_data_handler+0x84>)
   1040e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   10412:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   10416:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   1041a:	681a      	ldr	r2, [r3, #0]
    if (ret)
   1041c:	b132      	cbz	r2, 1042c <usbd_ep_data_handler+0x40>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   1041e:	2200      	movs	r2, #0
   10420:	601a      	str	r2, [r3, #0]
            if (ep != NRFX_USBD_EPIN0)
   10422:	2880      	cmp	r0, #128	; 0x80
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   10424:	681b      	ldr	r3, [r3, #0]
   10426:	d011      	beq.n	1044c <usbd_ep_data_handler+0x60>
                nrf_usbd_epin_dma_handler(ep);
   10428:	f007 fa5b 	bl	178e2 <nrf_usbd_epin_dma_handler>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   1042c:	6831      	ldr	r1, [r6, #0]
   1042e:	4029      	ands	r1, r5
   10430:	d10a      	bne.n	10448 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10432:	2306      	movs	r3, #6
   10434:	f88d 3004 	strb.w	r3, [sp, #4]
   10438:	f88d 4006 	strb.w	r4, [sp, #6]
   1043c:	f88d 1007 	strb.w	r1, [sp, #7]
            m_event_handler(&evt);
   10440:	4b0c      	ldr	r3, [pc, #48]	; (10474 <usbd_ep_data_handler+0x88>)
   10442:	a801      	add	r0, sp, #4
   10444:	681b      	ldr	r3, [r3, #0]
   10446:	4798      	blx	r3
}
   10448:	b002      	add	sp, #8
   1044a:	bd70      	pop	{r4, r5, r6, pc}
                nrf_usbd_ep0in_dma_handler();
   1044c:	f7ff ffb8 	bl	103c0 <nrf_usbd_ep0in_dma_handler>
   10450:	e7ec      	b.n	1042c <usbd_ep_data_handler+0x40>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   10452:	6833      	ldr	r3, [r6, #0]
   10454:	421d      	tst	r5, r3
   10456:	d1f7      	bne.n	10448 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
   10458:	2306      	movs	r3, #6
   1045a:	f88d 3004 	strb.w	r3, [sp, #4]
   1045e:	f88d 0006 	strb.w	r0, [sp, #6]
   10462:	f88d 2007 	strb.w	r2, [sp, #7]
   10466:	e7eb      	b.n	10440 <usbd_ep_data_handler+0x54>
   10468:	20003d14 	.word	0x20003d14
   1046c:	20003ca4 	.word	0x20003ca4
   10470:	00019b58 	.word	0x00019b58
   10474:	20003e38 	.word	0x20003e38

00010478 <ev_setup_data_handler>:
{
   10478:	b508      	push	{r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   1047a:	4b05      	ldr	r3, [pc, #20]	; (10490 <ev_setup_data_handler+0x18>)
   1047c:	781a      	ldrb	r2, [r3, #0]
   1047e:	4610      	mov	r0, r2
   10480:	f007 fa23 	bl	178ca <ep2bit>
}
   10484:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   10488:	4601      	mov	r1, r0
   1048a:	4610      	mov	r0, r2
   1048c:	f7ff bfae 	b.w	103ec <usbd_ep_data_handler>
   10490:	200087dd 	.word	0x200087dd

00010494 <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   10494:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
   10496:	f7ff feb1 	bl	101fc <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   1049a:	4b0c      	ldr	r3, [pc, #48]	; (104cc <ev_dma_epout8_handler+0x38>)
   1049c:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
   104a0:	2a03      	cmp	r2, #3
   104a2:	d010      	beq.n	104c6 <ev_dma_epout8_handler+0x32>
    else if (p_state->handler.consumer == NULL)
   104a4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   104a8:	b96b      	cbnz	r3, 104c6 <ev_dma_epout8_handler+0x32>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   104aa:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
   104ae:	f7ff ff75 	bl	1039c <atomic_and.constprop.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   104b2:	2306      	movs	r3, #6
   104b4:	f88d 3004 	strb.w	r3, [sp, #4]
   104b8:	2308      	movs	r3, #8
   104ba:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   104be:	4b04      	ldr	r3, [pc, #16]	; (104d0 <ev_dma_epout8_handler+0x3c>)
   104c0:	a801      	add	r0, sp, #4
   104c2:	681b      	ldr	r3, [r3, #0]
   104c4:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   104c6:	b003      	add	sp, #12
   104c8:	f85d fb04 	ldr.w	pc, [sp], #4
   104cc:	20003d18 	.word	0x20003d18
   104d0:	20003e38 	.word	0x20003e38

000104d4 <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   104d4:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
   104d6:	f7ff fe91 	bl	101fc <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   104da:	4b0f      	ldr	r3, [pc, #60]	; (10518 <ev_dma_epin8_handler+0x44>)
   104dc:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
   104e0:	2a03      	cmp	r2, #3
   104e2:	d106      	bne.n	104f2 <ev_dma_epin8_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   104e4:	f46f 7080 	mvn.w	r0, #256	; 0x100
   104e8:	f7ff ff58 	bl	1039c <atomic_and.constprop.0>
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   104ec:	b003      	add	sp, #12
   104ee:	f85d fb04 	ldr.w	pc, [sp], #4
    else if (p_state->handler.feeder == NULL)
   104f2:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   104f6:	2b00      	cmp	r3, #0
   104f8:	d1f8      	bne.n	104ec <ev_dma_epin8_handler+0x18>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   104fa:	f46f 7080 	mvn.w	r0, #256	; 0x100
   104fe:	f7ff ff4d 	bl	1039c <atomic_and.constprop.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10502:	2306      	movs	r3, #6
   10504:	f88d 3004 	strb.w	r3, [sp, #4]
   10508:	2388      	movs	r3, #136	; 0x88
   1050a:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   1050e:	4b03      	ldr	r3, [pc, #12]	; (1051c <ev_dma_epin8_handler+0x48>)
   10510:	a801      	add	r0, sp, #4
   10512:	681b      	ldr	r3, [r3, #0]
   10514:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   10516:	e7e9      	b.n	104ec <ev_dma_epin8_handler+0x18>
   10518:	20003d18 	.word	0x20003d18
   1051c:	20003e38 	.word	0x20003e38

00010520 <nrfx_usbd_uninit>:

void nrfx_usbd_uninit(void)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    m_event_handler = NULL;
   10520:	4a02      	ldr	r2, [pc, #8]	; (1052c <nrfx_usbd_uninit+0xc>)
   10522:	2300      	movs	r3, #0
   10524:	6013      	str	r3, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
   10526:	4a02      	ldr	r2, [pc, #8]	; (10530 <nrfx_usbd_uninit+0x10>)
   10528:	7013      	strb	r3, [r2, #0]
    return;
}
   1052a:	4770      	bx	lr
   1052c:	20003e38 	.word	0x20003e38
   10530:	200087dc 	.word	0x200087dc

00010534 <nrfx_usbd_enable>:
    p_reg->EVENTCAUSE = flags;
   10534:	4b5c      	ldr	r3, [pc, #368]	; (106a8 <nrfx_usbd_enable+0x174>)
   10536:	f44f 6200 	mov.w	r2, #2048	; 0x800

void nrfx_usbd_enable(void)
{
   1053a:	b510      	push	{r4, lr}
   1053c:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   10540:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   10544:	4b59      	ldr	r3, [pc, #356]	; (106ac <nrfx_usbd_enable+0x178>)
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
   10546:	681b      	ldr	r3, [r3, #0]
   10548:	2b08      	cmp	r3, #8
   1054a:	d11e      	bne.n	1058a <nrfx_usbd_enable+0x56>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   1054c:	4b58      	ldr	r3, [pc, #352]	; (106b0 <nrfx_usbd_enable+0x17c>)
   1054e:	681b      	ldr	r3, [r3, #0]
            {
                switch(var2)
   10550:	2b03      	cmp	r3, #3
   10552:	d81a      	bhi.n	1058a <nrfx_usbd_enable+0x56>
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    /* Prepare for READY event receiving */
    nrf_usbd_eventcause_clear(NRF_USBD, NRF_USBD_EVENTCAUSE_READY_MASK);

    if (nrfx_usbd_errata_187())
   10554:	4a57      	ldr	r2, [pc, #348]	; (106b4 <nrfx_usbd_enable+0x180>)
   10556:	5cd3      	ldrb	r3, [r2, r3]
   10558:	b1bb      	cbz	r3, 1058a <nrfx_usbd_enable+0x56>
	__asm__ volatile(
   1055a:	f04f 0320 	mov.w	r3, #32
   1055e:	f3ef 8411 	mrs	r4, BASEPRI
   10562:	f383 8811 	msr	BASEPRI, r3
   10566:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   1056a:	4b53      	ldr	r3, [pc, #332]	; (106b8 <nrfx_usbd_enable+0x184>)
   1056c:	4a53      	ldr	r2, [pc, #332]	; (106bc <nrfx_usbd_enable+0x188>)
   1056e:	6818      	ldr	r0, [r3, #0]
   10570:	2103      	movs	r1, #3
   10572:	2800      	cmp	r0, #0
   10574:	f040 808e 	bne.w	10694 <nrfx_usbd_enable+0x160>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   10578:	f249 3075 	movw	r0, #37749	; 0x9375
   1057c:	6018      	str	r0, [r3, #0]
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
   1057e:	6011      	str	r1, [r2, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   10580:	6018      	str	r0, [r3, #0]
	__asm__ volatile(
   10582:	f384 8811 	msr	BASEPRI, r4
   10586:	f3bf 8f6f 	isb	sy
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_171();
   1058a:	f7ff fe19 	bl	101c0 <nrf52_errata_166>
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
        }
        NRFX_CRITICAL_SECTION_EXIT();
    }

    if (nrfx_usbd_errata_171())
   1058e:	b1b0      	cbz	r0, 105be <nrfx_usbd_enable+0x8a>
	__asm__ volatile(
   10590:	f04f 0320 	mov.w	r3, #32
   10594:	f3ef 8411 	mrs	r4, BASEPRI
   10598:	f383 8811 	msr	BASEPRI, r3
   1059c:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   105a0:	4b45      	ldr	r3, [pc, #276]	; (106b8 <nrfx_usbd_enable+0x184>)
   105a2:	4a47      	ldr	r2, [pc, #284]	; (106c0 <nrfx_usbd_enable+0x18c>)
   105a4:	6818      	ldr	r0, [r3, #0]
   105a6:	21c0      	movs	r1, #192	; 0xc0
   105a8:	2800      	cmp	r0, #0
   105aa:	d175      	bne.n	10698 <nrfx_usbd_enable+0x164>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   105ac:	f249 3075 	movw	r0, #37749	; 0x9375
   105b0:	6018      	str	r0, [r3, #0]
            *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
   105b2:	6011      	str	r1, [r2, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   105b4:	6018      	str	r0, [r3, #0]
	__asm__ volatile(
   105b6:	f384 8811 	msr	BASEPRI, r4
   105ba:	f3bf 8f6f 	isb	sy
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
   105be:	4b3a      	ldr	r3, [pc, #232]	; (106a8 <nrfx_usbd_enable+0x174>)
   105c0:	2201      	movs	r2, #1
   105c2:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   105c6:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
    return p_reg->EVENTCAUSE;
   105ca:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    }

    /* Enable the peripheral */
    nrf_usbd_enable(NRF_USBD);
    /* Waiting for peripheral to enable, this should take a few us */
    while (0 == (NRF_USBD_EVENTCAUSE_READY_MASK & nrf_usbd_eventcause_get(NRF_USBD)))
   105ce:	0512      	lsls	r2, r2, #20
   105d0:	d5fb      	bpl.n	105ca <nrfx_usbd_enable+0x96>
    p_reg->EVENTCAUSE = flags;
   105d2:	f44f 6200 	mov.w	r2, #2048	; 0x800
   105d6:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   105da:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   105de:	f7ff fdef 	bl	101c0 <nrf52_errata_166>
    {
        /* Empty loop */
    }
    nrf_usbd_eventcause_clear(NRF_USBD, NRF_USBD_EVENTCAUSE_READY_MASK);

    if (nrfx_usbd_errata_171())
   105e2:	b1a8      	cbz	r0, 10610 <nrfx_usbd_enable+0xdc>
	__asm__ volatile(
   105e4:	f04f 0320 	mov.w	r3, #32
   105e8:	f3ef 8411 	mrs	r4, BASEPRI
   105ec:	f383 8811 	msr	BASEPRI, r3
   105f0:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   105f4:	4b30      	ldr	r3, [pc, #192]	; (106b8 <nrfx_usbd_enable+0x184>)
   105f6:	4a32      	ldr	r2, [pc, #200]	; (106c0 <nrfx_usbd_enable+0x18c>)
   105f8:	6818      	ldr	r0, [r3, #0]
   105fa:	2800      	cmp	r0, #0
   105fc:	d14e      	bne.n	1069c <nrfx_usbd_enable+0x168>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   105fe:	f249 3175 	movw	r1, #37749	; 0x9375
   10602:	6019      	str	r1, [r3, #0]
            *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
   10604:	6010      	str	r0, [r2, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   10606:	6019      	str	r1, [r3, #0]
	__asm__ volatile(
   10608:	f384 8811 	msr	BASEPRI, r4
   1060c:	f3bf 8f6f 	isb	sy
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_166();
   10610:	f7ff fdd6 	bl	101c0 <nrf52_errata_166>
        }

        NRFX_CRITICAL_SECTION_EXIT();
    }

    if (nrfx_usbd_errata_166())
   10614:	b148      	cbz	r0, 1062a <nrfx_usbd_enable+0xf6>
    {
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7E3;
   10616:	4b2b      	ldr	r3, [pc, #172]	; (106c4 <nrfx_usbd_enable+0x190>)
   10618:	f240 72e3 	movw	r2, #2019	; 0x7e3
   1061c:	601a      	str	r2, [r3, #0]
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = 0x40;
   1061e:	2240      	movs	r2, #64	; 0x40
   10620:	605a      	str	r2, [r3, #4]
  __ASM volatile ("isb 0xF":::"memory");
   10622:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
   10626:	f3bf 8f4f 	dsb	sy
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
   1062a:	4b1f      	ldr	r3, [pc, #124]	; (106a8 <nrfx_usbd_enable+0x174>)
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   1062c:	2100      	movs	r1, #0
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
   1062e:	2280      	movs	r2, #128	; 0x80
   10630:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   10634:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   10638:	4b23      	ldr	r3, [pc, #140]	; (106c8 <nrfx_usbd_enable+0x194>)
   1063a:	f240 12ff 	movw	r2, #511	; 0x1ff
   1063e:	601a      	str	r2, [r3, #0]
    m_ep_dma_waiting = 0;
   10640:	4b22      	ldr	r3, [pc, #136]	; (106cc <nrfx_usbd_enable+0x198>)
   10642:	6019      	str	r1, [r3, #0]
    usbd_dma_pending_clear();
   10644:	f7ff fdda 	bl	101fc <usbd_dma_pending_clear>
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   10648:	4b21      	ldr	r3, [pc, #132]	; (106d0 <nrfx_usbd_enable+0x19c>)
   1064a:	7019      	strb	r1, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
   1064c:	4b21      	ldr	r3, [pc, #132]	; (106d4 <nrfx_usbd_enable+0x1a0>)
   1064e:	2202      	movs	r2, #2
   10650:	701a      	strb	r2, [r3, #0]
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   10652:	4b16      	ldr	r3, [pc, #88]	; (106ac <nrfx_usbd_enable+0x178>)
            if (var1 == 0x08)
   10654:	681b      	ldr	r3, [r3, #0]
   10656:	2b08      	cmp	r3, #8
   10658:	d11b      	bne.n	10692 <nrfx_usbd_enable+0x15e>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   1065a:	4b15      	ldr	r3, [pc, #84]	; (106b0 <nrfx_usbd_enable+0x17c>)
   1065c:	681b      	ldr	r3, [r3, #0]
                switch(var2)
   1065e:	2b03      	cmp	r3, #3
   10660:	d817      	bhi.n	10692 <nrfx_usbd_enable+0x15e>

    if (nrfx_usbd_errata_187())
   10662:	4a14      	ldr	r2, [pc, #80]	; (106b4 <nrfx_usbd_enable+0x180>)
   10664:	5cd3      	ldrb	r3, [r2, r3]
   10666:	b1a3      	cbz	r3, 10692 <nrfx_usbd_enable+0x15e>
	__asm__ volatile(
   10668:	f04f 0320 	mov.w	r3, #32
   1066c:	f3ef 8411 	mrs	r4, BASEPRI
   10670:	f383 8811 	msr	BASEPRI, r3
   10674:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   10678:	4b0f      	ldr	r3, [pc, #60]	; (106b8 <nrfx_usbd_enable+0x184>)
   1067a:	4a10      	ldr	r2, [pc, #64]	; (106bc <nrfx_usbd_enable+0x188>)
   1067c:	6818      	ldr	r0, [r3, #0]
   1067e:	b980      	cbnz	r0, 106a2 <nrfx_usbd_enable+0x16e>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   10680:	f249 3175 	movw	r1, #37749	; 0x9375
   10684:	6019      	str	r1, [r3, #0]
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
   10686:	6010      	str	r0, [r2, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   10688:	6019      	str	r1, [r3, #0]
	__asm__ volatile(
   1068a:	f384 8811 	msr	BASEPRI, r4
   1068e:	f3bf 8f6f 	isb	sy
        {
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
        }
        NRFX_CRITICAL_SECTION_EXIT();
    }
}
   10692:	bd10      	pop	{r4, pc}
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
   10694:	6011      	str	r1, [r2, #0]
   10696:	e774      	b.n	10582 <nrfx_usbd_enable+0x4e>
            *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
   10698:	6011      	str	r1, [r2, #0]
   1069a:	e78c      	b.n	105b6 <nrfx_usbd_enable+0x82>
            *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
   1069c:	2300      	movs	r3, #0
   1069e:	6013      	str	r3, [r2, #0]
   106a0:	e7b2      	b.n	10608 <nrfx_usbd_enable+0xd4>
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
   106a2:	6011      	str	r1, [r2, #0]
   106a4:	e7f1      	b.n	1068a <nrfx_usbd_enable+0x156>
   106a6:	bf00      	nop
   106a8:	40027000 	.word	0x40027000
   106ac:	10000130 	.word	0x10000130
   106b0:	10000134 	.word	0x10000134
   106b4:	0001c052 	.word	0x0001c052
   106b8:	4006ec00 	.word	0x4006ec00
   106bc:	4006ed14 	.word	0x4006ed14
   106c0:	4006ec14 	.word	0x4006ec14
   106c4:	40027800 	.word	0x40027800
   106c8:	20003d14 	.word	0x20003d14
   106cc:	20003ca4 	.word	0x20003ca4
   106d0:	200087dd 	.word	0x200087dd
   106d4:	200087dc 	.word	0x200087dc

000106d8 <nrfx_usbd_start>:
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    m_bus_suspend = false;
   106d8:	4b0d      	ldr	r3, [pc, #52]	; (10710 <nrfx_usbd_start+0x38>)
   106da:	2200      	movs	r2, #0
{
   106dc:	b510      	push	{r4, lr}
    m_bus_suspend = false;
   106de:	701a      	strb	r2, [r3, #0]
       NRF_USBD_INT_ENDEPOUT0_MASK    |
       NRF_USBD_INT_USBEVENT_MASK     |
       NRF_USBD_INT_EP0SETUP_MASK     |
       NRF_USBD_INT_DATAEP_MASK;

   if (enable_sof || nrfx_usbd_errata_104())
   106e0:	b998      	cbnz	r0, 1070a <nrfx_usbd_start+0x32>
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_104();
   106e2:	f7ff fd59 	bl	10198 <nrf52_errata_104>
    uint32_t ints_to_enable =
   106e6:	4b0b      	ldr	r3, [pc, #44]	; (10714 <nrfx_usbd_start+0x3c>)
   106e8:	4a0b      	ldr	r2, [pc, #44]	; (10718 <nrfx_usbd_start+0x40>)
   106ea:	2800      	cmp	r0, #0
   106ec:	bf14      	ite	ne
   106ee:	4618      	movne	r0, r3
   106f0:	4610      	moveq	r0, r2
    p_reg->INTENSET = mask;
   106f2:	4c0a      	ldr	r4, [pc, #40]	; (1071c <nrfx_usbd_start+0x44>)
   106f4:	f8c4 0304 	str.w	r0, [r4, #772]	; 0x304
   /* Enable all required interrupts */
   nrf_usbd_int_enable(NRF_USBD, ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_DEFAULT_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
   106f8:	2027      	movs	r0, #39	; 0x27
   106fa:	f7f5 f9ed 	bl	5ad8 <arch_irq_enable>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
   106fe:	2301      	movs	r3, #1
   10700:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   10704:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504

   /* Enable pullups */
   nrf_usbd_pullup_enable(NRF_USBD);
}
   10708:	bd10      	pop	{r4, pc}
       ints_to_enable |= NRF_USBD_INT_SOF_MASK;
   1070a:	4802      	ldr	r0, [pc, #8]	; (10714 <nrfx_usbd_start+0x3c>)
   1070c:	e7f1      	b.n	106f2 <nrfx_usbd_start+0x1a>
   1070e:	bf00      	nop
   10710:	200087da 	.word	0x200087da
   10714:	01e01407 	.word	0x01e01407
   10718:	01c01407 	.word	0x01c01407
   1071c:	40027000 	.word	0x40027000

00010720 <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
   10720:	4b03      	ldr	r3, [pc, #12]	; (10730 <nrfx_usbd_is_enabled+0x10>)
   10722:	7818      	ldrb	r0, [r3, #0]
}
   10724:	2801      	cmp	r0, #1
   10726:	bf94      	ite	ls
   10728:	2000      	movls	r0, #0
   1072a:	2001      	movhi	r0, #1
   1072c:	4770      	bx	lr
   1072e:	bf00      	nop
   10730:	200087dc 	.word	0x200087dc

00010734 <nrfx_usbd_init>:
{
   10734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
   10736:	4b1c      	ldr	r3, [pc, #112]	; (107a8 <nrfx_usbd_init+0x74>)
   10738:	781c      	ldrb	r4, [r3, #0]
   1073a:	bb94      	cbnz	r4, 107a2 <nrfx_usbd_init+0x6e>
    m_event_handler = event_handler;
   1073c:	4a1b      	ldr	r2, [pc, #108]	; (107ac <nrfx_usbd_init+0x78>)
   1073e:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   10740:	2201      	movs	r2, #1
   10742:	701a      	strb	r2, [r3, #0]
   10744:	4625      	mov	r5, r4
        p_state->status = NRFX_USBD_EP_OK;
   10746:	4627      	mov	r7, r4
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   10748:	f065 067f 	orn	r6, r5, #127	; 0x7f
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   1074c:	f015 0f08 	tst.w	r5, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   10750:	b2f6      	uxtb	r6, r6
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   10752:	bf0c      	ite	eq
   10754:	2140      	moveq	r1, #64	; 0x40
   10756:	f44f 7100 	movne.w	r1, #512	; 0x200
   1075a:	4630      	mov	r0, r6
   1075c:	f007 f8ef 	bl	1793e <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   10760:	4630      	mov	r0, r6
   10762:	f7ff fd3d 	bl	101e0 <ep_state_access>
        p_state->status = NRFX_USBD_EP_OK;
   10766:	3501      	adds	r5, #1
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   10768:	2d09      	cmp	r5, #9
        p_state->status = NRFX_USBD_EP_OK;
   1076a:	7387      	strb	r7, [r0, #14]
        p_state->handler.feeder = NULL;
   1076c:	6007      	str	r7, [r0, #0]
        p_state->transfer_cnt = 0;
   1076e:	6087      	str	r7, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   10770:	d1ea      	bne.n	10748 <nrfx_usbd_init+0x14>
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   10772:	2140      	movs	r1, #64	; 0x40
        p_state->status = NRFX_USBD_EP_OK;
   10774:	2500      	movs	r5, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   10776:	4620      	mov	r0, r4
   10778:	f007 f8e1 	bl	1793e <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   1077c:	4620      	mov	r0, r4
   1077e:	f7ff fd2f 	bl	101e0 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   10782:	3401      	adds	r4, #1
   10784:	b2e4      	uxtb	r4, r4
   10786:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   10788:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
   1078a:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
   1078c:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   1078e:	d101      	bne.n	10794 <nrfx_usbd_init+0x60>
    return NRFX_SUCCESS;
   10790:	4807      	ldr	r0, [pc, #28]	; (107b0 <nrfx_usbd_init+0x7c>)
}
   10792:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   10794:	f014 0f08 	tst.w	r4, #8
   10798:	bf14      	ite	ne
   1079a:	f44f 7100 	movne.w	r1, #512	; 0x200
   1079e:	2140      	moveq	r1, #64	; 0x40
   107a0:	e7e9      	b.n	10776 <nrfx_usbd_init+0x42>
        return NRFX_ERROR_INVALID_STATE;
   107a2:	4804      	ldr	r0, [pc, #16]	; (107b4 <nrfx_usbd_init+0x80>)
   107a4:	e7f5      	b.n	10792 <nrfx_usbd_init+0x5e>
   107a6:	bf00      	nop
   107a8:	200087dc 	.word	0x200087dc
   107ac:	20003e38 	.word	0x20003e38
   107b0:	0bad0000 	.word	0x0bad0000
   107b4:	0bad0005 	.word	0x0bad0005

000107b8 <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
   107b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   107bc:	4605      	mov	r5, r0
	__asm__ volatile(
   107be:	f04f 0320 	mov.w	r3, #32
   107c2:	f3ef 8711 	mrs	r7, BASEPRI
   107c6:	f383 8811 	msr	BASEPRI, r3
   107ca:	f3bf 8f6f 	isb	sy
    const uint8_t ep_bitpos = ep2bit(ep);
    NRFX_ASSERT(NULL != p_transfer);

    NRFX_CRITICAL_SECTION_ENTER();
    /* Setup data transaction can go only in one direction at a time */
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
   107ce:	f010 040f 	ands.w	r4, r0, #15
   107d2:	d103      	bne.n	107dc <nrfx_usbd_ep_transfer+0x24>
   107d4:	4b28      	ldr	r3, [pc, #160]	; (10878 <nrfx_usbd_ep_transfer+0xc0>)
   107d6:	781b      	ldrb	r3, [r3, #0]
   107d8:	4283      	cmp	r3, r0
   107da:	d149      	bne.n	10870 <nrfx_usbd_ep_transfer+0xb8>
            (NRFX_USBD_ISO_DEBUG || (!NRF_USBD_EPISO_CHECK(ep))))
        {
            NRFX_LOG_DEBUG("Transfer failed: Invalid EPr\n");
        }
    }
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   107dc:	4b27      	ldr	r3, [pc, #156]	; (1087c <nrfx_usbd_ep_transfer+0xc4>)
   107de:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 108ac <nrfx_usbd_ep_transfer+0xf4>
   107e2:	681a      	ldr	r2, [r3, #0]
   107e4:	f8d9 6000 	ldr.w	r6, [r9]
   107e8:	43d2      	mvns	r2, r2
   107ea:	b292      	uxth	r2, r2
    const uint8_t ep_bitpos = ep2bit(ep);
   107ec:	4628      	mov	r0, r5
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   107ee:	4332      	orrs	r2, r6
    const uint8_t ep_bitpos = ep2bit(ep);
   107f0:	f007 f86b 	bl	178ca <ep2bit>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   107f4:	f04f 0801 	mov.w	r8, #1
   107f8:	fa08 f800 	lsl.w	r8, r8, r0
   107fc:	ea12 0f08 	tst.w	r2, r8
   10800:	d138      	bne.n	10874 <nrfx_usbd_ep_transfer+0xbc>
            NRFX_LOG_DEBUG("Transfer failed: EP is busy");
        }
    }
    else
    {
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   10802:	4628      	mov	r0, r5
   10804:	f7ff fcec 	bl	101e0 <ep_state_access>
   10808:	220c      	movs	r2, #12
   1080a:	4354      	muls	r4, r2
        /* Prepare transfer context and handler description */
        nrfx_usbd_transfer_t * p_context;
        if (NRF_USBD_EPIN_CHECK(ep))
   1080c:	062a      	lsls	r2, r5, #24
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   1080e:	4603      	mov	r3, r0
        if (NRF_USBD_EPIN_CHECK(ep))
   10810:	d52a      	bpl.n	10868 <nrfx_usbd_ep_transfer+0xb0>
        {
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   10812:	4a1b      	ldr	r2, [pc, #108]	; (10880 <nrfx_usbd_ep_transfer+0xc8>)
   10814:	6808      	ldr	r0, [r1, #0]
   10816:	4414      	add	r4, r2
   10818:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
   1081c:	688a      	ldr	r2, [r1, #8]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   1081e:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
   10822:	f002 0201 	and.w	r2, r2, #1
   10826:	d11a      	bne.n	1085e <nrfx_usbd_ep_transfer+0xa6>
            {
                /* RAM */
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   10828:	b9ba      	cbnz	r2, 1085a <nrfx_usbd_ep_transfer+0xa2>
                {
                    p_state->handler.feeder = nrfx_usbd_feeder_ram;
   1082a:	4a16      	ldr	r2, [pc, #88]	; (10884 <nrfx_usbd_ep_transfer+0xcc>)
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
            p_state->handler.consumer = nrfx_usbd_consumer;
   1082c:	601a      	str	r2, [r3, #0]
        }
        *p_context = *p_transfer;
   1082e:	c907      	ldmia	r1, {r0, r1, r2}
   10830:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        p_state->p_context = p_context;

        p_state->transfer_cnt = 0;
   10834:	2200      	movs	r2, #0
   10836:	609a      	str	r2, [r3, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
   10838:	739a      	strb	r2, [r3, #14]
        p_state->p_context = p_context;
   1083a:	605c      	str	r4, [r3, #4]
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1083c:	4b12      	ldr	r3, [pc, #72]	; (10888 <nrfx_usbd_ep_transfer+0xd0>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
        ret = NRFX_SUCCESS;
   1083e:	4813      	ldr	r0, [pc, #76]	; (1088c <nrfx_usbd_ep_transfer+0xd4>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   10840:	ea46 0608 	orr.w	r6, r6, r8
   10844:	2280      	movs	r2, #128	; 0x80
   10846:	f8c9 6000 	str.w	r6, [r9]
   1084a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
   1084e:	f387 8811 	msr	BASEPRI, r7
   10852:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
   10856:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                    p_state->handler.feeder = nrfx_usbd_feeder_ram_zlp;
   1085a:	4a0d      	ldr	r2, [pc, #52]	; (10890 <nrfx_usbd_ep_transfer+0xd8>)
   1085c:	e7e6      	b.n	1082c <nrfx_usbd_ep_transfer+0x74>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   1085e:	b90a      	cbnz	r2, 10864 <nrfx_usbd_ep_transfer+0xac>
                    p_state->handler.feeder = nrfx_usbd_feeder_flash;
   10860:	4a0c      	ldr	r2, [pc, #48]	; (10894 <nrfx_usbd_ep_transfer+0xdc>)
   10862:	e7e3      	b.n	1082c <nrfx_usbd_ep_transfer+0x74>
                    p_state->handler.feeder = nrfx_usbd_feeder_flash_zlp;
   10864:	4a0c      	ldr	r2, [pc, #48]	; (10898 <nrfx_usbd_ep_transfer+0xe0>)
   10866:	e7e1      	b.n	1082c <nrfx_usbd_ep_transfer+0x74>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
   10868:	4a0c      	ldr	r2, [pc, #48]	; (1089c <nrfx_usbd_ep_transfer+0xe4>)
   1086a:	4414      	add	r4, r2
            p_state->handler.consumer = nrfx_usbd_consumer;
   1086c:	4a0c      	ldr	r2, [pc, #48]	; (108a0 <nrfx_usbd_ep_transfer+0xe8>)
   1086e:	e7dd      	b.n	1082c <nrfx_usbd_ep_transfer+0x74>
        ret = NRFX_ERROR_INVALID_ADDR;
   10870:	480c      	ldr	r0, [pc, #48]	; (108a4 <nrfx_usbd_ep_transfer+0xec>)
   10872:	e7ec      	b.n	1084e <nrfx_usbd_ep_transfer+0x96>
        ret = NRFX_ERROR_BUSY;
   10874:	480c      	ldr	r0, [pc, #48]	; (108a8 <nrfx_usbd_ep_transfer+0xf0>)
   10876:	e7ea      	b.n	1084e <nrfx_usbd_ep_transfer+0x96>
   10878:	200087dd 	.word	0x200087dd
   1087c:	20003d14 	.word	0x20003d14
   10880:	20003ca8 	.word	0x20003ca8
   10884:	0001787f 	.word	0x0001787f
   10888:	e000e100 	.word	0xe000e100
   1088c:	0bad0000 	.word	0x0bad0000
   10890:	000178a1 	.word	0x000178a1
   10894:	00010251 	.word	0x00010251
   10898:	00010289 	.word	0x00010289
   1089c:	20003c38 	.word	0x20003c38
   108a0:	00017851 	.word	0x00017851
   108a4:	0bad000a 	.word	0x0bad000a
   108a8:	0bad000b 	.word	0x0bad000b
   108ac:	20003ca4 	.word	0x20003ca4

000108b0 <nrfx_usbd_epout_size_get>:
    if (NRF_USBD_EPISO_CHECK(ep))
   108b0:	f010 0f08 	tst.w	r0, #8
   108b4:	4b07      	ldr	r3, [pc, #28]	; (108d4 <nrfx_usbd_epout_size_get+0x24>)
   108b6:	d006      	beq.n	108c6 <nrfx_usbd_epout_size_get+0x16>
        size_t size_isoout = p_reg->SIZE.ISOOUT;
   108b8:	f8d3 04c0 	ldr.w	r0, [r3, #1216]	; 0x4c0
        if ((size_isoout & USBD_SIZE_ISOOUT_ZERO_Msk) ==
   108bc:	f410 3f80 	tst.w	r0, #65536	; 0x10000
            size_isoout = 0;
   108c0:	bf18      	it	ne
   108c2:	2000      	movne	r0, #0
   108c4:	4770      	bx	lr
    return p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   108c6:	f000 000f 	and.w	r0, r0, #15
   108ca:	f500 7094 	add.w	r0, r0, #296	; 0x128
   108ce:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_epout_size_get(NRF_USBD, ep_to_hal(ep));
}
   108d2:	4770      	bx	lr
   108d4:	40027000 	.word	0x40027000

000108d8 <usbd_dmareq_process>:
{
   108d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
   108dc:	4b77      	ldr	r3, [pc, #476]	; (10abc <usbd_dmareq_process+0x1e4>)
{
   108de:	b087      	sub	sp, #28
    if (!m_dma_pending)
   108e0:	781a      	ldrb	r2, [r3, #0]
   108e2:	9301      	str	r3, [sp, #4]
   108e4:	2a00      	cmp	r2, #0
   108e6:	f040 8088 	bne.w	109fa <usbd_dmareq_process+0x122>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
   108ea:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 10ae0 <usbd_dmareq_process+0x208>
   108ee:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 10ae4 <usbd_dmareq_process+0x20c>
   108f2:	46ca      	mov	sl, r9
   108f4:	f8db 1000 	ldr.w	r1, [fp]
   108f8:	f8d9 6000 	ldr.w	r6, [r9]
   108fc:	4031      	ands	r1, r6
   108fe:	d07c      	beq.n	109fa <usbd_dmareq_process+0x122>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
   10900:	f011 2601 	ands.w	r6, r1, #16777472	; 0x1000100
   10904:	d07c      	beq.n	10a00 <usbd_dmareq_process+0x128>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   10906:	fa96 f1a6 	rbit	r1, r6
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
   1090a:	2900      	cmp	r1, #0
   1090c:	d07b      	beq.n	10a06 <usbd_dmareq_process+0x12e>
  {
    return 32U;
  }
  return __builtin_clz(value);
   1090e:	fab1 f181 	clz	r1, r1
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   10912:	290f      	cmp	r1, #15
   10914:	d979      	bls.n	10a0a <usbd_dmareq_process+0x132>
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
   10916:	f1a1 0410 	sub.w	r4, r1, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   1091a:	b2e4      	uxtb	r4, r4
            usbd_ep_state_t * p_state = ep_state_access(ep);
   1091c:	4620      	mov	r0, r4
   1091e:	f7ff fc5f 	bl	101e0 <ep_state_access>
   10922:	2601      	movs	r6, #1
            if (NRF_USBD_EPIN_CHECK(ep))
   10924:	fa4f f884 	sxtb.w	r8, r4
   10928:	408e      	lsls	r6, r1
   1092a:	43f3      	mvns	r3, r6
   1092c:	f1b8 0f00 	cmp.w	r8, #0
            usbd_ep_state_t * p_state = ep_state_access(ep);
   10930:	4605      	mov	r5, r0
            if (NRF_USBD_EPIN_CHECK(ep))
   10932:	9300      	str	r3, [sp, #0]
   10934:	da6c      	bge.n	10a10 <usbd_dmareq_process+0x138>
                continue_transfer = p_state->handler.feeder(
   10936:	6803      	ldr	r3, [r0, #0]
   10938:	8982      	ldrh	r2, [r0, #12]
   1093a:	6841      	ldr	r1, [r0, #4]
   1093c:	a804      	add	r0, sp, #16
   1093e:	4798      	blx	r3
                if (!continue_transfer)
   10940:	b900      	cbnz	r0, 10944 <usbd_dmareq_process+0x6c>
                    p_state->handler.consumer = NULL;
   10942:	6028      	str	r0, [r5, #0]
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_199();
   10944:	f7ff fc3c 	bl	101c0 <nrf52_errata_166>
    if (nrfx_usbd_errata_199())
   10948:	b110      	cbz	r0, 10950 <usbd_dmareq_process+0x78>
        *((volatile uint32_t *)0x40027C1C) = 0x00000082;
   1094a:	4b5d      	ldr	r3, [pc, #372]	; (10ac0 <usbd_dmareq_process+0x1e8>)
   1094c:	2282      	movs	r2, #130	; 0x82
   1094e:	601a      	str	r2, [r3, #0]
    m_dma_pending = true;
   10950:	9a01      	ldr	r2, [sp, #4]
            m_ep_ready &= ~(1U << pos);
   10952:	9e00      	ldr	r6, [sp, #0]
            nrf_usbd_ep_easydma_set(NRF_USBD, ep, transfer.p_data.addr, (uint32_t)transfer.size);
   10954:	9804      	ldr	r0, [sp, #16]
    m_dma_pending = true;
   10956:	2301      	movs	r3, #1
   10958:	7013      	strb	r3, [r2, #0]
            m_ep_ready &= ~(1U << pos);
   1095a:	f8da 3000 	ldr.w	r3, [sl]
            p_state->transfer_cnt += transfer.size;
   1095e:	9a05      	ldr	r2, [sp, #20]
            m_ep_ready &= ~(1U << pos);
   10960:	401e      	ands	r6, r3
            p_state->transfer_cnt += transfer.size;
   10962:	68ab      	ldr	r3, [r5, #8]
            m_ep_ready &= ~(1U << pos);
   10964:	f8ca 6000 	str.w	r6, [sl]
            p_state->transfer_cnt += transfer.size;
   10968:	4413      	add	r3, r2
    if (NRF_USBD_EPIN_CHECK(ep))
   1096a:	f1b8 0f00 	cmp.w	r8, #0
   1096e:	60ab      	str	r3, [r5, #8]
   10970:	f004 0108 	and.w	r1, r4, #8
   10974:	4b53      	ldr	r3, [pc, #332]	; (10ac4 <usbd_dmareq_process+0x1ec>)
   10976:	f004 040f 	and.w	r4, r4, #15
   1097a:	da72      	bge.n	10a62 <usbd_dmareq_process+0x18a>
        if (NRF_USBD_EPISO_CHECK(ep))
   1097c:	2900      	cmp	r1, #0
   1097e:	d068      	beq.n	10a52 <usbd_dmareq_process+0x17a>
            p_reg->ISOIN.PTR    = ptr;
   10980:	f8c3 06a0 	str.w	r0, [r3, #1696]	; 0x6a0
            p_reg->ISOIN.MAXCNT = maxcnt;
   10984:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_104();
   10988:	f7ff fc06 	bl	10198 <nrf52_errata_104>
   1098c:	b226      	sxth	r6, r4
   1098e:	00a1      	lsls	r1, r4, #2
   10990:	4b4d      	ldr	r3, [pc, #308]	; (10ac8 <usbd_dmareq_process+0x1f0>)
   10992:	4a4e      	ldr	r2, [pc, #312]	; (10acc <usbd_dmareq_process+0x1f4>)
   10994:	0064      	lsls	r4, r4, #1
            if (nrfx_usbd_errata_104())
   10996:	2800      	cmp	r0, #0
   10998:	d073      	beq.n	10a82 <usbd_dmareq_process+0x1aa>
    return (nrf_usbd_task_t)(
   1099a:	f1b8 0f00 	cmp.w	r8, #0
   1099e:	bfb4      	ite	lt
   109a0:	2504      	movlt	r5, #4
   109a2:	2528      	movge	r5, #40	; 0x28
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   109a4:	440d      	add	r5, r1
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   109a6:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   109aa:	bfa8      	it	ge
   109ac:	4613      	movge	r3, r2
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   109ae:	4e48      	ldr	r6, [pc, #288]	; (10ad0 <usbd_dmareq_process+0x1f8>)
                    while (0 == (0x20 & *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x474))))
   109b0:	4f48      	ldr	r7, [pc, #288]	; (10ad4 <usbd_dmareq_process+0x1fc>)
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   109b2:	f505 351c 	add.w	r5, r5, #159744	; 0x27000
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   109b6:	441c      	add	r4, r3
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   109b8:	f04f 0800 	mov.w	r8, #0
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   109bc:	f04f 0901 	mov.w	r9, #1
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   109c0:	f8c6 8000 	str.w	r8, [r6]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   109c4:	6833      	ldr	r3, [r6, #0]
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   109c6:	f8c5 9000 	str.w	r9, [r5]
                        nrfx_systick_delay_us(2);
   109ca:	2002      	movs	r0, #2
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   109cc:	682b      	ldr	r3, [r5, #0]
   109ce:	f7ff fbd7 	bl	10180 <nrfx_systick_delay_us>
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   109d2:	6833      	ldr	r3, [r6, #0]
                    }while (!nrf_usbd_event_check(NRF_USBD, NRF_USBD_EVENT_STARTED));
   109d4:	2b00      	cmp	r3, #0
   109d6:	d0f3      	beq.n	109c0 <usbd_dmareq_process+0xe8>
                    nrfx_systick_delay_us(30);
   109d8:	201e      	movs	r0, #30
                        nrfx_systick_delay_us(2);
   109da:	f7ff fbd1 	bl	10180 <nrfx_systick_delay_us>
                    while (0 == (0x20 & *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x474))))
   109de:	683b      	ldr	r3, [r7, #0]
   109e0:	069b      	lsls	r3, r3, #26
   109e2:	d54c      	bpl.n	10a7e <usbd_dmareq_process+0x1a6>
                    nrfx_systick_delay_us(1);
   109e4:	2001      	movs	r0, #1
   109e6:	f7ff fbcb 	bl	10180 <nrfx_systick_delay_us>
   109ea:	8823      	ldrh	r3, [r4, #0]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   109ec:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   109f0:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   109f4:	681b      	ldr	r3, [r3, #0]
                } while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)));
   109f6:	2b00      	cmp	r3, #0
   109f8:	d0e0      	beq.n	109bc <usbd_dmareq_process+0xe4>
}
   109fa:	b007      	add	sp, #28
   109fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   10a00:	fa91 f1a1 	rbit	r1, r1
   10a04:	e781      	b.n	1090a <usbd_dmareq_process+0x32>
    return 32U;
   10a06:	2120      	movs	r1, #32
   10a08:	e785      	b.n	10916 <usbd_dmareq_process+0x3e>
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   10a0a:	f041 0480 	orr.w	r4, r1, #128	; 0x80
   10a0e:	e785      	b.n	1091c <usbd_dmareq_process+0x44>
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   10a10:	4620      	mov	r0, r4
   10a12:	f7ff ff4d 	bl	108b0 <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
   10a16:	89aa      	ldrh	r2, [r5, #12]
   10a18:	6869      	ldr	r1, [r5, #4]
   10a1a:	682e      	ldr	r6, [r5, #0]
   10a1c:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   10a1e:	4607      	mov	r7, r0
                continue_transfer = p_state->handler.consumer(
   10a20:	a804      	add	r0, sp, #16
   10a22:	47b0      	blx	r6
                if (transfer.p_data.rx == NULL)
   10a24:	9a04      	ldr	r2, [sp, #16]
   10a26:	2a00      	cmp	r2, #0
   10a28:	d08a      	beq.n	10940 <usbd_dmareq_process+0x68>
                else if (transfer.size < rx_size)
   10a2a:	9a05      	ldr	r2, [sp, #20]
   10a2c:	4297      	cmp	r7, r2
   10a2e:	d987      	bls.n	10940 <usbd_dmareq_process+0x68>
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   10a30:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   10a32:	9800      	ldr	r0, [sp, #0]
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   10a34:	73af      	strb	r7, [r5, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   10a36:	f7ff fcb1 	bl	1039c <atomic_and.constprop.0>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   10a3a:	2306      	movs	r3, #6
   10a3c:	f88d 300c 	strb.w	r3, [sp, #12]
                    m_event_handler(&evt);
   10a40:	4b25      	ldr	r3, [pc, #148]	; (10ad8 <usbd_dmareq_process+0x200>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   10a42:	f88d 400e 	strb.w	r4, [sp, #14]
                    m_event_handler(&evt);
   10a46:	681b      	ldr	r3, [r3, #0]
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   10a48:	f88d 700f 	strb.w	r7, [sp, #15]
                    m_event_handler(&evt);
   10a4c:	a803      	add	r0, sp, #12
   10a4e:	4798      	blx	r3
                    continue;
   10a50:	e750      	b.n	108f4 <usbd_dmareq_process+0x1c>
            p_reg->EPIN[epnr].PTR    = ptr;
   10a52:	2114      	movs	r1, #20
   10a54:	fb01 3304 	mla	r3, r1, r4, r3
   10a58:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            p_reg->EPIN[epnr].MAXCNT = maxcnt;
   10a5c:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
   10a60:	e792      	b.n	10988 <usbd_dmareq_process+0xb0>
        if (NRF_USBD_EPISO_CHECK(ep))
   10a62:	b121      	cbz	r1, 10a6e <usbd_dmareq_process+0x196>
            p_reg->ISOOUT.PTR    = ptr;
   10a64:	f8c3 07a0 	str.w	r0, [r3, #1952]	; 0x7a0
            p_reg->ISOOUT.MAXCNT = maxcnt;
   10a68:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
   10a6c:	e78c      	b.n	10988 <usbd_dmareq_process+0xb0>
            p_reg->EPOUT[epnr].PTR    = ptr;
   10a6e:	2114      	movs	r1, #20
   10a70:	fb01 3304 	mla	r3, r1, r4, r3
   10a74:	f8c3 0700 	str.w	r0, [r3, #1792]	; 0x700
            p_reg->EPOUT[epnr].MAXCNT = maxcnt;
   10a78:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
   10a7c:	e784      	b.n	10988 <usbd_dmareq_process+0xb0>
                        nrfx_systick_delay_us(2);
   10a7e:	2002      	movs	r0, #2
   10a80:	e7ab      	b.n	109da <usbd_dmareq_process+0x102>
    return (nrf_usbd_task_t)(
   10a82:	f1b8 0f00 	cmp.w	r8, #0
   10a86:	bfb4      	ite	lt
   10a88:	2504      	movlt	r5, #4
   10a8a:	2528      	movge	r5, #40	; 0x28
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10a8c:	440d      	add	r5, r1
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   10a8e:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   10a92:	bfa8      	it	ge
   10a94:	4613      	movge	r3, r2
   10a96:	f505 351c 	add.w	r5, r5, #159744	; 0x27000
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10a9a:	2101      	movs	r1, #1
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   10a9c:	f833 3016 	ldrh.w	r3, [r3, r6, lsl #1]
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10aa0:	6029      	str	r1, [r5, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10aa2:	6829      	ldr	r1, [r5, #0]
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   10aa4:	490d      	ldr	r1, [pc, #52]	; (10adc <usbd_dmareq_process+0x204>)
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   10aa6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   10aaa:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   10aae:	681a      	ldr	r2, [r3, #0]
                while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)) &&
   10ab0:	2a00      	cmp	r2, #0
   10ab2:	d1a2      	bne.n	109fa <usbd_dmareq_process+0x122>
   10ab4:	680a      	ldr	r2, [r1, #0]
   10ab6:	2a00      	cmp	r2, #0
   10ab8:	d0f9      	beq.n	10aae <usbd_dmareq_process+0x1d6>
   10aba:	e79e      	b.n	109fa <usbd_dmareq_process+0x122>
   10abc:	200087db 	.word	0x200087db
   10ac0:	40027c1c 	.word	0x40027c1c
   10ac4:	40027000 	.word	0x40027000
   10ac8:	00019b58 	.word	0x00019b58
   10acc:	00019b6a 	.word	0x00019b6a
   10ad0:	40027104 	.word	0x40027104
   10ad4:	40027474 	.word	0x40027474
   10ad8:	20003e38 	.word	0x20003e38
   10adc:	40027100 	.word	0x40027100
   10ae0:	20003d14 	.word	0x20003d14
   10ae4:	20003ca4 	.word	0x20003ca4

00010ae8 <ev_epdata_handler>:
{
   10ae8:	b538      	push	{r3, r4, r5, lr}
    return p_reg->EPDATASTATUS;
   10aea:	4b16      	ldr	r3, [pc, #88]	; (10b44 <ev_epdata_handler+0x5c>)
   10aec:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    p_reg->EPDATASTATUS = flags;
   10af0:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
   10af4:	f7ff fb50 	bl	10198 <nrf52_errata_104>
    if (nrfx_usbd_errata_104())
   10af8:	b138      	cbz	r0, 10b0a <ev_epdata_handler+0x22>
        dataepstatus |= (m_simulated_dataepstatus &
   10afa:	4a13      	ldr	r2, [pc, #76]	; (10b48 <ev_epdata_handler+0x60>)
   10afc:	6813      	ldr	r3, [r2, #0]
   10afe:	f023 1101 	bic.w	r1, r3, #65537	; 0x10001
        m_simulated_dataepstatus &=
   10b02:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
        dataepstatus |= (m_simulated_dataepstatus &
   10b06:	430c      	orrs	r4, r1
        m_simulated_dataepstatus &=
   10b08:	6013      	str	r3, [r2, #0]
        dataepstatus &= ~(1UL << bitpos);
   10b0a:	2501      	movs	r5, #1
    while (dataepstatus)
   10b0c:	b91c      	cbnz	r4, 10b16 <ev_epdata_handler+0x2e>
}
   10b0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
   10b12:	f7ff bee1 	b.w	108d8 <usbd_dmareq_process>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   10b16:	fa94 f1a4 	rbit	r1, r4
  if (value == 0U)
   10b1a:	b171      	cbz	r1, 10b3a <ev_epdata_handler+0x52>
  return __builtin_clz(value);
   10b1c:	fab1 f381 	clz	r3, r1
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   10b20:	2b0f      	cmp	r3, #15
   10b22:	4619      	mov	r1, r3
   10b24:	dd0b      	ble.n	10b3e <ev_epdata_handler+0x56>
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
   10b26:	f1a1 0010 	sub.w	r0, r1, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   10b2a:	b2c0      	uxtb	r0, r0
        dataepstatus &= ~(1UL << bitpos);
   10b2c:	fa05 f301 	lsl.w	r3, r5, r1
   10b30:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
   10b34:	f7ff fc5a 	bl	103ec <usbd_ep_data_handler>
   10b38:	e7e8      	b.n	10b0c <ev_epdata_handler+0x24>
    return 32U;
   10b3a:	2120      	movs	r1, #32
   10b3c:	e7f3      	b.n	10b26 <ev_epdata_handler+0x3e>
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   10b3e:	f043 0080 	orr.w	r0, r3, #128	; 0x80
   10b42:	e7f3      	b.n	10b2c <ev_epdata_handler+0x44>
   10b44:	40027000 	.word	0x40027000
   10b48:	20003e3c 	.word	0x20003e3c

00010b4c <nrf_usbd_epout_dma_handler>:
{
   10b4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   10b4e:	4604      	mov	r4, r0
    usbd_dma_pending_clear();
   10b50:	f7ff fb54 	bl	101fc <usbd_dma_pending_clear>
    usbd_ep_state_t * p_state = ep_state_access(ep);
   10b54:	4620      	mov	r0, r4
   10b56:	f7ff fb43 	bl	101e0 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   10b5a:	7b83      	ldrb	r3, [r0, #14]
   10b5c:	2b03      	cmp	r3, #3
   10b5e:	d10c      	bne.n	10b7a <nrf_usbd_epout_dma_handler+0x2e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   10b60:	4620      	mov	r0, r4
   10b62:	f006 feb2 	bl	178ca <ep2bit>
   10b66:	2301      	movs	r3, #1
   10b68:	fa03 f000 	lsl.w	r0, r3, r0
   10b6c:	43c0      	mvns	r0, r0
   10b6e:	f7ff fc15 	bl	1039c <atomic_and.constprop.0>
    usbd_dmareq_process();
   10b72:	f7ff feb1 	bl	108d8 <usbd_dmareq_process>
}
   10b76:	b003      	add	sp, #12
   10b78:	bd30      	pop	{r4, r5, pc}
    else if (p_state->handler.consumer == NULL)
   10b7a:	6805      	ldr	r5, [r0, #0]
   10b7c:	2d00      	cmp	r5, #0
   10b7e:	d1f8      	bne.n	10b72 <nrf_usbd_epout_dma_handler+0x26>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   10b80:	4620      	mov	r0, r4
   10b82:	f006 fea2 	bl	178ca <ep2bit>
   10b86:	2301      	movs	r3, #1
   10b88:	fa03 f000 	lsl.w	r0, r3, r0
   10b8c:	43c0      	mvns	r0, r0
   10b8e:	f7ff fc05 	bl	1039c <atomic_and.constprop.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10b92:	2306      	movs	r3, #6
   10b94:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   10b98:	4b04      	ldr	r3, [pc, #16]	; (10bac <nrf_usbd_epout_dma_handler+0x60>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10b9a:	f88d 4006 	strb.w	r4, [sp, #6]
        m_event_handler(&evt);
   10b9e:	681b      	ldr	r3, [r3, #0]
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10ba0:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
   10ba4:	a801      	add	r0, sp, #4
   10ba6:	4798      	blx	r3
   10ba8:	e7e3      	b.n	10b72 <nrf_usbd_epout_dma_handler+0x26>
   10baa:	bf00      	nop
   10bac:	20003e38 	.word	0x20003e38

00010bb0 <nrfx_usbd_ep_stall>:
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
   10bb0:	4b02      	ldr	r3, [pc, #8]	; (10bbc <nrfx_usbd_ep_stall+0xc>)
   10bb2:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   10bb6:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(NRF_USBD, ep_to_hal(ep));
}
   10bba:	4770      	bx	lr
   10bbc:	40027000 	.word	0x40027000

00010bc0 <nrfx_usbd_ep_stall_check>:
    if (NRF_USBD_EPISO_CHECK(ep))
   10bc0:	0702      	lsls	r2, r0, #28
   10bc2:	d413      	bmi.n	10bec <nrfx_usbd_ep_stall_check+0x2c>
    if (NRF_USBD_EPIN_CHECK(ep))
   10bc4:	f000 030f 	and.w	r3, r0, #15
   10bc8:	f010 0f80 	tst.w	r0, #128	; 0x80
   10bcc:	4a08      	ldr	r2, [pc, #32]	; (10bf0 <nrfx_usbd_ep_stall_check+0x30>)
        return p_reg->HALTED.EPOUT[epnr];
   10bce:	bf0b      	itete	eq
   10bd0:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return p_reg->HALTED.EPIN[epnr];
   10bd4:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return p_reg->HALTED.EPOUT[epnr];
   10bd8:	eb02 0383 	addeq.w	r3, r2, r3, lsl #2
        return p_reg->HALTED.EPIN[epnr];
   10bdc:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return p_reg->HALTED.EPOUT[epnr];
   10be0:	bf08      	it	eq
   10be2:	6858      	ldreq	r0, [r3, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_halted_get(p_reg, ep);
   10be4:	1e43      	subs	r3, r0, #1
   10be6:	4258      	negs	r0, r3
   10be8:	4158      	adcs	r0, r3
   10bea:	4770      	bx	lr
        return false;
   10bec:	2000      	movs	r0, #0
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_ep_is_stall(NRF_USBD, ep_to_hal(ep));
}
   10bee:	4770      	bx	lr
   10bf0:	40027000 	.word	0x40027000

00010bf4 <nrfx_usbd_ep_dtoggle_clear>:
    p_reg->DTOGGLE = ep | (NRF_USBD_DTOGGLE_NOP << USBD_DTOGGLE_VALUE_Pos);
   10bf4:	4b04      	ldr	r3, [pc, #16]	; (10c08 <nrfx_usbd_ep_dtoggle_clear+0x14>)
   10bf6:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->DTOGGLE = ep | (op << USBD_DTOGGLE_VALUE_Pos);
   10bfa:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   10bfe:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    (void) p_reg->DTOGGLE;
   10c02:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c

void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep)
{
    nrf_usbd_dtoggle_set(NRF_USBD, ep, NRF_USBD_DTOGGLE_DATA0);
}
   10c06:	4770      	bx	lr
   10c08:	40027000 	.word	0x40027000

00010c0c <nrfx_usbd_setup_get>:

void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
   10c0c:	b510      	push	{r4, lr}
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   10c0e:	2208      	movs	r2, #8
   10c10:	2100      	movs	r1, #0
{
   10c12:	4604      	mov	r4, r0
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   10c14:	f005 fa3c 	bl	16090 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   10c18:	4b0e      	ldr	r3, [pc, #56]	; (10c54 <nrfx_usbd_setup_get+0x48>)
   10c1a:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   10c1e:	7022      	strb	r2, [r4, #0]
    return (uint8_t)(p_reg->BREQUEST);
   10c20:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   10c24:	7062      	strb	r2, [r4, #1]
    const uint16_t val = p_reg->WVALUEL;
   10c26:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   10c2a:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   10c2e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
    p_setup->bRequest      = nrf_usbd_setup_brequest_get(NRF_USBD);
    p_setup->wValue        = nrf_usbd_setup_wvalue_get(NRF_USBD);
   10c32:	8062      	strh	r2, [r4, #2]
    const uint16_t val = p_reg->WINDEXL;
   10c34:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   10c38:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   10c3c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get(NRF_USBD);
   10c40:	80a2      	strh	r2, [r4, #4]
    const uint16_t val = p_reg->WLENGTHL;
   10c42:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   10c46:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
   10c4a:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get(NRF_USBD);
   10c4e:	80e3      	strh	r3, [r4, #6]
}
   10c50:	bd10      	pop	{r4, pc}
   10c52:	bf00      	nop
   10c54:	40027000 	.word	0x40027000

00010c58 <nrfx_usbd_setup_data_clear>:

void nrfx_usbd_setup_data_clear(void)
{
   10c58:	b508      	push	{r3, lr}
   10c5a:	f7ff fa9d 	bl	10198 <nrf52_errata_104>
   10c5e:	4b08      	ldr	r3, [pc, #32]	; (10c80 <nrfx_usbd_setup_data_clear+0x28>)
   10c60:	2201      	movs	r2, #1
    if (nrfx_usbd_errata_104())
   10c62:	b148      	cbz	r0, 10c78 <nrfx_usbd_setup_data_clear+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   10c64:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   10c68:	b672      	cpsid	i
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10c6a:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10c6c:	6818      	ldr	r0, [r3, #0]
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10c6e:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10c70:	681b      	ldr	r3, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   10c72:	f381 8810 	msr	PRIMASK, r1
    }
    else
    {
        nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0RCVOUT);
    }
}
   10c76:	bd08      	pop	{r3, pc}
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10c78:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10c7a:	681b      	ldr	r3, [r3, #0]
   10c7c:	e7fb      	b.n	10c76 <nrfx_usbd_setup_data_clear+0x1e>
   10c7e:	bf00      	nop
   10c80:	4002704c 	.word	0x4002704c

00010c84 <ev_dma_epout0_handler>:
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   10c84:	b513      	push	{r0, r1, r4, lr}
    usbd_dma_pending_clear();
   10c86:	f7ff fab9 	bl	101fc <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   10c8a:	4b0e      	ldr	r3, [pc, #56]	; (10cc4 <ev_dma_epout0_handler+0x40>)
   10c8c:	7b9a      	ldrb	r2, [r3, #14]
   10c8e:	2a03      	cmp	r2, #3
   10c90:	d105      	bne.n	10c9e <ev_dma_epout0_handler+0x1a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   10c92:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
   10c96:	f7ff fb81 	bl	1039c <atomic_and.constprop.0>
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   10c9a:	b002      	add	sp, #8
   10c9c:	bd10      	pop	{r4, pc}
    else if (p_state->handler.consumer == NULL)
   10c9e:	681c      	ldr	r4, [r3, #0]
   10ca0:	b96c      	cbnz	r4, 10cbe <ev_dma_epout0_handler+0x3a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   10ca2:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
   10ca6:	f7ff fb79 	bl	1039c <atomic_and.constprop.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10caa:	2306      	movs	r3, #6
   10cac:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   10cb0:	4b05      	ldr	r3, [pc, #20]	; (10cc8 <ev_dma_epout0_handler+0x44>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   10cb2:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
   10cb6:	681b      	ldr	r3, [r3, #0]
   10cb8:	a801      	add	r0, sp, #4
   10cba:	4798      	blx	r3
   10cbc:	e7ed      	b.n	10c9a <ev_dma_epout0_handler+0x16>
        nrfx_usbd_setup_data_clear();
   10cbe:	f7ff ffcb 	bl	10c58 <nrfx_usbd_setup_data_clear>
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   10cc2:	e7ea      	b.n	10c9a <ev_dma_epout0_handler+0x16>
   10cc4:	20003d18 	.word	0x20003d18
   10cc8:	20003e38 	.word	0x20003e38

00010ccc <nrfx_usbd_setup_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10ccc:	4b02      	ldr	r3, [pc, #8]	; (10cd8 <nrfx_usbd_setup_clear+0xc>)
   10cce:	2201      	movs	r2, #1
   10cd0:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10cd2:	681b      	ldr	r3, [r3, #0]

void nrfx_usbd_setup_clear(void)
{
    NRFX_LOG_DEBUG(">> ep0status >>");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STATUS);
}
   10cd4:	4770      	bx	lr
   10cd6:	bf00      	nop
   10cd8:	40027050 	.word	0x40027050

00010cdc <nrfx_usbd_setup_stall>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   10cdc:	4b02      	ldr	r3, [pc, #8]	; (10ce8 <nrfx_usbd_setup_stall+0xc>)
   10cde:	2201      	movs	r2, #1
   10ce0:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   10ce2:	681b      	ldr	r3, [r3, #0]

void nrfx_usbd_setup_stall(void)
{
    NRFX_LOG_DEBUG("Setup stalled.");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STALL);
}
   10ce4:	4770      	bx	lr
   10ce6:	bf00      	nop
   10ce8:	40027054 	.word	0x40027054

00010cec <nrfx_usbd_last_setup_dir_get>:

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
   10cec:	4b01      	ldr	r3, [pc, #4]	; (10cf4 <nrfx_usbd_last_setup_dir_get+0x8>)
   10cee:	7818      	ldrb	r0, [r3, #0]
   10cf0:	4770      	bx	lr
   10cf2:	bf00      	nop
   10cf4:	200087dd 	.word	0x200087dd

00010cf8 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
   10cf8:	b510      	push	{r4, lr}
   10cfa:	4601      	mov	r1, r0
}

/* Errata: SIZE.EPOUT not writable. **/
static inline bool nrfx_usbd_errata_200(void)
{
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_200();
   10cfc:	f7ff fa4c 	bl	10198 <nrf52_errata_104>
   10d00:	4604      	mov	r4, r0
   10d02:	4608      	mov	r0, r1
   10d04:	f006 fde1 	bl	178ca <ep2bit>
   10d08:	2301      	movs	r3, #1
   10d0a:	4083      	lsls	r3, r0
   10d0c:	4a1b      	ldr	r2, [pc, #108]	; (10d7c <nrfx_usbd_transfer_out_drop+0x84>)
   10d0e:	43db      	mvns	r3, r3
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));

    if (nrfx_usbd_errata_200())
   10d10:	b1d4      	cbz	r4, 10d48 <nrfx_usbd_transfer_out_drop+0x50>
	__asm__ volatile(
   10d12:	f04f 0020 	mov.w	r0, #32
   10d16:	f3ef 8411 	mrs	r4, BASEPRI
   10d1a:	f380 8811 	msr	BASEPRI, r0
   10d1e:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        m_ep_ready &= ~(1U << ep2bit(ep));
   10d22:	6810      	ldr	r0, [r2, #0]
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7C5 + (2u * NRF_USBD_EP_NR_GET(ep));
   10d24:	f001 010f 	and.w	r1, r1, #15
        m_ep_ready &= ~(1U << ep2bit(ep));
   10d28:	4003      	ands	r3, r0
   10d2a:	6013      	str	r3, [r2, #0]
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7C5 + (2u * NRF_USBD_EP_NR_GET(ep));
   10d2c:	0049      	lsls	r1, r1, #1
   10d2e:	4b14      	ldr	r3, [pc, #80]	; (10d80 <nrfx_usbd_transfer_out_drop+0x88>)
   10d30:	f201 71c5 	addw	r1, r1, #1989	; 0x7c5
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = 0;
   10d34:	2200      	movs	r2, #0
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7C5 + (2u * NRF_USBD_EP_NR_GET(ep));
   10d36:	6019      	str	r1, [r3, #0]
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = 0;
   10d38:	605a      	str	r2, [r3, #4]
   10d3a:	3304      	adds	r3, #4
        (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10d3c:	681b      	ldr	r3, [r3, #0]
	__asm__ volatile(
   10d3e:	f384 8811 	msr	BASEPRI, r4
   10d42:	f3bf 8f6f 	isb	sy
        {
            nrf_usbd_epout_clear(NRF_USBD, ep);
        }
        NRFX_CRITICAL_SECTION_EXIT();
    }
}
   10d46:	bd10      	pop	{r4, pc}
	__asm__ volatile(
   10d48:	f04f 0020 	mov.w	r0, #32
   10d4c:	f3ef 8411 	mrs	r4, BASEPRI
   10d50:	f380 8811 	msr	BASEPRI, r0
   10d54:	f3bf 8f6f 	isb	sy
        m_ep_ready &= ~(1U << ep2bit(ep));
   10d58:	6810      	ldr	r0, [r2, #0]
   10d5a:	4003      	ands	r3, r0
   10d5c:	6013      	str	r3, [r2, #0]
        if (!NRF_USBD_EPISO_CHECK(ep))
   10d5e:	f011 0308 	ands.w	r3, r1, #8
   10d62:	d1ec      	bne.n	10d3e <nrfx_usbd_transfer_out_drop+0x46>
    p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
   10d64:	f001 010f 	and.w	r1, r1, #15
   10d68:	0089      	lsls	r1, r1, #2
   10d6a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   10d6e:	f501 311c 	add.w	r1, r1, #159744	; 0x27000
   10d72:	f8c1 34a0 	str.w	r3, [r1, #1184]	; 0x4a0
    (void) p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   10d76:	f8d1 34a0 	ldr.w	r3, [r1, #1184]	; 0x4a0
}
   10d7a:	e7e0      	b.n	10d3e <nrfx_usbd_transfer_out_drop+0x46>
   10d7c:	20003d14 	.word	0x20003d14
   10d80:	40027800 	.word	0x40027800

00010d84 <usbd_ep_abort>:
{
   10d84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   10d86:	4601      	mov	r1, r0
   10d88:	f04f 0320 	mov.w	r3, #32
   10d8c:	f3ef 8511 	mrs	r5, BASEPRI
   10d90:	f383 8811 	msr	BASEPRI, r3
   10d94:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
   10d98:	f7ff fa22 	bl	101e0 <ep_state_access>
   10d9c:	4606      	mov	r6, r0
    if (NRF_USBD_EPOUT_CHECK(ep))
   10d9e:	4608      	mov	r0, r1
   10da0:	f006 fd93 	bl	178ca <ep2bit>
   10da4:	2301      	movs	r3, #1
   10da6:	f011 0f80 	tst.w	r1, #128	; 0x80
   10daa:	4f2b      	ldr	r7, [pc, #172]	; (10e58 <usbd_ep_abort+0xd4>)
   10dac:	fa03 f300 	lsl.w	r3, r3, r0
   10db0:	d118      	bne.n	10de4 <usbd_ep_abort+0x60>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   10db2:	683a      	ldr	r2, [r7, #0]
   10db4:	ea33 0002 	bics.w	r0, r3, r2
   10db8:	d00a      	beq.n	10dd0 <usbd_ep_abort+0x4c>
            nrfx_usbd_transfer_out_drop(ep);
   10dba:	4608      	mov	r0, r1
   10dbc:	f7ff ff9c 	bl	10cf8 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
   10dc0:	2303      	movs	r3, #3
   10dc2:	73b3      	strb	r3, [r6, #14]
	__asm__ volatile(
   10dc4:	f385 8811 	msr	BASEPRI, r5
   10dc8:	f3bf 8f6f 	isb	sy
}
   10dcc:	b003      	add	sp, #12
   10dce:	bdf0      	pop	{r4, r5, r6, r7, pc}
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   10dd0:	ea22 0203 	bic.w	r2, r2, r3
            p_state->handler.consumer = NULL;
   10dd4:	6030      	str	r0, [r6, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   10dd6:	603a      	str	r2, [r7, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   10dd8:	4a20      	ldr	r2, [pc, #128]	; (10e5c <usbd_ep_abort+0xd8>)
   10dda:	6810      	ldr	r0, [r2, #0]
   10ddc:	ea20 0003 	bic.w	r0, r0, r3
   10de0:	6010      	str	r0, [r2, #0]
   10de2:	e7ed      	b.n	10dc0 <usbd_ep_abort+0x3c>
        if(!NRF_USBD_EPISO_CHECK(ep))
   10de4:	070a      	lsls	r2, r1, #28
   10de6:	d411      	bmi.n	10e0c <usbd_ep_abort+0x88>
            if(ep != NRFX_USBD_EPIN0)
   10de8:	2980      	cmp	r1, #128	; 0x80
   10dea:	4c1d      	ldr	r4, [pc, #116]	; (10e60 <usbd_ep_abort+0xdc>)
   10dec:	4a1d      	ldr	r2, [pc, #116]	; (10e64 <usbd_ep_abort+0xe0>)
   10dee:	d02a      	beq.n	10e46 <usbd_ep_abort+0xc2>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
   10df0:	f001 000f 	and.w	r0, r1, #15
   10df4:	f200 30da 	addw	r0, r0, #986	; 0x3da
   10df8:	0040      	lsls	r0, r0, #1
   10dfa:	6020      	str	r0, [r4, #0]
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10dfc:	6814      	ldr	r4, [r2, #0]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   10dfe:	6810      	ldr	r0, [r2, #0]
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10e00:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   10e02:	f044 0402 	orr.w	r4, r4, #2
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   10e06:	4304      	orrs	r4, r0
   10e08:	6014      	str	r4, [r2, #0]
                (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10e0a:	6812      	ldr	r2, [r2, #0]
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
   10e0c:	4c13      	ldr	r4, [pc, #76]	; (10e5c <usbd_ep_abort+0xd8>)
   10e0e:	683a      	ldr	r2, [r7, #0]
   10e10:	6820      	ldr	r0, [r4, #0]
   10e12:	ea62 0c00 	orn	ip, r2, r0
   10e16:	ea1c 0f03 	tst.w	ip, r3
   10e1a:	d0d3      	beq.n	10dc4 <usbd_ep_abort+0x40>
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   10e1c:	ea22 0203 	bic.w	r2, r2, r3
            m_ep_ready       |=   1U << ep2bit(ep) ;
   10e20:	4318      	orrs	r0, r3
            p_state->handler.feeder = NULL;
   10e22:	2300      	movs	r3, #0
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   10e24:	603a      	str	r2, [r7, #0]
            p_state->handler.feeder = NULL;
   10e26:	6033      	str	r3, [r6, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
   10e28:	2303      	movs	r3, #3
   10e2a:	73b3      	strb	r3, [r6, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   10e2c:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   10e30:	4b0d      	ldr	r3, [pc, #52]	; (10e68 <usbd_ep_abort+0xe4>)
            m_ep_ready       |=   1U << ep2bit(ep) ;
   10e32:	6020      	str	r0, [r4, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   10e34:	2206      	movs	r2, #6
            m_event_handler(&evt);
   10e36:	681b      	ldr	r3, [r3, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   10e38:	f88d 2004 	strb.w	r2, [sp, #4]
   10e3c:	f88d 1006 	strb.w	r1, [sp, #6]
            m_event_handler(&evt);
   10e40:	a801      	add	r0, sp, #4
   10e42:	4798      	blx	r3
   10e44:	e7be      	b.n	10dc4 <usbd_ep_abort+0x40>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B4;
   10e46:	f240 70b4 	movw	r0, #1972	; 0x7b4
   10e4a:	6020      	str	r0, [r4, #0]
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10e4c:	6814      	ldr	r4, [r2, #0]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   10e4e:	6810      	ldr	r0, [r2, #0]
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10e50:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   10e52:	f044 0404 	orr.w	r4, r4, #4
   10e56:	e7d6      	b.n	10e06 <usbd_ep_abort+0x82>
   10e58:	20003ca4 	.word	0x20003ca4
   10e5c:	20003d14 	.word	0x20003d14
   10e60:	40027800 	.word	0x40027800
   10e64:	40027804 	.word	0x40027804
   10e68:	20003e38 	.word	0x20003e38

00010e6c <ev_setup_handler>:
{
   10e6c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   10e6e:	4b17      	ldr	r3, [pc, #92]	; (10ecc <ev_setup_handler+0x60>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   10e70:	4c17      	ldr	r4, [pc, #92]	; (10ed0 <ev_setup_handler+0x64>)
   10e72:	f8d3 6480 	ldr.w	r6, [r3, #1152]	; 0x480
   10e76:	6823      	ldr	r3, [r4, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   10e78:	4d16      	ldr	r5, [pc, #88]	; (10ed4 <ev_setup_handler+0x68>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   10e7a:	43da      	mvns	r2, r3
   10e7c:	4b16      	ldr	r3, [pc, #88]	; (10ed8 <ev_setup_handler+0x6c>)
        & (1U <<ep2bit(m_last_setup_dir)))
   10e7e:	782f      	ldrb	r7, [r5, #0]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   10e80:	681b      	ldr	r3, [r3, #0]
   10e82:	b292      	uxth	r2, r2
        & (1U <<ep2bit(m_last_setup_dir)))
   10e84:	4638      	mov	r0, r7
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   10e86:	431a      	orrs	r2, r3
        & (1U <<ep2bit(m_last_setup_dir)))
   10e88:	f006 fd1f 	bl	178ca <ep2bit>
   10e8c:	2301      	movs	r3, #1
   10e8e:	4083      	lsls	r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   10e90:	4213      	tst	r3, r2
   10e92:	d002      	beq.n	10e9a <ev_setup_handler+0x2e>
        usbd_ep_abort(m_last_setup_dir);
   10e94:	4638      	mov	r0, r7
   10e96:	f7ff ff75 	bl	10d84 <usbd_ep_abort>
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
   10e9a:	f006 0680 	and.w	r6, r6, #128	; 0x80
    (void)(NRFX_ATOMIC_FETCH_AND(
   10e9e:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
    m_last_setup_dir =
   10ea2:	702e      	strb	r6, [r5, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
   10ea4:	f7ff fa7a 	bl	1039c <atomic_and.constprop.0>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   10ea8:	6823      	ldr	r3, [r4, #0]
   10eaa:	f043 0301 	orr.w	r3, r3, #1
   10eae:	6023      	str	r3, [r4, #0]
    const nrfx_usbd_evt_t evt = {
   10eb0:	2300      	movs	r3, #0
   10eb2:	f8ad 3005 	strh.w	r3, [sp, #5]
   10eb6:	f88d 3007 	strb.w	r3, [sp, #7]
   10eba:	2305      	movs	r3, #5
   10ebc:	f88d 3004 	strb.w	r3, [sp, #4]
    m_event_handler(&evt);
   10ec0:	4b06      	ldr	r3, [pc, #24]	; (10edc <ev_setup_handler+0x70>)
   10ec2:	a801      	add	r0, sp, #4
   10ec4:	681b      	ldr	r3, [r3, #0]
   10ec6:	4798      	blx	r3
}
   10ec8:	b003      	add	sp, #12
   10eca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10ecc:	40027000 	.word	0x40027000
   10ed0:	20003d14 	.word	0x20003d14
   10ed4:	200087dd 	.word	0x200087dd
   10ed8:	20003ca4 	.word	0x20003ca4
   10edc:	20003e38 	.word	0x20003e38

00010ee0 <nrfx_usbd_irq_handler>:
    return p_reg->INTENSET;
   10ee0:	4b53      	ldr	r3, [pc, #332]	; (11030 <nrfx_usbd_irq_handler+0x150>)
{
   10ee2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10ee6:	f8d3 5304 	ldr.w	r5, [r3, #772]	; 0x304
    uint32_t active = 0;
   10eea:	2100      	movs	r1, #0
    uint32_t to_process = enabled;
   10eec:	4628      	mov	r0, r5
   10eee:	2401      	movs	r4, #1
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   10ef0:	460e      	mov	r6, r1
    while (to_process)
   10ef2:	2800      	cmp	r0, #0
   10ef4:	d17c      	bne.n	10ff0 <nrfx_usbd_irq_handler+0x110>
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_104();
   10ef6:	f7ff f94f 	bl	10198 <nrf52_errata_104>
    if (nrfx_usbd_errata_104())
   10efa:	2800      	cmp	r0, #0
   10efc:	d069      	beq.n	10fd2 <nrfx_usbd_irq_handler+0xf2>
        if ((!m_dma_pending) && (0 != (active & (USBD_INTEN_SOF_Msk))))
   10efe:	4b4d      	ldr	r3, [pc, #308]	; (11034 <nrfx_usbd_irq_handler+0x154>)
   10f00:	781b      	ldrb	r3, [r3, #0]
   10f02:	2b00      	cmp	r3, #0
   10f04:	d165      	bne.n	10fd2 <nrfx_usbd_irq_handler+0xf2>
   10f06:	028e      	lsls	r6, r1, #10
   10f08:	d563      	bpl.n	10fd2 <nrfx_usbd_irq_handler+0xf2>
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7A9;
   10f0a:	4a4b      	ldr	r2, [pc, #300]	; (11038 <nrfx_usbd_irq_handler+0x158>)
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AB;
   10f0c:	4e4a      	ldr	r6, [pc, #296]	; (11038 <nrfx_usbd_irq_handler+0x158>)
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7A9;
   10f0e:	f240 73a9 	movw	r3, #1961	; 0x7a9
   10f12:	6013      	str	r3, [r2, #0]
            uii = (uint8_t)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10f14:	4b49      	ldr	r3, [pc, #292]	; (1103c <nrfx_usbd_irq_handler+0x15c>)
   10f16:	681c      	ldr	r4, [r3, #0]
            if (0 != uii)
   10f18:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
                uii &= (uint8_t)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10f1c:	bf1c      	itt	ne
   10f1e:	6818      	ldrne	r0, [r3, #0]
   10f20:	4004      	andne	r4, r0
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AA;
   10f22:	f240 70aa 	movw	r0, #1962	; 0x7aa
   10f26:	6010      	str	r0, [r2, #0]
            uoi = (uint8_t)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10f28:	6818      	ldr	r0, [r3, #0]
            if (0 != uoi)
   10f2a:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
                uoi &= (uint8_t)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10f2e:	bf1c      	itt	ne
   10f30:	681a      	ldrne	r2, [r3, #0]
   10f32:	4010      	andne	r0, r2
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AB;
   10f34:	f240 72ab 	movw	r2, #1963	; 0x7ab
   10f38:	6032      	str	r2, [r6, #0]
            usbi = (uint8_t)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10f3a:	681a      	ldr	r2, [r3, #0]
            if (0 != usbi)
   10f3c:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
   10f40:	46b4      	mov	ip, r6
                usbi &= (uint8_t)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   10f42:	bf1c      	itt	ne
   10f44:	681e      	ldrne	r6, [r3, #0]
   10f46:	4032      	andne	r2, r6
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AC;
   10f48:	f240 76ac 	movw	r6, #1964	; 0x7ac
   10f4c:	f8cc 6000 	str.w	r6, [ip]
            uii &= (uint8_t)*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10f50:	681e      	ldr	r6, [r3, #0]
            if (0 != uii)
   10f52:	4034      	ands	r4, r6
   10f54:	4e3a      	ldr	r6, [pc, #232]	; (11040 <nrfx_usbd_irq_handler+0x160>)
   10f56:	d008      	beq.n	10f6a <nrfx_usbd_irq_handler+0x8a>
                m_simulated_dataepstatus |= ((uint32_t)uii) << NRFX_USBD_EPIN_BITPOS_0;
   10f58:	6837      	ldr	r7, [r6, #0]
   10f5a:	4327      	orrs	r7, r4
   10f5c:	6037      	str	r7, [r6, #0]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7A9;
   10f5e:	f240 77a9 	movw	r7, #1961	; 0x7a9
   10f62:	f8cc 7000 	str.w	r7, [ip]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = uii;
   10f66:	601c      	str	r4, [r3, #0]
                rb = (uint8_t)*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10f68:	681c      	ldr	r4, [r3, #0]
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AD;
   10f6a:	4f33      	ldr	r7, [pc, #204]	; (11038 <nrfx_usbd_irq_handler+0x158>)
   10f6c:	f240 74ad 	movw	r4, #1965	; 0x7ad
   10f70:	603c      	str	r4, [r7, #0]
            uoi &= (uint8_t)*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10f72:	681c      	ldr	r4, [r3, #0]
            if (0 != uoi)
   10f74:	4020      	ands	r0, r4
   10f76:	d008      	beq.n	10f8a <nrfx_usbd_irq_handler+0xaa>
                m_simulated_dataepstatus |= ((uint32_t)uoi) << NRFX_USBD_EPOUT_BITPOS_0;
   10f78:	6834      	ldr	r4, [r6, #0]
   10f7a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
   10f7e:	6034      	str	r4, [r6, #0]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AA;
   10f80:	f240 74aa 	movw	r4, #1962	; 0x7aa
   10f84:	603c      	str	r4, [r7, #0]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = uoi;
   10f86:	6018      	str	r0, [r3, #0]
                rb = (uint8_t)*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10f88:	6818      	ldr	r0, [r3, #0]
            *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AE;
   10f8a:	482b      	ldr	r0, [pc, #172]	; (11038 <nrfx_usbd_irq_handler+0x158>)
   10f8c:	f240 74ae 	movw	r4, #1966	; 0x7ae
   10f90:	6004      	str	r4, [r0, #0]
            usbi &= (uint8_t)*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10f92:	6818      	ldr	r0, [r3, #0]
            if (0 != usbi)
   10f94:	4002      	ands	r2, r0
   10f96:	d00d      	beq.n	10fb4 <nrfx_usbd_irq_handler+0xd4>
                if (usbi & 0x01)
   10f98:	07d4      	lsls	r4, r2, #31
                    active |= USBD_INTEN_EP0SETUP_Msk;
   10f9a:	bf48      	it	mi
   10f9c:	f441 0100 	orrmi.w	r1, r1, #8388608	; 0x800000
                if (usbi & 0x10)
   10fa0:	06d0      	lsls	r0, r2, #27
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7AB;
   10fa2:	4825      	ldr	r0, [pc, #148]	; (11038 <nrfx_usbd_irq_handler+0x158>)
   10fa4:	f240 74ab 	movw	r4, #1963	; 0x7ab
   10fa8:	6004      	str	r4, [r0, #0]
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = usbi;
   10faa:	601a      	str	r2, [r3, #0]
                rb = (uint8_t)*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   10fac:	681b      	ldr	r3, [r3, #0]
                    active |= USBD_INTEN_USBRESET_Msk;
   10fae:	bf48      	it	mi
   10fb0:	f041 0101 	orrmi.w	r1, r1, #1
            if (0 != (m_simulated_dataepstatus &
   10fb4:	6833      	ldr	r3, [r6, #0]
   10fb6:	f033 1201 	bics.w	r2, r3, #65537	; 0x10001
                active |= enabled & NRF_USBD_INT_DATAEP_MASK;
   10fba:	bf1c      	itt	ne
   10fbc:	f005 7080 	andne.w	r0, r5, #16777216	; 0x1000000
   10fc0:	4301      	orrne	r1, r0
            if (0 != (m_simulated_dataepstatus &
   10fc2:	f013 1f01 	tst.w	r3, #65537	; 0x10001
   10fc6:	d004      	beq.n	10fd2 <nrfx_usbd_irq_handler+0xf2>
                if (0 != (enabled & NRF_USBD_INT_EP0DATADONE_MASK))
   10fc8:	056b      	lsls	r3, r5, #21
                    m_simulated_dataepstatus &=
   10fca:	bf44      	itt	mi
   10fcc:	6032      	strmi	r2, [r6, #0]
                    active |= NRF_USBD_INT_EP0DATADONE_MASK;
   10fce:	f441 6180 	orrmi.w	r1, r1, #1024	; 0x400
        m_isr[event_nr]();
   10fd2:	4f1c      	ldr	r7, [pc, #112]	; (11044 <nrfx_usbd_irq_handler+0x164>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
   10fd4:	f401 0600 	and.w	r6, r1, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
   10fd8:	f421 0400 	bic.w	r4, r1, #8388608	; 0x800000
        active &= ~(1UL << event_nr);
   10fdc:	f04f 0801 	mov.w	r8, #1
    while (active)
   10fe0:	b9bc      	cbnz	r4, 11012 <nrfx_usbd_irq_handler+0x132>
    usbd_dmareq_process();
   10fe2:	f7ff fc79 	bl	108d8 <usbd_dmareq_process>
    if (setup_active)
   10fe6:	b306      	cbz	r6, 1102a <nrfx_usbd_irq_handler+0x14a>
}
   10fe8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
   10fec:	f7ff bf3e 	b.w	10e6c <ev_setup_handler>
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   10ff0:	4a15      	ldr	r2, [pc, #84]	; (11048 <nrfx_usbd_irq_handler+0x168>)
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   10ff2:	fa90 f3a0 	rbit	r3, r0
  return __builtin_clz(value);
   10ff6:	fab3 f383 	clz	r3, r3
}

NRF_STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
   10ffa:	009f      	lsls	r7, r3, #2
   10ffc:	443a      	add	r2, r7
   10ffe:	fa04 f303 	lsl.w	r3, r4, r3
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   11002:	6817      	ldr	r7, [r2, #0]
    if (ret)
   11004:	b117      	cbz	r7, 1100c <nrfx_usbd_irq_handler+0x12c>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   11006:	6016      	str	r6, [r2, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   11008:	6812      	ldr	r2, [r2, #0]
            active |= 1UL << event_nr;
   1100a:	4319      	orrs	r1, r3
        to_process &= ~(1UL << event_nr);
   1100c:	ea20 0003 	bic.w	r0, r0, r3
   11010:	e76f      	b.n	10ef2 <nrfx_usbd_irq_handler+0x12>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   11012:	fa94 f5a4 	rbit	r5, r4
  return __builtin_clz(value);
   11016:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
   1101a:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
   1101e:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
   11022:	4798      	blx	r3
        active &= ~(1UL << event_nr);
   11024:	ea24 0405 	bic.w	r4, r4, r5
   11028:	e7da      	b.n	10fe0 <nrfx_usbd_irq_handler+0x100>
}
   1102a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1102e:	bf00      	nop
   11030:	40027000 	.word	0x40027000
   11034:	200087db 	.word	0x200087db
   11038:	40027800 	.word	0x40027800
   1103c:	40027804 	.word	0x40027804
   11040:	20003e3c 	.word	0x20003e3c
   11044:	00019a88 	.word	0x00019a88
   11048:	40027100 	.word	0x40027100

0001104c <usbd_ep_abort_all>:
{
   1104c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
   1104e:	4e13      	ldr	r6, [pc, #76]	; (1109c <usbd_ep_abort_all+0x50>)
   11050:	4a13      	ldr	r2, [pc, #76]	; (110a0 <usbd_ep_abort_all+0x54>)
   11052:	6834      	ldr	r4, [r6, #0]
   11054:	6812      	ldr	r2, [r2, #0]
   11056:	0c24      	lsrs	r4, r4, #16
   11058:	0424      	lsls	r4, r4, #16
   1105a:	4314      	orrs	r4, r2
        ep_waiting &= ~(1U << bitpos);
   1105c:	2701      	movs	r7, #1
    while (0 != ep_waiting)
   1105e:	b91c      	cbnz	r4, 11068 <usbd_ep_abort_all+0x1c>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   11060:	f240 13ff 	movw	r3, #511	; 0x1ff
   11064:	6033      	str	r3, [r6, #0]
}
   11066:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   11068:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
   1106c:	b185      	cbz	r5, 11090 <usbd_ep_abort_all+0x44>
  return __builtin_clz(value);
   1106e:	fab5 f385 	clz	r3, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   11072:	2b0f      	cmp	r3, #15
   11074:	461d      	mov	r5, r3
   11076:	dd0d      	ble.n	11094 <usbd_ep_abort_all+0x48>
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
   11078:	f1a5 0010 	sub.w	r0, r5, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   1107c:	b2c0      	uxtb	r0, r0
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
   1107e:	0703      	lsls	r3, r0, #28
   11080:	d401      	bmi.n	11086 <usbd_ep_abort_all+0x3a>
            usbd_ep_abort(bit2ep(bitpos));
   11082:	f7ff fe7f 	bl	10d84 <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
   11086:	fa07 f505 	lsl.w	r5, r7, r5
   1108a:	ea24 0405 	bic.w	r4, r4, r5
   1108e:	e7e6      	b.n	1105e <usbd_ep_abort_all+0x12>
    return 32U;
   11090:	2520      	movs	r5, #32
   11092:	e7f1      	b.n	11078 <usbd_ep_abort_all+0x2c>
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   11094:	f043 0080 	orr.w	r0, r3, #128	; 0x80
   11098:	e7f1      	b.n	1107e <usbd_ep_abort_all+0x32>
   1109a:	bf00      	nop
   1109c:	20003d14 	.word	0x20003d14
   110a0:	20003ca4 	.word	0x20003ca4

000110a4 <nrfx_usbd_stop>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   110a4:	4b0c      	ldr	r3, [pc, #48]	; (110d8 <nrfx_usbd_stop+0x34>)
   110a6:	2280      	movs	r2, #128	; 0x80
{
   110a8:	b510      	push	{r4, lr}
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
   110aa:	2027      	movs	r0, #39	; 0x27
   110ac:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
   110b0:	f7f4 fd36 	bl	5b20 <arch_irq_is_enabled>
   110b4:	b170      	cbz	r0, 110d4 <nrfx_usbd_stop+0x30>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
   110b6:	4c09      	ldr	r4, [pc, #36]	; (110dc <nrfx_usbd_stop+0x38>)
        usbd_ep_abort_all();
   110b8:	f7ff ffc8 	bl	1104c <usbd_ep_abort_all>
   110bc:	2300      	movs	r3, #0
   110be:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
        NRFX_IRQ_DISABLE(USBD_IRQn);
   110c2:	2027      	movs	r0, #39	; 0x27
    (void) p_reg->USBPULLUP;
   110c4:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
   110c8:	f7f4 fd16 	bl	5af8 <arch_irq_disable>
    p_reg->INTENCLR = mask;
   110cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   110d0:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
}
   110d4:	bd10      	pop	{r4, pc}
   110d6:	bf00      	nop
   110d8:	e000e100 	.word	0xe000e100
   110dc:	40027000 	.word	0x40027000

000110e0 <nrfx_usbd_disable>:
{
   110e0:	b508      	push	{r3, lr}
    nrfx_usbd_stop();
   110e2:	f7ff ffdf 	bl	110a4 <nrfx_usbd_stop>
    return p_reg->INTENSET;
   110e6:	4b08      	ldr	r3, [pc, #32]	; (11108 <nrfx_usbd_disable+0x28>)
   110e8:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
   110ec:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
   110f0:	2200      	movs	r2, #0
   110f2:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   110f6:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
    usbd_dma_pending_clear();
   110fa:	f7ff f87f 	bl	101fc <usbd_dma_pending_clear>
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   110fe:	4b03      	ldr	r3, [pc, #12]	; (1110c <nrfx_usbd_disable+0x2c>)
   11100:	2201      	movs	r2, #1
   11102:	701a      	strb	r2, [r3, #0]
}
   11104:	bd08      	pop	{r3, pc}
   11106:	bf00      	nop
   11108:	40027000 	.word	0x40027000
   1110c:	200087dc 	.word	0x200087dc

00011110 <nrfx_usbd_suspend>:
{
   11110:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   11112:	f04f 0320 	mov.w	r3, #32
   11116:	f3ef 8511 	mrs	r5, BASEPRI
   1111a:	f383 8811 	msr	BASEPRI, r3
   1111e:	f3bf 8f6f 	isb	sy
    if (m_bus_suspend)
   11122:	4b11      	ldr	r3, [pc, #68]	; (11168 <nrfx_usbd_suspend+0x58>)
   11124:	781b      	ldrb	r3, [r3, #0]
   11126:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   1112a:	b933      	cbnz	r3, 1113a <nrfx_usbd_suspend+0x2a>
    bool suspended = false;
   1112c:	2400      	movs	r4, #0
	__asm__ volatile(
   1112e:	f385 8811 	msr	BASEPRI, r5
   11132:	f3bf 8f6f 	isb	sy
}
   11136:	4620      	mov	r0, r4
   11138:	bd38      	pop	{r3, r4, r5, pc}
        usbd_ep_abort_all();
   1113a:	f7ff ff87 	bl	1104c <usbd_ep_abort_all>
    return p_reg->EVENTCAUSE;
   1113e:	4b0b      	ldr	r3, [pc, #44]	; (1116c <nrfx_usbd_suspend+0x5c>)
   11140:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        if (!(nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK))
   11144:	f412 7200 	ands.w	r2, r2, #512	; 0x200
   11148:	d1f0      	bne.n	1112c <nrfx_usbd_suspend+0x1c>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
   1114a:	2101      	movs	r1, #1
   1114c:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   11150:	f8d3 152c 	ldr.w	r1, [r3, #1324]	; 0x52c
    return p_reg->EVENTCAUSE;
   11154:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
            if (nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   11158:	0589      	lsls	r1, r1, #22
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
   1115a:	bf42      	ittt	mi
   1115c:	f8c3 252c 	strmi.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   11160:	f8d3 352c 	ldrmi.w	r3, [r3, #1324]	; 0x52c
    bool suspended = false;
   11164:	4614      	movmi	r4, r2
}
   11166:	e7e2      	b.n	1112e <nrfx_usbd_suspend+0x1e>
   11168:	200087da 	.word	0x200087da
   1116c:	40027000 	.word	0x40027000

00011170 <nrfx_usbd_ep_disable>:
{
   11170:	b510      	push	{r4, lr}
   11172:	4604      	mov	r4, r0
    usbd_ep_abort(ep);
   11174:	f7ff fe06 	bl	10d84 <usbd_ep_abort>
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   11178:	4a10      	ldr	r2, [pc, #64]	; (111bc <nrfx_usbd_ep_disable+0x4c>)
    if (NRF_USBD_EPIN_CHECK(ep))
   1117a:	f014 0f80 	tst.w	r4, #128	; 0x80
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   1117e:	f004 000f 	and.w	r0, r4, #15
        p_reg->EPINEN &= ~(1UL << epnr);
   11182:	f04f 0301 	mov.w	r3, #1
   11186:	bf14      	ite	ne
   11188:	f8d2 1510 	ldrne.w	r1, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   1118c:	f8d2 1514 	ldreq.w	r1, [r2, #1300]	; 0x514
   11190:	fa03 f300 	lsl.w	r3, r3, r0
   11194:	ea6f 0303 	mvn.w	r3, r3
        p_reg->EPINEN &= ~(1UL << epnr);
   11198:	bf15      	itete	ne
   1119a:	400b      	andne	r3, r1
        p_reg->EPOUTEN &= ~(1UL << epnr);
   1119c:	400b      	andeq	r3, r1
        p_reg->EPINEN &= ~(1UL << epnr);
   1119e:	f8c2 3510 	strne.w	r3, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   111a2:	f8c2 3514 	streq.w	r3, [r2, #1300]	; 0x514
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   111a6:	bf14      	ite	ne
   111a8:	4b05      	ldrne	r3, [pc, #20]	; (111c0 <nrfx_usbd_ep_disable+0x50>)
   111aa:	4b06      	ldreq	r3, [pc, #24]	; (111c4 <nrfx_usbd_ep_disable+0x54>)
   111ac:	5c1a      	ldrb	r2, [r3, r0]
   111ae:	2301      	movs	r3, #1
   111b0:	4093      	lsls	r3, r2
    p_reg->INTENCLR = mask;
   111b2:	4a02      	ldr	r2, [pc, #8]	; (111bc <nrfx_usbd_ep_disable+0x4c>)
   111b4:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
   111b8:	bd10      	pop	{r4, pc}
   111ba:	bf00      	nop
   111bc:	40027000 	.word	0x40027000
   111c0:	0001c056 	.word	0x0001c056
   111c4:	0001c05f 	.word	0x0001c05f

000111c8 <nrfx_usbd_ep_enable>:
{
   111c8:	b570      	push	{r4, r5, r6, lr}
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   111ca:	b243      	sxtb	r3, r0
   111cc:	2b00      	cmp	r3, #0
   111ce:	4b23      	ldr	r3, [pc, #140]	; (1125c <nrfx_usbd_ep_enable+0x94>)
   111d0:	4a23      	ldr	r2, [pc, #140]	; (11260 <nrfx_usbd_ep_enable+0x98>)
   111d2:	bfa8      	it	ge
   111d4:	461a      	movge	r2, r3
   111d6:	f000 030f 	and.w	r3, r0, #15
   111da:	f04f 0401 	mov.w	r4, #1
   111de:	5cd1      	ldrb	r1, [r2, r3]
    p_reg->INTENSET = mask;
   111e0:	4a20      	ldr	r2, [pc, #128]	; (11264 <nrfx_usbd_ep_enable+0x9c>)
   111e2:	fa04 f101 	lsl.w	r1, r4, r1
{
   111e6:	4605      	mov	r5, r0
   111e8:	f8c2 1304 	str.w	r1, [r2, #772]	; 0x304
    if (NRF_USBD_EPIN_CHECK(ep))
   111ec:	da0c      	bge.n	11208 <nrfx_usbd_ep_enable+0x40>
        return 0 != (p_reg->EPINEN & (1UL << epnr));
   111ee:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   111f2:	40d9      	lsrs	r1, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   111f4:	07c8      	lsls	r0, r1, #31
   111f6:	d406      	bmi.n	11206 <nrfx_usbd_ep_enable+0x3e>
        p_reg->EPINEN |= 1UL << epnr;
   111f8:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   111fc:	fa04 f303 	lsl.w	r3, r4, r3
   11200:	4303      	orrs	r3, r0
   11202:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
}
   11206:	bd70      	pop	{r4, r5, r6, pc}
        return 0 != (p_reg->EPOUTEN & (1UL << epnr));
   11208:	f8d2 1514 	ldr.w	r1, [r2, #1300]	; 0x514
   1120c:	40d9      	lsrs	r1, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   1120e:	07c9      	lsls	r1, r1, #31
   11210:	d4f9      	bmi.n	11206 <nrfx_usbd_ep_enable+0x3e>
        p_reg->EPOUTEN |= 1UL << epnr;
   11212:	f8d2 6514 	ldr.w	r6, [r2, #1300]	; 0x514
   11216:	fa04 f103 	lsl.w	r1, r4, r3
   1121a:	4331      	orrs	r1, r6
   1121c:	f8c2 1514 	str.w	r1, [r2, #1300]	; 0x514
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
   11220:	2b00      	cmp	r3, #0
   11222:	d0f0      	beq.n	11206 <nrfx_usbd_ep_enable+0x3e>
        NRF_USBD_EPOUT_CHECK(ep) &&
   11224:	0703      	lsls	r3, r0, #28
   11226:	d4ee      	bmi.n	11206 <nrfx_usbd_ep_enable+0x3e>
	__asm__ volatile(
   11228:	f04f 0320 	mov.w	r3, #32
   1122c:	f3ef 8611 	mrs	r6, BASEPRI
   11230:	f383 8811 	msr	BASEPRI, r3
   11234:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
   11238:	f7ff fd5e 	bl	10cf8 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   1123c:	4628      	mov	r0, r5
   1123e:	f006 fb44 	bl	178ca <ep2bit>
   11242:	4a09      	ldr	r2, [pc, #36]	; (11268 <nrfx_usbd_ep_enable+0xa0>)
   11244:	6813      	ldr	r3, [r2, #0]
   11246:	fa04 f000 	lsl.w	r0, r4, r0
   1124a:	ea23 0000 	bic.w	r0, r3, r0
   1124e:	6010      	str	r0, [r2, #0]
	__asm__ volatile(
   11250:	f386 8811 	msr	BASEPRI, r6
   11254:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   11258:	e7d5      	b.n	11206 <nrfx_usbd_ep_enable+0x3e>
   1125a:	bf00      	nop
   1125c:	0001c05f 	.word	0x0001c05f
   11260:	0001c056 	.word	0x0001c056
   11264:	40027000 	.word	0x40027000
   11268:	20003ca4 	.word	0x20003ca4

0001126c <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   1126c:	0603      	lsls	r3, r0, #24
{
   1126e:	b510      	push	{r4, lr}
   11270:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   11272:	d405      	bmi.n	11280 <nrfx_usbd_ep_stall_clear+0x14>
   11274:	f7ff fca4 	bl	10bc0 <nrfx_usbd_ep_stall_check>
   11278:	b110      	cbz	r0, 11280 <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
   1127a:	4620      	mov	r0, r4
   1127c:	f7ff fd3c 	bl	10cf8 <nrfx_usbd_transfer_out_drop>
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
   11280:	4b01      	ldr	r3, [pc, #4]	; (11288 <nrfx_usbd_ep_stall_clear+0x1c>)
   11282:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
}
   11286:	bd10      	pop	{r4, pc}
   11288:	40027000 	.word	0x40027000

0001128c <lfs_dir_traverse_filter>:
    (void)buffer;

    // which mask depends on unique bit in tag structure
    uint32_t mask = (tag & LFS_MKTAG(0x100, 0, 0))
            ? LFS_MKTAG(0x7ff, 0x3ff, 0)
            : LFS_MKTAG(0x700, 0x3ff, 0);
   1128c:	4a16      	ldr	r2, [pc, #88]	; (112e8 <lfs_dir_traverse_filter+0x5c>)

    // check for redundancy
    if ((mask & tag) == (mask & *filtertag) ||
   1128e:	6803      	ldr	r3, [r0, #0]
        lfs_tag_t tag, const void *buffer) {
   11290:	b530      	push	{r4, r5, lr}
            : LFS_MKTAG(0x700, 0x3ff, 0);
   11292:	f011 5f80 	tst.w	r1, #268435456	; 0x10000000
   11296:	4c15      	ldr	r4, [pc, #84]	; (112ec <lfs_dir_traverse_filter+0x60>)
    if ((mask & tag) == (mask & *filtertag) ||
   11298:	ea83 0501 	eor.w	r5, r3, r1
            : LFS_MKTAG(0x700, 0x3ff, 0);
   1129c:	bf18      	it	ne
   1129e:	4614      	movne	r4, r2
    if ((mask & tag) == (mask & *filtertag) ||
   112a0:	4225      	tst	r5, r4
   112a2:	d01f      	beq.n	112e4 <lfs_dir_traverse_filter+0x58>
    return ((int32_t)(tag << 22) >> 22) == -1;
   112a4:	f343 0409 	sbfx	r4, r3, #0, #10
    if ((mask & tag) == (mask & *filtertag) ||
   112a8:	3401      	adds	r4, #1
   112aa:	d01b      	beq.n	112e4 <lfs_dir_traverse_filter+0x58>
            lfs_tag_isdelete(*filtertag) ||
            (LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) == (
   112ac:	ea01 0402 	and.w	r4, r1, r2
                LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
                    (LFS_MKTAG(0, 0x3ff, 0) & *filtertag))) {
   112b0:	4a0f      	ldr	r2, [pc, #60]	; (112f0 <lfs_dir_traverse_filter+0x64>)
   112b2:	401a      	ands	r2, r3
                LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
   112b4:	f042 429f 	orr.w	r2, r2, #1333788672	; 0x4f800000
   112b8:	f442 02e0 	orr.w	r2, r2, #7340032	; 0x700000
            lfs_tag_isdelete(*filtertag) ||
   112bc:	4294      	cmp	r4, r2
   112be:	d011      	beq.n	112e4 <lfs_dir_traverse_filter+0x58>
    return (tag & 0x70000000) >> 20;
   112c0:	0d0a      	lsrs	r2, r1, #20
        return true;
    }

    // check if we need to adjust for created/deleted tags
    if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&
   112c2:	f402 64e0 	and.w	r4, r2, #1792	; 0x700
   112c6:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   112ca:	d109      	bne.n	112e0 <lfs_dir_traverse_filter+0x54>
   112cc:	f3c3 2489 	ubfx	r4, r3, #10, #10
   112d0:	f3c1 2189 	ubfx	r1, r1, #10, #10
   112d4:	428c      	cmp	r4, r1
   112d6:	d303      	bcc.n	112e0 <lfs_dir_traverse_filter+0x54>
            lfs_tag_id(tag) <= lfs_tag_id(*filtertag)) {
        *filtertag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
   112d8:	b252      	sxtb	r2, r2
   112da:	eb03 2382 	add.w	r3, r3, r2, lsl #10
   112de:	6003      	str	r3, [r0, #0]
    }

    return false;
   112e0:	2000      	movs	r0, #0
   112e2:	e000      	b.n	112e6 <lfs_dir_traverse_filter+0x5a>
        return true;
   112e4:	2001      	movs	r0, #1
}
   112e6:	bd30      	pop	{r4, r5, pc}
   112e8:	7ffffc00 	.word	0x7ffffc00
   112ec:	700ffc00 	.word	0x700ffc00
   112f0:	000ffc00 	.word	0x000ffc00

000112f4 <lfs_dir_fetchmatch>:
}

static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
        lfs_mdir_t *dir, const lfs_block_t pair[2],
        lfs_tag_t fmask, lfs_tag_t ftag, uint16_t *id,
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
   112f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   112f8:	b097      	sub	sp, #92	; 0x5c
   112fa:	4615      	mov	r5, r2
   112fc:	930b      	str	r3, [sp, #44]	; 0x2c
    // scanning the entire directory
    lfs_stag_t besttag = -1;

    // if either block address is invalid we return LFS_ERR_CORRUPT here,
    // otherwise later writes to the pair could fail
    if (pair[0] >= lfs->cfg->block_count || pair[1] >= lfs->cfg->block_count) {
   112fe:	6813      	ldr	r3, [r2, #0]
   11300:	6e82      	ldr	r2, [r0, #104]	; 0x68
   11302:	6a12      	ldr	r2, [r2, #32]
   11304:	4293      	cmp	r3, r2
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
   11306:	4607      	mov	r7, r0
   11308:	460c      	mov	r4, r1
    if (pair[0] >= lfs->cfg->block_count || pair[1] >= lfs->cfg->block_count) {
   1130a:	f080 81df 	bcs.w	116cc <lfs_dir_fetchmatch+0x3d8>
   1130e:	6869      	ldr	r1, [r5, #4]
   11310:	428a      	cmp	r2, r1
   11312:	f240 81db 	bls.w	116cc <lfs_dir_fetchmatch+0x3d8>
        return LFS_ERR_CORRUPT;
    }

    // find the block with the most recent revision
    uint32_t revs[2] = {0, 0};
   11316:	2100      	movs	r1, #0
    int r = 0;
    for (int i = 0; i < 2; i++) {
        int err = lfs_bd_read(lfs,
   11318:	f04f 0804 	mov.w	r8, #4
   1131c:	aa0e      	add	r2, sp, #56	; 0x38
   1131e:	f100 0b68 	add.w	fp, r0, #104	; 0x68
   11322:	e9cd 1201 	strd	r1, r2, [sp, #4]
   11326:	9300      	str	r3, [sp, #0]
   11328:	4602      	mov	r2, r0
   1132a:	4643      	mov	r3, r8
   1132c:	f8cd 800c 	str.w	r8, [sp, #12]
   11330:	4658      	mov	r0, fp
    uint32_t revs[2] = {0, 0};
   11332:	e9cd 110e 	strd	r1, r1, [sp, #56]	; 0x38
        int err = lfs_bd_read(lfs,
   11336:	f006 fbc1 	bl	17abc <lfs_bd_read.isra.0>
                NULL, &lfs->rcache, sizeof(revs[i]),
                pair[i], 0, &revs[i], sizeof(revs[i]));
        revs[i] = lfs_fromle32(revs[i]);
        if (err && err != LFS_ERR_CORRUPT) {
   1133a:	4643      	mov	r3, r8
   1133c:	4606      	mov	r6, r0
   1133e:	b110      	cbz	r0, 11346 <lfs_dir_fetchmatch+0x52>
   11340:	f110 0f54 	cmn.w	r0, #84	; 0x54
   11344:	d113      	bne.n	1136e <lfs_dir_fetchmatch+0x7a>
        int err = lfs_bd_read(lfs,
   11346:	9303      	str	r3, [sp, #12]
   11348:	f04f 0800 	mov.w	r8, #0
   1134c:	ab0f      	add	r3, sp, #60	; 0x3c
   1134e:	9302      	str	r3, [sp, #8]
   11350:	f8cd 8004 	str.w	r8, [sp, #4]
   11354:	686b      	ldr	r3, [r5, #4]
   11356:	9300      	str	r3, [sp, #0]
   11358:	463a      	mov	r2, r7
   1135a:	2304      	movs	r3, #4
   1135c:	4641      	mov	r1, r8
   1135e:	4658      	mov	r0, fp
   11360:	f006 fbac 	bl	17abc <lfs_bd_read.isra.0>
        if (err && err != LFS_ERR_CORRUPT) {
   11364:	4606      	mov	r6, r0
   11366:	b130      	cbz	r0, 11376 <lfs_dir_fetchmatch+0x82>
   11368:	f110 0f54 	cmn.w	r0, #84	; 0x54
   1136c:	d04c      	beq.n	11408 <lfs_dir_fetchmatch+0x114>
    }

    LFS_ERROR("Corrupted dir pair at {0x%"PRIx32", 0x%"PRIx32"}",
            dir->pair[0], dir->pair[1]);
    return LFS_ERR_CORRUPT;
}
   1136e:	4630      	mov	r0, r6
   11370:	b017      	add	sp, #92	; 0x5c
   11372:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}

// Find the sequence comparison of a and b, this is the distance
// between a and b ignoring overflow
static inline int lfs_scmp(uint32_t a, uint32_t b) {
    return (int)(unsigned)(a - b);
   11376:	e9dd 310e 	ldrd	r3, r1, [sp, #56]	; 0x38
   1137a:	1ac9      	subs	r1, r1, r3
        if (err != LFS_ERR_CORRUPT &&
   1137c:	2900      	cmp	r1, #0
   1137e:	bfd4      	ite	le
   11380:	2100      	movle	r1, #0
   11382:	2101      	movgt	r1, #1
    dir->pair[0] = pair[(r+0)%2];
   11384:	f855 3021 	ldr.w	r3, [r5, r1, lsl #2]
   11388:	6023      	str	r3, [r4, #0]
    dir->pair[1] = pair[(r+1)%2];
   1138a:	f081 0301 	eor.w	r3, r1, #1
   1138e:	9309      	str	r3, [sp, #36]	; 0x24
   11390:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   11394:	6063      	str	r3, [r4, #4]
    dir->rev = revs[(r+0)%2];
   11396:	ab16      	add	r3, sp, #88	; 0x58
   11398:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    dir->off = 0; // nonzero = found some commits
   1139c:	2202      	movs	r2, #2
    dir->rev = revs[(r+0)%2];
   1139e:	f851 3c20 	ldr.w	r3, [r1, #-32]
   113a2:	60a3      	str	r3, [r4, #8]
    dir->off = 0; // nonzero = found some commits
   113a4:	2300      	movs	r3, #0
   113a6:	60e3      	str	r3, [r4, #12]
   113a8:	920a      	str	r2, [sp, #40]	; 0x28
    lfs_stag_t besttag = -1;
   113aa:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
        bool tempsplit = false;
   113ae:	9308      	str	r3, [sp, #32]
        lfs_block_t temptail[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
   113b0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));
   113b4:	2204      	movs	r2, #4
   113b6:	f104 0108 	add.w	r1, r4, #8
   113ba:	4628      	mov	r0, r5
        lfs_block_t temptail[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
   113bc:	e9cd 5510 	strd	r5, r5, [sp, #64]	; 0x40
        uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));
   113c0:	f002 f922 	bl	13608 <lfs_crc>
        bool tempsplit = false;
   113c4:	2300      	movs	r3, #0
        uint16_t tempcount = 0;
   113c6:	e9cd 3306 	strd	r3, r3, [sp, #24]
        uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));
   113ca:	9005      	str	r0, [sp, #20]
   113cc:	46b0      	mov	r8, r6
        lfs_tag_t ptag = 0xffffffff;
   113ce:	46a9      	mov	r9, r5
        lfs_off_t off = 0;
   113d0:	469a      	mov	sl, r3
            off += lfs_tag_dsize(ptag);
   113d2:	4648      	mov	r0, r9
   113d4:	f006 faff 	bl	179d6 <lfs_tag_dsize>
            int err = lfs_bd_read(lfs,
   113d8:	2204      	movs	r2, #4
   113da:	9203      	str	r2, [sp, #12]
            off += lfs_tag_dsize(ptag);
   113dc:	4482      	add	sl, r0
            int err = lfs_bd_read(lfs,
   113de:	aa0d      	add	r2, sp, #52	; 0x34
   113e0:	e9cd a201 	strd	sl, r2, [sp, #4]
   113e4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   113e6:	6822      	ldr	r2, [r4, #0]
   113e8:	9200      	str	r2, [sp, #0]
   113ea:	69db      	ldr	r3, [r3, #28]
   113ec:	463a      	mov	r2, r7
   113ee:	2100      	movs	r1, #0
   113f0:	4658      	mov	r0, fp
   113f2:	f006 fb63 	bl	17abc <lfs_bd_read.isra.0>
            if (err) {
   113f6:	4605      	mov	r5, r0
   113f8:	b158      	cbz	r0, 11412 <lfs_dir_fetchmatch+0x11e>
                    if (err == LFS_ERR_CORRUPT) {
   113fa:	f115 0f54 	cmn.w	r5, #84	; 0x54
   113fe:	f040 8139 	bne.w	11674 <lfs_dir_fetchmatch+0x380>
                        dir->erased = false;
   11402:	9b08      	ldr	r3, [sp, #32]
   11404:	75a3      	strb	r3, [r4, #22]
                        break;
   11406:	e026      	b.n	11456 <lfs_dir_fetchmatch+0x162>
   11408:	4641      	mov	r1, r8
   1140a:	e7bb      	b.n	11384 <lfs_dir_fetchmatch+0x90>
   1140c:	2301      	movs	r3, #1
   1140e:	930a      	str	r3, [sp, #40]	; 0x28
   11410:	e7ce      	b.n	113b0 <lfs_dir_fetchmatch+0xbc>
            crc = lfs_crc(crc, &tag, sizeof(tag));
   11412:	9805      	ldr	r0, [sp, #20]
   11414:	2204      	movs	r2, #4
   11416:	a90d      	add	r1, sp, #52	; 0x34
   11418:	f002 f8f6 	bl	13608 <lfs_crc>
static inline uint32_t lfs_frombe32(uint32_t a) {
#if !defined(LFS_NO_INTRINSICS) && ( \
    (defined(  BYTE_ORDER  ) && defined(  ORDER_LITTLE_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_LITTLE_ENDIAN  ) || \
    (defined(__BYTE_ORDER  ) && defined(__ORDER_LITTLE_ENDIAN  ) && __BYTE_ORDER   == __ORDER_LITTLE_ENDIAN  ) || \
    (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
    return __builtin_bswap32(a);
   1141c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1141e:	9005      	str	r0, [sp, #20]
   11420:	ba1b      	rev	r3, r3
            tag = lfs_frombe32(tag) ^ ptag;
   11422:	ea89 0303 	eor.w	r3, r9, r3
            if (!lfs_tag_isvalid(tag)) {
   11426:	2b00      	cmp	r3, #0
            tag = lfs_frombe32(tag) ^ ptag;
   11428:	9304      	str	r3, [sp, #16]
   1142a:	930d      	str	r3, [sp, #52]	; 0x34
            if (!lfs_tag_isvalid(tag)) {
   1142c:	da3d      	bge.n	114aa <lfs_dir_fetchmatch+0x1b6>
    return (tag & 0x70000000) >> 20;
   1142e:	ea4f 5919 	mov.w	r9, r9, lsr #20
                dir->erased = (lfs_tag_type1(ptag) == LFS_TYPE_CRC &&
   11432:	f409 69e0 	and.w	r9, r9, #1792	; 0x700
   11436:	f5b9 6fa0 	cmp.w	r9, #1280	; 0x500
   1143a:	d109      	bne.n	11450 <lfs_dir_fetchmatch+0x15c>
                        dir->off % lfs->cfg->prog_size == 0);
   1143c:	6eba      	ldr	r2, [r7, #104]	; 0x68
   1143e:	68e3      	ldr	r3, [r4, #12]
   11440:	6995      	ldr	r5, [r2, #24]
   11442:	fbb3 f0f5 	udiv	r0, r3, r5
   11446:	fb05 3010 	mls	r0, r5, r0, r3
                dir->erased = (lfs_tag_type1(ptag) == LFS_TYPE_CRC &&
   1144a:	fab0 f580 	clz	r5, r0
   1144e:	096d      	lsrs	r5, r5, #5
   11450:	f005 0001 	and.w	r0, r5, #1
   11454:	75a0      	strb	r0, [r4, #22]
        if (dir->off > 0) {
   11456:	68e3      	ldr	r3, [r4, #12]
   11458:	2b00      	cmp	r3, #0
   1145a:	f000 8115 	beq.w	11688 <lfs_dir_fetchmatch+0x394>
            if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {
   1145e:	4621      	mov	r1, r4
   11460:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   11464:	f006 facf 	bl	17a06 <lfs_gstate_hasmovehere>
   11468:	b148      	cbz	r0, 1147e <lfs_dir_fetchmatch+0x18a>
    return (tag & 0x000ffc00) >> 10;
   1146a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1146c:	f3c6 2289 	ubfx	r2, r6, #10, #10
   11470:	f3c3 2389 	ubfx	r3, r3, #10, #10
                if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {
   11474:	429a      	cmp	r2, r3
   11476:	f040 80ff 	bne.w	11678 <lfs_dir_fetchmatch+0x384>
                    besttag |= 0x80000000;
   1147a:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
            if (id) {
   1147e:	9b21      	ldr	r3, [sp, #132]	; 0x84
   11480:	b13b      	cbz	r3, 11492 <lfs_dir_fetchmatch+0x19e>
                *id = lfs_min(lfs_tag_id(besttag), dir->count);
   11482:	8aa2      	ldrh	r2, [r4, #20]
   11484:	f3c6 2389 	ubfx	r3, r6, #10, #10
    return (a < b) ? a : b;
   11488:	4293      	cmp	r3, r2
   1148a:	bf28      	it	cs
   1148c:	4613      	movcs	r3, r2
   1148e:	9a21      	ldr	r2, [sp, #132]	; 0x84
   11490:	8013      	strh	r3, [r2, #0]
            if (lfs_tag_isvalid(besttag)) {
   11492:	2e00      	cmp	r6, #0
   11494:	f6bf af6b 	bge.w	1136e <lfs_dir_fetchmatch+0x7a>
            } else if (lfs_tag_id(besttag) < dir->count) {
   11498:	8aa3      	ldrh	r3, [r4, #20]
   1149a:	f3c6 2689 	ubfx	r6, r6, #10, #10
                return 0;
   1149e:	42b3      	cmp	r3, r6
   114a0:	bf8c      	ite	hi
   114a2:	f06f 0601 	mvnhi.w	r6, #1
   114a6:	2600      	movls	r6, #0
   114a8:	e761      	b.n	1136e <lfs_dir_fetchmatch+0x7a>
            } else if (off + lfs_tag_dsize(tag) > lfs->cfg->block_size) {
   114aa:	9804      	ldr	r0, [sp, #16]
   114ac:	f006 fa93 	bl	179d6 <lfs_tag_dsize>
   114b0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   114b2:	69db      	ldr	r3, [r3, #28]
   114b4:	4450      	add	r0, sl
   114b6:	4298      	cmp	r0, r3
   114b8:	d8a3      	bhi.n	11402 <lfs_dir_fetchmatch+0x10e>
    return (tag & 0x70000000) >> 20;
   114ba:	9a04      	ldr	r2, [sp, #16]
   114bc:	0d12      	lsrs	r2, r2, #20
            if (lfs_tag_type1(tag) == LFS_TYPE_CRC) {
   114be:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   114c2:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
   114c6:	d17f      	bne.n	115c8 <lfs_dir_fetchmatch+0x2d4>
                err = lfs_bd_read(lfs,
   114c8:	2204      	movs	r2, #4
   114ca:	9203      	str	r2, [sp, #12]
   114cc:	aa12      	add	r2, sp, #72	; 0x48
   114ce:	9202      	str	r2, [sp, #8]
   114d0:	f10a 0204 	add.w	r2, sl, #4
   114d4:	9201      	str	r2, [sp, #4]
   114d6:	6822      	ldr	r2, [r4, #0]
   114d8:	9200      	str	r2, [sp, #0]
   114da:	4629      	mov	r1, r5
   114dc:	463a      	mov	r2, r7
   114de:	4658      	mov	r0, fp
   114e0:	f006 faec 	bl	17abc <lfs_bd_read.isra.0>
                if (err) {
   114e4:	4605      	mov	r5, r0
   114e6:	2800      	cmp	r0, #0
   114e8:	d187      	bne.n	113fa <lfs_dir_fetchmatch+0x106>
                if (crc != dcrc) {
   114ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
   114ec:	9a05      	ldr	r2, [sp, #20]
   114ee:	4293      	cmp	r3, r2
   114f0:	d187      	bne.n	11402 <lfs_dir_fetchmatch+0x10e>
                ptag ^= (lfs_tag_t)(lfs_tag_chunk(tag) & 1U) << 31;
   114f2:	980d      	ldr	r0, [sp, #52]	; 0x34
   114f4:	9a04      	ldr	r2, [sp, #16]
    return (tag & 0x0ff00000) >> 20;
   114f6:	0d03      	lsrs	r3, r0, #20
                ptag ^= (lfs_tag_t)(lfs_tag_chunk(tag) & 1U) << 31;
   114f8:	ea82 73c3 	eor.w	r3, r2, r3, lsl #31
   114fc:	9304      	str	r3, [sp, #16]
                lfs->seed ^= crc;
   114fe:	9a05      	ldr	r2, [sp, #20]
   11500:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   11502:	4053      	eors	r3, r2
   11504:	62fb      	str	r3, [r7, #44]	; 0x2c
                dir->off = off + lfs_tag_dsize(tag);
   11506:	f006 fa66 	bl	179d6 <lfs_tag_dsize>
                dir->etag = ptag;
   1150a:	9b04      	ldr	r3, [sp, #16]
   1150c:	6123      	str	r3, [r4, #16]
                dir->count = tempcount;
   1150e:	9b06      	ldr	r3, [sp, #24]
   11510:	82a3      	strh	r3, [r4, #20]
                dir->tail[0] = temptail[0];
   11512:	9b10      	ldr	r3, [sp, #64]	; 0x40
   11514:	61a3      	str	r3, [r4, #24]
                dir->tail[1] = temptail[1];
   11516:	9b11      	ldr	r3, [sp, #68]	; 0x44
   11518:	61e3      	str	r3, [r4, #28]
                dir->off = off + lfs_tag_dsize(tag);
   1151a:	4450      	add	r0, sl
                dir->split = tempsplit;
   1151c:	9b07      	ldr	r3, [sp, #28]
   1151e:	75e3      	strb	r3, [r4, #23]
                crc = 0xffffffff;
   11520:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
                dir->off = off + lfs_tag_dsize(tag);
   11524:	60e0      	str	r0, [r4, #12]
                continue;
   11526:	4643      	mov	r3, r8
                crc = 0xffffffff;
   11528:	9205      	str	r2, [sp, #20]
   1152a:	4646      	mov	r6, r8
   1152c:	f8dd 9010 	ldr.w	r9, [sp, #16]
   11530:	4698      	mov	r8, r3
   11532:	e74e      	b.n	113d2 <lfs_dir_fetchmatch+0xde>
                crc = lfs_crc(crc, &dat, 1);
   11534:	9805      	ldr	r0, [sp, #20]
   11536:	2201      	movs	r2, #1
   11538:	a912      	add	r1, sp, #72	; 0x48
   1153a:	f002 f865 	bl	13608 <lfs_crc>
            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
   1153e:	f109 0901 	add.w	r9, r9, #1
                crc = lfs_crc(crc, &dat, 1);
   11542:	9005      	str	r0, [sp, #20]
            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
   11544:	980d      	ldr	r0, [sp, #52]	; 0x34
   11546:	f006 fa46 	bl	179d6 <lfs_tag_dsize>
   1154a:	4548      	cmp	r0, r9
   1154c:	6823      	ldr	r3, [r4, #0]
   1154e:	d916      	bls.n	1157e <lfs_dir_fetchmatch+0x28a>
                err = lfs_bd_read(lfs,
   11550:	2101      	movs	r1, #1
   11552:	9103      	str	r1, [sp, #12]
   11554:	a912      	add	r1, sp, #72	; 0x48
   11556:	9102      	str	r1, [sp, #8]
   11558:	eb09 010a 	add.w	r1, r9, sl
   1155c:	e9cd 3100 	strd	r3, r1, [sp]
   11560:	6eba      	ldr	r2, [r7, #104]	; 0x68
   11562:	2100      	movs	r1, #0
   11564:	69d3      	ldr	r3, [r2, #28]
   11566:	4658      	mov	r0, fp
   11568:	463a      	mov	r2, r7
   1156a:	f006 faa7 	bl	17abc <lfs_bd_read.isra.0>
                if (err) {
   1156e:	4605      	mov	r5, r0
   11570:	2800      	cmp	r0, #0
   11572:	d0df      	beq.n	11534 <lfs_dir_fetchmatch+0x240>
                    if (err == LFS_ERR_CORRUPT) {
   11574:	f110 0f54 	cmn.w	r0, #84	; 0x54
   11578:	d17c      	bne.n	11674 <lfs_dir_fetchmatch+0x380>
                        dir->erased = false;
   1157a:	9b08      	ldr	r3, [sp, #32]
   1157c:	75a3      	strb	r3, [r4, #22]
            if (lfs_tag_type1(tag) == LFS_TYPE_NAME) {
   1157e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    return (tag & 0x70000000) >> 20;
   11580:	0d1a      	lsrs	r2, r3, #20
            if (lfs_tag_type1(tag) == LFS_TYPE_NAME) {
   11582:	f412 61e0 	ands.w	r1, r2, #1792	; 0x700
   11586:	d122      	bne.n	115ce <lfs_dir_fetchmatch+0x2da>
                if (lfs_tag_id(tag) >= tempcount) {
   11588:	9a06      	ldr	r2, [sp, #24]
    return (tag & 0x000ffc00) >> 10;
   1158a:	f3c3 2389 	ubfx	r3, r3, #10, #10
                if (lfs_tag_id(tag) >= tempcount) {
   1158e:	429a      	cmp	r2, r3
   11590:	d801      	bhi.n	11596 <lfs_dir_fetchmatch+0x2a2>
                    tempcount = lfs_tag_id(tag) + 1;
   11592:	3301      	adds	r3, #1
   11594:	9306      	str	r3, [sp, #24]
            if ((fmask & tag) == (fmask & ftag)) {
   11596:	9b20      	ldr	r3, [sp, #128]	; 0x80
   11598:	990d      	ldr	r1, [sp, #52]	; 0x34
   1159a:	ea81 0903 	eor.w	r9, r1, r3
   1159e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   115a0:	ea19 0903 	ands.w	r9, r9, r3
   115a4:	d150      	bne.n	11648 <lfs_dir_fetchmatch+0x354>
                int res = cb(data, tag, &(struct lfs_diskoff){
   115a6:	6823      	ldr	r3, [r4, #0]
   115a8:	9312      	str	r3, [sp, #72]	; 0x48
                        dir->pair[0], off+sizeof(tag)});
   115aa:	f10a 0304 	add.w	r3, sl, #4
                int res = cb(data, tag, &(struct lfs_diskoff){
   115ae:	9313      	str	r3, [sp, #76]	; 0x4c
   115b0:	aa12      	add	r2, sp, #72	; 0x48
   115b2:	e9dd 3022 	ldrd	r3, r0, [sp, #136]	; 0x88
   115b6:	4798      	blx	r3
                if (res < 0) {
   115b8:	1e05      	subs	r5, r0, #0
   115ba:	da42      	bge.n	11642 <lfs_dir_fetchmatch+0x34e>
                    if (res == LFS_ERR_CORRUPT) {
   115bc:	f115 0f54 	cmn.w	r5, #84	; 0x54
   115c0:	d158      	bne.n	11674 <lfs_dir_fetchmatch+0x380>
                        dir->erased = false;
   115c2:	f884 9016 	strb.w	r9, [r4, #22]
                        break;
   115c6:	e746      	b.n	11456 <lfs_dir_fetchmatch+0x162>
            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
   115c8:	f04f 0904 	mov.w	r9, #4
   115cc:	e7ba      	b.n	11544 <lfs_dir_fetchmatch+0x250>
            } else if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE) {
   115ce:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
   115d2:	d11d      	bne.n	11610 <lfs_dir_fetchmatch+0x31c>
                tempcount += lfs_tag_splice(tag);
   115d4:	9806      	ldr	r0, [sp, #24]
    return (int8_t)lfs_tag_chunk(tag);
   115d6:	b251      	sxtb	r1, r2
                tempcount += lfs_tag_splice(tag);
   115d8:	fa40 f282 	sxtab	r2, r0, r2
   115dc:	b292      	uxth	r2, r2
   115de:	9206      	str	r2, [sp, #24]
                        (LFS_MKTAG(0, 0x3ff, 0) & tempbesttag))) {
   115e0:	4a3c      	ldr	r2, [pc, #240]	; (116d4 <lfs_dir_fetchmatch+0x3e0>)
   115e2:	ea08 0202 	and.w	r2, r8, r2
                if (tag == (LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
   115e6:	f042 429f 	orr.w	r2, r2, #1333788672	; 0x4f800000
   115ea:	f442 02e0 	orr.w	r2, r2, #7340032	; 0x700000
   115ee:	4293      	cmp	r3, r2
   115f0:	d102      	bne.n	115f8 <lfs_dir_fetchmatch+0x304>
                    tempbesttag |= 0x80000000;
   115f2:	f048 4800 	orr.w	r8, r8, #2147483648	; 0x80000000
   115f6:	e7ce      	b.n	11596 <lfs_dir_fetchmatch+0x2a2>
                } else if (tempbesttag != -1 &&
   115f8:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   115fc:	d0cb      	beq.n	11596 <lfs_dir_fetchmatch+0x2a2>
   115fe:	f3c3 2389 	ubfx	r3, r3, #10, #10
   11602:	f3c8 2289 	ubfx	r2, r8, #10, #10
   11606:	4293      	cmp	r3, r2
   11608:	d8c5      	bhi.n	11596 <lfs_dir_fetchmatch+0x2a2>
                    tempbesttag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
   1160a:	eb08 2881 	add.w	r8, r8, r1, lsl #10
   1160e:	e7c2      	b.n	11596 <lfs_dir_fetchmatch+0x2a2>
            } else if (lfs_tag_type1(tag) == LFS_TYPE_TAIL) {
   11610:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
   11614:	d1bf      	bne.n	11596 <lfs_dir_fetchmatch+0x2a2>
                tempsplit = (lfs_tag_chunk(tag) & 1);
   11616:	f002 0301 	and.w	r3, r2, #1
                err = lfs_bd_read(lfs,
   1161a:	2208      	movs	r2, #8
   1161c:	9203      	str	r2, [sp, #12]
   1161e:	aa10      	add	r2, sp, #64	; 0x40
   11620:	9202      	str	r2, [sp, #8]
   11622:	f10a 0204 	add.w	r2, sl, #4
   11626:	9201      	str	r2, [sp, #4]
                tempsplit = (lfs_tag_chunk(tag) & 1);
   11628:	9307      	str	r3, [sp, #28]
                err = lfs_bd_read(lfs,
   1162a:	6822      	ldr	r2, [r4, #0]
   1162c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1162e:	9200      	str	r2, [sp, #0]
   11630:	69db      	ldr	r3, [r3, #28]
   11632:	463a      	mov	r2, r7
   11634:	2100      	movs	r1, #0
   11636:	4658      	mov	r0, fp
   11638:	f006 fa40 	bl	17abc <lfs_bd_read.isra.0>
                    if (err == LFS_ERR_CORRUPT) {
   1163c:	3054      	adds	r0, #84	; 0x54
   1163e:	d1aa      	bne.n	11596 <lfs_dir_fetchmatch+0x2a2>
   11640:	e6df      	b.n	11402 <lfs_dir_fetchmatch+0x10e>
                if (res == LFS_CMP_EQ) {
   11642:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   11644:	d103      	bne.n	1164e <lfs_dir_fetchmatch+0x35a>
                    tempbesttag = tag;
   11646:	4698      	mov	r8, r3
   11648:	4643      	mov	r3, r8
   1164a:	46b0      	mov	r8, r6
   1164c:	e76d      	b.n	1152a <lfs_dir_fetchmatch+0x236>
                } else if ((LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) ==
   1164e:	4922      	ldr	r1, [pc, #136]	; (116d8 <lfs_dir_fetchmatch+0x3e4>)
   11650:	ea88 0203 	eor.w	r2, r8, r3
   11654:	420a      	tst	r2, r1
   11656:	d00a      	beq.n	1166e <lfs_dir_fetchmatch+0x37a>
                } else if (res == LFS_CMP_GT &&
   11658:	2d02      	cmp	r5, #2
   1165a:	d1f5      	bne.n	11648 <lfs_dir_fetchmatch+0x354>
   1165c:	f3c8 2289 	ubfx	r2, r8, #10, #10
   11660:	f3c3 2189 	ubfx	r1, r3, #10, #10
   11664:	428a      	cmp	r2, r1
   11666:	d3ef      	bcc.n	11648 <lfs_dir_fetchmatch+0x354>
                    tempbesttag = tag | 0x80000000;
   11668:	f043 4800 	orr.w	r8, r3, #2147483648	; 0x80000000
   1166c:	e7ec      	b.n	11648 <lfs_dir_fetchmatch+0x354>
                    tempbesttag = -1;
   1166e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   11672:	e7e9      	b.n	11648 <lfs_dir_fetchmatch+0x354>
                return err;
   11674:	462e      	mov	r6, r5
   11676:	e67a      	b.n	1136e <lfs_dir_fetchmatch+0x7a>
                } else if (besttag != -1 &&
   11678:	1c71      	adds	r1, r6, #1
   1167a:	f43f af00 	beq.w	1147e <lfs_dir_fetchmatch+0x18a>
   1167e:	429a      	cmp	r2, r3
                    besttag -= LFS_MKTAG(0, 1, 0);
   11680:	bf88      	it	hi
   11682:	f5a6 6680 	subhi.w	r6, r6, #1024	; 0x400
   11686:	e6fa      	b.n	1147e <lfs_dir_fetchmatch+0x18a>
        dir->rev = revs[(r+1)%2];
   11688:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1168a:	a816      	add	r0, sp, #88	; 0x58
   1168c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    pair[0] = pair[1];
   11690:	e9d4 2100 	ldrd	r2, r1, [r4]
        dir->rev = revs[(r+1)%2];
   11694:	f853 3c20 	ldr.w	r3, [r3, #-32]
   11698:	60a3      	str	r3, [r4, #8]
    for (int i = 0; i < 2; i++) {
   1169a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1169c:	2b01      	cmp	r3, #1
    pair[1] = t;
   1169e:	e9c4 1200 	strd	r1, r2, [r4]
    for (int i = 0; i < 2; i++) {
   116a2:	f47f aeb3 	bne.w	1140c <lfs_dir_fetchmatch+0x118>
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   116a6:	480d      	ldr	r0, [pc, #52]	; (116dc <lfs_dir_fetchmatch+0x3e8>)
   116a8:	4b0d      	ldr	r3, [pc, #52]	; (116e0 <lfs_dir_fetchmatch+0x3ec>)
    LFS_ERROR("Corrupted dir pair at {0x%"PRIx32", 0x%"PRIx32"}",
   116aa:	9215      	str	r2, [sp, #84]	; 0x54
   116ac:	1a1b      	subs	r3, r3, r0
   116ae:	08db      	lsrs	r3, r3, #3
   116b0:	480c      	ldr	r0, [pc, #48]	; (116e4 <lfs_dir_fetchmatch+0x3f0>)
   116b2:	9012      	str	r0, [sp, #72]	; 0x48
   116b4:	019b      	lsls	r3, r3, #6
   116b6:	f240 30e5 	movw	r0, #997	; 0x3e5
   116ba:	e9cd 0113 	strd	r0, r1, [sp, #76]	; 0x4c
   116be:	f043 0301 	orr.w	r3, r3, #1
   116c2:	4809      	ldr	r0, [pc, #36]	; (116e8 <lfs_dir_fetchmatch+0x3f4>)
   116c4:	2204      	movs	r2, #4
   116c6:	a912      	add	r1, sp, #72	; 0x48
   116c8:	f003 fe15 	bl	152f6 <log_n>
        return LFS_ERR_CORRUPT;
   116cc:	f06f 0653 	mvn.w	r6, #83	; 0x53
   116d0:	e64d      	b.n	1136e <lfs_dir_fetchmatch+0x7a>
   116d2:	bf00      	nop
   116d4:	000ffc00 	.word	0x000ffc00
   116d8:	7ffffc00 	.word	0x7ffffc00
   116dc:	0001956c 	.word	0x0001956c
   116e0:	0001960c 	.word	0x0001960c
   116e4:	0001c068 	.word	0x0001c068
   116e8:	0001c08e 	.word	0x0001c08e

000116ec <lfs_fs_parent>:
    lfs_pair_fromle32(child);
    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;
}

static lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],
        lfs_mdir_t *parent) {
   116ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // use fetchmatch with callback to find pairs
    parent->tail[0] = 0;
    parent->tail[1] = 1;
   116f0:	2301      	movs	r3, #1
   116f2:	2400      	movs	r4, #0
   116f4:	e9c2 4306 	strd	r4, r3, [r2, #24]
            // loop detected
            return LFS_ERR_CORRUPT;
        }
        cycle += 1;

        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,
   116f8:	4f18      	ldr	r7, [pc, #96]	; (1175c <lfs_fs_parent+0x70>)
   116fa:	f8df 8064 	ldr.w	r8, [pc, #100]	; 11760 <lfs_fs_parent+0x74>
   116fe:	f8df 9064 	ldr.w	r9, [pc, #100]	; 11764 <lfs_fs_parent+0x78>
        lfs_mdir_t *parent) {
   11702:	b088      	sub	sp, #32
   11704:	4605      	mov	r5, r0
   11706:	460e      	mov	r6, r1
   11708:	4692      	mov	sl, r2
    while (!lfs_pair_isnull(parent->tail)) {
   1170a:	f10a 0218 	add.w	r2, sl, #24
   1170e:	4610      	mov	r0, r2
   11710:	f006 f946 	bl	179a0 <lfs_pair_isnull>
   11714:	b110      	cbz	r0, 1171c <lfs_fs_parent+0x30>
        if (tag && tag != LFS_ERR_NOENT) {
            return tag;
        }
    }

    return LFS_ERR_NOENT;
   11716:	f06f 0001 	mvn.w	r0, #1
   1171a:	e018      	b.n	1174e <lfs_fs_parent+0x62>
        if (cycle >= lfs->cfg->block_count/2) {
   1171c:	6eab      	ldr	r3, [r5, #104]	; 0x68
   1171e:	6a1b      	ldr	r3, [r3, #32]
   11720:	ebb4 0f53 	cmp.w	r4, r3, lsr #1
   11724:	d216      	bcs.n	11754 <lfs_fs_parent+0x68>
                lfs_fs_parent_match, &(struct lfs_fs_parent_match){
   11726:	6833      	ldr	r3, [r6, #0]
   11728:	9306      	str	r3, [sp, #24]
   1172a:	6873      	ldr	r3, [r6, #4]
   1172c:	9307      	str	r3, [sp, #28]
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,
   1172e:	ab05      	add	r3, sp, #20
   11730:	e9cd 7302 	strd	r7, r3, [sp, #8]
   11734:	e9cd 8000 	strd	r8, r0, [sp]
   11738:	464b      	mov	r3, r9
   1173a:	4651      	mov	r1, sl
   1173c:	4628      	mov	r0, r5
        cycle += 1;
   1173e:	3401      	adds	r4, #1
                lfs_fs_parent_match, &(struct lfs_fs_parent_match){
   11740:	9505      	str	r5, [sp, #20]
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,
   11742:	f7ff fdd7 	bl	112f4 <lfs_dir_fetchmatch>
        if (tag && tag != LFS_ERR_NOENT) {
   11746:	2800      	cmp	r0, #0
   11748:	d0df      	beq.n	1170a <lfs_fs_parent+0x1e>
   1174a:	1c83      	adds	r3, r0, #2
   1174c:	d0dd      	beq.n	1170a <lfs_fs_parent+0x1e>
}
   1174e:	b008      	add	sp, #32
   11750:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            return LFS_ERR_CORRUPT;
   11754:	f06f 0053 	mvn.w	r0, #83	; 0x53
   11758:	e7f9      	b.n	1174e <lfs_fs_parent+0x62>
   1175a:	bf00      	nop
   1175c:	00017c0f 	.word	0x00017c0f
   11760:	20000008 	.word	0x20000008
   11764:	7ff003ff 	.word	0x7ff003ff

00011768 <lfs_dir_traverse>:
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
   11768:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1176c:	b093      	sub	sp, #76	; 0x4c
   1176e:	461e      	mov	r6, r3
   11770:	f8bd 3080 	ldrh.w	r3, [sp, #128]	; 0x80
   11774:	930c      	str	r3, [sp, #48]	; 0x30
   11776:	f8bd 3084 	ldrh.w	r3, [sp, #132]	; 0x84
   1177a:	930d      	str	r3, [sp, #52]	; 0x34
    return (tag & 0x000ffc00) >> 10;
   1177c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
   1177e:	f9bd b088 	ldrsh.w	fp, [sp, #136]	; 0x88
   11782:	f8dd a070 	ldr.w	sl, [sp, #112]	; 0x70
    return (tag & 0x000ffc00) >> 10;
   11786:	f3c3 238f 	ubfx	r3, r3, #10, #16
   1178a:	930b      	str	r3, [sp, #44]	; 0x2c
            int err = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
   1178c:	ea4f 238b 	mov.w	r3, fp, lsl #10
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
   11790:	4607      	mov	r7, r0
   11792:	4688      	mov	r8, r1
   11794:	4691      	mov	r9, r2
            int err = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
   11796:	930a      	str	r3, [sp, #40]	; 0x28
        if (off+lfs_tag_dsize(ptag) < dir->off) {
   11798:	4630      	mov	r0, r6
   1179a:	f006 f91c 	bl	179d6 <lfs_tag_dsize>
   1179e:	f8d8 300c 	ldr.w	r3, [r8, #12]
   117a2:	eb00 0409 	add.w	r4, r0, r9
   117a6:	429c      	cmp	r4, r3
   117a8:	d253      	bcs.n	11852 <lfs_dir_traverse+0xea>
            int err = lfs_bd_read(lfs,
   117aa:	aa0f      	add	r2, sp, #60	; 0x3c
   117ac:	e9cd 4201 	strd	r4, r2, [sp, #4]
   117b0:	2304      	movs	r3, #4
   117b2:	f8d8 2000 	ldr.w	r2, [r8]
   117b6:	9200      	str	r2, [sp, #0]
   117b8:	9303      	str	r3, [sp, #12]
   117ba:	463a      	mov	r2, r7
   117bc:	2100      	movs	r1, #0
   117be:	f107 0068 	add.w	r0, r7, #104	; 0x68
   117c2:	f006 f97b 	bl	17abc <lfs_bd_read.isra.0>
            if (err) {
   117c6:	2800      	cmp	r0, #0
   117c8:	d140      	bne.n	1184c <lfs_dir_traverse+0xe4>
    return __builtin_bswap32(a);
   117ca:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   117cc:	ba1b      	rev	r3, r3
            tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
   117ce:	405e      	eors	r6, r3
            disk.block = dir->pair[0];
   117d0:	f8d8 3000 	ldr.w	r3, [r8]
   117d4:	9310      	str	r3, [sp, #64]	; 0x40
            tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
   117d6:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
            disk.off = off+sizeof(lfs_tag_t);
   117da:	1d23      	adds	r3, r4, #4
            tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
   117dc:	960f      	str	r6, [sp, #60]	; 0x3c
            disk.off = off+sizeof(lfs_tag_t);
   117de:	9311      	str	r3, [sp, #68]	; 0x44
            ptag = tag;
   117e0:	46a1      	mov	r9, r4
            buffer = &disk;
   117e2:	ad10      	add	r5, sp, #64	; 0x40
        if ((mask & tmask & tag) != (mask & tmask & ttag)) {
   117e4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   117e6:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   117e8:	405c      	eors	r4, r3
   117ea:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   117ec:	401c      	ands	r4, r3
   117ee:	4b43      	ldr	r3, [pc, #268]	; (118fc <lfs_dir_traverse+0x194>)
   117f0:	401c      	ands	r4, r3
   117f2:	d1d1      	bne.n	11798 <lfs_dir_traverse+0x30>
        if (lfs_tag_id(tmask) != 0) {
   117f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   117f6:	2b00      	cmp	r3, #0
   117f8:	d139      	bne.n	1186e <lfs_dir_traverse+0x106>
        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {
   117fa:	990f      	ldr	r1, [sp, #60]	; 0x3c
    return (tag & 0x7ff00000) >> 20;
   117fc:	f3c1 530a 	ubfx	r3, r1, #20, #11
        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {
   11800:	2b00      	cmp	r3, #0
   11802:	d0c9      	beq.n	11798 <lfs_dir_traverse+0x30>
        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {
   11804:	f240 1201 	movw	r2, #257	; 0x101
   11808:	4293      	cmp	r3, r2
   1180a:	d151      	bne.n	118b0 <lfs_dir_traverse+0x148>
    return tag & 0x000003ff;
   1180c:	f3c1 0309 	ubfx	r3, r1, #0, #10
    return (tag & 0x000ffc00) >> 10;
   11810:	f3c1 2189 	ubfx	r1, r1, #10, #10
            uint16_t fromid = lfs_tag_size(tag);
   11814:	461a      	mov	r2, r3
                    fromid, fromid+1, toid-fromid+diff,
   11816:	1ac9      	subs	r1, r1, r3
            int err = lfs_dir_traverse(lfs,
   11818:	3301      	adds	r3, #1
   1181a:	e9cd 2304 	strd	r2, r3, [sp, #16]
   1181e:	4b38      	ldr	r3, [pc, #224]	; (11900 <lfs_dir_traverse+0x198>)
   11820:	9824      	ldr	r0, [sp, #144]	; 0x90
   11822:	9008      	str	r0, [sp, #32]
   11824:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   11828:	4459      	add	r1, fp
   1182a:	e9cd 3202 	strd	r3, r2, [sp, #8]
   1182e:	9823      	ldr	r0, [sp, #140]	; 0x8c
   11830:	9007      	str	r0, [sp, #28]
   11832:	b209      	sxth	r1, r1
   11834:	2200      	movs	r2, #0
   11836:	9106      	str	r1, [sp, #24]
   11838:	e9cd 2200 	strd	r2, r2, [sp]
   1183c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11840:	4629      	mov	r1, r5
   11842:	4638      	mov	r0, r7
   11844:	f7ff ff90 	bl	11768 <lfs_dir_traverse>
            if (err) {
   11848:	2800      	cmp	r0, #0
   1184a:	d0a5      	beq.n	11798 <lfs_dir_traverse+0x30>
}
   1184c:	b013      	add	sp, #76	; 0x4c
   1184e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } else if (attrcount > 0) {
   11852:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   11854:	2b00      	cmp	r3, #0
   11856:	dd4f      	ble.n	118f8 <lfs_dir_traverse+0x190>
            tag = attrs[0].tag;
   11858:	f8da 3000 	ldr.w	r3, [sl]
   1185c:	930f      	str	r3, [sp, #60]	; 0x3c
            attrcount -= 1;
   1185e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
            buffer = attrs[0].buffer;
   11860:	f8da 5004 	ldr.w	r5, [sl, #4]
            attrcount -= 1;
   11864:	3b01      	subs	r3, #1
            attrs += 1;
   11866:	f10a 0a08 	add.w	sl, sl, #8
            attrcount -= 1;
   1186a:	931d      	str	r3, [sp, #116]	; 0x74
   1186c:	e7ba      	b.n	117e4 <lfs_dir_traverse+0x7c>
            int filter = lfs_dir_traverse(lfs,
   1186e:	ab0f      	add	r3, sp, #60	; 0x3c
   11870:	9308      	str	r3, [sp, #32]
   11872:	4b24      	ldr	r3, [pc, #144]	; (11904 <lfs_dir_traverse+0x19c>)
   11874:	e9cd 4306 	strd	r4, r3, [sp, #24]
   11878:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   1187a:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1187e:	e9cd a300 	strd	sl, r3, [sp]
   11882:	e9cd 4402 	strd	r4, r4, [sp, #8]
   11886:	4633      	mov	r3, r6
   11888:	464a      	mov	r2, r9
   1188a:	4641      	mov	r1, r8
   1188c:	4638      	mov	r0, r7
   1188e:	f7ff ff6b 	bl	11768 <lfs_dir_traverse>
            if (filter < 0) {
   11892:	2800      	cmp	r0, #0
   11894:	dbda      	blt.n	1184c <lfs_dir_traverse+0xe4>
            if (filter) {
   11896:	f47f af7f 	bne.w	11798 <lfs_dir_traverse+0x30>
    return (tag & 0x000ffc00) >> 10;
   1189a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
            if (!(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
   1189c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    return (tag & 0x000ffc00) >> 10;
   1189e:	f3c3 2389 	ubfx	r3, r3, #10, #10
            if (!(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
   118a2:	429a      	cmp	r2, r3
   118a4:	f63f af78 	bhi.w	11798 <lfs_dir_traverse+0x30>
   118a8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   118aa:	429a      	cmp	r2, r3
   118ac:	d8a5      	bhi.n	117fa <lfs_dir_traverse+0x92>
   118ae:	e773      	b.n	11798 <lfs_dir_traverse+0x30>
        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {
   118b0:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
   118b4:	d119      	bne.n	118ea <lfs_dir_traverse+0x182>
            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
   118b6:	990f      	ldr	r1, [sp, #60]	; 0x3c
    return tag & 0x000003ff;
   118b8:	f3c1 0309 	ubfx	r3, r1, #0, #10
            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
   118bc:	429c      	cmp	r4, r3
   118be:	f4bf af6b 	bcs.w	11798 <lfs_dir_traverse+0x30>
                int err = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
   118c2:	68ab      	ldr	r3, [r5, #8]
   118c4:	686a      	ldr	r2, [r5, #4]
   118c6:	f3c1 2189 	ubfx	r1, r1, #10, #10
   118ca:	4459      	add	r1, fp
   118cc:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
   118d0:	782b      	ldrb	r3, [r5, #0]
   118d2:	f503 7340 	add.w	r3, r3, #768	; 0x300
   118d6:	ea41 5103 	orr.w	r1, r1, r3, lsl #20
   118da:	e9dd 3023 	ldrd	r3, r0, [sp, #140]	; 0x8c
   118de:	4798      	blx	r3
                if (err) {
   118e0:	350c      	adds	r5, #12
   118e2:	2800      	cmp	r0, #0
   118e4:	d1b2      	bne.n	1184c <lfs_dir_traverse+0xe4>
            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
   118e6:	3401      	adds	r4, #1
   118e8:	e7e5      	b.n	118b6 <lfs_dir_traverse+0x14e>
            int err = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
   118ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   118ec:	462a      	mov	r2, r5
   118ee:	4419      	add	r1, r3
   118f0:	e9dd 3023 	ldrd	r3, r0, [sp, #140]	; 0x8c
   118f4:	4798      	blx	r3
   118f6:	e7a7      	b.n	11848 <lfs_dir_traverse+0xe0>
            return 0;
   118f8:	2000      	movs	r0, #0
   118fa:	e7a7      	b.n	1184c <lfs_dir_traverse+0xe4>
   118fc:	7ff00000 	.word	0x7ff00000
   11900:	600ffc00 	.word	0x600ffc00
   11904:	0001128d 	.word	0x0001128d

00011908 <lfs_dir_getslice>:
        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {
   11908:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1190c:	4699      	mov	r9, r3
    lfs_tag_t ntag = dir->etag;
   1190e:	e9d1 8303 	ldrd	r8, r3, [r1, #12]
        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {
   11912:	b089      	sub	sp, #36	; 0x24
   11914:	4606      	mov	r6, r0
    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&
   11916:	303c      	adds	r0, #60	; 0x3c
    lfs_tag_t ntag = dir->etag;
   11918:	9307      	str	r3, [sp, #28]
        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {
   1191a:	460f      	mov	r7, r1
   1191c:	9205      	str	r2, [sp, #20]
    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&
   1191e:	f006 f872 	bl	17a06 <lfs_gstate_hasmovehere>
   11922:	9b05      	ldr	r3, [sp, #20]
   11924:	4604      	mov	r4, r0
   11926:	f3c3 2a89 	ubfx	sl, r3, #10, #10
   1192a:	b160      	cbz	r0, 11946 <lfs_dir_getslice+0x3e>
   1192c:	f1ba 0f00 	cmp.w	sl, #0
   11930:	d07a      	beq.n	11a28 <lfs_dir_getslice+0x120>
    return (tag & 0x000ffc00) >> 10;
   11932:	6bf4      	ldr	r4, [r6, #60]	; 0x3c
        gdiff -= LFS_MKTAG(0, 1, 0);
   11934:	4a3d      	ldr	r2, [pc, #244]	; (11a2c <lfs_dir_getslice+0x124>)
            lfs_tag_id(gmask) != 0 &&
   11936:	f3c4 2389 	ubfx	r3, r4, #10, #10
   1193a:	f3c9 2489 	ubfx	r4, r9, #10, #10
        gdiff -= LFS_MKTAG(0, 1, 0);
   1193e:	42a3      	cmp	r3, r4
   11940:	bf94      	ite	ls
   11942:	4614      	movls	r4, r2
   11944:	2400      	movhi	r4, #0
   11946:	f106 0b68 	add.w	fp, r6, #104	; 0x68
    while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {
   1194a:	9d07      	ldr	r5, [sp, #28]
   1194c:	4628      	mov	r0, r5
   1194e:	f006 f842 	bl	179d6 <lfs_tag_dsize>
   11952:	1d03      	adds	r3, r0, #4
   11954:	4543      	cmp	r3, r8
   11956:	d833      	bhi.n	119c0 <lfs_dir_getslice+0xb8>
        off -= lfs_tag_dsize(ntag);
   11958:	eba8 0800 	sub.w	r8, r8, r0
        int err = lfs_bd_read(lfs,
   1195c:	aa07      	add	r2, sp, #28
   1195e:	e9cd 8201 	strd	r8, r2, [sp, #4]
   11962:	2304      	movs	r3, #4
   11964:	683a      	ldr	r2, [r7, #0]
   11966:	9200      	str	r2, [sp, #0]
   11968:	9303      	str	r3, [sp, #12]
   1196a:	4632      	mov	r2, r6
   1196c:	2100      	movs	r1, #0
   1196e:	4658      	mov	r0, fp
   11970:	f006 f8a4 	bl	17abc <lfs_bd_read.isra.0>
        if (err) {
   11974:	bb30      	cbnz	r0, 119c4 <lfs_dir_getslice+0xbc>
   11976:	9b07      	ldr	r3, [sp, #28]
   11978:	ba1b      	rev	r3, r3
        ntag = (lfs_frombe32(ntag) ^ tag) & 0x7fffffff;
   1197a:	406b      	eors	r3, r5
   1197c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   11980:	9307      	str	r3, [sp, #28]
        if (lfs_tag_id(gmask) != 0 &&
   11982:	f1ba 0f00 	cmp.w	sl, #0
   11986:	d023      	beq.n	119d0 <lfs_dir_getslice+0xc8>
    return (tag & 0x70000000) >> 20;
   11988:	0d2a      	lsrs	r2, r5, #20
        if (lfs_tag_id(gmask) != 0 &&
   1198a:	f402 63e0 	and.w	r3, r2, #1792	; 0x700
   1198e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   11992:	d11d      	bne.n	119d0 <lfs_dir_getslice+0xc8>
   11994:	eba9 0304 	sub.w	r3, r9, r4
                lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&
   11998:	f3c3 2089 	ubfx	r0, r3, #10, #10
   1199c:	f3c5 2189 	ubfx	r1, r5, #10, #10
   119a0:	4288      	cmp	r0, r1
   119a2:	d315      	bcc.n	119d0 <lfs_dir_getslice+0xc8>
                    (LFS_MKTAG(0, 0x3ff, 0) & (gtag - gdiff)))) {
   119a4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   119a8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
   119ac:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
   119b0:	f023 0303 	bic.w	r3, r3, #3
            if (tag == (LFS_MKTAG(LFS_TYPE_CREATE, 0, 0) |
   119b4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   119b8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   119bc:	42ab      	cmp	r3, r5
   119be:	d104      	bne.n	119ca <lfs_dir_getslice+0xc2>
                return LFS_ERR_NOENT;
   119c0:	f06f 0001 	mvn.w	r0, #1
}
   119c4:	b009      	add	sp, #36	; 0x24
   119c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            gdiff += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
   119ca:	b252      	sxtb	r2, r2
   119cc:	eb04 2482 	add.w	r4, r4, r2, lsl #10
        if ((gmask & tag) == (gmask & (gtag - gdiff))) {
   119d0:	9b05      	ldr	r3, [sp, #20]
   119d2:	eba9 0104 	sub.w	r1, r9, r4
   119d6:	4069      	eors	r1, r5
   119d8:	4019      	ands	r1, r3
   119da:	d1b6      	bne.n	1194a <lfs_dir_getslice+0x42>
    return ((int32_t)(tag << 22) >> 22) == -1;
   119dc:	f345 0309 	sbfx	r3, r5, #0, #10
            if (lfs_tag_isdelete(tag)) {
   119e0:	3301      	adds	r3, #1
   119e2:	d0ed      	beq.n	119c0 <lfs_dir_getslice+0xb8>
    return (a < b) ? a : b;
   119e4:	9b14      	ldr	r3, [sp, #80]	; 0x50
    return tag & 0x000003ff;
   119e6:	f3c5 0909 	ubfx	r9, r5, #0, #10
   119ea:	4599      	cmp	r9, r3
   119ec:	bf28      	it	cs
   119ee:	4699      	movcs	r9, r3
            err = lfs_bd_read(lfs,
   119f0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   119f2:	9302      	str	r3, [sp, #8]
   119f4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   119f6:	f8cd 900c 	str.w	r9, [sp, #12]
   119fa:	3304      	adds	r3, #4
   119fc:	4443      	add	r3, r8
   119fe:	9301      	str	r3, [sp, #4]
   11a00:	683b      	ldr	r3, [r7, #0]
   11a02:	9300      	str	r3, [sp, #0]
   11a04:	4632      	mov	r2, r6
   11a06:	464b      	mov	r3, r9
   11a08:	4658      	mov	r0, fp
   11a0a:	f006 f857 	bl	17abc <lfs_bd_read.isra.0>
            if (err) {
   11a0e:	2800      	cmp	r0, #0
   11a10:	d1d8      	bne.n	119c4 <lfs_dir_getslice+0xbc>
            memset((uint8_t*)gbuffer + diff, 0, gsize - diff);
   11a12:	9b14      	ldr	r3, [sp, #80]	; 0x50
   11a14:	eba3 0209 	sub.w	r2, r3, r9
   11a18:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   11a1a:	4601      	mov	r1, r0
   11a1c:	eb03 0009 	add.w	r0, r3, r9
   11a20:	f004 fb36 	bl	16090 <memset>
            return tag + gdiff;
   11a24:	1960      	adds	r0, r4, r5
   11a26:	e7cd      	b.n	119c4 <lfs_dir_getslice+0xbc>
    lfs_stag_t gdiff = 0;
   11a28:	4654      	mov	r4, sl
   11a2a:	e78c      	b.n	11946 <lfs_dir_getslice+0x3e>
   11a2c:	fffffc00 	.word	0xfffffc00

00011a30 <lfs_dir_getgstate>:
        lfs_gstate_t *gstate) {
   11a30:	b530      	push	{r4, r5, lr}
   11a32:	b087      	sub	sp, #28
    lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x7ff, 0, 0),
   11a34:	ad03      	add	r5, sp, #12
   11a36:	4b09      	ldr	r3, [pc, #36]	; (11a5c <lfs_dir_getgstate+0x2c>)
   11a38:	9500      	str	r5, [sp, #0]
        lfs_gstate_t *gstate) {
   11a3a:	4614      	mov	r4, r2
    lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x7ff, 0, 0),
   11a3c:	4a08      	ldr	r2, [pc, #32]	; (11a60 <lfs_dir_getgstate+0x30>)
   11a3e:	f006 f93b 	bl	17cb8 <lfs_dir_get>
    if (res < 0 && res != LFS_ERR_NOENT) {
   11a42:	2800      	cmp	r0, #0
   11a44:	da04      	bge.n	11a50 <lfs_dir_getgstate+0x20>
   11a46:	1c83      	adds	r3, r0, #2
    return 0;
   11a48:	bf08      	it	eq
   11a4a:	2000      	moveq	r0, #0
}
   11a4c:	b007      	add	sp, #28
   11a4e:	bd30      	pop	{r4, r5, pc}
        lfs_gstate_xor(gstate, &temp);
   11a50:	4620      	mov	r0, r4
   11a52:	4629      	mov	r1, r5
   11a54:	f005 ffc9 	bl	179ea <lfs_gstate_xor>
    return 0;
   11a58:	2000      	movs	r0, #0
   11a5a:	e7f7      	b.n	11a4c <lfs_dir_getgstate+0x1c>
   11a5c:	7ff0000c 	.word	0x7ff0000c
   11a60:	7ff00000 	.word	0x7ff00000

00011a64 <lfs_dir_find>:
        const char **path, uint16_t *id) {
   11a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11a68:	b08d      	sub	sp, #52	; 0x34
    const char *name = *path;
   11a6a:	6816      	ldr	r6, [r2, #0]
        const char **path, uint16_t *id) {
   11a6c:	9205      	str	r2, [sp, #20]
   11a6e:	4681      	mov	r9, r0
   11a70:	4688      	mov	r8, r1
    if (id) {
   11a72:	9304      	str	r3, [sp, #16]
   11a74:	b11b      	cbz	r3, 11a7e <lfs_dir_find+0x1a>
        *id = 0x3ff;
   11a76:	9a04      	ldr	r2, [sp, #16]
   11a78:	f240 33ff 	movw	r3, #1023	; 0x3ff
   11a7c:	8013      	strh	r3, [r2, #0]
    dir->tail[0] = lfs->root[0];
   11a7e:	f8d9 3020 	ldr.w	r3, [r9, #32]
   11a82:	f8c8 3018 	str.w	r3, [r8, #24]
    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);
   11a86:	4c43      	ldr	r4, [pc, #268]	; (11b94 <lfs_dir_find+0x130>)
    dir->tail[1] = lfs->root[1];
   11a88:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
        name += strspn(name, "/");
   11a8c:	f8df a11c 	ldr.w	sl, [pc, #284]	; 11bac <lfs_dir_find+0x148>
    dir->tail[1] = lfs->root[1];
   11a90:	f8c8 301c 	str.w	r3, [r8, #28]
        name += strspn(name, "/");
   11a94:	4651      	mov	r1, sl
   11a96:	4630      	mov	r0, r6
   11a98:	f004 fb1d 	bl	160d6 <strspn>
   11a9c:	1835      	adds	r5, r6, r0
        lfs_size_t namelen = strcspn(name, "/");
   11a9e:	4651      	mov	r1, sl
   11aa0:	4628      	mov	r0, r5
   11aa2:	f004 fb28 	bl	160f6 <strcspn>
        if ((namelen == 1 && memcmp(name, ".", 1) == 0) ||
   11aa6:	2801      	cmp	r0, #1
        lfs_size_t namelen = strcspn(name, "/");
   11aa8:	4607      	mov	r7, r0
        if ((namelen == 1 && memcmp(name, ".", 1) == 0) ||
   11aaa:	eb05 0600 	add.w	r6, r5, r0
   11aae:	d125      	bne.n	11afc <lfs_dir_find+0x98>
   11ab0:	4939      	ldr	r1, [pc, #228]	; (11b98 <lfs_dir_find+0x134>)
   11ab2:	4602      	mov	r2, r0
            (namelen == 2 && memcmp(name, "..", 2) == 0)) {
   11ab4:	4628      	mov	r0, r5
   11ab6:	f004 fab0 	bl	1601a <memcmp>
   11aba:	2800      	cmp	r0, #0
   11abc:	d0ea      	beq.n	11a94 <lfs_dir_find+0x30>
        const char *suffix = name + namelen;
   11abe:	46b3      	mov	fp, r6
        int depth = 1;
   11ac0:	2301      	movs	r3, #1
            suffix += strspn(suffix, "/");
   11ac2:	4651      	mov	r1, sl
   11ac4:	4658      	mov	r0, fp
   11ac6:	9306      	str	r3, [sp, #24]
   11ac8:	f004 fb05 	bl	160d6 <strspn>
   11acc:	4483      	add	fp, r0
            sufflen = strcspn(suffix, "/");
   11ace:	4651      	mov	r1, sl
   11ad0:	4658      	mov	r0, fp
   11ad2:	f004 fb10 	bl	160f6 <strcspn>
            if (sufflen == 0) {
   11ad6:	4602      	mov	r2, r0
   11ad8:	b1c0      	cbz	r0, 11b0c <lfs_dir_find+0xa8>
            if (sufflen == 2 && memcmp(suffix, "..", 2) == 0) {
   11ada:	2802      	cmp	r0, #2
   11adc:	9b06      	ldr	r3, [sp, #24]
   11ade:	d112      	bne.n	11b06 <lfs_dir_find+0xa2>
   11ae0:	e9cd 0306 	strd	r0, r3, [sp, #24]
   11ae4:	492d      	ldr	r1, [pc, #180]	; (11b9c <lfs_dir_find+0x138>)
   11ae6:	4658      	mov	r0, fp
   11ae8:	f004 fa97 	bl	1601a <memcmp>
   11aec:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   11af0:	b948      	cbnz	r0, 11b06 <lfs_dir_find+0xa2>
                if (depth == 0) {
   11af2:	3b01      	subs	r3, #1
   11af4:	d108      	bne.n	11b08 <lfs_dir_find+0xa4>
                    name = suffix + sufflen;
   11af6:	f10b 0602 	add.w	r6, fp, #2
                    goto nextname;
   11afa:	e7cb      	b.n	11a94 <lfs_dir_find+0x30>
        if ((namelen == 1 && memcmp(name, ".", 1) == 0) ||
   11afc:	2802      	cmp	r0, #2
   11afe:	d1de      	bne.n	11abe <lfs_dir_find+0x5a>
            (namelen == 2 && memcmp(name, "..", 2) == 0)) {
   11b00:	4926      	ldr	r1, [pc, #152]	; (11b9c <lfs_dir_find+0x138>)
   11b02:	4602      	mov	r2, r0
   11b04:	e7d6      	b.n	11ab4 <lfs_dir_find+0x50>
                depth += 1;
   11b06:	3301      	adds	r3, #1
            suffix += sufflen;
   11b08:	4493      	add	fp, r2
            suffix += strspn(suffix, "/");
   11b0a:	e7da      	b.n	11ac2 <lfs_dir_find+0x5e>
        if (name[0] == '\0') {
   11b0c:	782b      	ldrb	r3, [r5, #0]
   11b0e:	2b00      	cmp	r3, #0
   11b10:	d039      	beq.n	11b86 <lfs_dir_find+0x122>
        *path = name;
   11b12:	9b05      	ldr	r3, [sp, #20]
   11b14:	601d      	str	r5, [r3, #0]
    return (tag & 0x7ff00000) >> 20;
   11b16:	0d23      	lsrs	r3, r4, #20
        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {
   11b18:	2b02      	cmp	r3, #2
   11b1a:	d138      	bne.n	11b8e <lfs_dir_find+0x12a>
    return (tag & 0x000ffc00) >> 10;
   11b1c:	f3c4 2489 	ubfx	r4, r4, #10, #10
        if (lfs_tag_id(tag) != 0x3ff) {
   11b20:	f240 33ff 	movw	r3, #1023	; 0x3ff
   11b24:	429c      	cmp	r4, r3
   11b26:	f108 0b18 	add.w	fp, r8, #24
   11b2a:	d00b      	beq.n	11b44 <lfs_dir_find+0xe0>
            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
   11b2c:	4b1c      	ldr	r3, [pc, #112]	; (11ba0 <lfs_dir_find+0x13c>)
   11b2e:	4a1d      	ldr	r2, [pc, #116]	; (11ba4 <lfs_dir_find+0x140>)
   11b30:	f8cd b000 	str.w	fp, [sp]
   11b34:	ea43 2384 	orr.w	r3, r3, r4, lsl #10
   11b38:	4641      	mov	r1, r8
   11b3a:	4648      	mov	r0, r9
   11b3c:	f006 f8bc 	bl	17cb8 <lfs_dir_get>
            if (res < 0) {
   11b40:	1e04      	subs	r4, r0, #0
   11b42:	db20      	blt.n	11b86 <lfs_dir_find+0x122>
                    (strchr(name, '/') == NULL) ? id : NULL,
   11b44:	212f      	movs	r1, #47	; 0x2f
   11b46:	4628      	mov	r0, r5
   11b48:	f004 fa37 	bl	15fba <strchr>
            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
   11b4c:	aa09      	add	r2, sp, #36	; 0x24
   11b4e:	9b04      	ldr	r3, [sp, #16]
   11b50:	9203      	str	r2, [sp, #12]
   11b52:	2800      	cmp	r0, #0
   11b54:	4a14      	ldr	r2, [pc, #80]	; (11ba8 <lfs_dir_find+0x144>)
   11b56:	9700      	str	r7, [sp, #0]
   11b58:	bf18      	it	ne
   11b5a:	2300      	movne	r3, #0
   11b5c:	e9cd 3201 	strd	r3, r2, [sp, #4]
   11b60:	4641      	mov	r1, r8
   11b62:	f04f 43f0 	mov.w	r3, #2013265920	; 0x78000000
   11b66:	465a      	mov	r2, fp
   11b68:	4648      	mov	r0, r9
                    lfs_dir_find_match, &(struct lfs_dir_find_match){
   11b6a:	e9cd 9509 	strd	r9, r5, [sp, #36]	; 0x24
   11b6e:	970b      	str	r7, [sp, #44]	; 0x2c
            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
   11b70:	f7ff fbc0 	bl	112f4 <lfs_dir_fetchmatch>
            if (tag < 0) {
   11b74:	1e04      	subs	r4, r0, #0
   11b76:	db06      	blt.n	11b86 <lfs_dir_find+0x122>
            if (tag) {
   11b78:	d18c      	bne.n	11a94 <lfs_dir_find+0x30>
            if (!dir->split) {
   11b7a:	f898 3017 	ldrb.w	r3, [r8, #23]
   11b7e:	2b00      	cmp	r3, #0
   11b80:	d1e0      	bne.n	11b44 <lfs_dir_find+0xe0>
                return LFS_ERR_NOENT;
   11b82:	f06f 0401 	mvn.w	r4, #1
}
   11b86:	4620      	mov	r0, r4
   11b88:	b00d      	add	sp, #52	; 0x34
   11b8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return LFS_ERR_NOTDIR;
   11b8e:	f06f 0413 	mvn.w	r4, #19
   11b92:	e7f8      	b.n	11b86 <lfs_dir_find+0x122>
   11b94:	002ffc00 	.word	0x002ffc00
   11b98:	0001a247 	.word	0x0001a247
   11b9c:	0001ba63 	.word	0x0001ba63
   11ba0:	20000008 	.word	0x20000008
   11ba4:	700ffc00 	.word	0x700ffc00
   11ba8:	00018329 	.word	0x00018329
   11bac:	0001ba47 	.word	0x0001ba47

00011bb0 <lfs_dir_getinfo>:
        uint16_t id, struct lfs_info *info) {
   11bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   11bb2:	f103 0c08 	add.w	ip, r3, #8
   11bb6:	461c      	mov	r4, r3
    if (id == 0x3ff) {
   11bb8:	f240 33ff 	movw	r3, #1023	; 0x3ff
   11bbc:	429a      	cmp	r2, r3
        uint16_t id, struct lfs_info *info) {
   11bbe:	b085      	sub	sp, #20
   11bc0:	4605      	mov	r5, r0
   11bc2:	460e      	mov	r6, r1
    if (id == 0x3ff) {
   11bc4:	d108      	bne.n	11bd8 <lfs_dir_getinfo+0x28>
        strcpy(info->name, "/");
   11bc6:	491b      	ldr	r1, [pc, #108]	; (11c34 <lfs_dir_getinfo+0x84>)
   11bc8:	4660      	mov	r0, ip
   11bca:	f004 f9d9 	bl	15f80 <strcpy>
        info->type = LFS_TYPE_DIR;
   11bce:	2302      	movs	r3, #2
   11bd0:	7023      	strb	r3, [r4, #0]
    return 0;
   11bd2:	2000      	movs	r0, #0
}
   11bd4:	b005      	add	sp, #20
   11bd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);
   11bd8:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),
   11bda:	f8cd c000 	str.w	ip, [sp]
            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);
   11bde:	3301      	adds	r3, #1
    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),
   11be0:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);
   11be4:	0297      	lsls	r7, r2, #10
    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),
   11be6:	4a14      	ldr	r2, [pc, #80]	; (11c38 <lfs_dir_getinfo+0x88>)
   11be8:	f006 f866 	bl	17cb8 <lfs_dir_get>
    if (tag < 0) {
   11bec:	2800      	cmp	r0, #0
   11bee:	dbf1      	blt.n	11bd4 <lfs_dir_getinfo+0x24>
    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
   11bf0:	ab02      	add	r3, sp, #8
    return (tag & 0x7ff00000) >> 20;
   11bf2:	0d00      	lsrs	r0, r0, #20
    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
   11bf4:	9300      	str	r3, [sp, #0]
   11bf6:	f047 5300 	orr.w	r3, r7, #536870912	; 0x20000000
    info->type = lfs_tag_type3(tag);
   11bfa:	7020      	strb	r0, [r4, #0]
    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
   11bfc:	4a0f      	ldr	r2, [pc, #60]	; (11c3c <lfs_dir_getinfo+0x8c>)
   11bfe:	f043 0308 	orr.w	r3, r3, #8
   11c02:	4631      	mov	r1, r6
   11c04:	4628      	mov	r0, r5
   11c06:	f006 f857 	bl	17cb8 <lfs_dir_get>
    if (tag < 0) {
   11c0a:	2800      	cmp	r0, #0
   11c0c:	dbe2      	blt.n	11bd4 <lfs_dir_getinfo+0x24>
    if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
   11c0e:	f240 2302 	movw	r3, #514	; 0x202
   11c12:	ebb3 5f10 	cmp.w	r3, r0, lsr #20
    return (tag & 0x7ff00000) >> 20;
   11c16:	ea4f 5210 	mov.w	r2, r0, lsr #20
    if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
   11c1a:	d102      	bne.n	11c22 <lfs_dir_getinfo+0x72>
        info->size = ctz.size;
   11c1c:	9b03      	ldr	r3, [sp, #12]
   11c1e:	6063      	str	r3, [r4, #4]
   11c20:	e7d7      	b.n	11bd2 <lfs_dir_getinfo+0x22>
    } else if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {
   11c22:	f240 2301 	movw	r3, #513	; 0x201
   11c26:	429a      	cmp	r2, r3
    return tag & 0x000003ff;
   11c28:	bf04      	itt	eq
   11c2a:	f3c0 0009 	ubfxeq	r0, r0, #0, #10
        info->size = lfs_tag_size(tag);
   11c2e:	6060      	streq	r0, [r4, #4]
   11c30:	e7cf      	b.n	11bd2 <lfs_dir_getinfo+0x22>
   11c32:	bf00      	nop
   11c34:	0001ba47 	.word	0x0001ba47
   11c38:	780ffc00 	.word	0x780ffc00
   11c3c:	700ffc00 	.word	0x700ffc00

00011c40 <lfs_dir_getread.part.0.constprop.0>:
static int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,
   11c40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11c44:	b087      	sub	sp, #28
   11c46:	e9dd 4911 	ldrd	r4, r9, [sp, #68]	; 0x44
   11c4a:	9e13      	ldr	r6, [sp, #76]	; 0x4c
        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,
   11c4c:	f8df b098 	ldr.w	fp, [pc, #152]	; 11ce8 <lfs_dir_getread.part.0.constprop.0+0xa8>
static int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,
   11c50:	4607      	mov	r7, r0
   11c52:	4688      	mov	r8, r1
   11c54:	4615      	mov	r5, r2
    return lfs_aligndown(a + alignment-1, alignment);
   11c56:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
    while (size > 0) {
   11c5a:	b90e      	cbnz	r6, 11c60 <lfs_dir_getread.part.0.constprop.0+0x20>
    return 0;
   11c5c:	4630      	mov	r0, r6
   11c5e:	e040      	b.n	11ce2 <lfs_dir_getread.part.0.constprop.0+0xa2>
        if (rcache->block == LFS_BLOCK_INLINE &&
   11c60:	682b      	ldr	r3, [r5, #0]
   11c62:	68e8      	ldr	r0, [r5, #12]
   11c64:	3302      	adds	r3, #2
   11c66:	d116      	bne.n	11c96 <lfs_dir_getread.part.0.constprop.0+0x56>
                off < rcache->off + rcache->size) {
   11c68:	e9d5 1201 	ldrd	r1, r2, [r5, #4]
   11c6c:	440a      	add	r2, r1
        if (rcache->block == LFS_BLOCK_INLINE &&
   11c6e:	4294      	cmp	r4, r2
   11c70:	d211      	bcs.n	11c96 <lfs_dir_getread.part.0.constprop.0+0x56>
            if (off >= rcache->off) {
   11c72:	428c      	cmp	r4, r1
   11c74:	d30f      	bcc.n	11c96 <lfs_dir_getread.part.0.constprop.0+0x56>
                diff = lfs_min(diff, rcache->size - (off-rcache->off));
   11c76:	1b12      	subs	r2, r2, r4
    return (a < b) ? a : b;
   11c78:	42b2      	cmp	r2, r6
                memcpy(data, &rcache->buffer[off-rcache->off], diff);
   11c7a:	eba4 0101 	sub.w	r1, r4, r1
   11c7e:	bf28      	it	cs
   11c80:	4632      	movcs	r2, r6
   11c82:	4401      	add	r1, r0
   11c84:	4648      	mov	r0, r9
   11c86:	9205      	str	r2, [sp, #20]
   11c88:	f004 f9d7 	bl	1603a <memcpy>
                data += diff;
   11c8c:	9a05      	ldr	r2, [sp, #20]
   11c8e:	4491      	add	r9, r2
                off += diff;
   11c90:	4414      	add	r4, r2
                size -= diff;
   11c92:	1ab6      	subs	r6, r6, r2
                continue;
   11c94:	e7e1      	b.n	11c5a <lfs_dir_getread.part.0.constprop.0+0x1a>
        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
   11c96:	f8d7 c068 	ldr.w	ip, [r7, #104]	; 0x68
   11c9a:	f8dc 1014 	ldr.w	r1, [ip, #20]
    return a - (a % alignment);
   11c9e:	fbb4 f2f1 	udiv	r2, r4, r1
        rcache->block = LFS_BLOCK_INLINE;
   11ca2:	f06f 0301 	mvn.w	r3, #1
   11ca6:	602b      	str	r3, [r5, #0]
    return lfs_aligndown(a + alignment-1, alignment);
   11ca8:	eb0a 0301 	add.w	r3, sl, r1
   11cac:	4423      	add	r3, r4
    return a - (a % alignment);
   11cae:	fb01 4212 	mls	r2, r1, r2, r4
   11cb2:	fbb3 fef1 	udiv	lr, r3, r1
   11cb6:	fb01 311e 	mls	r1, r1, lr, r3
   11cba:	1a5b      	subs	r3, r3, r1
    return (a < b) ? a : b;
   11cbc:	f8dc 1028 	ldr.w	r1, [ip, #40]	; 0x28
   11cc0:	428b      	cmp	r3, r1
   11cc2:	bf28      	it	cs
   11cc4:	460b      	movcs	r3, r1
    return a - (a % alignment);
   11cc6:	1aa2      	subs	r2, r4, r2
        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,
   11cc8:	e9cd 0301 	strd	r0, r3, [sp, #4]
        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
   11ccc:	606a      	str	r2, [r5, #4]
        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),
   11cce:	60ab      	str	r3, [r5, #8]
        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,
   11cd0:	9200      	str	r2, [sp, #0]
   11cd2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   11cd4:	465a      	mov	r2, fp
   11cd6:	4641      	mov	r1, r8
   11cd8:	4638      	mov	r0, r7
   11cda:	f7ff fe15 	bl	11908 <lfs_dir_getslice>
        if (err < 0) {
   11cde:	2800      	cmp	r0, #0
   11ce0:	dabb      	bge.n	11c5a <lfs_dir_getread.part.0.constprop.0+0x1a>
}
   11ce2:	b007      	add	sp, #28
   11ce4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11ce8:	fff7fc00 	.word	0xfff7fc00

00011cec <lfs_dir_open>:
int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
   11cec:	b5f0      	push	{r4, r5, r6, r7, lr}
   11cee:	b087      	sub	sp, #28
    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);
   11cf0:	f101 0608 	add.w	r6, r1, #8
int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
   11cf4:	9203      	str	r2, [sp, #12]
   11cf6:	460c      	mov	r4, r1
    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);
   11cf8:	2300      	movs	r3, #0
   11cfa:	aa03      	add	r2, sp, #12
   11cfc:	4631      	mov	r1, r6
int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
   11cfe:	4605      	mov	r5, r0
    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);
   11d00:	f7ff feb0 	bl	11a64 <lfs_dir_find>
    if (tag < 0) {
   11d04:	2800      	cmp	r0, #0
   11d06:	db2a      	blt.n	11d5e <lfs_dir_open+0x72>
    return (tag & 0x7ff00000) >> 20;
   11d08:	0d03      	lsrs	r3, r0, #20
    if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {
   11d0a:	2b02      	cmp	r3, #2
   11d0c:	d129      	bne.n	11d62 <lfs_dir_open+0x76>
    return (tag & 0x000ffc00) >> 10;
   11d0e:	f3c0 2089 	ubfx	r0, r0, #10, #10
    if (lfs_tag_id(tag) == 0x3ff) {
   11d12:	f240 33ff 	movw	r3, #1023	; 0x3ff
   11d16:	4298      	cmp	r0, r3
   11d18:	af04      	add	r7, sp, #16
   11d1a:	d115      	bne.n	11d48 <lfs_dir_open+0x5c>
        pair[0] = lfs->root[0];
   11d1c:	6a2b      	ldr	r3, [r5, #32]
   11d1e:	9304      	str	r3, [sp, #16]
        pair[1] = lfs->root[1];
   11d20:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   11d22:	9305      	str	r3, [sp, #20]
    int err = lfs_dir_fetch(lfs, &dir->m, pair);
   11d24:	463a      	mov	r2, r7
   11d26:	4631      	mov	r1, r6
   11d28:	4628      	mov	r0, r5
   11d2a:	f005 ff8f 	bl	17c4c <lfs_dir_fetch>
    if (err) {
   11d2e:	b9b0      	cbnz	r0, 11d5e <lfs_dir_open+0x72>
    dir->head[0] = dir->m.pair[0];
   11d30:	68a3      	ldr	r3, [r4, #8]
   11d32:	62e3      	str	r3, [r4, #44]	; 0x2c
    dir->head[1] = dir->m.pair[1];
   11d34:	68e3      	ldr	r3, [r4, #12]
   11d36:	6323      	str	r3, [r4, #48]	; 0x30
    dir->type = LFS_TYPE_DIR;
   11d38:	2302      	movs	r3, #2
   11d3a:	71a3      	strb	r3, [r4, #6]
    dir->next = (lfs_dir_t*)lfs->mlist;
   11d3c:	6aab      	ldr	r3, [r5, #40]	; 0x28
    dir->id = 0;
   11d3e:	80a0      	strh	r0, [r4, #4]
    dir->pos = 0;
   11d40:	62a0      	str	r0, [r4, #40]	; 0x28
    dir->next = (lfs_dir_t*)lfs->mlist;
   11d42:	6023      	str	r3, [r4, #0]
    lfs->mlist = (struct lfs_mlist*)dir;
   11d44:	62ac      	str	r4, [r5, #40]	; 0x28
    return 0;
   11d46:	e00a      	b.n	11d5e <lfs_dir_open+0x72>
        lfs_stag_t res = lfs_dir_get(lfs, &dir->m, LFS_MKTAG(0x700, 0x3ff, 0),
   11d48:	4b07      	ldr	r3, [pc, #28]	; (11d68 <lfs_dir_open+0x7c>)
   11d4a:	4a08      	ldr	r2, [pc, #32]	; (11d6c <lfs_dir_open+0x80>)
   11d4c:	9700      	str	r7, [sp, #0]
   11d4e:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
   11d52:	4631      	mov	r1, r6
   11d54:	4628      	mov	r0, r5
   11d56:	f005 ffaf 	bl	17cb8 <lfs_dir_get>
        if (res < 0) {
   11d5a:	2800      	cmp	r0, #0
   11d5c:	dae2      	bge.n	11d24 <lfs_dir_open+0x38>
}
   11d5e:	b007      	add	sp, #28
   11d60:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LFS_ERR_NOTDIR;
   11d62:	f06f 0013 	mvn.w	r0, #19
   11d66:	e7fa      	b.n	11d5e <lfs_dir_open+0x72>
   11d68:	20000008 	.word	0x20000008
   11d6c:	700ffc00 	.word	0x700ffc00

00011d70 <lfs_dir_read>:
int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
   11d70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11d74:	460d      	mov	r5, r1
   11d76:	4616      	mov	r6, r2
   11d78:	4607      	mov	r7, r0
    memset(info, 0, sizeof(*info));
   11d7a:	f44f 7284 	mov.w	r2, #264	; 0x108
   11d7e:	2100      	movs	r1, #0
   11d80:	4630      	mov	r0, r6
   11d82:	f004 f985 	bl	16090 <memset>
    if (dir->pos == 0) {
   11d86:	6aac      	ldr	r4, [r5, #40]	; 0x28
   11d88:	b964      	cbnz	r4, 11da4 <lfs_dir_read+0x34>
        info->type = LFS_TYPE_DIR;
   11d8a:	4630      	mov	r0, r6
   11d8c:	2302      	movs	r3, #2
   11d8e:	f800 3b08 	strb.w	r3, [r0], #8
        strcpy(info->name, ".");
   11d92:	491a      	ldr	r1, [pc, #104]	; (11dfc <lfs_dir_read+0x8c>)
        strcpy(info->name, "..");
   11d94:	f004 f8f4 	bl	15f80 <strcpy>
    dir->pos += 1;
   11d98:	6aab      	ldr	r3, [r5, #40]	; 0x28
   11d9a:	3301      	adds	r3, #1
   11d9c:	62ab      	str	r3, [r5, #40]	; 0x28
    return true;
   11d9e:	2001      	movs	r0, #1
}
   11da0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if (dir->pos == 1) {
   11da4:	2c01      	cmp	r4, #1
   11da6:	d022      	beq.n	11dee <lfs_dir_read+0x7e>
            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);
   11da8:	f105 0420 	add.w	r4, r5, #32
   11dac:	f105 0808 	add.w	r8, r5, #8
        if (dir->id == dir->m.count) {
   11db0:	88aa      	ldrh	r2, [r5, #4]
   11db2:	8bab      	ldrh	r3, [r5, #28]
   11db4:	429a      	cmp	r2, r3
   11db6:	d10a      	bne.n	11dce <lfs_dir_read+0x5e>
            if (!dir->m.split) {
   11db8:	7fe8      	ldrb	r0, [r5, #31]
   11dba:	2800      	cmp	r0, #0
   11dbc:	d0f0      	beq.n	11da0 <lfs_dir_read+0x30>
            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);
   11dbe:	4622      	mov	r2, r4
   11dc0:	4641      	mov	r1, r8
   11dc2:	4638      	mov	r0, r7
   11dc4:	f005 ff42 	bl	17c4c <lfs_dir_fetch>
            if (err) {
   11dc8:	2800      	cmp	r0, #0
   11dca:	d1e9      	bne.n	11da0 <lfs_dir_read+0x30>
            dir->id = 0;
   11dcc:	80a8      	strh	r0, [r5, #4]
        int err = lfs_dir_getinfo(lfs, &dir->m, dir->id, info);
   11dce:	88aa      	ldrh	r2, [r5, #4]
   11dd0:	4633      	mov	r3, r6
   11dd2:	4641      	mov	r1, r8
   11dd4:	4638      	mov	r0, r7
   11dd6:	f7ff feeb 	bl	11bb0 <lfs_dir_getinfo>
        if (err && err != LFS_ERR_NOENT) {
   11dda:	b108      	cbz	r0, 11de0 <lfs_dir_read+0x70>
   11ddc:	1c83      	adds	r3, r0, #2
   11dde:	d1df      	bne.n	11da0 <lfs_dir_read+0x30>
        dir->id += 1;
   11de0:	88ab      	ldrh	r3, [r5, #4]
        if (err != LFS_ERR_NOENT) {
   11de2:	3002      	adds	r0, #2
        dir->id += 1;
   11de4:	f103 0301 	add.w	r3, r3, #1
   11de8:	80ab      	strh	r3, [r5, #4]
        if (err != LFS_ERR_NOENT) {
   11dea:	d0e1      	beq.n	11db0 <lfs_dir_read+0x40>
   11dec:	e7d4      	b.n	11d98 <lfs_dir_read+0x28>
        info->type = LFS_TYPE_DIR;
   11dee:	4630      	mov	r0, r6
   11df0:	2302      	movs	r3, #2
   11df2:	f800 3b08 	strb.w	r3, [r0], #8
        strcpy(info->name, "..");
   11df6:	4902      	ldr	r1, [pc, #8]	; (11e00 <lfs_dir_read+0x90>)
   11df8:	e7cc      	b.n	11d94 <lfs_dir_read+0x24>
   11dfa:	bf00      	nop
   11dfc:	0001a247 	.word	0x0001a247
   11e00:	0001ba63 	.word	0x0001ba63

00011e04 <lfs_mount>:
int lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {
   11e04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11e08:	b09b      	sub	sp, #108	; 0x6c
   11e0a:	4604      	mov	r4, r0
    int err = lfs_init(lfs, cfg);
   11e0c:	f005 ff6b 	bl	17ce6 <lfs_init>
    if (err) {
   11e10:	4605      	mov	r5, r0
   11e12:	bb78      	cbnz	r0, 11e74 <lfs_mount+0x70>
    lfs_mdir_t dir = {.tail = {0, 1}};
   11e14:	4601      	mov	r1, r0
   11e16:	221c      	movs	r2, #28
   11e18:	a812      	add	r0, sp, #72	; 0x48
   11e1a:	f004 f939 	bl	16090 <memset>
                lfs_dir_find_match, &(struct lfs_dir_find_match){
   11e1e:	4f6a      	ldr	r7, [pc, #424]	; (11fc8 <lfs_mount+0x1c4>)
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
   11e20:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 11ff0 <lfs_mount+0x1ec>
            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
   11e24:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 11ff4 <lfs_mount+0x1f0>
    lfs_mdir_t dir = {.tail = {0, 1}};
   11e28:	2301      	movs	r3, #1
   11e2a:	9319      	str	r3, [sp, #100]	; 0x64
    lfs_block_t cycle = 0;
   11e2c:	462e      	mov	r6, r5
    while (!lfs_pair_isnull(dir.tail)) {
   11e2e:	a818      	add	r0, sp, #96	; 0x60
   11e30:	f005 fdb6 	bl	179a0 <lfs_pair_isnull>
   11e34:	b310      	cbz	r0, 11e7c <lfs_mount+0x78>
    if (lfs_pair_isnull(lfs->root)) {
   11e36:	f104 0020 	add.w	r0, r4, #32
   11e3a:	f005 fdb1 	bl	179a0 <lfs_pair_isnull>
   11e3e:	4603      	mov	r3, r0
   11e40:	2800      	cmp	r0, #0
   11e42:	f040 80be 	bne.w	11fc2 <lfs_mount+0x1be>
    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);
   11e46:	6b22      	ldr	r2, [r4, #48]	; 0x30
   11e48:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   11e4c:	6322      	str	r2, [r4, #48]	; 0x30
    lfs->gdisk = lfs->gstate;
   11e4e:	f104 0230 	add.w	r2, r4, #48	; 0x30
   11e52:	ca07      	ldmia	r2, {r0, r1, r2}
   11e54:	f104 063c 	add.w	r6, r4, #60	; 0x3c
   11e58:	e886 0007 	stmia.w	r6, {r0, r1, r2}
    lfs->free.off = lfs->seed % lfs->cfg->block_size;
   11e5c:	6ea1      	ldr	r1, [r4, #104]	; 0x68
   11e5e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   11e60:	69c8      	ldr	r0, [r1, #28]
   11e62:	fbb6 f2f0 	udiv	r2, r6, r0
   11e66:	fb00 6212 	mls	r2, r0, r2, r6
    lfs->free.size = 0;
   11e6a:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
    lfs->free.i = 0;
   11e6e:	65e3      	str	r3, [r4, #92]	; 0x5c
    lfs->free.ack = lfs->cfg->block_count;
   11e70:	6a0b      	ldr	r3, [r1, #32]
   11e72:	6623      	str	r3, [r4, #96]	; 0x60
}
   11e74:	4628      	mov	r0, r5
   11e76:	b01b      	add	sp, #108	; 0x6c
   11e78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (cycle >= lfs->cfg->block_count/2) {
   11e7c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   11e7e:	6a1b      	ldr	r3, [r3, #32]
   11e80:	ebb6 0f53 	cmp.w	r6, r3, lsr #1
   11e84:	f080 809a 	bcs.w	11fbc <lfs_mount+0x1b8>
                lfs_dir_find_match, &(struct lfs_dir_find_match){
   11e88:	2308      	movs	r3, #8
   11e8a:	9307      	str	r3, [sp, #28]
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
   11e8c:	ab05      	add	r3, sp, #20
   11e8e:	e9cd 8302 	strd	r8, r3, [sp, #8]
   11e92:	4b4e      	ldr	r3, [pc, #312]	; (11fcc <lfs_mount+0x1c8>)
   11e94:	9001      	str	r0, [sp, #4]
   11e96:	9300      	str	r3, [sp, #0]
   11e98:	aa18      	add	r2, sp, #96	; 0x60
   11e9a:	4b4d      	ldr	r3, [pc, #308]	; (11fd0 <lfs_mount+0x1cc>)
   11e9c:	a912      	add	r1, sp, #72	; 0x48
   11e9e:	4620      	mov	r0, r4
                lfs_dir_find_match, &(struct lfs_dir_find_match){
   11ea0:	e9cd 4705 	strd	r4, r7, [sp, #20]
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
   11ea4:	f7ff fa26 	bl	112f4 <lfs_dir_fetchmatch>
        if (tag < 0) {
   11ea8:	2800      	cmp	r0, #0
        cycle += 1;
   11eaa:	f106 0601 	add.w	r6, r6, #1
        if (tag < 0) {
   11eae:	db2e      	blt.n	11f0e <lfs_mount+0x10a>
        if (tag && !lfs_tag_isdelete(tag)) {
   11eb0:	d07a      	beq.n	11fa8 <lfs_mount+0x1a4>
    return ((int32_t)(tag << 22) >> 22) == -1;
   11eb2:	f340 0009 	sbfx	r0, r0, #0, #10
        if (tag && !lfs_tag_isdelete(tag)) {
   11eb6:	3001      	adds	r0, #1
   11eb8:	d076      	beq.n	11fa8 <lfs_mount+0x1a4>
            lfs->root[0] = dir.pair[0];
   11eba:	9b12      	ldr	r3, [sp, #72]	; 0x48
   11ebc:	6223      	str	r3, [r4, #32]
            lfs->root[1] = dir.pair[1];
   11ebe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   11ec0:	6263      	str	r3, [r4, #36]	; 0x24
            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
   11ec2:	ab0c      	add	r3, sp, #48	; 0x30
   11ec4:	9300      	str	r3, [sp, #0]
   11ec6:	4a42      	ldr	r2, [pc, #264]	; (11fd0 <lfs_mount+0x1cc>)
   11ec8:	464b      	mov	r3, r9
   11eca:	a912      	add	r1, sp, #72	; 0x48
   11ecc:	4620      	mov	r0, r4
   11ece:	f005 fef3 	bl	17cb8 <lfs_dir_get>
            if (tag < 0) {
   11ed2:	2800      	cmp	r0, #0
   11ed4:	db1b      	blt.n	11f0e <lfs_mount+0x10a>
            uint16_t major_version = (0xffff & (superblock.version >> 16));
   11ed6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   11ed8:	0c11      	lsrs	r1, r2, #16
            if ((major_version != LFS_DISK_VERSION_MAJOR ||
   11eda:	2902      	cmp	r1, #2
            uint16_t minor_version = (0xffff & (superblock.version >>  0));
   11edc:	b293      	uxth	r3, r2
            if ((major_version != LFS_DISK_VERSION_MAJOR ||
   11ede:	d100      	bne.n	11ee2 <lfs_mount+0xde>
   11ee0:	b1d3      	cbz	r3, 11f18 <lfs_mount+0x114>
   11ee2:	483c      	ldr	r0, [pc, #240]	; (11fd4 <lfs_mount+0x1d0>)
   11ee4:	4b3c      	ldr	r3, [pc, #240]	; (11fd8 <lfs_mount+0x1d4>)
   11ee6:	1a1b      	subs	r3, r3, r0
                LFS_ERROR("Invalid version v%"PRIu16".%"PRIu16,
   11ee8:	483c      	ldr	r0, [pc, #240]	; (11fdc <lfs_mount+0x1d8>)
   11eea:	9008      	str	r0, [sp, #32]
   11eec:	08db      	lsrs	r3, r3, #3
   11eee:	f640 6098 	movw	r0, #3736	; 0xe98
   11ef2:	e9cd 0109 	strd	r0, r1, [sp, #36]	; 0x24
   11ef6:	b292      	uxth	r2, r2
   11ef8:	019b      	lsls	r3, r3, #6
   11efa:	4839      	ldr	r0, [pc, #228]	; (11fe0 <lfs_mount+0x1dc>)
   11efc:	920b      	str	r2, [sp, #44]	; 0x2c
   11efe:	f043 0301 	orr.w	r3, r3, #1
   11f02:	2204      	movs	r2, #4
   11f04:	a908      	add	r1, sp, #32
                    LFS_ERROR("Unsupported attr_max (%"PRIu32" > %"PRIu32")",
   11f06:	f003 f9f6 	bl	152f6 <log_n>
                    err = LFS_ERR_INVAL;
   11f0a:	f06f 0015 	mvn.w	r0, #21
            goto cleanup;
   11f0e:	4605      	mov	r5, r0
    lfs_unmount(lfs);
   11f10:	4620      	mov	r0, r4
   11f12:	f006 fa53 	bl	183bc <lfs_unmount>
    return err;
   11f16:	e7ad      	b.n	11e74 <lfs_mount+0x70>
            if (superblock.name_max) {
   11f18:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   11f1a:	b1aa      	cbz	r2, 11f48 <lfs_mount+0x144>
                if (superblock.name_max > lfs->name_max) {
   11f1c:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
   11f1e:	428a      	cmp	r2, r1
   11f20:	d911      	bls.n	11f46 <lfs_mount+0x142>
   11f22:	482c      	ldr	r0, [pc, #176]	; (11fd4 <lfs_mount+0x1d0>)
   11f24:	4b2c      	ldr	r3, [pc, #176]	; (11fd8 <lfs_mount+0x1d4>)
                    LFS_ERROR("Unsupported name_max (%"PRIu32" > %"PRIu32")",
   11f26:	910b      	str	r1, [sp, #44]	; 0x2c
   11f28:	1a1b      	subs	r3, r3, r0
   11f2a:	08db      	lsrs	r3, r3, #3
   11f2c:	482b      	ldr	r0, [pc, #172]	; (11fdc <lfs_mount+0x1d8>)
   11f2e:	9008      	str	r0, [sp, #32]
   11f30:	019b      	lsls	r3, r3, #6
   11f32:	f640 60a1 	movw	r0, #3745	; 0xea1
   11f36:	e9cd 0209 	strd	r0, r2, [sp, #36]	; 0x24
   11f3a:	f043 0301 	orr.w	r3, r3, #1
   11f3e:	4829      	ldr	r0, [pc, #164]	; (11fe4 <lfs_mount+0x1e0>)
   11f40:	2204      	movs	r2, #4
   11f42:	a908      	add	r1, sp, #32
   11f44:	e7df      	b.n	11f06 <lfs_mount+0x102>
                lfs->name_max = superblock.name_max;
   11f46:	66e2      	str	r2, [r4, #108]	; 0x6c
            if (superblock.file_max) {
   11f48:	9a10      	ldr	r2, [sp, #64]	; 0x40
   11f4a:	b1aa      	cbz	r2, 11f78 <lfs_mount+0x174>
                if (superblock.file_max > lfs->file_max) {
   11f4c:	6f21      	ldr	r1, [r4, #112]	; 0x70
   11f4e:	428a      	cmp	r2, r1
   11f50:	d911      	bls.n	11f76 <lfs_mount+0x172>
   11f52:	4820      	ldr	r0, [pc, #128]	; (11fd4 <lfs_mount+0x1d0>)
   11f54:	4b20      	ldr	r3, [pc, #128]	; (11fd8 <lfs_mount+0x1d4>)
                    LFS_ERROR("Unsupported file_max (%"PRIu32" > %"PRIu32")",
   11f56:	910b      	str	r1, [sp, #44]	; 0x2c
   11f58:	1a1b      	subs	r3, r3, r0
   11f5a:	08db      	lsrs	r3, r3, #3
   11f5c:	481f      	ldr	r0, [pc, #124]	; (11fdc <lfs_mount+0x1d8>)
   11f5e:	9008      	str	r0, [sp, #32]
   11f60:	019b      	lsls	r3, r3, #6
   11f62:	f640 60ac 	movw	r0, #3756	; 0xeac
   11f66:	e9cd 0209 	strd	r0, r2, [sp, #36]	; 0x24
   11f6a:	f043 0301 	orr.w	r3, r3, #1
   11f6e:	481e      	ldr	r0, [pc, #120]	; (11fe8 <lfs_mount+0x1e4>)
   11f70:	2204      	movs	r2, #4
   11f72:	a908      	add	r1, sp, #32
   11f74:	e7c7      	b.n	11f06 <lfs_mount+0x102>
                lfs->file_max = superblock.file_max;
   11f76:	6722      	str	r2, [r4, #112]	; 0x70
            if (superblock.attr_max) {
   11f78:	9a11      	ldr	r2, [sp, #68]	; 0x44
   11f7a:	b1aa      	cbz	r2, 11fa8 <lfs_mount+0x1a4>
                if (superblock.attr_max > lfs->attr_max) {
   11f7c:	6f61      	ldr	r1, [r4, #116]	; 0x74
   11f7e:	428a      	cmp	r2, r1
   11f80:	d911      	bls.n	11fa6 <lfs_mount+0x1a2>
   11f82:	4814      	ldr	r0, [pc, #80]	; (11fd4 <lfs_mount+0x1d0>)
   11f84:	4b14      	ldr	r3, [pc, #80]	; (11fd8 <lfs_mount+0x1d4>)
                    LFS_ERROR("Unsupported attr_max (%"PRIu32" > %"PRIu32")",
   11f86:	910b      	str	r1, [sp, #44]	; 0x2c
   11f88:	1a1b      	subs	r3, r3, r0
   11f8a:	08db      	lsrs	r3, r3, #3
   11f8c:	4813      	ldr	r0, [pc, #76]	; (11fdc <lfs_mount+0x1d8>)
   11f8e:	9008      	str	r0, [sp, #32]
   11f90:	019b      	lsls	r3, r3, #6
   11f92:	f640 60b7 	movw	r0, #3767	; 0xeb7
   11f96:	e9cd 0209 	strd	r0, r2, [sp, #36]	; 0x24
   11f9a:	f043 0301 	orr.w	r3, r3, #1
   11f9e:	4813      	ldr	r0, [pc, #76]	; (11fec <lfs_mount+0x1e8>)
   11fa0:	2204      	movs	r2, #4
   11fa2:	a908      	add	r1, sp, #32
   11fa4:	e7af      	b.n	11f06 <lfs_mount+0x102>
                lfs->attr_max = superblock.attr_max;
   11fa6:	6762      	str	r2, [r4, #116]	; 0x74
        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);
   11fa8:	f104 0230 	add.w	r2, r4, #48	; 0x30
   11fac:	a912      	add	r1, sp, #72	; 0x48
   11fae:	4620      	mov	r0, r4
   11fb0:	f7ff fd3e 	bl	11a30 <lfs_dir_getgstate>
        if (err) {
   11fb4:	2800      	cmp	r0, #0
   11fb6:	f43f af3a 	beq.w	11e2e <lfs_mount+0x2a>
   11fba:	e7a8      	b.n	11f0e <lfs_mount+0x10a>
            err = LFS_ERR_CORRUPT;
   11fbc:	f06f 0053 	mvn.w	r0, #83	; 0x53
   11fc0:	e7a5      	b.n	11f0e <lfs_mount+0x10a>
        err = LFS_ERR_INVAL;
   11fc2:	f06f 0515 	mvn.w	r5, #21
   11fc6:	e7a3      	b.n	11f10 <lfs_mount+0x10c>
   11fc8:	0001bcfa 	.word	0x0001bcfa
   11fcc:	0ff00008 	.word	0x0ff00008
   11fd0:	7ffffc00 	.word	0x7ffffc00
   11fd4:	0001956c 	.word	0x0001956c
   11fd8:	0001960c 	.word	0x0001960c
   11fdc:	0001c068 	.word	0x0001c068
   11fe0:	0001c0b8 	.word	0x0001c0b8
   11fe4:	0001c0d6 	.word	0x0001c0d6
   11fe8:	0001c0fc 	.word	0x0001c0fc
   11fec:	0001c122 	.word	0x0001c122
   11ff0:	00018329 	.word	0x00018329
   11ff4:	20100018 	.word	0x20100018

00011ff8 <lfs_fs_traverseraw>:
        bool includeorphans) {
   11ff8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ffc:	b091      	sub	sp, #68	; 0x44
   11ffe:	4604      	mov	r4, r0
   12000:	460d      	mov	r5, r1
   12002:	4616      	mov	r6, r2
    lfs_mdir_t dir = {.tail = {0, 1}};
   12004:	2100      	movs	r1, #0
   12006:	221c      	movs	r2, #28
   12008:	a808      	add	r0, sp, #32
        bool includeorphans) {
   1200a:	9305      	str	r3, [sp, #20]
                    LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);
   1200c:	f8df 913c 	ldr.w	r9, [pc, #316]	; 1214c <lfs_fs_traverseraw+0x154>
            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),
   12010:	f8df a13c 	ldr.w	sl, [pc, #316]	; 12150 <lfs_fs_traverseraw+0x158>
    lfs_mdir_t dir = {.tail = {0, 1}};
   12014:	f004 f83c 	bl	16090 <memset>
   12018:	2301      	movs	r3, #1
   1201a:	930f      	str	r3, [sp, #60]	; 0x3c
    lfs_block_t cycle = 0;
   1201c:	f04f 0800 	mov.w	r8, #0
    while (!lfs_pair_isnull(dir.tail)) {
   12020:	a80e      	add	r0, sp, #56	; 0x38
   12022:	f005 fcbd 	bl	179a0 <lfs_pair_isnull>
   12026:	b120      	cbz	r0, 12032 <lfs_fs_traverseraw+0x3a>
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
   12028:	6aa7      	ldr	r7, [r4, #40]	; 0x28
   1202a:	2f00      	cmp	r7, #0
   1202c:	d159      	bne.n	120e2 <lfs_fs_traverseraw+0xea>
    return 0;
   1202e:	4638      	mov	r0, r7
   12030:	e045      	b.n	120be <lfs_fs_traverseraw+0xc6>
        if (cycle >= lfs->cfg->block_count/2) {
   12032:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   12034:	6a1b      	ldr	r3, [r3, #32]
   12036:	ebb8 0f53 	cmp.w	r8, r3, lsr #1
   1203a:	f080 8083 	bcs.w	12144 <lfs_fs_traverseraw+0x14c>
            int err = cb(data, dir.tail[i]);
   1203e:	990e      	ldr	r1, [sp, #56]	; 0x38
   12040:	4630      	mov	r0, r6
        cycle += 1;
   12042:	f108 0801 	add.w	r8, r8, #1
            int err = cb(data, dir.tail[i]);
   12046:	47a8      	blx	r5
            if (err) {
   12048:	2800      	cmp	r0, #0
   1204a:	d138      	bne.n	120be <lfs_fs_traverseraw+0xc6>
            int err = cb(data, dir.tail[i]);
   1204c:	990f      	ldr	r1, [sp, #60]	; 0x3c
   1204e:	4630      	mov	r0, r6
   12050:	47a8      	blx	r5
            if (err) {
   12052:	2800      	cmp	r0, #0
   12054:	d133      	bne.n	120be <lfs_fs_traverseraw+0xc6>
        int err = lfs_dir_fetch(lfs, &dir, dir.tail);
   12056:	aa0e      	add	r2, sp, #56	; 0x38
   12058:	a908      	add	r1, sp, #32
   1205a:	4620      	mov	r0, r4
   1205c:	f005 fdf6 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   12060:	bb68      	cbnz	r0, 120be <lfs_fs_traverseraw+0xc6>
            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),
   12062:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 12154 <lfs_fs_traverseraw+0x15c>
   12066:	4607      	mov	r7, r0
        for (uint16_t id = 0; id < dir.count; id++) {
   12068:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
   1206c:	b2bb      	uxth	r3, r7
   1206e:	429a      	cmp	r2, r3
   12070:	d9d6      	bls.n	12020 <lfs_fs_traverseraw+0x28>
            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),
   12072:	aa06      	add	r2, sp, #24
                    LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);
   12074:	ea09 2387 	and.w	r3, r9, r7, lsl #10
            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),
   12078:	9200      	str	r2, [sp, #0]
   1207a:	ea43 030b 	orr.w	r3, r3, fp
   1207e:	4652      	mov	r2, sl
   12080:	a908      	add	r1, sp, #32
   12082:	4620      	mov	r0, r4
   12084:	f005 fe18 	bl	17cb8 <lfs_dir_get>
            if (tag < 0) {
   12088:	2800      	cmp	r0, #0
   1208a:	da03      	bge.n	12094 <lfs_fs_traverseraw+0x9c>
                if (tag == LFS_ERR_NOENT) {
   1208c:	1c83      	adds	r3, r0, #2
   1208e:	d116      	bne.n	120be <lfs_fs_traverseraw+0xc6>
        for (uint16_t id = 0; id < dir.count; id++) {
   12090:	3701      	adds	r7, #1
   12092:	e7e9      	b.n	12068 <lfs_fs_traverseraw+0x70>
            if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
   12094:	f240 2202 	movw	r2, #514	; 0x202
   12098:	ebb2 5f10 	cmp.w	r2, r0, lsr #20
    return (tag & 0x7ff00000) >> 20;
   1209c:	ea4f 5310 	mov.w	r3, r0, lsr #20
            if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
   120a0:	d110      	bne.n	120c4 <lfs_fs_traverseraw+0xcc>
                err = lfs_ctz_traverse(lfs, NULL, &lfs->rcache,
   120a2:	9b07      	ldr	r3, [sp, #28]
    if (size == 0) {
   120a4:	2b00      	cmp	r3, #0
   120a6:	d0f3      	beq.n	12090 <lfs_fs_traverseraw+0x98>
   120a8:	9300      	str	r3, [sp, #0]
   120aa:	e9cd 5601 	strd	r5, r6, [sp, #4]
   120ae:	9b06      	ldr	r3, [sp, #24]
   120b0:	4622      	mov	r2, r4
   120b2:	2100      	movs	r1, #0
   120b4:	4620      	mov	r0, r4
   120b6:	f005 fe8d 	bl	17dd4 <lfs_ctz_traverse.part.0>
                    if (err) {
   120ba:	2800      	cmp	r0, #0
   120bc:	d0e8      	beq.n	12090 <lfs_fs_traverseraw+0x98>
}
   120be:	b011      	add	sp, #68	; 0x44
   120c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            } else if (includeorphans && 
   120c4:	9a05      	ldr	r2, [sp, #20]
   120c6:	2a00      	cmp	r2, #0
   120c8:	d0e2      	beq.n	12090 <lfs_fs_traverseraw+0x98>
   120ca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   120ce:	d1df      	bne.n	12090 <lfs_fs_traverseraw+0x98>
                    err = cb(data, (&ctz.head)[i]);
   120d0:	9906      	ldr	r1, [sp, #24]
   120d2:	4630      	mov	r0, r6
   120d4:	47a8      	blx	r5
                    if (err) {
   120d6:	2800      	cmp	r0, #0
   120d8:	d1f1      	bne.n	120be <lfs_fs_traverseraw+0xc6>
                    err = cb(data, (&ctz.head)[i]);
   120da:	9907      	ldr	r1, [sp, #28]
   120dc:	4630      	mov	r0, r6
   120de:	47a8      	blx	r5
   120e0:	e7eb      	b.n	120ba <lfs_fs_traverseraw+0xc2>
        if (f->type != LFS_TYPE_REG) {
   120e2:	79bb      	ldrb	r3, [r7, #6]
   120e4:	2b01      	cmp	r3, #1
   120e6:	d001      	beq.n	120ec <lfs_fs_traverseraw+0xf4>
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
   120e8:	683f      	ldr	r7, [r7, #0]
   120ea:	e79e      	b.n	1202a <lfs_fs_traverseraw+0x32>
        if ((f->flags & LFS_F_DIRTY) && !(f->flags & LFS_F_INLINE)) {
   120ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   120ee:	f403 1388 	and.w	r3, r3, #1114112	; 0x110000
   120f2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   120f6:	d015      	beq.n	12124 <lfs_fs_traverseraw+0x12c>
        if ((f->flags & LFS_F_WRITING) && !(f->flags & LFS_F_INLINE)) {
   120f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   120fa:	f403 1390 	and.w	r3, r3, #1179648	; 0x120000
   120fe:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   12102:	d1f1      	bne.n	120e8 <lfs_fs_traverseraw+0xf0>
            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,
   12104:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    if (size == 0) {
   12106:	2b00      	cmp	r3, #0
   12108:	d0ee      	beq.n	120e8 <lfs_fs_traverseraw+0xf0>
   1210a:	e9cd 5601 	strd	r5, r6, [sp, #4]
   1210e:	9300      	str	r3, [sp, #0]
   12110:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   12112:	4622      	mov	r2, r4
   12114:	f107 0140 	add.w	r1, r7, #64	; 0x40
   12118:	4620      	mov	r0, r4
   1211a:	f005 fe5b 	bl	17dd4 <lfs_ctz_traverse.part.0>
            if (err) {
   1211e:	2800      	cmp	r0, #0
   12120:	d0e2      	beq.n	120e8 <lfs_fs_traverseraw+0xf0>
   12122:	e7cc      	b.n	120be <lfs_fs_traverseraw+0xc6>
            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,
   12124:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    if (size == 0) {
   12126:	2b00      	cmp	r3, #0
   12128:	d0e6      	beq.n	120f8 <lfs_fs_traverseraw+0x100>
   1212a:	e9cd 5601 	strd	r5, r6, [sp, #4]
   1212e:	9300      	str	r3, [sp, #0]
   12130:	6abb      	ldr	r3, [r7, #40]	; 0x28
   12132:	4622      	mov	r2, r4
   12134:	f107 0140 	add.w	r1, r7, #64	; 0x40
   12138:	4620      	mov	r0, r4
   1213a:	f005 fe4b 	bl	17dd4 <lfs_ctz_traverse.part.0>
            if (err) {
   1213e:	2800      	cmp	r0, #0
   12140:	d0da      	beq.n	120f8 <lfs_fs_traverseraw+0x100>
   12142:	e7bc      	b.n	120be <lfs_fs_traverseraw+0xc6>
            return LFS_ERR_CORRUPT;
   12144:	f06f 0053 	mvn.w	r0, #83	; 0x53
   12148:	e7b9      	b.n	120be <lfs_fs_traverseraw+0xc6>
   1214a:	bf00      	nop
   1214c:	03fffc00 	.word	0x03fffc00
   12150:	700ffc00 	.word	0x700ffc00
   12154:	20000008 	.word	0x20000008

00012158 <lfs_alloc>:
static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
   12158:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        int err = lfs_fs_traverseraw(lfs, lfs_alloc_lookahead, lfs, true);
   1215c:	4e3e      	ldr	r6, [pc, #248]	; (12258 <lfs_alloc+0x100>)
static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
   1215e:	4604      	mov	r4, r0
   12160:	460d      	mov	r5, r1
            if (!(lfs->free.buffer[off / 32] & (1U << (off % 32)))) {
   12162:	2701      	movs	r7, #1
        while (lfs->free.i != lfs->free.size) {
   12164:	6da3      	ldr	r3, [r4, #88]	; 0x58
   12166:	e9d4 2017 	ldrd	r2, r0, [r4, #92]	; 0x5c
   1216a:	429a      	cmp	r2, r3
   1216c:	d115      	bne.n	1219a <lfs_alloc+0x42>
        if (lfs->free.ack == 0) {
   1216e:	6d62      	ldr	r2, [r4, #84]	; 0x54
   12170:	4413      	add	r3, r2
   12172:	2800      	cmp	r0, #0
   12174:	d141      	bne.n	121fa <lfs_alloc+0xa2>
   12176:	4939      	ldr	r1, [pc, #228]	; (1225c <lfs_alloc+0x104>)
   12178:	4a39      	ldr	r2, [pc, #228]	; (12260 <lfs_alloc+0x108>)
            LFS_ERROR("No more free space %"PRIu32,
   1217a:	483a      	ldr	r0, [pc, #232]	; (12264 <lfs_alloc+0x10c>)
   1217c:	1a52      	subs	r2, r2, r1
   1217e:	08d2      	lsrs	r2, r2, #3
   12180:	0192      	lsls	r2, r2, #6
   12182:	f042 0201 	orr.w	r2, r2, #1
   12186:	f8ad 2000 	strh.w	r2, [sp]
   1218a:	4937      	ldr	r1, [pc, #220]	; (12268 <lfs_alloc+0x110>)
   1218c:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
   12190:	f003 f895 	bl	152be <log_3>
            return LFS_ERR_NOSPC;
   12194:	f06f 001b 	mvn.w	r0, #27
   12198:	e026      	b.n	121e8 <lfs_alloc+0x90>
            lfs->free.i += 1;
   1219a:	1c51      	adds	r1, r2, #1
   1219c:	65e1      	str	r1, [r4, #92]	; 0x5c
            lfs->free.ack -= 1;
   1219e:	3801      	subs	r0, #1
            if (!(lfs->free.buffer[off / 32] & (1U << (off % 32)))) {
   121a0:	6e61      	ldr	r1, [r4, #100]	; 0x64
            lfs->free.ack -= 1;
   121a2:	6620      	str	r0, [r4, #96]	; 0x60
            if (!(lfs->free.buffer[off / 32] & (1U << (off % 32)))) {
   121a4:	ea4f 1c52 	mov.w	ip, r2, lsr #5
   121a8:	f002 001f 	and.w	r0, r2, #31
   121ac:	f851 c02c 	ldr.w	ip, [r1, ip, lsl #2]
   121b0:	fa07 f000 	lsl.w	r0, r7, r0
   121b4:	ea10 0f0c 	tst.w	r0, ip
   121b8:	d1d5      	bne.n	12166 <lfs_alloc+0xe>
                *block = (lfs->free.off + off) % lfs->cfg->block_count;
   121ba:	6d63      	ldr	r3, [r4, #84]	; 0x54
   121bc:	441a      	add	r2, r3
   121be:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   121c0:	6a18      	ldr	r0, [r3, #32]
   121c2:	fbb2 f3f0 	udiv	r3, r2, r0
   121c6:	fb00 2213 	mls	r2, r0, r3, r2
   121ca:	602a      	str	r2, [r5, #0]
                while (lfs->free.i != lfs->free.size &&
   121cc:	6da6      	ldr	r6, [r4, #88]	; 0x58
                            & (1U << (lfs->free.i % 32)))) {
   121ce:	2501      	movs	r5, #1
                while (lfs->free.i != lfs->free.size &&
   121d0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   121d2:	42b3      	cmp	r3, r6
   121d4:	d03d      	beq.n	12252 <lfs_alloc+0xfa>
                        (lfs->free.buffer[lfs->free.i / 32]
   121d6:	095a      	lsrs	r2, r3, #5
                            & (1U << (lfs->free.i % 32)))) {
   121d8:	f003 001f 	and.w	r0, r3, #31
   121dc:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
   121e0:	fa05 f000 	lsl.w	r0, r5, r0
                while (lfs->free.i != lfs->free.size &&
   121e4:	4010      	ands	r0, r2
   121e6:	d102      	bne.n	121ee <lfs_alloc+0x96>
}
   121e8:	b002      	add	sp, #8
   121ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    lfs->free.i += 1;
   121ee:	3301      	adds	r3, #1
   121f0:	65e3      	str	r3, [r4, #92]	; 0x5c
                    lfs->free.ack -= 1;
   121f2:	6e23      	ldr	r3, [r4, #96]	; 0x60
   121f4:	3b01      	subs	r3, #1
   121f6:	6623      	str	r3, [r4, #96]	; 0x60
   121f8:	e7ea      	b.n	121d0 <lfs_alloc+0x78>
                % lfs->cfg->block_count;
   121fa:	6ea1      	ldr	r1, [r4, #104]	; 0x68
   121fc:	f8d1 c020 	ldr.w	ip, [r1, #32]
   12200:	fbb3 f2fc 	udiv	r2, r3, ip
   12204:	fb0c 3312 	mls	r3, ip, r2, r3
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size, lfs->free.ack);
   12208:	6aca      	ldr	r2, [r1, #44]	; 0x2c
        lfs->free.off = (lfs->free.off + lfs->free.size)
   1220a:	6563      	str	r3, [r4, #84]	; 0x54
        lfs->free.i = 0;
   1220c:	f04f 0800 	mov.w	r8, #0
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size, lfs->free.ack);
   12210:	00d3      	lsls	r3, r2, #3
   12212:	4283      	cmp	r3, r0
   12214:	bf94      	ite	ls
   12216:	65a3      	strls	r3, [r4, #88]	; 0x58
   12218:	65a0      	strhi	r0, [r4, #88]	; 0x58
        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
   1221a:	4641      	mov	r1, r8
   1221c:	6e60      	ldr	r0, [r4, #100]	; 0x64
        lfs->free.i = 0;
   1221e:	f8c4 805c 	str.w	r8, [r4, #92]	; 0x5c
        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
   12222:	f003 ff35 	bl	16090 <memset>
        int err = lfs_fs_traverseraw(lfs, lfs_alloc_lookahead, lfs, true);
   12226:	2301      	movs	r3, #1
   12228:	4622      	mov	r2, r4
   1222a:	4631      	mov	r1, r6
   1222c:	4620      	mov	r0, r4
   1222e:	f7ff fee3 	bl	11ff8 <lfs_fs_traverseraw>
        if (err) {
   12232:	2800      	cmp	r0, #0
   12234:	d096      	beq.n	12164 <lfs_alloc+0xc>
    lfs->free.off = lfs->seed % lfs->cfg->block_size;
   12236:	6ea2      	ldr	r2, [r4, #104]	; 0x68
   12238:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
   1223a:	69d1      	ldr	r1, [r2, #28]
   1223c:	fbb5 f3f1 	udiv	r3, r5, r1
   12240:	fb01 5313 	mls	r3, r1, r3, r5
    lfs->free.size = 0;
   12244:	e9c4 3815 	strd	r3, r8, [r4, #84]	; 0x54
    lfs->free.ack = lfs->cfg->block_count;
   12248:	6a13      	ldr	r3, [r2, #32]
    lfs->free.i = 0;
   1224a:	f8c4 805c 	str.w	r8, [r4, #92]	; 0x5c
    lfs->free.ack = lfs->cfg->block_count;
   1224e:	6623      	str	r3, [r4, #96]	; 0x60
}
   12250:	e7ca      	b.n	121e8 <lfs_alloc+0x90>
                return 0;
   12252:	2000      	movs	r0, #0
   12254:	e7c8      	b.n	121e8 <lfs_alloc+0x90>
   12256:	bf00      	nop
   12258:	00017a23 	.word	0x00017a23
   1225c:	0001956c 	.word	0x0001956c
   12260:	0001960c 	.word	0x0001960c
   12264:	0001c148 	.word	0x0001c148
   12268:	0001c068 	.word	0x0001c068

0001226c <lfs_file_relocate>:
static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
   1226c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                err = lfs_dir_getread(lfs, &file->m,
   12270:	f8df 9100 	ldr.w	r9, [pc, #256]	; 12374 <lfs_file_relocate+0x108>
static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
   12274:	b086      	sub	sp, #24
   12276:	4604      	mov	r4, r0
   12278:	460d      	mov	r5, r1
        int err = lfs_alloc(lfs, &nblock);
   1227a:	a905      	add	r1, sp, #20
   1227c:	4620      	mov	r0, r4
   1227e:	f7ff ff6b 	bl	12158 <lfs_alloc>
        if (err) {
   12282:	4606      	mov	r6, r0
   12284:	b948      	cbnz	r0, 1229a <lfs_file_relocate+0x2e>
        err = lfs_bd_erase(lfs, nblock);
   12286:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    int err = lfs->cfg->erase(lfs->cfg, block);
   12288:	9905      	ldr	r1, [sp, #20]
   1228a:	68c3      	ldr	r3, [r0, #12]
   1228c:	4798      	blx	r3
        if (err) {
   1228e:	4606      	mov	r6, r0
   12290:	2800      	cmp	r0, #0
   12292:	d064      	beq.n	1235e <lfs_file_relocate+0xf2>
            if (err == LFS_ERR_CORRUPT) {
   12294:	f110 0f54 	cmn.w	r0, #84	; 0x54
   12298:	d067      	beq.n	1236a <lfs_file_relocate+0xfe>
}
   1229a:	4630      	mov	r0, r6
   1229c:	b006      	add	sp, #24
   1229e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (file->flags & LFS_F_INLINE) {
   122a2:	6b2a      	ldr	r2, [r5, #48]	; 0x30
   122a4:	02d2      	lsls	r2, r2, #11
   122a6:	eba3 0307 	sub.w	r3, r3, r7
   122aa:	d52b      	bpl.n	12304 <lfs_file_relocate+0x98>
                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),
   122ac:	88aa      	ldrh	r2, [r5, #4]
                err = lfs_dir_getread(lfs, &file->m,
   122ae:	ea49 2e82 	orr.w	lr, r9, r2, lsl #10
    if (off+size > lfs->cfg->block_size) {
   122b2:	6ea2      	ldr	r2, [r4, #104]	; 0x68
   122b4:	f8d2 c01c 	ldr.w	ip, [r2, #28]
   122b8:	1c78      	adds	r0, r7, #1
   122ba:	4560      	cmp	r0, ip
                err = lfs_dir_getread(lfs, &file->m,
   122bc:	f105 0108 	add.w	r1, r5, #8
    if (off+size > lfs->cfg->block_size) {
   122c0:	d84a      	bhi.n	12358 <lfs_file_relocate+0xec>
   122c2:	2001      	movs	r0, #1
   122c4:	9003      	str	r0, [sp, #12]
   122c6:	f10d 0013 	add.w	r0, sp, #19
   122ca:	e9cd 7001 	strd	r7, r0, [sp, #4]
   122ce:	f8cd e000 	str.w	lr, [sp]
   122d2:	4642      	mov	r2, r8
   122d4:	4620      	mov	r0, r4
   122d6:	f7ff fcb3 	bl	11c40 <lfs_dir_getread.part.0.constprop.0>
                if (err) {
   122da:	b988      	cbnz	r0, 12300 <lfs_file_relocate+0x94>
            err = lfs_bd_prog(lfs,
   122dc:	f10d 0213 	add.w	r2, sp, #19
   122e0:	e9cd 7201 	strd	r7, r2, [sp, #4]
   122e4:	2301      	movs	r3, #1
   122e6:	9a05      	ldr	r2, [sp, #20]
   122e8:	9200      	str	r2, [sp, #0]
   122ea:	9303      	str	r3, [sp, #12]
   122ec:	4622      	mov	r2, r4
   122ee:	f104 0110 	add.w	r1, r4, #16
   122f2:	4620      	mov	r0, r4
   122f4:	f005 fe6a 	bl	17fcc <lfs_bd_prog>
            if (err) {
   122f8:	b190      	cbz	r0, 12320 <lfs_file_relocate+0xb4>
                if (err == LFS_ERR_CORRUPT) {
   122fa:	f110 0f54 	cmn.w	r0, #84	; 0x54
   122fe:	d034      	beq.n	1236a <lfs_file_relocate+0xfe>
                    return err;
   12300:	4606      	mov	r6, r0
   12302:	e7ca      	b.n	1229a <lfs_file_relocate+0x2e>
                err = lfs_bd_read(lfs,
   12304:	2201      	movs	r2, #1
   12306:	9203      	str	r2, [sp, #12]
   12308:	f10d 0213 	add.w	r2, sp, #19
   1230c:	e9cd 7201 	strd	r7, r2, [sp, #4]
   12310:	6baa      	ldr	r2, [r5, #56]	; 0x38
   12312:	9200      	str	r2, [sp, #0]
   12314:	4641      	mov	r1, r8
   12316:	4622      	mov	r2, r4
   12318:	4650      	mov	r0, sl
   1231a:	f005 fbcf 	bl	17abc <lfs_bd_read.isra.0>
   1231e:	e7dc      	b.n	122da <lfs_file_relocate+0x6e>
        for (lfs_off_t i = 0; i < file->off; i++) {
   12320:	3701      	adds	r7, #1
   12322:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   12324:	42bb      	cmp	r3, r7
   12326:	d8bc      	bhi.n	122a2 <lfs_file_relocate+0x36>
        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);
   12328:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   1232a:	69e1      	ldr	r1, [r4, #28]
   1232c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1232e:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
   12330:	f003 fe83 	bl	1603a <memcpy>
        file->cache.block = lfs->pcache.block;
   12334:	6923      	ldr	r3, [r4, #16]
   12336:	642b      	str	r3, [r5, #64]	; 0x40
        file->cache.off = lfs->pcache.off;
   12338:	6963      	ldr	r3, [r4, #20]
   1233a:	646b      	str	r3, [r5, #68]	; 0x44
        file->cache.size = lfs->pcache.size;
   1233c:	69a3      	ldr	r3, [r4, #24]
   1233e:	64ab      	str	r3, [r5, #72]	; 0x48
        lfs_cache_zero(lfs, &lfs->pcache);
   12340:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   12342:	f104 0110 	add.w	r1, r4, #16
   12346:	f005 fcc3 	bl	17cd0 <lfs_cache_zero.isra.0>
        file->block = nblock;
   1234a:	9b05      	ldr	r3, [sp, #20]
   1234c:	63ab      	str	r3, [r5, #56]	; 0x38
        file->flags |= LFS_F_WRITING;
   1234e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   12350:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   12354:	632b      	str	r3, [r5, #48]	; 0x30
        return 0;
   12356:	e7a0      	b.n	1229a <lfs_file_relocate+0x2e>
        return LFS_ERR_CORRUPT;
   12358:	f06f 0053 	mvn.w	r0, #83	; 0x53
   1235c:	e7d0      	b.n	12300 <lfs_file_relocate+0x94>
        for (lfs_off_t i = 0; i < file->off; i++) {
   1235e:	4607      	mov	r7, r0
   12360:	f105 0840 	add.w	r8, r5, #64	; 0x40
                err = lfs_bd_read(lfs,
   12364:	f104 0a68 	add.w	sl, r4, #104	; 0x68
   12368:	e7db      	b.n	12322 <lfs_file_relocate+0xb6>
    rcache->block = LFS_BLOCK_NULL;
   1236a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1236e:	6123      	str	r3, [r4, #16]
   12370:	e783      	b.n	1227a <lfs_file_relocate+0xe>
   12372:	bf00      	nop
   12374:	20100000 	.word	0x20100000

00012378 <lfs_file_flush>:
static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
   12378:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (file->flags & LFS_F_READING) {
   1237a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
   1237c:	460c      	mov	r4, r1
    if (file->flags & LFS_F_READING) {
   1237e:	0359      	lsls	r1, r3, #13
static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
   12380:	b097      	sub	sp, #92	; 0x5c
   12382:	4605      	mov	r5, r0
    if (file->flags & LFS_F_READING) {
   12384:	d508      	bpl.n	12398 <lfs_file_flush+0x20>
        if (!(file->flags & LFS_F_INLINE)) {
   12386:	02da      	lsls	r2, r3, #11
    rcache->block = LFS_BLOCK_NULL;
   12388:	bf58      	it	pl
   1238a:	f04f 32ff 	movpl.w	r2, #4294967295	; 0xffffffff
        file->flags &= ~LFS_F_READING;
   1238e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    rcache->block = LFS_BLOCK_NULL;
   12392:	bf58      	it	pl
   12394:	6422      	strpl	r2, [r4, #64]	; 0x40
        file->flags &= ~LFS_F_READING;
   12396:	6323      	str	r3, [r4, #48]	; 0x30
    if (file->flags & LFS_F_WRITING) {
   12398:	6b21      	ldr	r1, [r4, #48]	; 0x30
   1239a:	f411 3000 	ands.w	r0, r1, #131072	; 0x20000
   1239e:	d02c      	beq.n	123fa <lfs_file_flush+0x82>
        if (!(file->flags & LFS_F_INLINE)) {
   123a0:	f411 1180 	ands.w	r1, r1, #1048576	; 0x100000
        lfs_off_t pos = file->pos;
   123a4:	6b66      	ldr	r6, [r4, #52]	; 0x34
        if (!(file->flags & LFS_F_INLINE)) {
   123a6:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   123a8:	d140      	bne.n	1242c <lfs_file_flush+0xb4>
            lfs_file_t orig = {
   123aa:	2254      	movs	r2, #84	; 0x54
   123ac:	a801      	add	r0, sp, #4
   123ae:	f003 fe6f 	bl	16090 <memset>
   123b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   123b4:	e9cd 370b 	strd	r3, r7, [sp, #44]	; 0x2c
   123b8:	4b25      	ldr	r3, [pc, #148]	; (12450 <lfs_file_flush+0xd8>)
   123ba:	e9cd 360d 	strd	r3, r6, [sp, #52]	; 0x34
   123be:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   123c2:	af11      	add	r7, sp, #68	; 0x44
   123c4:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    rcache->block = LFS_BLOCK_NULL;
   123c8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   123cc:	602f      	str	r7, [r5, #0]
            while (file->pos < file->ctz.size) {
   123ce:	6b62      	ldr	r2, [r4, #52]	; 0x34
   123d0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   123d2:	429a      	cmp	r2, r3
   123d4:	d313      	bcc.n	123fe <lfs_file_flush+0x86>
                int err = lfs_bd_flush(lfs, &file->cache, &lfs->rcache, true);
   123d6:	f104 0740 	add.w	r7, r4, #64	; 0x40
   123da:	2301      	movs	r3, #1
   123dc:	462a      	mov	r2, r5
   123de:	4639      	mov	r1, r7
   123e0:	4628      	mov	r0, r5
   123e2:	f005 fdb4 	bl	17f4e <lfs_bd_flush>
                if (err) {
   123e6:	b328      	cbz	r0, 12434 <lfs_file_flush+0xbc>
                    if (err == LFS_ERR_CORRUPT) {
   123e8:	f110 0f54 	cmn.w	r0, #84	; 0x54
   123ec:	d105      	bne.n	123fa <lfs_file_flush+0x82>
                err = lfs_file_relocate(lfs, file);
   123ee:	4621      	mov	r1, r4
   123f0:	4628      	mov	r0, r5
   123f2:	f7ff ff3b 	bl	1226c <lfs_file_relocate>
                if (err) {
   123f6:	2800      	cmp	r0, #0
   123f8:	d0ef      	beq.n	123da <lfs_file_flush+0x62>
}
   123fa:	b017      	add	sp, #92	; 0x5c
   123fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                lfs_ssize_t res = lfs_file_read(lfs, &orig, &data, 1);
   123fe:	2301      	movs	r3, #1
   12400:	f10d 0203 	add.w	r2, sp, #3
   12404:	a901      	add	r1, sp, #4
   12406:	4628      	mov	r0, r5
   12408:	f000 f824 	bl	12454 <lfs_file_read>
                if (res < 0) {
   1240c:	2800      	cmp	r0, #0
   1240e:	dbf4      	blt.n	123fa <lfs_file_flush+0x82>
                res = lfs_file_write(lfs, file, &data, 1);
   12410:	2301      	movs	r3, #1
   12412:	f10d 0203 	add.w	r2, sp, #3
   12416:	4621      	mov	r1, r4
   12418:	4628      	mov	r0, r5
   1241a:	f006 f805 	bl	18428 <lfs_file_write>
                if (res < 0) {
   1241e:	2800      	cmp	r0, #0
   12420:	dbeb      	blt.n	123fa <lfs_file_flush+0x82>
                if (lfs->rcache.block != LFS_BLOCK_NULL) {
   12422:	682b      	ldr	r3, [r5, #0]
   12424:	3301      	adds	r3, #1
   12426:	d0d2      	beq.n	123ce <lfs_file_flush+0x56>
    rcache->block = LFS_BLOCK_NULL;
   12428:	9711      	str	r7, [sp, #68]	; 0x44
   1242a:	e7cf      	b.n	123cc <lfs_file_flush+0x54>
            file->pos = lfs_max(file->pos, file->ctz.size);
   1242c:	42be      	cmp	r6, r7
   1242e:	bf2c      	ite	cs
   12430:	6366      	strcs	r6, [r4, #52]	; 0x34
   12432:	6367      	strcc	r7, [r4, #52]	; 0x34
        file->ctz.head = file->block;
   12434:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12436:	62a3      	str	r3, [r4, #40]	; 0x28
        file->ctz.size = file->pos;
   12438:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1243a:	62e3      	str	r3, [r4, #44]	; 0x2c
        file->flags &= ~LFS_F_WRITING;
   1243c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1243e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
        file->flags |= LFS_F_DIRTY;
   12442:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
        file->pos = pos;
   12446:	e9c4 360c 	strd	r3, r6, [r4, #48]	; 0x30
    return 0;
   1244a:	2000      	movs	r0, #0
   1244c:	e7d5      	b.n	123fa <lfs_file_flush+0x82>
   1244e:	bf00      	nop
   12450:	00200001 	.word	0x00200001

00012454 <lfs_file_read>:
        void *buffer, lfs_size_t size) {
   12454:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12458:	461d      	mov	r5, r3
    if (file->flags & LFS_F_WRITING) {
   1245a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   1245c:	039e      	lsls	r6, r3, #14
        void *buffer, lfs_size_t size) {
   1245e:	b085      	sub	sp, #20
   12460:	4607      	mov	r7, r0
   12462:	460c      	mov	r4, r1
   12464:	4690      	mov	r8, r2
    if (file->flags & LFS_F_WRITING) {
   12466:	d405      	bmi.n	12474 <lfs_file_read+0x20>
    if (file->pos >= file->ctz.size) {
   12468:	6b66      	ldr	r6, [r4, #52]	; 0x34
   1246a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1246c:	4296      	cmp	r6, r2
   1246e:	d308      	bcc.n	12482 <lfs_file_read+0x2e>
        return 0;
   12470:	2000      	movs	r0, #0
   12472:	e003      	b.n	1247c <lfs_file_read+0x28>
        int err = lfs_file_flush(lfs, file);
   12474:	f7ff ff80 	bl	12378 <lfs_file_flush>
        if (err) {
   12478:	2800      	cmp	r0, #0
   1247a:	d0f5      	beq.n	12468 <lfs_file_read+0x14>
}
   1247c:	b005      	add	sp, #20
   1247e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    size = lfs_min(size, file->ctz.size - file->pos);
   12482:	1b96      	subs	r6, r2, r6
    return (a < b) ? a : b;
   12484:	42ae      	cmp	r6, r5
   12486:	bf28      	it	cs
   12488:	462e      	movcs	r6, r5
            int err = lfs_dir_getread(lfs, &file->m,
   1248a:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 12550 <lfs_file_read+0xfc>
    nsize = size;
   1248e:	46b1      	mov	r9, r6
   12490:	f104 0a40 	add.w	sl, r4, #64	; 0x40
    while (nsize > 0) {
   12494:	f1b9 0f00 	cmp.w	r9, #0
   12498:	d101      	bne.n	1249e <lfs_file_read+0x4a>
    return size;
   1249a:	4630      	mov	r0, r6
   1249c:	e7ee      	b.n	1247c <lfs_file_read+0x28>
        if (!(file->flags & LFS_F_READING) ||
   1249e:	6b22      	ldr	r2, [r4, #48]	; 0x30
   124a0:	0351      	lsls	r1, r2, #13
   124a2:	d504      	bpl.n	124ae <lfs_file_read+0x5a>
                file->off == lfs->cfg->block_size) {
   124a4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
        if (!(file->flags & LFS_F_READING) ||
   124a6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   124a8:	69db      	ldr	r3, [r3, #28]
   124aa:	4299      	cmp	r1, r3
   124ac:	d115      	bne.n	124da <lfs_file_read+0x86>
            if (!(file->flags & LFS_F_INLINE)) {
   124ae:	02d2      	lsls	r2, r2, #11
   124b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   124b2:	d43a      	bmi.n	1252a <lfs_file_read+0xd6>
                int err = lfs_ctz_find(lfs, NULL, &file->cache,
   124b4:	f104 023c 	add.w	r2, r4, #60	; 0x3c
   124b8:	9202      	str	r2, [sp, #8]
   124ba:	f104 0238 	add.w	r2, r4, #56	; 0x38
   124be:	e9cd 3200 	strd	r3, r2, [sp]
   124c2:	4651      	mov	r1, sl
   124c4:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
   124c8:	4638      	mov	r0, r7
   124ca:	f005 fcc3 	bl	17e54 <lfs_ctz_find.constprop.0>
                if (err) {
   124ce:	2800      	cmp	r0, #0
   124d0:	d1d4      	bne.n	1247c <lfs_file_read+0x28>
            file->flags |= LFS_F_READING;
   124d2:	6b23      	ldr	r3, [r4, #48]	; 0x30
   124d4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   124d8:	6323      	str	r3, [r4, #48]	; 0x30
        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
   124da:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   124dc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   124de:	69db      	ldr	r3, [r3, #28]
        if (file->flags & LFS_F_INLINE) {
   124e0:	6b21      	ldr	r1, [r4, #48]	; 0x30
        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
   124e2:	1a9d      	subs	r5, r3, r2
   124e4:	454d      	cmp	r5, r9
   124e6:	bf28      	it	cs
   124e8:	464d      	movcs	r5, r9
        if (file->flags & LFS_F_INLINE) {
   124ea:	f411 1180 	ands.w	r1, r1, #1048576	; 0x100000
   124ee:	d021      	beq.n	12534 <lfs_file_read+0xe0>
                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),
   124f0:	88a0      	ldrh	r0, [r4, #4]
    if (off+size > lfs->cfg->block_size) {
   124f2:	eb02 0c05 	add.w	ip, r2, r5
   124f6:	4563      	cmp	r3, ip
            int err = lfs_dir_getread(lfs, &file->m,
   124f8:	f104 0108 	add.w	r1, r4, #8
   124fc:	ea4b 2080 	orr.w	r0, fp, r0, lsl #10
    if (off+size > lfs->cfg->block_size) {
   12500:	d323      	bcc.n	1254a <lfs_file_read+0xf6>
   12502:	e9cd 0200 	strd	r0, r2, [sp]
   12506:	e9cd 8502 	strd	r8, r5, [sp, #8]
   1250a:	4652      	mov	r2, sl
   1250c:	4638      	mov	r0, r7
   1250e:	f7ff fb97 	bl	11c40 <lfs_dir_getread.part.0.constprop.0>
            if (err) {
   12512:	2800      	cmp	r0, #0
   12514:	d1b2      	bne.n	1247c <lfs_file_read+0x28>
        file->pos += diff;
   12516:	6b63      	ldr	r3, [r4, #52]	; 0x34
   12518:	442b      	add	r3, r5
   1251a:	6363      	str	r3, [r4, #52]	; 0x34
        file->off += diff;
   1251c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1251e:	442b      	add	r3, r5
   12520:	63e3      	str	r3, [r4, #60]	; 0x3c
        data += diff;
   12522:	44a8      	add	r8, r5
        nsize -= diff;
   12524:	eba9 0905 	sub.w	r9, r9, r5
   12528:	e7b4      	b.n	12494 <lfs_file_read+0x40>
                file->block = LFS_BLOCK_INLINE;
   1252a:	f06f 0201 	mvn.w	r2, #1
                file->off = file->pos;
   1252e:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
   12532:	e7ce      	b.n	124d2 <lfs_file_read+0x7e>
            int err = lfs_bd_read(lfs,
   12534:	9201      	str	r2, [sp, #4]
   12536:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12538:	9200      	str	r2, [sp, #0]
   1253a:	e9cd 8502 	strd	r8, r5, [sp, #8]
   1253e:	4652      	mov	r2, sl
   12540:	f107 0068 	add.w	r0, r7, #104	; 0x68
   12544:	f005 faba 	bl	17abc <lfs_bd_read.isra.0>
   12548:	e7e3      	b.n	12512 <lfs_file_read+0xbe>
        return LFS_ERR_CORRUPT;
   1254a:	f06f 0053 	mvn.w	r0, #83	; 0x53
   1254e:	e795      	b.n	1247c <lfs_file_read+0x28>
   12550:	20100000 	.word	0x20100000

00012554 <lfs_fs_size>:
    lfs_size_t *size = p;
    *size += 1;
    return 0;
}

lfs_ssize_t lfs_fs_size(lfs_t *lfs) {
   12554:	b507      	push	{r0, r1, r2, lr}
    LFS_TRACE("lfs_fs_size(%p)", (void*)lfs);
    lfs_size_t size = 0;
   12556:	2300      	movs	r3, #0
    int err = lfs_fs_traverseraw(lfs, lfs_fs_size_count, &size, false);
   12558:	4904      	ldr	r1, [pc, #16]	; (1256c <lfs_fs_size+0x18>)
    lfs_size_t size = 0;
   1255a:	9301      	str	r3, [sp, #4]
    int err = lfs_fs_traverseraw(lfs, lfs_fs_size_count, &size, false);
   1255c:	aa01      	add	r2, sp, #4
   1255e:	f7ff fd4b 	bl	11ff8 <lfs_fs_traverseraw>
    if (err) {
   12562:	b900      	cbnz	r0, 12566 <lfs_fs_size+0x12>
        LFS_TRACE("lfs_fs_size -> %d", err);
        return err;
    }

    LFS_TRACE("lfs_fs_size -> %d", err);
    return size;
   12564:	9801      	ldr	r0, [sp, #4]
}
   12566:	b003      	add	sp, #12
   12568:	f85d fb04 	ldr.w	pc, [sp], #4
   1256c:	00017a6d 	.word	0x00017a6d

00012570 <lfs_dir_compact>:
        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
   12570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12574:	b09d      	sub	sp, #116	; 0x74
   12576:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    const lfs_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};
   1257a:	680b      	ldr	r3, [r1, #0]
   1257c:	930c      	str	r3, [sp, #48]	; 0x30
        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
   1257e:	f8bd 809c 	ldrh.w	r8, [sp, #156]	; 0x9c
    const lfs_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};
   12582:	684b      	ldr	r3, [r1, #4]
        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
   12584:	f8bd a0a0 	ldrh.w	sl, [sp, #160]	; 0xa0
        int err = lfs_dir_traverse(lfs,
   12588:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 12938 <lfs_dir_compact+0x3c8>
    const lfs_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};
   1258c:	930d      	str	r3, [sp, #52]	; 0x34
        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
   1258e:	4605      	mov	r5, r0
   12590:	460e      	mov	r6, r1
        lfs_size_t size = 0;
   12592:	f04f 0900 	mov.w	r9, #0
    while (end - begin > 1) {
   12596:	ebaa 0708 	sub.w	r7, sl, r8
   1259a:	2f01      	cmp	r7, #1
   1259c:	dc4d      	bgt.n	1263a <lfs_dir_compact+0xca>
    if (lfs->cfg->block_cycles > 0 &&
   1259e:	6eab      	ldr	r3, [r5, #104]	; 0x68
    dir->rev += 1;
   125a0:	68b2      	ldr	r2, [r6, #8]
    if (lfs->cfg->block_cycles > 0 &&
   125a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    dir->rev += 1;
   125a4:	3201      	adds	r2, #1
    if (lfs->cfg->block_cycles > 0 &&
   125a6:	2b00      	cmp	r3, #0
    dir->rev += 1;
   125a8:	60b2      	str	r2, [r6, #8]
    if (lfs->cfg->block_cycles > 0 &&
   125aa:	dd2c      	ble.n	12606 <lfs_dir_compact+0x96>
            (dir->rev % ((lfs->cfg->block_cycles+1)|1) == 0)) {
   125ac:	3301      	adds	r3, #1
   125ae:	f043 0301 	orr.w	r3, r3, #1
   125b2:	fbb2 f1f3 	udiv	r1, r2, r3
   125b6:	fb03 2311 	mls	r3, r3, r1, r2
    if (lfs->cfg->block_cycles > 0 &&
   125ba:	bb23      	cbnz	r3, 12606 <lfs_dir_compact+0x96>
        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
   125bc:	2401      	movs	r4, #1
   125be:	a914      	add	r1, sp, #80	; 0x50
   125c0:	4630      	mov	r0, r6
   125c2:	9314      	str	r3, [sp, #80]	; 0x50
   125c4:	9415      	str	r4, [sp, #84]	; 0x54
   125c6:	f005 f9f5 	bl	179b4 <lfs_pair_cmp>
   125ca:	2800      	cmp	r0, #0
   125cc:	f040 8084 	bne.w	126d8 <lfs_dir_compact+0x168>
            lfs_ssize_t res = lfs_fs_size(lfs);
   125d0:	4628      	mov	r0, r5
   125d2:	f7ff ffbf 	bl	12554 <lfs_fs_size>
            if (res < 0) {
   125d6:	1e04      	subs	r4, r0, #0
   125d8:	db78      	blt.n	126cc <lfs_dir_compact+0x15c>
            if ((lfs_size_t)res < lfs->cfg->block_count/2) {
   125da:	6eab      	ldr	r3, [r5, #104]	; 0x68
   125dc:	6a1b      	ldr	r3, [r3, #32]
   125de:	ebb4 0f53 	cmp.w	r4, r3, lsr #1
   125e2:	d210      	bcs.n	12606 <lfs_dir_compact+0x96>
                int err = lfs_dir_split(lfs, dir, attrs, attrcount,
   125e4:	9b26      	ldr	r3, [sp, #152]	; 0x98
   125e6:	9300      	str	r3, [sp, #0]
   125e8:	e9cd 8a01 	strd	r8, sl, [sp, #4]
   125ec:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   125f0:	4631      	mov	r1, r6
   125f2:	4628      	mov	r0, r5
   125f4:	f006 f95f 	bl	188b6 <lfs_dir_split>
                if (err && err != LFS_ERR_NOSPC) {
   125f8:	4604      	mov	r4, r0
   125fa:	2800      	cmp	r0, #0
   125fc:	f000 808e 	beq.w	1271c <lfs_dir_compact+0x1ac>
   12600:	f110 0f1c 	cmn.w	r0, #28
   12604:	d162      	bne.n	126cc <lfs_dir_compact+0x15c>
    bool relocated = false;
   12606:	f04f 0900 	mov.w	r9, #0
                .end = lfs->cfg->block_size - 8,
   1260a:	6ea8      	ldr	r0, [r5, #104]	; 0x68
                .block = dir->pair[1],
   1260c:	6871      	ldr	r1, [r6, #4]
            struct lfs_commit commit = {
   1260e:	9114      	str	r1, [sp, #80]	; 0x50
   12610:	2300      	movs	r3, #0
   12612:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
   12616:	e9cd 3b15 	strd	r3, fp, [sp, #84]	; 0x54
   1261a:	e9cd b317 	strd	fp, r3, [sp, #92]	; 0x5c
                .end = lfs->cfg->block_size - 8,
   1261e:	69c3      	ldr	r3, [r0, #28]
   12620:	3b08      	subs	r3, #8
            struct lfs_commit commit = {
   12622:	9319      	str	r3, [sp, #100]	; 0x64
    int err = lfs->cfg->erase(lfs->cfg, block);
   12624:	68c3      	ldr	r3, [r0, #12]
   12626:	4798      	blx	r3
            if (err) {
   12628:	4604      	mov	r4, r0
   1262a:	2800      	cmp	r0, #0
   1262c:	d078      	beq.n	12720 <lfs_dir_compact+0x1b0>
                if (err == LFS_ERR_CORRUPT) {
   1262e:	f114 0f54 	cmn.w	r4, #84	; 0x54
   12632:	d14b      	bne.n	126cc <lfs_dir_compact+0x15c>
                    goto relocate;
   12634:	f04f 0b00 	mov.w	fp, #0
   12638:	e04f      	b.n	126da <lfs_dir_compact+0x16a>
        int err = lfs_dir_traverse(lfs,
   1263a:	ab14      	add	r3, sp, #80	; 0x50
   1263c:	9308      	str	r3, [sp, #32]
   1263e:	4bb8      	ldr	r3, [pc, #736]	; (12920 <lfs_dir_compact+0x3b0>)
   12640:	9307      	str	r3, [sp, #28]
   12642:	f1c8 0300 	rsb	r3, r8, #0
   12646:	b21b      	sxth	r3, r3
   12648:	e9cd a305 	strd	sl, r3, [sp, #20]
   1264c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1264e:	9301      	str	r3, [sp, #4]
   12650:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   12652:	9300      	str	r3, [sp, #0]
   12654:	e9cd 9803 	strd	r9, r8, [sp, #12]
   12658:	9926      	ldr	r1, [sp, #152]	; 0x98
   1265a:	f8cd b008 	str.w	fp, [sp, #8]
   1265e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12662:	2200      	movs	r2, #0
   12664:	4628      	mov	r0, r5
        lfs_size_t size = 0;
   12666:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
        int err = lfs_dir_traverse(lfs,
   1266a:	f7ff f87d 	bl	11768 <lfs_dir_traverse>
        if (err) {
   1266e:	4604      	mov	r4, r0
   12670:	bb60      	cbnz	r0, 126cc <lfs_dir_compact+0x15c>
        if (end - begin < 0xff &&
   12672:	2ffe      	cmp	r7, #254	; 0xfe
   12674:	dc11      	bgt.n	1269a <lfs_dir_compact+0x12a>
                size <= lfs_min(lfs->cfg->block_size - 36,
   12676:	6eab      	ldr	r3, [r5, #104]	; 0x68
   12678:	e9d3 0206 	ldrd	r0, r2, [r3, #24]
    return lfs_aligndown(a + alignment-1, alignment);
   1267c:	1e43      	subs	r3, r0, #1
   1267e:	eb03 0352 	add.w	r3, r3, r2, lsr #1
    return a - (a % alignment);
   12682:	fbb3 f1f0 	udiv	r1, r3, r0
   12686:	fb00 3111 	mls	r1, r0, r1, r3
   1268a:	1a5b      	subs	r3, r3, r1
   1268c:	3a24      	subs	r2, #36	; 0x24
    return (a < b) ? a : b;
   1268e:	4293      	cmp	r3, r2
   12690:	bf28      	it	cs
   12692:	4613      	movcs	r3, r2
        if (end - begin < 0xff &&
   12694:	9a14      	ldr	r2, [sp, #80]	; 0x50
   12696:	429a      	cmp	r2, r3
   12698:	d981      	bls.n	1259e <lfs_dir_compact+0x2e>
        err = lfs_dir_split(lfs, dir, attrs, attrcount,
   1269a:	eb08 0767 	add.w	r7, r8, r7, asr #1
   1269e:	9b26      	ldr	r3, [sp, #152]	; 0x98
   126a0:	9300      	str	r3, [sp, #0]
   126a2:	b2bf      	uxth	r7, r7
   126a4:	e9cd 7a01 	strd	r7, sl, [sp, #4]
   126a8:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   126ac:	4631      	mov	r1, r6
   126ae:	4628      	mov	r0, r5
   126b0:	f006 f901 	bl	188b6 <lfs_dir_split>
        if (err) {
   126b4:	4604      	mov	r4, r0
   126b6:	b168      	cbz	r0, 126d4 <lfs_dir_compact+0x164>
            if (err == LFS_ERR_NOSPC && size <= lfs->cfg->block_size - 36) {
   126b8:	f110 0f1c 	cmn.w	r0, #28
   126bc:	d106      	bne.n	126cc <lfs_dir_compact+0x15c>
   126be:	6eab      	ldr	r3, [r5, #104]	; 0x68
   126c0:	9a14      	ldr	r2, [sp, #80]	; 0x50
   126c2:	69db      	ldr	r3, [r3, #28]
   126c4:	3b24      	subs	r3, #36	; 0x24
   126c6:	4293      	cmp	r3, r2
   126c8:	f4bf af69 	bcs.w	1259e <lfs_dir_compact+0x2e>
}
   126cc:	4620      	mov	r0, r4
   126ce:	b01d      	add	sp, #116	; 0x74
   126d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        end = begin + split;
   126d4:	46ba      	mov	sl, r7
   126d6:	e75e      	b.n	12596 <lfs_dir_compact+0x26>
            tired = true;
   126d8:	46a3      	mov	fp, r4
    rcache->block = LFS_BLOCK_NULL;
   126da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   126de:	612b      	str	r3, [r5, #16]
        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
   126e0:	2701      	movs	r7, #1
   126e2:	2300      	movs	r3, #0
   126e4:	a914      	add	r1, sp, #80	; 0x50
   126e6:	4630      	mov	r0, r6
   126e8:	e9cd 3714 	strd	r3, r7, [sp, #80]	; 0x50
   126ec:	f005 f962 	bl	179b4 <lfs_pair_cmp>
   126f0:	2800      	cmp	r0, #0
   126f2:	f040 80ac 	bne.w	1284e <lfs_dir_compact+0x2de>
   126f6:	4a8b      	ldr	r2, [pc, #556]	; (12924 <lfs_dir_compact+0x3b4>)
   126f8:	4b8b      	ldr	r3, [pc, #556]	; (12928 <lfs_dir_compact+0x3b8>)
            LFS_WARN("Superblock 0x%"PRIx32" has become unwritable",
   126fa:	498c      	ldr	r1, [pc, #560]	; (1292c <lfs_dir_compact+0x3bc>)
   126fc:	488c      	ldr	r0, [pc, #560]	; (12930 <lfs_dir_compact+0x3c0>)
   126fe:	1a9b      	subs	r3, r3, r2
   12700:	08db      	lsrs	r3, r3, #3
   12702:	019b      	lsls	r3, r3, #6
   12704:	f043 0302 	orr.w	r3, r3, #2
   12708:	f8ad 3000 	strh.w	r3, [sp]
   1270c:	f240 629a 	movw	r2, #1690	; 0x69a
   12710:	6873      	ldr	r3, [r6, #4]
   12712:	f002 fdd4 	bl	152be <log_3>
            return LFS_ERR_NOSPC;
   12716:	f06f 041b 	mvn.w	r4, #27
   1271a:	e7d7      	b.n	126cc <lfs_dir_compact+0x15c>
                    end = begin;
   1271c:	46c2      	mov	sl, r8
   1271e:	e772      	b.n	12606 <lfs_dir_compact+0x96>
            err = lfs_dir_commitprog(lfs, &commit,
   12720:	af14      	add	r7, sp, #80	; 0x50
   12722:	2304      	movs	r3, #4
   12724:	f106 0208 	add.w	r2, r6, #8
   12728:	4639      	mov	r1, r7
   1272a:	4628      	mov	r0, r5
   1272c:	f005 fc99 	bl	18062 <lfs_dir_commitprog>
            if (err) {
   12730:	4604      	mov	r4, r0
   12732:	2800      	cmp	r0, #0
   12734:	f47f af7b 	bne.w	1262e <lfs_dir_compact+0xbe>
            err = lfs_dir_traverse(lfs,
   12738:	ab0e      	add	r3, sp, #56	; 0x38
   1273a:	9308      	str	r3, [sp, #32]
   1273c:	4b7d      	ldr	r3, [pc, #500]	; (12934 <lfs_dir_compact+0x3c4>)
   1273e:	9307      	str	r3, [sp, #28]
   12740:	f1c8 0300 	rsb	r3, r8, #0
   12744:	b21b      	sxth	r3, r3
   12746:	e9cd a305 	strd	sl, r3, [sp, #20]
   1274a:	4b7b      	ldr	r3, [pc, #492]	; (12938 <lfs_dir_compact+0x3c8>)
   1274c:	9302      	str	r3, [sp, #8]
   1274e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12750:	9301      	str	r3, [sp, #4]
   12752:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   12754:	9300      	str	r3, [sp, #0]
   12756:	e9cd 0803 	strd	r0, r8, [sp, #12]
   1275a:	4602      	mov	r2, r0
   1275c:	9926      	ldr	r1, [sp, #152]	; 0x98
   1275e:	465b      	mov	r3, fp
   12760:	4628      	mov	r0, r5
                    lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
   12762:	e9cd 570e 	strd	r5, r7, [sp, #56]	; 0x38
            err = lfs_dir_traverse(lfs,
   12766:	f7fe ffff 	bl	11768 <lfs_dir_traverse>
            if (err) {
   1276a:	4604      	mov	r4, r0
   1276c:	2800      	cmp	r0, #0
   1276e:	f47f af5e 	bne.w	1262e <lfs_dir_compact+0xbe>
            if (!lfs_pair_isnull(dir->tail)) {
   12772:	f106 0118 	add.w	r1, r6, #24
   12776:	4608      	mov	r0, r1
   12778:	f005 f912 	bl	179a0 <lfs_pair_isnull>
   1277c:	b970      	cbnz	r0, 1279c <lfs_dir_compact+0x22c>
                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
   1277e:	7df2      	ldrb	r2, [r6, #23]
                err = lfs_dir_commitattr(lfs, &commit,
   12780:	460b      	mov	r3, r1
   12782:	496e      	ldr	r1, [pc, #440]	; (1293c <lfs_dir_compact+0x3cc>)
                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
   12784:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
                err = lfs_dir_commitattr(lfs, &commit,
   12788:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
   1278c:	4628      	mov	r0, r5
   1278e:	4639      	mov	r1, r7
   12790:	f005 fc86 	bl	180a0 <lfs_dir_commitattr>
                if (err) {
   12794:	4604      	mov	r4, r0
   12796:	2800      	cmp	r0, #0
   12798:	f47f af49 	bne.w	1262e <lfs_dir_compact+0xbe>
            lfs_gstate_t delta = {0};
   1279c:	2300      	movs	r3, #0
   1279e:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
   127a2:	9312      	str	r3, [sp, #72]	; 0x48
            if (!relocated) {
   127a4:	f1b9 0f00 	cmp.w	r9, #0
   127a8:	d109      	bne.n	127be <lfs_dir_compact+0x24e>
                lfs_gstate_xor(&delta, &lfs->gdisk);
   127aa:	f105 013c 	add.w	r1, r5, #60	; 0x3c
   127ae:	a810      	add	r0, sp, #64	; 0x40
   127b0:	f005 f91b 	bl	179ea <lfs_gstate_xor>
                lfs_gstate_xor(&delta, &lfs->gstate);
   127b4:	f105 0130 	add.w	r1, r5, #48	; 0x30
   127b8:	a810      	add	r0, sp, #64	; 0x40
   127ba:	f005 f916 	bl	179ea <lfs_gstate_xor>
            lfs_gstate_xor(&delta, &lfs->gdelta);
   127be:	f105 0b48 	add.w	fp, r5, #72	; 0x48
   127c2:	4659      	mov	r1, fp
   127c4:	a810      	add	r0, sp, #64	; 0x40
   127c6:	f005 f910 	bl	179ea <lfs_gstate_xor>
            delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
   127ca:	9b10      	ldr	r3, [sp, #64]	; 0x40
   127cc:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
   127d0:	f023 0303 	bic.w	r3, r3, #3
            err = lfs_dir_getgstate(lfs, dir, &delta);
   127d4:	aa10      	add	r2, sp, #64	; 0x40
   127d6:	4631      	mov	r1, r6
   127d8:	4628      	mov	r0, r5
            delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
   127da:	9310      	str	r3, [sp, #64]	; 0x40
            err = lfs_dir_getgstate(lfs, dir, &delta);
   127dc:	f7ff f928 	bl	11a30 <lfs_dir_getgstate>
            if (err) {
   127e0:	4604      	mov	r4, r0
   127e2:	2800      	cmp	r0, #0
   127e4:	f47f af72 	bne.w	126cc <lfs_dir_compact+0x15c>
        if (((uint32_t*)a)[i] != 0) {
   127e8:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
   127ec:	4313      	orrs	r3, r2
   127ee:	9a12      	ldr	r2, [sp, #72]	; 0x48
   127f0:	4313      	orrs	r3, r2
   127f2:	d009      	beq.n	12808 <lfs_dir_compact+0x298>
                err = lfs_dir_commitattr(lfs, &commit,
   127f4:	4a52      	ldr	r2, [pc, #328]	; (12940 <lfs_dir_compact+0x3d0>)
   127f6:	ab10      	add	r3, sp, #64	; 0x40
   127f8:	4639      	mov	r1, r7
   127fa:	4628      	mov	r0, r5
   127fc:	f005 fc50 	bl	180a0 <lfs_dir_commitattr>
                if (err) {
   12800:	4604      	mov	r4, r0
   12802:	2800      	cmp	r0, #0
   12804:	f47f af13 	bne.w	1262e <lfs_dir_compact+0xbe>
            err = lfs_dir_commitcrc(lfs, &commit);
   12808:	4639      	mov	r1, r7
   1280a:	4628      	mov	r0, r5
   1280c:	f005 fca9 	bl	18162 <lfs_dir_commitcrc>
            if (err) {
   12810:	4604      	mov	r4, r0
   12812:	2800      	cmp	r0, #0
   12814:	f47f af0b 	bne.w	1262e <lfs_dir_compact+0xbe>
    pair[0] = pair[1];
   12818:	e9d6 3200 	ldrd	r3, r2, [r6]
    pair[1] = t;
   1281c:	e9c6 2300 	strd	r2, r3, [r6]
            dir->off = commit.off;
   12820:	9b15      	ldr	r3, [sp, #84]	; 0x54
   12822:	60f3      	str	r3, [r6, #12]
            dir->count = end - begin;
   12824:	ebaa 0808 	sub.w	r8, sl, r8
            dir->etag = commit.ptag;
   12828:	9b16      	ldr	r3, [sp, #88]	; 0x58
            dir->count = end - begin;
   1282a:	f8a6 8014 	strh.w	r8, [r6, #20]
            dir->etag = commit.ptag;
   1282e:	6133      	str	r3, [r6, #16]
            lfs->gdelta = (lfs_gstate_t){0};
   12830:	64a8      	str	r0, [r5, #72]	; 0x48
   12832:	e9cb 0001 	strd	r0, r0, [fp, #4]
            if (!relocated) {
   12836:	f1b9 0f00 	cmp.w	r9, #0
   1283a:	f040 80b9 	bne.w	129b0 <lfs_dir_compact+0x440>
                lfs->gdisk = lfs->gstate;
   1283e:	f105 033c 	add.w	r3, r5, #60	; 0x3c
   12842:	3530      	adds	r5, #48	; 0x30
   12844:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   12848:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    if (relocated) {
   1284c:	e73e      	b.n	126cc <lfs_dir_compact+0x15c>
        int err = lfs_alloc(lfs, &dir->pair[1]);
   1284e:	1d31      	adds	r1, r6, #4
   12850:	4628      	mov	r0, r5
   12852:	f7ff fc81 	bl	12158 <lfs_alloc>
        relocated = true;
   12856:	46b9      	mov	r9, r7
        if (err && (err != LFS_ERR_NOSPC || !tired)) {
   12858:	4604      	mov	r4, r0
   1285a:	2800      	cmp	r0, #0
   1285c:	f43f aed5 	beq.w	1260a <lfs_dir_compact+0x9a>
   12860:	f110 0f1c 	cmn.w	r0, #28
   12864:	f47f af32 	bne.w	126cc <lfs_dir_compact+0x15c>
   12868:	f1bb 0f00 	cmp.w	fp, #0
   1286c:	f43f af2e 	beq.w	126cc <lfs_dir_compact+0x15c>
        relocated = true;
   12870:	46d9      	mov	r9, fp
   12872:	e6ca      	b.n	1260a <lfs_dir_compact+0x9a>
        if (lfs_pair_cmp(oldpair, d->m.pair) == 0) {
   12874:	f109 0108 	add.w	r1, r9, #8
   12878:	a80c      	add	r0, sp, #48	; 0x30
   1287a:	f005 f89b 	bl	179b4 <lfs_pair_cmp>
   1287e:	b928      	cbnz	r0, 1288c <lfs_dir_compact+0x31c>
            d->m.pair[0] = newpair[0];
   12880:	6833      	ldr	r3, [r6, #0]
   12882:	f8c9 3008 	str.w	r3, [r9, #8]
            d->m.pair[1] = newpair[1];
   12886:	6873      	ldr	r3, [r6, #4]
   12888:	f8c9 300c 	str.w	r3, [r9, #12]
        if (d->type == LFS_TYPE_DIR &&
   1288c:	f899 3006 	ldrb.w	r3, [r9, #6]
   12890:	2b02      	cmp	r3, #2
   12892:	d10b      	bne.n	128ac <lfs_dir_compact+0x33c>
                lfs_pair_cmp(oldpair, ((lfs_dir_t*)d)->head) == 0) {
   12894:	f109 012c 	add.w	r1, r9, #44	; 0x2c
   12898:	a80c      	add	r0, sp, #48	; 0x30
   1289a:	f005 f88b 	bl	179b4 <lfs_pair_cmp>
        if (d->type == LFS_TYPE_DIR &&
   1289e:	b928      	cbnz	r0, 128ac <lfs_dir_compact+0x33c>
            ((lfs_dir_t*)d)->head[0] = newpair[0];
   128a0:	6833      	ldr	r3, [r6, #0]
   128a2:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
            ((lfs_dir_t*)d)->head[1] = newpair[1];
   128a6:	6873      	ldr	r3, [r6, #4]
   128a8:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   128ac:	f8d9 9000 	ldr.w	r9, [r9]
   128b0:	e08a      	b.n	129c8 <lfs_dir_compact+0x458>
        lfs_fs_preporphans(lfs, +1);
   128b2:	f105 0a30 	add.w	sl, r5, #48	; 0x30
   128b6:	2101      	movs	r1, #1
   128b8:	4650      	mov	r0, sl
   128ba:	f005 f8f2 	bl	17aa2 <lfs_fs_preporphans.isra.0>
        if (lfs_gstate_hasmovehere(&lfs->gstate, parent.pair)) {
   128be:	4639      	mov	r1, r7
   128c0:	f005 f8a1 	bl	17a06 <lfs_gstate_hasmovehere>
   128c4:	b348      	cbz	r0, 1291a <lfs_dir_compact+0x3aa>
            moveid = lfs_tag_id(lfs->gstate.tag);
   128c6:	6b29      	ldr	r1, [r5, #48]	; 0x30
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   128c8:	4b1e      	ldr	r3, [pc, #120]	; (12944 <lfs_dir_compact+0x3d4>)
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
   128ca:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   128ce:	400b      	ands	r3, r1
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
   128d0:	e9c5 390c 	strd	r3, r9, [r5, #48]	; 0x30
    return (tag & 0x000ffc00) >> 10;
   128d4:	f3c1 2289 	ubfx	r2, r1, #10, #10
            if (moveid < lfs_tag_id(tag)) {
   128d8:	f3c8 2389 	ubfx	r3, r8, #10, #10
   128dc:	429a      	cmp	r2, r3
   128de:	d201      	bcs.n	128e4 <lfs_dir_compact+0x374>
                tag -= LFS_MKTAG(0, 1, 0);
   128e0:	f5a8 6880 	sub.w	r8, r8, #1024	; 0x400
        int err = lfs_dir_commit(lfs, &parent, LFS_MKATTRS(
   128e4:	f240 31ff 	movw	r1, #1023	; 0x3ff
   128e8:	2300      	movs	r3, #0
   128ea:	428a      	cmp	r2, r1
   128ec:	9311      	str	r3, [sp, #68]	; 0x44
   128ee:	bf1c      	itt	ne
   128f0:	4b15      	ldrne	r3, [pc, #84]	; (12948 <lfs_dir_compact+0x3d8>)
   128f2:	ea43 2382 	orrne.w	r3, r3, r2, lsl #10
   128f6:	9310      	str	r3, [sp, #64]	; 0x40
   128f8:	aa10      	add	r2, sp, #64	; 0x40
   128fa:	2302      	movs	r3, #2
   128fc:	4639      	mov	r1, r7
   128fe:	4628      	mov	r0, r5
   12900:	e9cd 8612 	strd	r8, r6, [sp, #72]	; 0x48
   12904:	f000 f884 	bl	12a10 <lfs_dir_commit>
        if (err) {
   12908:	4680      	mov	r8, r0
   1290a:	2800      	cmp	r0, #0
   1290c:	d178      	bne.n	12a00 <lfs_dir_compact+0x490>
        lfs_fs_preporphans(lfs, -1);
   1290e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   12912:	4650      	mov	r0, sl
   12914:	f005 f8c5 	bl	17aa2 <lfs_fs_preporphans.isra.0>
   12918:	e066      	b.n	129e8 <lfs_dir_compact+0x478>
        uint16_t moveid = 0x3ff;
   1291a:	f240 32ff 	movw	r2, #1023	; 0x3ff
   1291e:	e7e1      	b.n	128e4 <lfs_dir_compact+0x374>
   12920:	00017a59 	.word	0x00017a59
   12924:	0001956c 	.word	0x0001956c
   12928:	0001960c 	.word	0x0001960c
   1292c:	0001c068 	.word	0x0001c068
   12930:	0001c165 	.word	0x0001c165
   12934:	00018157 	.word	0x00018157
   12938:	400ffc00 	.word	0x400ffc00
   1293c:	000ffc08 	.word	0x000ffc08
   12940:	7ffffc0c 	.word	0x7ffffc0c
   12944:	800003ff 	.word	0x800003ff
   12948:	4ff00000 	.word	0x4ff00000
        if (lfs_gstate_hasmovehere(&lfs->gstate, parent.pair)) {
   1294c:	4639      	mov	r1, r7
   1294e:	f105 0030 	add.w	r0, r5, #48	; 0x30
   12952:	f005 f858 	bl	17a06 <lfs_gstate_hasmovehere>
   12956:	b9b0      	cbnz	r0, 12986 <lfs_dir_compact+0x416>
        err = lfs_dir_commit(lfs, &parent, LFS_MKATTRS(
   12958:	9011      	str	r0, [sp, #68]	; 0x44
   1295a:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
   1295e:	9010      	str	r0, [sp, #64]	; 0x40
   12960:	f503 62c0 	add.w	r2, r3, #1536	; 0x600
   12964:	4b27      	ldr	r3, [pc, #156]	; (12a04 <lfs_dir_compact+0x494>)
   12966:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
   1296a:	e9cd 3612 	strd	r3, r6, [sp, #72]	; 0x48
   1296e:	aa10      	add	r2, sp, #64	; 0x40
   12970:	2302      	movs	r3, #2
   12972:	4639      	mov	r1, r7
   12974:	4628      	mov	r0, r5
   12976:	f000 f84b 	bl	12a10 <lfs_dir_commit>
        if (err) {
   1297a:	4604      	mov	r4, r0
   1297c:	2800      	cmp	r0, #0
   1297e:	f43f aea5 	beq.w	126cc <lfs_dir_compact+0x15c>
            return err;
   12982:	4680      	mov	r8, r0
   12984:	e03c      	b.n	12a00 <lfs_dir_compact+0x490>
            moveid = lfs_tag_id(lfs->gstate.tag);
   12986:	6b29      	ldr	r1, [r5, #48]	; 0x30
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   12988:	4b1f      	ldr	r3, [pc, #124]	; (12a08 <lfs_dir_compact+0x498>)
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
   1298a:	f8c5 8038 	str.w	r8, [r5, #56]	; 0x38
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   1298e:	400b      	ands	r3, r1
    return (tag & 0x000ffc00) >> 10;
   12990:	f3c1 2289 	ubfx	r2, r1, #10, #10
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
   12994:	e9c5 380c 	strd	r3, r8, [r5, #48]	; 0x30
        err = lfs_dir_commit(lfs, &parent, LFS_MKATTRS(
   12998:	f240 33ff 	movw	r3, #1023	; 0x3ff
   1299c:	429a      	cmp	r2, r3
   1299e:	bf18      	it	ne
   129a0:	481a      	ldrne	r0, [pc, #104]	; (12a0c <lfs_dir_compact+0x49c>)
   129a2:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
   129a6:	bf14      	ite	ne
   129a8:	ea40 2082 	orrne.w	r0, r0, r2, lsl #10
   129ac:	4640      	moveq	r0, r8
   129ae:	e7d4      	b.n	1295a <lfs_dir_compact+0x3ea>
    if (lfs_pair_cmp(oldpair, lfs->root) == 0) {
   129b0:	f105 0120 	add.w	r1, r5, #32
   129b4:	a80c      	add	r0, sp, #48	; 0x30
   129b6:	f004 fffd 	bl	179b4 <lfs_pair_cmp>
   129ba:	b918      	cbnz	r0, 129c4 <lfs_dir_compact+0x454>
        lfs->root[0] = newpair[0];
   129bc:	6833      	ldr	r3, [r6, #0]
   129be:	622b      	str	r3, [r5, #32]
        lfs->root[1] = newpair[1];
   129c0:	6873      	ldr	r3, [r6, #4]
   129c2:	626b      	str	r3, [r5, #36]	; 0x24
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   129c4:	f8d5 9028 	ldr.w	r9, [r5, #40]	; 0x28
   129c8:	f1b9 0f00 	cmp.w	r9, #0
   129cc:	f47f af52 	bne.w	12874 <lfs_dir_compact+0x304>
    lfs_stag_t tag = lfs_fs_parent(lfs, oldpair, &parent);
   129d0:	463a      	mov	r2, r7
   129d2:	a90c      	add	r1, sp, #48	; 0x30
   129d4:	4628      	mov	r0, r5
   129d6:	f7fe fe89 	bl	116ec <lfs_fs_parent>
    if (tag < 0 && tag != LFS_ERR_NOENT) {
   129da:	f1b0 0800 	subs.w	r8, r0, #0
   129de:	f6bf af68 	bge.w	128b2 <lfs_dir_compact+0x342>
   129e2:	f118 0f02 	cmn.w	r8, #2
   129e6:	d10b      	bne.n	12a00 <lfs_dir_compact+0x490>
    int err = lfs_fs_pred(lfs, oldpair, &parent);
   129e8:	463a      	mov	r2, r7
   129ea:	a90c      	add	r1, sp, #48	; 0x30
   129ec:	4628      	mov	r0, r5
   129ee:	f005 f93a 	bl	17c66 <lfs_fs_pred>
    if (err && err != LFS_ERR_NOENT) {
   129f2:	4680      	mov	r8, r0
   129f4:	2800      	cmp	r0, #0
   129f6:	d0a9      	beq.n	1294c <lfs_dir_compact+0x3dc>
   129f8:	f110 0f02 	cmn.w	r0, #2
   129fc:	f43f ae66 	beq.w	126cc <lfs_dir_compact+0x15c>
        if (err) {
   12a00:	4644      	mov	r4, r8
   12a02:	e663      	b.n	126cc <lfs_dir_compact+0x15c>
   12a04:	000ffc08 	.word	0x000ffc08
   12a08:	800003ff 	.word	0x800003ff
   12a0c:	4ff00000 	.word	0x4ff00000

00012a10 <lfs_dir_commit>:
        const struct lfs_mattr *attrs, int attrcount) {
   12a10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
   12a14:	6a86      	ldr	r6, [r0, #40]	; 0x28
        const struct lfs_mattr *attrs, int attrcount) {
   12a16:	b0a1      	sub	sp, #132	; 0x84
   12a18:	4605      	mov	r5, r0
   12a1a:	460c      	mov	r4, r1
   12a1c:	4691      	mov	r9, r2
   12a1e:	469a      	mov	sl, r3
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
   12a20:	bb4e      	cbnz	r6, 12a76 <lfs_dir_commit+0x66>
    lfs_mdir_t olddir = *dir;
   12a22:	46a4      	mov	ip, r4
   12a24:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   12a28:	af10      	add	r7, sp, #64	; 0x40
   12a2a:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   12a2c:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
            dir->tail[0] = ((lfs_block_t*)attrs[i].buffer)[0];
   12a30:	f109 0c04 	add.w	ip, r9, #4
    lfs_mdir_t olddir = *dir;
   12a34:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    bool hasdelete = false;
   12a38:	4632      	mov	r2, r6
        if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {
   12a3a:	f240 4101 	movw	r1, #1025	; 0x401
        } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE) {
   12a3e:	f240 47ff 	movw	r7, #1279	; 0x4ff
    for (int i = 0; i < attrcount; i++) {
   12a42:	4556      	cmp	r6, sl
   12a44:	d146      	bne.n	12ad4 <lfs_dir_commit+0xc4>
    if (hasdelete && dir->count == 0) {
   12a46:	2a00      	cmp	r2, #0
   12a48:	d072      	beq.n	12b30 <lfs_dir_commit+0x120>
   12a4a:	8aa3      	ldrh	r3, [r4, #20]
   12a4c:	2b00      	cmp	r3, #0
   12a4e:	d16f      	bne.n	12b30 <lfs_dir_commit+0x120>
        int err = lfs_fs_pred(lfs, dir->pair, &pdir);
   12a50:	aa18      	add	r2, sp, #96	; 0x60
   12a52:	4621      	mov	r1, r4
   12a54:	4628      	mov	r0, r5
   12a56:	f005 f906 	bl	17c66 <lfs_fs_pred>
        if (err && err != LFS_ERR_NOENT) {
   12a5a:	4684      	mov	ip, r0
   12a5c:	2800      	cmp	r0, #0
   12a5e:	d05c      	beq.n	12b1a <lfs_dir_commit+0x10a>
   12a60:	f110 0f02 	cmn.w	r0, #2
   12a64:	d064      	beq.n	12b30 <lfs_dir_commit+0x120>
            *dir = olddir;
   12a66:	ad10      	add	r5, sp, #64	; 0x40
   12a68:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   12a6a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   12a6c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   12a70:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            return err;
   12a74:	e02a      	b.n	12acc <lfs_dir_commit+0xbc>
        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
   12a76:	f106 0008 	add.w	r0, r6, #8
   12a7a:	42a0      	cmp	r0, r4
   12a7c:	d101      	bne.n	12a82 <lfs_dir_commit+0x72>
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
   12a7e:	6836      	ldr	r6, [r6, #0]
   12a80:	e7ce      	b.n	12a20 <lfs_dir_commit+0x10>
        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
   12a82:	4621      	mov	r1, r4
   12a84:	f004 ff96 	bl	179b4 <lfs_pair_cmp>
   12a88:	2800      	cmp	r0, #0
   12a8a:	d1f8      	bne.n	12a7e <lfs_dir_commit+0x6e>
   12a8c:	79b3      	ldrb	r3, [r6, #6]
   12a8e:	2b01      	cmp	r3, #1
   12a90:	d1f5      	bne.n	12a7e <lfs_dir_commit+0x6e>
                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
   12a92:	6b33      	ldr	r3, [r6, #48]	; 0x30
   12a94:	02db      	lsls	r3, r3, #11
   12a96:	d5f2      	bpl.n	12a7e <lfs_dir_commit+0x6e>
                f->ctz.size > lfs->cfg->cache_size) {
   12a98:	6eab      	ldr	r3, [r5, #104]	; 0x68
                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
   12a9a:	6af1      	ldr	r1, [r6, #44]	; 0x2c
   12a9c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   12a9e:	4291      	cmp	r1, r2
   12aa0:	d9ed      	bls.n	12a7e <lfs_dir_commit+0x6e>
    file->off = file->pos;
   12aa2:	6b72      	ldr	r2, [r6, #52]	; 0x34
    lfs->free.ack = lfs->cfg->block_count;
   12aa4:	6a1b      	ldr	r3, [r3, #32]
    file->off = file->pos;
   12aa6:	63f2      	str	r2, [r6, #60]	; 0x3c
    int err = lfs_file_relocate(lfs, file);
   12aa8:	4631      	mov	r1, r6
    lfs->free.ack = lfs->cfg->block_count;
   12aaa:	662b      	str	r3, [r5, #96]	; 0x60
    int err = lfs_file_relocate(lfs, file);
   12aac:	4628      	mov	r0, r5
   12aae:	f7ff fbdd 	bl	1226c <lfs_file_relocate>
    if (err) {
   12ab2:	4684      	mov	ip, r0
   12ab4:	b950      	cbnz	r0, 12acc <lfs_dir_commit+0xbc>
    file->flags &= ~LFS_F_INLINE;
   12ab6:	6b33      	ldr	r3, [r6, #48]	; 0x30
   12ab8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   12abc:	6333      	str	r3, [r6, #48]	; 0x30
            err = lfs_file_flush(lfs, f);
   12abe:	4631      	mov	r1, r6
   12ac0:	4628      	mov	r0, r5
   12ac2:	f7ff fc59 	bl	12378 <lfs_file_flush>
            if (err) {
   12ac6:	4684      	mov	ip, r0
   12ac8:	2800      	cmp	r0, #0
   12aca:	d0d8      	beq.n	12a7e <lfs_dir_commit+0x6e>
}
   12acc:	4660      	mov	r0, ip
   12ace:	b021      	add	sp, #132	; 0x84
   12ad0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return (tag & 0x7ff00000) >> 20;
   12ad4:	f859 3036 	ldr.w	r3, [r9, r6, lsl #3]
   12ad8:	ea4f 5e13 	mov.w	lr, r3, lsr #20
   12adc:	f3c3 530a 	ubfx	r3, r3, #20, #11
        if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {
   12ae0:	428b      	cmp	r3, r1
   12ae2:	d104      	bne.n	12aee <lfs_dir_commit+0xde>
            dir->count += 1;
   12ae4:	8aa3      	ldrh	r3, [r4, #20]
   12ae6:	3301      	adds	r3, #1
   12ae8:	82a3      	strh	r3, [r4, #20]
    for (int i = 0; i < attrcount; i++) {
   12aea:	3601      	adds	r6, #1
   12aec:	e7a9      	b.n	12a42 <lfs_dir_commit+0x32>
        } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE) {
   12aee:	42bb      	cmp	r3, r7
   12af0:	d104      	bne.n	12afc <lfs_dir_commit+0xec>
            dir->count -= 1;
   12af2:	8aa3      	ldrh	r3, [r4, #20]
   12af4:	3b01      	subs	r3, #1
   12af6:	82a3      	strh	r3, [r4, #20]
            hasdelete = true;
   12af8:	2201      	movs	r2, #1
   12afa:	e7f6      	b.n	12aea <lfs_dir_commit+0xda>
        } else if (lfs_tag_type1(attrs[i].tag) == LFS_TYPE_TAIL) {
   12afc:	f40e 63e0 	and.w	r3, lr, #1792	; 0x700
   12b00:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
   12b04:	d1f1      	bne.n	12aea <lfs_dir_commit+0xda>
            dir->tail[0] = ((lfs_block_t*)attrs[i].buffer)[0];
   12b06:	f85c 3036 	ldr.w	r3, [ip, r6, lsl #3]
   12b0a:	6818      	ldr	r0, [r3, #0]
   12b0c:	61a0      	str	r0, [r4, #24]
            dir->tail[1] = ((lfs_block_t*)attrs[i].buffer)[1];
   12b0e:	6858      	ldr	r0, [r3, #4]
   12b10:	61e0      	str	r0, [r4, #28]
            dir->split = (lfs_tag_chunk(attrs[i].tag) & 1);
   12b12:	f00e 0301 	and.w	r3, lr, #1
   12b16:	75e3      	strb	r3, [r4, #23]
            lfs_pair_fromle32(dir->tail);
   12b18:	e7e7      	b.n	12aea <lfs_dir_commit+0xda>
        if (err != LFS_ERR_NOENT && pdir.split) {
   12b1a:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
   12b1e:	b13b      	cbz	r3, 12b30 <lfs_dir_commit+0x120>
            err = lfs_dir_drop(lfs, &pdir, dir);
   12b20:	4622      	mov	r2, r4
   12b22:	a918      	add	r1, sp, #96	; 0x60
   12b24:	4628      	mov	r0, r5
   12b26:	f000 f901 	bl	12d2c <lfs_dir_drop>
            if (err) {
   12b2a:	4684      	mov	ip, r0
   12b2c:	2800      	cmp	r0, #0
   12b2e:	d19a      	bne.n	12a66 <lfs_dir_commit+0x56>
    if (dir->erased || dir->count >= 0xff) {
   12b30:	7da3      	ldrb	r3, [r4, #22]
   12b32:	b913      	cbnz	r3, 12b3a <lfs_dir_commit+0x12a>
   12b34:	8aa3      	ldrh	r3, [r4, #20]
   12b36:	2bfe      	cmp	r3, #254	; 0xfe
   12b38:	d92c      	bls.n	12b94 <lfs_dir_commit+0x184>
            .off = dir->off,
   12b3a:	68e2      	ldr	r2, [r4, #12]
        struct lfs_commit commit = {
   12b3c:	6823      	ldr	r3, [r4, #0]
   12b3e:	9318      	str	r3, [sp, #96]	; 0x60
   12b40:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   12b44:	e9cd 121b 	strd	r1, r2, [sp, #108]	; 0x6c
            .end = lfs->cfg->block_size - 8,
   12b48:	6ea9      	ldr	r1, [r5, #104]	; 0x68
            .ptag = dir->etag,
   12b4a:	6923      	ldr	r3, [r4, #16]
            .end = lfs->cfg->block_size - 8,
   12b4c:	69c9      	ldr	r1, [r1, #28]
        int err = lfs_dir_traverse(lfs,
   12b4e:	f8cd 9000 	str.w	r9, [sp]
            .end = lfs->cfg->block_size - 8,
   12b52:	3908      	subs	r1, #8
        struct lfs_commit commit = {
   12b54:	911d      	str	r1, [sp, #116]	; 0x74
        int err = lfs_dir_traverse(lfs,
   12b56:	a90b      	add	r1, sp, #44	; 0x2c
   12b58:	9108      	str	r1, [sp, #32]
   12b5a:	4972      	ldr	r1, [pc, #456]	; (12d24 <lfs_dir_commit+0x314>)
   12b5c:	9107      	str	r1, [sp, #28]
   12b5e:	2100      	movs	r1, #0
   12b60:	e9cd 1105 	strd	r1, r1, [sp, #20]
   12b64:	e9cd 1103 	strd	r1, r1, [sp, #12]
   12b68:	e9cd a101 	strd	sl, r1, [sp, #4]
                lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
   12b6c:	f10d 0b60 	add.w	fp, sp, #96	; 0x60
        int err = lfs_dir_traverse(lfs,
   12b70:	4621      	mov	r1, r4
   12b72:	4628      	mov	r0, r5
        struct lfs_commit commit = {
   12b74:	9219      	str	r2, [sp, #100]	; 0x64
   12b76:	931a      	str	r3, [sp, #104]	; 0x68
                lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
   12b78:	950b      	str	r5, [sp, #44]	; 0x2c
   12b7a:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
        int err = lfs_dir_traverse(lfs,
   12b7e:	f7fe fdf3 	bl	11768 <lfs_dir_traverse>
        if (err) {
   12b82:	4684      	mov	ip, r0
   12b84:	b1c0      	cbz	r0, 12bb8 <lfs_dir_commit+0x1a8>
            if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
   12b86:	f11c 0f1c 	cmn.w	ip, #28
   12b8a:	d003      	beq.n	12b94 <lfs_dir_commit+0x184>
   12b8c:	f11c 0f54 	cmn.w	ip, #84	; 0x54
   12b90:	f47f af69 	bne.w	12a66 <lfs_dir_commit+0x56>
    rcache->block = LFS_BLOCK_NULL;
   12b94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12b98:	612b      	str	r3, [r5, #16]
        int err = lfs_dir_compact(lfs, dir, attrs, attrcount,
   12b9a:	8aa3      	ldrh	r3, [r4, #20]
   12b9c:	9302      	str	r3, [sp, #8]
   12b9e:	2300      	movs	r3, #0
   12ba0:	e9cd 4300 	strd	r4, r3, [sp]
   12ba4:	464a      	mov	r2, r9
   12ba6:	4653      	mov	r3, sl
   12ba8:	4621      	mov	r1, r4
   12baa:	4628      	mov	r0, r5
   12bac:	f7ff fce0 	bl	12570 <lfs_dir_compact>
        if (err) {
   12bb0:	4684      	mov	ip, r0
   12bb2:	2800      	cmp	r0, #0
   12bb4:	d045      	beq.n	12c42 <lfs_dir_commit+0x232>
   12bb6:	e756      	b.n	12a66 <lfs_dir_commit+0x56>
        lfs_gstate_xor(&delta, &lfs->gstate);
   12bb8:	f105 0730 	add.w	r7, r5, #48	; 0x30
        lfs_gstate_t delta = {0};
   12bbc:	e9cd 000d 	strd	r0, r0, [sp, #52]	; 0x34
   12bc0:	900f      	str	r0, [sp, #60]	; 0x3c
        lfs_gstate_xor(&delta, &lfs->gstate);
   12bc2:	4639      	mov	r1, r7
   12bc4:	a80d      	add	r0, sp, #52	; 0x34
        lfs_gstate_xor(&delta, &lfs->gdisk);
   12bc6:	f105 063c 	add.w	r6, r5, #60	; 0x3c
        lfs_gstate_xor(&delta, &lfs->gstate);
   12bca:	f004 ff0e 	bl	179ea <lfs_gstate_xor>
        lfs_gstate_xor(&delta, &lfs->gdelta);
   12bce:	f105 0848 	add.w	r8, r5, #72	; 0x48
        lfs_gstate_xor(&delta, &lfs->gdisk);
   12bd2:	4631      	mov	r1, r6
   12bd4:	a80d      	add	r0, sp, #52	; 0x34
   12bd6:	f004 ff08 	bl	179ea <lfs_gstate_xor>
        lfs_gstate_xor(&delta, &lfs->gdelta);
   12bda:	4641      	mov	r1, r8
   12bdc:	a80d      	add	r0, sp, #52	; 0x34
   12bde:	f004 ff04 	bl	179ea <lfs_gstate_xor>
        delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
   12be2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
        if (((uint32_t*)a)[i] != 0) {
   12be4:	e9dd 210e 	ldrd	r2, r1, [sp, #56]	; 0x38
        delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
   12be8:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
   12bec:	f023 0303 	bic.w	r3, r3, #3
        if (((uint32_t*)a)[i] != 0) {
   12bf0:	430a      	orrs	r2, r1
        delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
   12bf2:	930d      	str	r3, [sp, #52]	; 0x34
        if (((uint32_t*)a)[i] != 0) {
   12bf4:	4313      	orrs	r3, r2
   12bf6:	d011      	beq.n	12c1c <lfs_dir_commit+0x20c>
            err = lfs_dir_getgstate(lfs, dir, &delta);
   12bf8:	aa0d      	add	r2, sp, #52	; 0x34
   12bfa:	4621      	mov	r1, r4
   12bfc:	4628      	mov	r0, r5
   12bfe:	f7fe ff17 	bl	11a30 <lfs_dir_getgstate>
            if (err) {
   12c02:	4684      	mov	ip, r0
   12c04:	2800      	cmp	r0, #0
   12c06:	f47f af2e 	bne.w	12a66 <lfs_dir_commit+0x56>
            err = lfs_dir_commitattr(lfs, &commit,
   12c0a:	4a47      	ldr	r2, [pc, #284]	; (12d28 <lfs_dir_commit+0x318>)
   12c0c:	ab0d      	add	r3, sp, #52	; 0x34
   12c0e:	4659      	mov	r1, fp
   12c10:	4628      	mov	r0, r5
   12c12:	f005 fa45 	bl	180a0 <lfs_dir_commitattr>
            if (err) {
   12c16:	4684      	mov	ip, r0
   12c18:	2800      	cmp	r0, #0
   12c1a:	d1b4      	bne.n	12b86 <lfs_dir_commit+0x176>
        err = lfs_dir_commitcrc(lfs, &commit);
   12c1c:	4659      	mov	r1, fp
   12c1e:	4628      	mov	r0, r5
   12c20:	f005 fa9f 	bl	18162 <lfs_dir_commitcrc>
        if (err) {
   12c24:	4684      	mov	ip, r0
   12c26:	2800      	cmp	r0, #0
   12c28:	d1ad      	bne.n	12b86 <lfs_dir_commit+0x176>
        lfs->gdisk = lfs->gstate;
   12c2a:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
        dir->off = commit.off;
   12c2e:	9b19      	ldr	r3, [sp, #100]	; 0x64
   12c30:	60e3      	str	r3, [r4, #12]
        dir->etag = commit.ptag;
   12c32:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   12c34:	6123      	str	r3, [r4, #16]
        lfs->gdisk = lfs->gstate;
   12c36:	e886 0007 	stmia.w	r6, {r0, r1, r2}
        lfs->gdelta = (lfs_gstate_t){0};
   12c3a:	f8c5 c048 	str.w	ip, [r5, #72]	; 0x48
   12c3e:	e9c8 cc01 	strd	ip, ip, [r8, #4]
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   12c42:	f8d5 8028 	ldr.w	r8, [r5, #40]	; 0x28
                    d->m.pair[0] = LFS_BLOCK_NULL;
   12c46:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   12c4a:	4646      	mov	r6, r8
   12c4c:	b926      	cbnz	r6, 12c58 <lfs_dir_commit+0x248>
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   12c4e:	f1b8 0f00 	cmp.w	r8, #0
   12c52:	d145      	bne.n	12ce0 <lfs_dir_commit+0x2d0>
    return 0;
   12c54:	46c4      	mov	ip, r8
   12c56:	e739      	b.n	12acc <lfs_dir_commit+0xbc>
        if (&d->m != dir && lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
   12c58:	f106 0708 	add.w	r7, r6, #8
   12c5c:	42a7      	cmp	r7, r4
   12c5e:	d101      	bne.n	12c64 <lfs_dir_commit+0x254>
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   12c60:	6836      	ldr	r6, [r6, #0]
   12c62:	e7f3      	b.n	12c4c <lfs_dir_commit+0x23c>
        if (&d->m != dir && lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
   12c64:	a910      	add	r1, sp, #64	; 0x40
   12c66:	4638      	mov	r0, r7
   12c68:	f004 fea4 	bl	179b4 <lfs_pair_cmp>
   12c6c:	4686      	mov	lr, r0
   12c6e:	2800      	cmp	r0, #0
   12c70:	d1f6      	bne.n	12c60 <lfs_dir_commit+0x250>
            d->m = *dir;
   12c72:	46a4      	mov	ip, r4
   12c74:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   12c78:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   12c7a:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
   12c7e:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
            for (int i = 0; i < attrcount; i++) {
   12c82:	45d6      	cmp	lr, sl
   12c84:	d0ec      	beq.n	12c60 <lfs_dir_commit+0x250>
                if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
   12c86:	f859 303e 	ldr.w	r3, [r9, lr, lsl #3]
   12c8a:	f240 41ff 	movw	r1, #1279	; 0x4ff
    return (tag & 0x7ff00000) >> 20;
   12c8e:	f3c3 520a 	ubfx	r2, r3, #20, #11
                if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
   12c92:	428a      	cmp	r2, r1
   12c94:	d113      	bne.n	12cbe <lfs_dir_commit+0x2ae>
                        d->id == lfs_tag_id(attrs[i].tag)) {
   12c96:	88b2      	ldrh	r2, [r6, #4]
    return (tag & 0x000ffc00) >> 10;
   12c98:	f3c3 2389 	ubfx	r3, r3, #10, #10
                if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
   12c9c:	429a      	cmp	r2, r3
   12c9e:	d104      	bne.n	12caa <lfs_dir_commit+0x29a>
                    d->m.pair[1] = LFS_BLOCK_NULL;
   12ca0:	e9c6 bb02 	strd	fp, fp, [r6, #8]
            for (int i = 0; i < attrcount; i++) {
   12ca4:	f10e 0e01 	add.w	lr, lr, #1
   12ca8:	e7eb      	b.n	12c82 <lfs_dir_commit+0x272>
                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
   12caa:	d9fb      	bls.n	12ca4 <lfs_dir_commit+0x294>
                    if (d->type == LFS_TYPE_DIR) {
   12cac:	79b3      	ldrb	r3, [r6, #6]
                    d->id -= 1;
   12cae:	3a01      	subs	r2, #1
                    if (d->type == LFS_TYPE_DIR) {
   12cb0:	2b02      	cmp	r3, #2
                    d->id -= 1;
   12cb2:	80b2      	strh	r2, [r6, #4]
                    if (d->type == LFS_TYPE_DIR) {
   12cb4:	d1f6      	bne.n	12ca4 <lfs_dir_commit+0x294>
                        ((lfs_dir_t*)d)->pos -= 1;
   12cb6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   12cb8:	3b01      	subs	r3, #1
                        ((lfs_dir_t*)d)->pos += 1;
   12cba:	62b3      	str	r3, [r6, #40]	; 0x28
   12cbc:	e7f2      	b.n	12ca4 <lfs_dir_commit+0x294>
                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
   12cbe:	f240 4101 	movw	r1, #1025	; 0x401
   12cc2:	428a      	cmp	r2, r1
   12cc4:	d1ee      	bne.n	12ca4 <lfs_dir_commit+0x294>
                        d->id >= lfs_tag_id(attrs[i].tag)) {
   12cc6:	88b2      	ldrh	r2, [r6, #4]
                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
   12cc8:	f3c3 2389 	ubfx	r3, r3, #10, #10
   12ccc:	429a      	cmp	r2, r3
   12cce:	d3e9      	bcc.n	12ca4 <lfs_dir_commit+0x294>
                    if (d->type == LFS_TYPE_DIR) {
   12cd0:	79b3      	ldrb	r3, [r6, #6]
                    d->id += 1;
   12cd2:	3201      	adds	r2, #1
                    if (d->type == LFS_TYPE_DIR) {
   12cd4:	2b02      	cmp	r3, #2
                    d->id += 1;
   12cd6:	80b2      	strh	r2, [r6, #4]
                    if (d->type == LFS_TYPE_DIR) {
   12cd8:	d1e4      	bne.n	12ca4 <lfs_dir_commit+0x294>
                        ((lfs_dir_t*)d)->pos += 1;
   12cda:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   12cdc:	3301      	adds	r3, #1
   12cde:	e7ec      	b.n	12cba <lfs_dir_commit+0x2aa>
        if (lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
   12ce0:	f108 0408 	add.w	r4, r8, #8
   12ce4:	a910      	add	r1, sp, #64	; 0x40
   12ce6:	4620      	mov	r0, r4
   12ce8:	f004 fe64 	bl	179b4 <lfs_pair_cmp>
   12cec:	b950      	cbnz	r0, 12d04 <lfs_dir_commit+0x2f4>
                int err = lfs_dir_fetch(lfs, &d->m, d->m.tail);
   12cee:	f108 0620 	add.w	r6, r8, #32
            while (d->id >= d->m.count && d->m.split) {
   12cf2:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   12cf6:	f8b8 101c 	ldrh.w	r1, [r8, #28]
   12cfa:	428b      	cmp	r3, r1
   12cfc:	d302      	bcc.n	12d04 <lfs_dir_commit+0x2f4>
   12cfe:	f898 001f 	ldrb.w	r0, [r8, #31]
   12d02:	b910      	cbnz	r0, 12d0a <lfs_dir_commit+0x2fa>
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
   12d04:	f8d8 8000 	ldr.w	r8, [r8]
   12d08:	e7a1      	b.n	12c4e <lfs_dir_commit+0x23e>
                d->id -= d->m.count;
   12d0a:	1a5b      	subs	r3, r3, r1
   12d0c:	f8a8 3004 	strh.w	r3, [r8, #4]
                int err = lfs_dir_fetch(lfs, &d->m, d->m.tail);
   12d10:	4632      	mov	r2, r6
   12d12:	4621      	mov	r1, r4
   12d14:	4628      	mov	r0, r5
   12d16:	f004 ff99 	bl	17c4c <lfs_dir_fetch>
                if (err) {
   12d1a:	4684      	mov	ip, r0
   12d1c:	2800      	cmp	r0, #0
   12d1e:	d0e8      	beq.n	12cf2 <lfs_dir_commit+0x2e2>
   12d20:	e6d4      	b.n	12acc <lfs_dir_commit+0xbc>
   12d22:	bf00      	nop
   12d24:	00018157 	.word	0x00018157
   12d28:	7ffffc0c 	.word	0x7ffffc0c

00012d2c <lfs_dir_drop>:
static int lfs_dir_drop(lfs_t *lfs, lfs_mdir_t *dir, lfs_mdir_t *tail) {
   12d2c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   12d2e:	4614      	mov	r4, r2
   12d30:	460e      	mov	r6, r1
    int err = lfs_dir_getgstate(lfs, tail, &lfs->gdelta);
   12d32:	f100 0248 	add.w	r2, r0, #72	; 0x48
   12d36:	4621      	mov	r1, r4
static int lfs_dir_drop(lfs_t *lfs, lfs_mdir_t *dir, lfs_mdir_t *tail) {
   12d38:	4605      	mov	r5, r0
    int err = lfs_dir_getgstate(lfs, tail, &lfs->gdelta);
   12d3a:	f7fe fe79 	bl	11a30 <lfs_dir_getgstate>
    if (err) {
   12d3e:	b970      	cbnz	r0, 12d5e <lfs_dir_drop+0x32>
    err = lfs_dir_commit(lfs, dir, LFS_MKATTRS(
   12d40:	7de3      	ldrb	r3, [r4, #23]
   12d42:	f503 62c0 	add.w	r2, r3, #1536	; 0x600
   12d46:	4b07      	ldr	r3, [pc, #28]	; (12d64 <lfs_dir_drop+0x38>)
   12d48:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
   12d4c:	9300      	str	r3, [sp, #0]
    lfs_pair_tole32(tail->tail);
   12d4e:	3418      	adds	r4, #24
    err = lfs_dir_commit(lfs, dir, LFS_MKATTRS(
   12d50:	2301      	movs	r3, #1
   12d52:	466a      	mov	r2, sp
   12d54:	4631      	mov	r1, r6
   12d56:	4628      	mov	r0, r5
   12d58:	9401      	str	r4, [sp, #4]
   12d5a:	f7ff fe59 	bl	12a10 <lfs_dir_commit>
}
   12d5e:	b002      	add	sp, #8
   12d60:	bd70      	pop	{r4, r5, r6, pc}
   12d62:	bf00      	nop
   12d64:	000ffc08 	.word	0x000ffc08

00012d68 <lfs_fs_forceconsistency>:
static int lfs_fs_forceconsistency(lfs_t *lfs) {
   12d68:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (tag & 0x70000000) >> 20;
   12d6a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   12d6c:	0d1b      	lsrs	r3, r3, #20
    if (!lfs_gstate_hasmove(&lfs->gdisk)) {
   12d6e:	f413 6fe0 	tst.w	r3, #1792	; 0x700
static int lfs_fs_forceconsistency(lfs_t *lfs) {
   12d72:	b09f      	sub	sp, #124	; 0x7c
   12d74:	4604      	mov	r4, r0
    if (!lfs_gstate_hasmove(&lfs->gdisk)) {
   12d76:	d105      	bne.n	12d84 <lfs_fs_forceconsistency+0x1c>
    return tag & 0x000003ff;
   12d78:	6b20      	ldr	r0, [r4, #48]	; 0x30
   12d7a:	f3c0 0009 	ubfx	r0, r0, #0, #10
    if (!lfs_gstate_hasorphans(&lfs->gstate)) {
   12d7e:	b9f8      	cbnz	r0, 12dc0 <lfs_fs_forceconsistency+0x58>
}
   12d80:	b01f      	add	sp, #124	; 0x7c
   12d82:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);
   12d84:	f100 0240 	add.w	r2, r0, #64	; 0x40
   12d88:	a916      	add	r1, sp, #88	; 0x58
   12d8a:	f004 ff5f 	bl	17c4c <lfs_dir_fetch>
    if (err) {
   12d8e:	2800      	cmp	r0, #0
   12d90:	d1f6      	bne.n	12d80 <lfs_fs_forceconsistency+0x18>
    return (tag & 0x000ffc00) >> 10;
   12d92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   12d94:	6b21      	ldr	r1, [r4, #48]	; 0x30
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
   12d96:	63a0      	str	r0, [r4, #56]	; 0x38
    return (tag & 0x000ffc00) >> 10;
   12d98:	f3c3 2289 	ubfx	r2, r3, #10, #10
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   12d9c:	4b38      	ldr	r3, [pc, #224]	; (12e80 <lfs_fs_forceconsistency+0x118>)
    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(
   12d9e:	900f      	str	r0, [sp, #60]	; 0x3c
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   12da0:	400b      	ands	r3, r1
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
   12da2:	e9c4 300c 	strd	r3, r0, [r4, #48]	; 0x30
    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(
   12da6:	4b37      	ldr	r3, [pc, #220]	; (12e84 <lfs_fs_forceconsistency+0x11c>)
   12da8:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   12dac:	930e      	str	r3, [sp, #56]	; 0x38
   12dae:	aa0e      	add	r2, sp, #56	; 0x38
   12db0:	2301      	movs	r3, #1
   12db2:	a916      	add	r1, sp, #88	; 0x58
   12db4:	4620      	mov	r0, r4
   12db6:	f7ff fe2b 	bl	12a10 <lfs_dir_commit>
    if (err) {
   12dba:	2800      	cmp	r0, #0
   12dbc:	d0dc      	beq.n	12d78 <lfs_fs_forceconsistency+0x10>
   12dbe:	e7df      	b.n	12d80 <lfs_fs_forceconsistency+0x18>
    lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
   12dc0:	221c      	movs	r2, #28
   12dc2:	2100      	movs	r1, #0
   12dc4:	a806      	add	r0, sp, #24
   12dc6:	f003 f963 	bl	16090 <memset>
            lfs_stag_t res = lfs_dir_get(lfs, &parent,
   12dca:	4e2f      	ldr	r6, [pc, #188]	; (12e88 <lfs_fs_forceconsistency+0x120>)
                err = lfs_dir_commit(lfs, &pdir, LFS_MKATTRS(
   12dcc:	4f2f      	ldr	r7, [pc, #188]	; (12e8c <lfs_fs_forceconsistency+0x124>)
    lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
   12dce:	2301      	movs	r3, #1
   12dd0:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   12dd4:	930d      	str	r3, [sp, #52]	; 0x34
    while (!lfs_pair_isnull(pdir.tail)) {
   12dd6:	a80c      	add	r0, sp, #48	; 0x30
   12dd8:	f004 fde2 	bl	179a0 <lfs_pair_isnull>
   12ddc:	b140      	cbz	r0, 12df0 <lfs_fs_forceconsistency+0x88>
    return tag & 0x000003ff;
   12dde:	4620      	mov	r0, r4
   12de0:	f850 1f30 	ldr.w	r1, [r0, #48]!
    lfs_fs_preporphans(lfs, -lfs_gstate_getorphans(&lfs->gstate));
   12de4:	4249      	negs	r1, r1
   12de6:	b249      	sxtb	r1, r1
   12de8:	f004 fe5b 	bl	17aa2 <lfs_fs_preporphans.isra.0>
    return 0;
   12dec:	2000      	movs	r0, #0
   12dee:	e7c7      	b.n	12d80 <lfs_fs_forceconsistency+0x18>
        int err = lfs_dir_fetch(lfs, &dir, pdir.tail);
   12df0:	aa0c      	add	r2, sp, #48	; 0x30
   12df2:	a90e      	add	r1, sp, #56	; 0x38
   12df4:	4620      	mov	r0, r4
   12df6:	f004 ff29 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   12dfa:	2800      	cmp	r0, #0
   12dfc:	d1c0      	bne.n	12d80 <lfs_fs_forceconsistency+0x18>
        if (!pdir.split) {
   12dfe:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   12e02:	2b00      	cmp	r3, #0
   12e04:	d130      	bne.n	12e68 <lfs_fs_forceconsistency+0x100>
            lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);
   12e06:	aa16      	add	r2, sp, #88	; 0x58
   12e08:	a90c      	add	r1, sp, #48	; 0x30
   12e0a:	4620      	mov	r0, r4
   12e0c:	f7fe fc6e 	bl	116ec <lfs_fs_parent>
            if (tag < 0 && tag != LFS_ERR_NOENT) {
   12e10:	2800      	cmp	r0, #0
   12e12:	da09      	bge.n	12e28 <lfs_fs_forceconsistency+0xc0>
   12e14:	1c83      	adds	r3, r0, #2
   12e16:	d1b3      	bne.n	12d80 <lfs_fs_forceconsistency+0x18>
                err = lfs_dir_drop(lfs, &pdir, &dir);
   12e18:	aa0e      	add	r2, sp, #56	; 0x38
   12e1a:	a906      	add	r1, sp, #24
   12e1c:	4620      	mov	r0, r4
   12e1e:	f7ff ff85 	bl	12d2c <lfs_dir_drop>
                if (err) {
   12e22:	2800      	cmp	r0, #0
   12e24:	d1ac      	bne.n	12d80 <lfs_fs_forceconsistency+0x18>
   12e26:	e7d6      	b.n	12dd6 <lfs_fs_forceconsistency+0x6e>
            lfs_stag_t res = lfs_dir_get(lfs, &parent,
   12e28:	ad02      	add	r5, sp, #8
   12e2a:	4603      	mov	r3, r0
   12e2c:	9500      	str	r5, [sp, #0]
   12e2e:	4632      	mov	r2, r6
   12e30:	a916      	add	r1, sp, #88	; 0x58
   12e32:	4620      	mov	r0, r4
   12e34:	f004 ff40 	bl	17cb8 <lfs_dir_get>
            if (res < 0) {
   12e38:	2800      	cmp	r0, #0
   12e3a:	dba1      	blt.n	12d80 <lfs_fs_forceconsistency+0x18>
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
   12e3c:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
   12e40:	9902      	ldr	r1, [sp, #8]
   12e42:	4299      	cmp	r1, r3
   12e44:	d102      	bne.n	12e4c <lfs_fs_forceconsistency+0xe4>
   12e46:	9803      	ldr	r0, [sp, #12]
   12e48:	4290      	cmp	r0, r2
   12e4a:	d00d      	beq.n	12e68 <lfs_fs_forceconsistency+0x100>
   12e4c:	4291      	cmp	r1, r2
   12e4e:	d102      	bne.n	12e56 <lfs_fs_forceconsistency+0xee>
           (paira[0] == pairb[1] && paira[1] == pairb[0]);
   12e50:	9a03      	ldr	r2, [sp, #12]
   12e52:	4293      	cmp	r3, r2
   12e54:	d008      	beq.n	12e68 <lfs_fs_forceconsistency+0x100>
                err = lfs_dir_commit(lfs, &pdir, LFS_MKATTRS(
   12e56:	2301      	movs	r3, #1
   12e58:	aa04      	add	r2, sp, #16
   12e5a:	a906      	add	r1, sp, #24
   12e5c:	4620      	mov	r0, r4
   12e5e:	e9cd 7504 	strd	r7, r5, [sp, #16]
   12e62:	f7ff fdd5 	bl	12a10 <lfs_dir_commit>
   12e66:	e7dc      	b.n	12e22 <lfs_fs_forceconsistency+0xba>
        pdir = dir;
   12e68:	ad0e      	add	r5, sp, #56	; 0x38
   12e6a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   12e6c:	f10d 0c18 	add.w	ip, sp, #24
   12e70:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   12e74:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   12e78:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
   12e7c:	e7ab      	b.n	12dd6 <lfs_fs_forceconsistency+0x6e>
   12e7e:	bf00      	nop
   12e80:	800003ff 	.word	0x800003ff
   12e84:	4ff00000 	.word	0x4ff00000
   12e88:	7ffffc00 	.word	0x7ffffc00
   12e8c:	600ffc08 	.word	0x600ffc08

00012e90 <lfs_mkdir>:
int lfs_mkdir(lfs_t *lfs, const char *path) {
   12e90:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12e94:	b0a9      	sub	sp, #164	; 0xa4
   12e96:	4605      	mov	r5, r0
   12e98:	9101      	str	r1, [sp, #4]
    int err = lfs_fs_forceconsistency(lfs);
   12e9a:	f7ff ff65 	bl	12d68 <lfs_fs_forceconsistency>
    if (err) {
   12e9e:	4604      	mov	r4, r0
   12ea0:	b988      	cbnz	r0, 12ec6 <lfs_mkdir+0x36>
    cwd.next = lfs->mlist;
   12ea2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   12ea4:	931e      	str	r3, [sp, #120]	; 0x78
    err = lfs_dir_find(lfs, &cwd.m, &path, &id);
   12ea6:	aa01      	add	r2, sp, #4
   12ea8:	f10d 030e 	add.w	r3, sp, #14
   12eac:	a920      	add	r1, sp, #128	; 0x80
   12eae:	4628      	mov	r0, r5
   12eb0:	f7fe fdd8 	bl	11a64 <lfs_dir_find>
    if (!(err == LFS_ERR_NOENT && id != 0x3ff)) {
   12eb4:	1c83      	adds	r3, r0, #2
    err = lfs_dir_find(lfs, &cwd.m, &path, &id);
   12eb6:	4604      	mov	r4, r0
    if (!(err == LFS_ERR_NOENT && id != 0x3ff)) {
   12eb8:	d109      	bne.n	12ece <lfs_mkdir+0x3e>
   12eba:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   12ebe:	f240 33ff 	movw	r3, #1023	; 0x3ff
   12ec2:	429a      	cmp	r2, r3
   12ec4:	d108      	bne.n	12ed8 <lfs_mkdir+0x48>
}
   12ec6:	4620      	mov	r0, r4
   12ec8:	b029      	add	sp, #164	; 0xa4
   12eca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return (err < 0) ? err : LFS_ERR_EXIST;
   12ece:	2800      	cmp	r0, #0
   12ed0:	bfa8      	it	ge
   12ed2:	f06f 0410 	mvnge.w	r4, #16
   12ed6:	e7f6      	b.n	12ec6 <lfs_mkdir+0x36>
    lfs_size_t nlen = strlen(path);
   12ed8:	9801      	ldr	r0, [sp, #4]
   12eda:	f003 f87c 	bl	15fd6 <strlen>
    if (nlen > lfs->name_max) {
   12ede:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   12ee0:	4283      	cmp	r3, r0
    lfs_size_t nlen = strlen(path);
   12ee2:	4680      	mov	r8, r0
    if (nlen > lfs->name_max) {
   12ee4:	d372      	bcc.n	12fcc <lfs_mkdir+0x13c>
    lfs->free.ack = lfs->cfg->block_count;
   12ee6:	6eab      	ldr	r3, [r5, #104]	; 0x68
    err = lfs_dir_alloc(lfs, &dir);
   12ee8:	ae06      	add	r6, sp, #24
    lfs->free.ack = lfs->cfg->block_count;
   12eea:	6a1b      	ldr	r3, [r3, #32]
   12eec:	662b      	str	r3, [r5, #96]	; 0x60
    err = lfs_dir_alloc(lfs, &dir);
   12eee:	4631      	mov	r1, r6
   12ef0:	4628      	mov	r0, r5
   12ef2:	f005 fa65 	bl	183c0 <lfs_dir_alloc>
    if (err) {
   12ef6:	4604      	mov	r4, r0
   12ef8:	2800      	cmp	r0, #0
   12efa:	d1e4      	bne.n	12ec6 <lfs_mkdir+0x36>
    lfs_mdir_t pred = cwd.m;
   12efc:	af20      	add	r7, sp, #128	; 0x80
   12efe:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   12f00:	ac0e      	add	r4, sp, #56	; 0x38
   12f02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   12f04:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
   12f08:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    while (pred.split) {
   12f0c:	af14      	add	r7, sp, #80	; 0x50
   12f0e:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
   12f12:	2b00      	cmp	r3, #0
   12f14:	d151      	bne.n	12fba <lfs_mkdir+0x12a>
    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(
   12f16:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 12fdc <lfs_mkdir+0x14c>
   12f1a:	2301      	movs	r3, #1
   12f1c:	aa04      	add	r2, sp, #16
   12f1e:	4631      	mov	r1, r6
   12f20:	4628      	mov	r0, r5
   12f22:	e9cd 9704 	strd	r9, r7, [sp, #16]
   12f26:	f7ff fd73 	bl	12a10 <lfs_dir_commit>
    if (err) {
   12f2a:	4604      	mov	r4, r0
   12f2c:	2800      	cmp	r0, #0
   12f2e:	d1ca      	bne.n	12ec6 <lfs_mkdir+0x36>
    if (cwd.m.split) {
   12f30:	f89d 3097 	ldrb.w	r3, [sp, #151]	; 0x97
   12f34:	b1eb      	cbz	r3, 12f72 <lfs_mkdir+0xe2>
        lfs_fs_preporphans(lfs, +1);
   12f36:	f105 0730 	add.w	r7, r5, #48	; 0x30
   12f3a:	2101      	movs	r1, #1
   12f3c:	4638      	mov	r0, r7
   12f3e:	f004 fdb0 	bl	17aa2 <lfs_fs_preporphans.isra.0>
        lfs->mlist = &cwd;
   12f42:	ab1e      	add	r3, sp, #120	; 0x78
   12f44:	62ab      	str	r3, [r5, #40]	; 0x28
        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(
   12f46:	aa16      	add	r2, sp, #88	; 0x58
   12f48:	2301      	movs	r3, #1
   12f4a:	a90e      	add	r1, sp, #56	; 0x38
   12f4c:	4628      	mov	r0, r5
        cwd.type = 0;
   12f4e:	f88d 407e 	strb.w	r4, [sp, #126]	; 0x7e
        cwd.id = 0;
   12f52:	f8ad 407c 	strh.w	r4, [sp, #124]	; 0x7c
        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(
   12f56:	e9cd 9616 	strd	r9, r6, [sp, #88]	; 0x58
   12f5a:	f7ff fd59 	bl	12a10 <lfs_dir_commit>
        if (err) {
   12f5e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
            lfs->mlist = cwd.next;
   12f60:	62ab      	str	r3, [r5, #40]	; 0x28
        if (err) {
   12f62:	4604      	mov	r4, r0
   12f64:	2800      	cmp	r0, #0
   12f66:	d1ae      	bne.n	12ec6 <lfs_mkdir+0x36>
        lfs_fs_preporphans(lfs, -1);
   12f68:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   12f6c:	4638      	mov	r0, r7
   12f6e:	f004 fd98 	bl	17aa2 <lfs_fs_preporphans.isra.0>
    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(
   12f72:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   12f76:	4b17      	ldr	r3, [pc, #92]	; (12fd4 <lfs_mkdir+0x144>)
   12f78:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   12f7c:	9316      	str	r3, [sp, #88]	; 0x58
   12f7e:	2300      	movs	r3, #0
   12f80:	9317      	str	r3, [sp, #92]	; 0x5c
   12f82:	9b01      	ldr	r3, [sp, #4]
   12f84:	9319      	str	r3, [sp, #100]	; 0x64
   12f86:	4b14      	ldr	r3, [pc, #80]	; (12fd8 <lfs_mkdir+0x148>)
   12f88:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   12f8c:	e9cd 361a 	strd	r3, r6, [sp, #104]	; 0x68
   12f90:	f89d 3097 	ldrb.w	r3, [sp, #151]	; 0x97
   12f94:	ea48 2082 	orr.w	r0, r8, r2, lsl #10
   12f98:	2b00      	cmp	r3, #0
   12f9a:	4b10      	ldr	r3, [pc, #64]	; (12fdc <lfs_mkdir+0x14c>)
   12f9c:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
   12fa0:	bf18      	it	ne
   12fa2:	2300      	movne	r3, #0
   12fa4:	e9cd 361c 	strd	r3, r6, [sp, #112]	; 0x70
   12fa8:	9018      	str	r0, [sp, #96]	; 0x60
   12faa:	2304      	movs	r3, #4
   12fac:	aa16      	add	r2, sp, #88	; 0x58
   12fae:	a920      	add	r1, sp, #128	; 0x80
   12fb0:	4628      	mov	r0, r5
   12fb2:	f7ff fd2d 	bl	12a10 <lfs_dir_commit>
   12fb6:	4604      	mov	r4, r0
    if (err) {
   12fb8:	e785      	b.n	12ec6 <lfs_mkdir+0x36>
        err = lfs_dir_fetch(lfs, &pred, pred.tail);
   12fba:	463a      	mov	r2, r7
   12fbc:	a90e      	add	r1, sp, #56	; 0x38
   12fbe:	4628      	mov	r0, r5
   12fc0:	f004 fe44 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   12fc4:	4604      	mov	r4, r0
   12fc6:	2800      	cmp	r0, #0
   12fc8:	d0a1      	beq.n	12f0e <lfs_mkdir+0x7e>
   12fca:	e77c      	b.n	12ec6 <lfs_mkdir+0x36>
        return LFS_ERR_NAMETOOLONG;
   12fcc:	f06f 0423 	mvn.w	r4, #35	; 0x23
   12fd0:	e779      	b.n	12ec6 <lfs_mkdir+0x36>
   12fd2:	bf00      	nop
   12fd4:	40100000 	.word	0x40100000
   12fd8:	20000008 	.word	0x20000008
   12fdc:	600ffc08 	.word	0x600ffc08

00012fe0 <lfs_file_opencfg>:
        const struct lfs_file_config *cfg) {
   12fe0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12fe4:	4698      	mov	r8, r3
   12fe6:	b08a      	sub	sp, #40	; 0x28
    if ((flags & 3) != LFS_O_RDONLY) {
   12fe8:	f003 0303 	and.w	r3, r3, #3
   12fec:	2b01      	cmp	r3, #1
        const struct lfs_file_config *cfg) {
   12fee:	4606      	mov	r6, r0
   12ff0:	460d      	mov	r5, r1
   12ff2:	9203      	str	r2, [sp, #12]
    if ((flags & 3) != LFS_O_RDONLY) {
   12ff4:	d135      	bne.n	13062 <lfs_file_opencfg+0x82>
    file->cfg = cfg;
   12ff6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   12ff8:	652b      	str	r3, [r5, #80]	; 0x50
    file->flags = flags | LFS_F_OPENED;
   12ffa:	f448 1300 	orr.w	r3, r8, #2097152	; 0x200000
   12ffe:	632b      	str	r3, [r5, #48]	; 0x30
    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);
   13000:	f105 0708 	add.w	r7, r5, #8
    file->pos = 0;
   13004:	2300      	movs	r3, #0
   13006:	636b      	str	r3, [r5, #52]	; 0x34
    file->off = 0;
   13008:	63eb      	str	r3, [r5, #60]	; 0x3c
    file->cache.buffer = NULL;
   1300a:	64eb      	str	r3, [r5, #76]	; 0x4c
    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);
   1300c:	aa03      	add	r2, sp, #12
   1300e:	1d2b      	adds	r3, r5, #4
   13010:	4639      	mov	r1, r7
   13012:	4630      	mov	r0, r6
   13014:	f7fe fd26 	bl	11a64 <lfs_dir_find>
    if (tag < 0 && !(tag == LFS_ERR_NOENT && file->id != 0x3ff)) {
   13018:	1e04      	subs	r4, r0, #0
   1301a:	da06      	bge.n	1302a <lfs_file_opencfg+0x4a>
   1301c:	1ca1      	adds	r1, r4, #2
   1301e:	d117      	bne.n	13050 <lfs_file_opencfg+0x70>
   13020:	88aa      	ldrh	r2, [r5, #4]
   13022:	f240 33ff 	movw	r3, #1023	; 0x3ff
   13026:	429a      	cmp	r2, r3
   13028:	d012      	beq.n	13050 <lfs_file_opencfg+0x70>
    file->type = LFS_TYPE_REG;
   1302a:	2301      	movs	r3, #1
   1302c:	71ab      	strb	r3, [r5, #6]
    file->next = (lfs_file_t*)lfs->mlist;
   1302e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   13030:	602b      	str	r3, [r5, #0]
    if (tag == LFS_ERR_NOENT) {
   13032:	1ca2      	adds	r2, r4, #2
    lfs->mlist = (struct lfs_mlist*)file;
   13034:	62b5      	str	r5, [r6, #40]	; 0x28
    if (tag == LFS_ERR_NOENT) {
   13036:	d155      	bne.n	130e4 <lfs_file_opencfg+0x104>
        if (!(flags & LFS_O_CREAT)) {
   13038:	f418 7f80 	tst.w	r8, #256	; 0x100
   1303c:	d008      	beq.n	13050 <lfs_file_opencfg+0x70>
        lfs_size_t nlen = strlen(path);
   1303e:	9803      	ldr	r0, [sp, #12]
   13040:	f002 ffc9 	bl	15fd6 <strlen>
        if (nlen > lfs->name_max) {
   13044:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
   13046:	4283      	cmp	r3, r0
        lfs_size_t nlen = strlen(path);
   13048:	4604      	mov	r4, r0
        if (nlen > lfs->name_max) {
   1304a:	d213      	bcs.n	13074 <lfs_file_opencfg+0x94>
            err = LFS_ERR_NAMETOOLONG;
   1304c:	f06f 0423 	mvn.w	r4, #35	; 0x23
    file->flags |= LFS_F_ERRED;
   13050:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   13052:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   13056:	632b      	str	r3, [r5, #48]	; 0x30
    lfs_file_close(lfs, file);
   13058:	4629      	mov	r1, r5
   1305a:	4630      	mov	r0, r6
   1305c:	f005 fc0e 	bl	1887c <lfs_file_close>
    return err;
   13060:	e004      	b.n	1306c <lfs_file_opencfg+0x8c>
        int err = lfs_fs_forceconsistency(lfs);
   13062:	f7ff fe81 	bl	12d68 <lfs_fs_forceconsistency>
        if (err) {
   13066:	4604      	mov	r4, r0
   13068:	2800      	cmp	r0, #0
   1306a:	d0c4      	beq.n	12ff6 <lfs_file_opencfg+0x16>
}
   1306c:	4620      	mov	r0, r4
   1306e:	b00a      	add	sp, #40	; 0x28
   13070:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
   13074:	2214      	movs	r2, #20
   13076:	2100      	movs	r1, #0
   13078:	eb0d 0002 	add.w	r0, sp, r2
   1307c:	f003 f808 	bl	16090 <memset>
   13080:	88ab      	ldrh	r3, [r5, #4]
   13082:	4a63      	ldr	r2, [pc, #396]	; (13210 <lfs_file_opencfg+0x230>)
   13084:	ea44 2483 	orr.w	r4, r4, r3, lsl #10
   13088:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
   1308c:	9406      	str	r4, [sp, #24]
   1308e:	4c61      	ldr	r4, [pc, #388]	; (13214 <lfs_file_opencfg+0x234>)
   13090:	ea42 2283 	orr.w	r2, r2, r3, lsl #10
   13094:	9204      	str	r2, [sp, #16]
   13096:	ea44 2383 	orr.w	r3, r4, r3, lsl #10
   1309a:	9a03      	ldr	r2, [sp, #12]
   1309c:	9207      	str	r2, [sp, #28]
   1309e:	9308      	str	r3, [sp, #32]
   130a0:	aa04      	add	r2, sp, #16
   130a2:	2303      	movs	r3, #3
   130a4:	4639      	mov	r1, r7
   130a6:	4630      	mov	r0, r6
   130a8:	f7ff fcb2 	bl	12a10 <lfs_dir_commit>
        if (err) {
   130ac:	2800      	cmp	r0, #0
   130ae:	d1cd      	bne.n	1304c <lfs_file_opencfg+0x6c>
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
   130b0:	f8df a168 	ldr.w	sl, [pc, #360]	; 1321c <lfs_file_opencfg+0x23c>
    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
   130b4:	f04f 0800 	mov.w	r8, #0
                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,
   130b8:	f04f 090c 	mov.w	r9, #12
    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
   130bc:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   130be:	689a      	ldr	r2, [r3, #8]
   130c0:	4542      	cmp	r2, r8
   130c2:	d836      	bhi.n	13132 <lfs_file_opencfg+0x152>
    if (file->cfg->buffer) {
   130c4:	681b      	ldr	r3, [r3, #0]
   130c6:	2b00      	cmp	r3, #0
   130c8:	d067      	beq.n	1319a <lfs_file_opencfg+0x1ba>
        file->cache.buffer = file->cfg->buffer;
   130ca:	64eb      	str	r3, [r5, #76]	; 0x4c
    lfs_cache_zero(lfs, &file->cache);
   130cc:	6eb0      	ldr	r0, [r6, #104]	; 0x68
   130ce:	f105 0140 	add.w	r1, r5, #64	; 0x40
   130d2:	f004 fdfd 	bl	17cd0 <lfs_cache_zero.isra.0>
    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {
   130d6:	f240 2301 	movw	r3, #513	; 0x201
   130da:	ebb3 5f14 	cmp.w	r3, r4, lsr #20
   130de:	d066      	beq.n	131ae <lfs_file_opencfg+0x1ce>
    return 0;
   130e0:	2400      	movs	r4, #0
   130e2:	e7c3      	b.n	1306c <lfs_file_opencfg+0x8c>
    } else if (flags & LFS_O_EXCL) {
   130e4:	f418 7f00 	tst.w	r8, #512	; 0x200
   130e8:	f040 8088 	bne.w	131fc <lfs_file_opencfg+0x21c>
    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {
   130ec:	f3c4 500a 	ubfx	r0, r4, #20, #11
   130f0:	2801      	cmp	r0, #1
   130f2:	f040 8086 	bne.w	13202 <lfs_file_opencfg+0x222>
    } else if (flags & LFS_O_TRUNC) {
   130f6:	88ab      	ldrh	r3, [r5, #4]
   130f8:	f418 6f80 	tst.w	r8, #1024	; 0x400
   130fc:	ea4f 2383 	mov.w	r3, r3, lsl #10
   13100:	d008      	beq.n	13114 <lfs_file_opencfg+0x134>
        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);
   13102:	f043 5400 	orr.w	r4, r3, #536870912	; 0x20000000
        file->flags |= LFS_F_DIRTY;
   13106:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   13108:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);
   1310c:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
        file->flags |= LFS_F_DIRTY;
   13110:	632b      	str	r3, [r5, #48]	; 0x30
   13112:	e7cd      	b.n	130b0 <lfs_file_opencfg+0xd0>
                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);
   13114:	f105 0228 	add.w	r2, r5, #40	; 0x28
        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),
   13118:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   1311c:	9200      	str	r2, [sp, #0]
   1311e:	f043 0308 	orr.w	r3, r3, #8
   13122:	4a3d      	ldr	r2, [pc, #244]	; (13218 <lfs_file_opencfg+0x238>)
   13124:	4639      	mov	r1, r7
   13126:	4630      	mov	r0, r6
   13128:	f004 fdc6 	bl	17cb8 <lfs_dir_get>
        if (tag < 0) {
   1312c:	1e04      	subs	r4, r0, #0
   1312e:	dabf      	bge.n	130b0 <lfs_file_opencfg+0xd0>
   13130:	e78e      	b.n	13050 <lfs_file_opencfg+0x70>
        if ((file->flags & 3) != LFS_O_WRONLY) {
   13132:	6b2a      	ldr	r2, [r5, #48]	; 0x30
   13134:	f002 0203 	and.w	r2, r2, #3
   13138:	2a02      	cmp	r2, #2
   1313a:	d107      	bne.n	1314c <lfs_file_opencfg+0x16c>
        if ((file->flags & 3) != LFS_O_RDONLY) {
   1313c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   1313e:	f003 0203 	and.w	r2, r3, #3
   13142:	2a01      	cmp	r2, #1
   13144:	d11d      	bne.n	13182 <lfs_file_opencfg+0x1a2>
    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
   13146:	f108 0801 	add.w	r8, r8, #1
   1314a:	e7b7      	b.n	130bc <lfs_file_opencfg+0xdc>
                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,
   1314c:	6858      	ldr	r0, [r3, #4]
   1314e:	f8b5 c004 	ldrh.w	ip, [r5, #4]
   13152:	fb09 f208 	mul.w	r2, r9, r8
   13156:	1881      	adds	r1, r0, r2
   13158:	5c82      	ldrb	r2, [r0, r2]
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
   1315a:	688b      	ldr	r3, [r1, #8]
   1315c:	6849      	ldr	r1, [r1, #4]
   1315e:	9100      	str	r1, [sp, #0]
   13160:	ea43 238c 	orr.w	r3, r3, ip, lsl #10
                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,
   13164:	f502 7240 	add.w	r2, r2, #768	; 0x300
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
   13168:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
   1316c:	4639      	mov	r1, r7
   1316e:	4652      	mov	r2, sl
   13170:	4630      	mov	r0, r6
   13172:	f004 fda1 	bl	17cb8 <lfs_dir_get>
            if (res < 0 && res != LFS_ERR_NOENT) {
   13176:	2800      	cmp	r0, #0
   13178:	dae0      	bge.n	1313c <lfs_file_opencfg+0x15c>
   1317a:	1c83      	adds	r3, r0, #2
   1317c:	d0de      	beq.n	1313c <lfs_file_opencfg+0x15c>
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
   1317e:	4604      	mov	r4, r0
   13180:	e766      	b.n	13050 <lfs_file_opencfg+0x70>
            if (file->cfg->attrs[i].size > lfs->attr_max) {
   13182:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   13184:	6852      	ldr	r2, [r2, #4]
   13186:	fb09 2208 	mla	r2, r9, r8, r2
   1318a:	6891      	ldr	r1, [r2, #8]
   1318c:	6f72      	ldr	r2, [r6, #116]	; 0x74
   1318e:	4291      	cmp	r1, r2
   13190:	d83a      	bhi.n	13208 <lfs_file_opencfg+0x228>
            file->flags |= LFS_F_DIRTY;
   13192:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   13196:	632b      	str	r3, [r5, #48]	; 0x30
   13198:	e7d5      	b.n	13146 <lfs_file_opencfg+0x166>
        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);
   1319a:	6eb3      	ldr	r3, [r6, #104]	; 0x68

// Allocate memory, only used if buffers are not provided to littlefs
// Note, memory must be 64-bit aligned
static inline void *lfs_malloc(size_t size) {
#ifndef LFS_NO_MALLOC
    return malloc(size);
   1319c:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1319e:	f002 fee6 	bl	15f6e <malloc>
   131a2:	64e8      	str	r0, [r5, #76]	; 0x4c
        if (!file->cache.buffer) {
   131a4:	2800      	cmp	r0, #0
   131a6:	d191      	bne.n	130cc <lfs_file_opencfg+0xec>
            err = LFS_ERR_NOMEM;
   131a8:	f06f 040b 	mvn.w	r4, #11
   131ac:	e750      	b.n	13050 <lfs_file_opencfg+0x70>
        file->ctz.head = LFS_BLOCK_INLINE;
   131ae:	f06f 0301 	mvn.w	r3, #1
   131b2:	62ab      	str	r3, [r5, #40]	; 0x28
        file->cache.block = file->ctz.head;
   131b4:	642b      	str	r3, [r5, #64]	; 0x40
        file->cache.off = 0;
   131b6:	2300      	movs	r3, #0
        file->flags |= LFS_F_INLINE;
   131b8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
        file->cache.off = 0;
   131ba:	646b      	str	r3, [r5, #68]	; 0x44
        file->cache.size = lfs->cfg->cache_size;
   131bc:	6eb3      	ldr	r3, [r6, #104]	; 0x68
    return tag & 0x000003ff;
   131be:	f3c4 0409 	ubfx	r4, r4, #0, #10
        file->cache.size = lfs->cfg->cache_size;
   131c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        file->ctz.size = lfs_tag_size(tag);
   131c4:	62ec      	str	r4, [r5, #44]	; 0x2c
        file->flags |= LFS_F_INLINE;
   131c6:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   131ca:	632a      	str	r2, [r5, #48]	; 0x30
        file->cache.size = lfs->cfg->cache_size;
   131cc:	64ab      	str	r3, [r5, #72]	; 0x48
        if (file->ctz.size > 0) {
   131ce:	2c00      	cmp	r4, #0
   131d0:	d086      	beq.n	130e0 <lfs_file_opencfg+0x100>
    return (a < b) ? a : b;
   131d2:	f240 31fe 	movw	r1, #1022	; 0x3fe
   131d6:	428b      	cmp	r3, r1
                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,
   131d8:	88aa      	ldrh	r2, [r5, #4]
   131da:	bf28      	it	cs
   131dc:	460b      	movcs	r3, r1
   131de:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
   131e2:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   131e4:	9200      	str	r2, [sp, #0]
   131e6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   131ea:	4a0b      	ldr	r2, [pc, #44]	; (13218 <lfs_file_opencfg+0x238>)
   131ec:	4639      	mov	r1, r7
   131ee:	4630      	mov	r0, r6
   131f0:	f004 fd62 	bl	17cb8 <lfs_dir_get>
            if (res < 0) {
   131f4:	1e04      	subs	r4, r0, #0
   131f6:	f6bf af73 	bge.w	130e0 <lfs_file_opencfg+0x100>
   131fa:	e729      	b.n	13050 <lfs_file_opencfg+0x70>
        err = LFS_ERR_EXIST;
   131fc:	f06f 0410 	mvn.w	r4, #16
   13200:	e726      	b.n	13050 <lfs_file_opencfg+0x70>
        err = LFS_ERR_ISDIR;
   13202:	f06f 0414 	mvn.w	r4, #20
   13206:	e723      	b.n	13050 <lfs_file_opencfg+0x70>
                err = LFS_ERR_NOSPC;
   13208:	f06f 041b 	mvn.w	r4, #27
   1320c:	e720      	b.n	13050 <lfs_file_opencfg+0x70>
   1320e:	bf00      	nop
   13210:	40100000 	.word	0x40100000
   13214:	20100000 	.word	0x20100000
   13218:	700ffc00 	.word	0x700ffc00
   1321c:	7ffffc00 	.word	0x7ffffc00

00013220 <lfs_remove>:
int lfs_remove(lfs_t *lfs, const char *path) {
   13220:	b5f0      	push	{r4, r5, r6, r7, lr}
   13222:	b099      	sub	sp, #100	; 0x64
   13224:	4604      	mov	r4, r0
   13226:	9103      	str	r1, [sp, #12]
    int err = lfs_fs_forceconsistency(lfs);
   13228:	f7ff fd9e 	bl	12d68 <lfs_fs_forceconsistency>
    if (err) {
   1322c:	2800      	cmp	r0, #0
   1322e:	d15d      	bne.n	132ec <lfs_remove+0xcc>
    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
   13230:	4603      	mov	r3, r0
   13232:	aa03      	add	r2, sp, #12
   13234:	a906      	add	r1, sp, #24
   13236:	4620      	mov	r0, r4
   13238:	f7fe fc14 	bl	11a64 <lfs_dir_find>
    if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {
   1323c:	2800      	cmp	r0, #0
   1323e:	db55      	blt.n	132ec <lfs_remove+0xcc>
    return (tag & 0x000ffc00) >> 10;
   13240:	f3c0 2389 	ubfx	r3, r0, #10, #10
    if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {
   13244:	f240 32ff 	movw	r2, #1023	; 0x3ff
   13248:	4293      	cmp	r3, r2
   1324a:	d051      	beq.n	132f0 <lfs_remove+0xd0>
    return (tag & 0x7ff00000) >> 20;
   1324c:	0d06      	lsrs	r6, r0, #20
    dir.next = lfs->mlist;
   1324e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   13250:	920e      	str	r2, [sp, #56]	; 0x38
    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
   13252:	2e02      	cmp	r6, #2
   13254:	ea4f 2583 	mov.w	r5, r3, lsl #10
   13258:	af04      	add	r7, sp, #16
   1325a:	d121      	bne.n	132a0 <lfs_remove+0x80>
        lfs_stag_t res = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x700, 0x3ff, 0),
   1325c:	f045 5300 	orr.w	r3, r5, #536870912	; 0x20000000
   13260:	4a25      	ldr	r2, [pc, #148]	; (132f8 <lfs_remove+0xd8>)
   13262:	9700      	str	r7, [sp, #0]
   13264:	f043 0308 	orr.w	r3, r3, #8
   13268:	a906      	add	r1, sp, #24
   1326a:	4620      	mov	r0, r4
   1326c:	f004 fd24 	bl	17cb8 <lfs_dir_get>
        if (res < 0) {
   13270:	2800      	cmp	r0, #0
   13272:	db3b      	blt.n	132ec <lfs_remove+0xcc>
        err = lfs_dir_fetch(lfs, &dir.m, pair);
   13274:	463a      	mov	r2, r7
   13276:	a910      	add	r1, sp, #64	; 0x40
   13278:	4620      	mov	r0, r4
   1327a:	f004 fce7 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   1327e:	2800      	cmp	r0, #0
   13280:	d134      	bne.n	132ec <lfs_remove+0xcc>
        if (dir.m.count > 0 || dir.m.split) {
   13282:	9b15      	ldr	r3, [sp, #84]	; 0x54
   13284:	f433 027f 	bics.w	r2, r3, #16711680	; 0xff0000
   13288:	d12e      	bne.n	132e8 <lfs_remove+0xc8>
        lfs_fs_preporphans(lfs, +1);
   1328a:	2101      	movs	r1, #1
   1328c:	f104 0030 	add.w	r0, r4, #48	; 0x30
   13290:	f004 fc07 	bl	17aa2 <lfs_fs_preporphans.isra.0>
        lfs->mlist = &dir;
   13294:	ab0e      	add	r3, sp, #56	; 0x38
        dir.type = 0;
   13296:	f88d 203e 	strb.w	r2, [sp, #62]	; 0x3e
        dir.id = 0;
   1329a:	f8ad 203c 	strh.w	r2, [sp, #60]	; 0x3c
        lfs->mlist = &dir;
   1329e:	62a3      	str	r3, [r4, #40]	; 0x28
    err = lfs_dir_commit(lfs, &cwd, LFS_MKATTRS(
   132a0:	2300      	movs	r3, #0
   132a2:	f045 459f 	orr.w	r5, r5, #1333788672	; 0x4f800000
   132a6:	9305      	str	r3, [sp, #20]
   132a8:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
   132ac:	2301      	movs	r3, #1
   132ae:	463a      	mov	r2, r7
   132b0:	a906      	add	r1, sp, #24
   132b2:	4620      	mov	r0, r4
   132b4:	9504      	str	r5, [sp, #16]
   132b6:	f7ff fbab 	bl	12a10 <lfs_dir_commit>
    if (err) {
   132ba:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        lfs->mlist = dir.next;
   132bc:	62a3      	str	r3, [r4, #40]	; 0x28
    if (err) {
   132be:	b9a8      	cbnz	r0, 132ec <lfs_remove+0xcc>
    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
   132c0:	2e02      	cmp	r6, #2
   132c2:	d113      	bne.n	132ec <lfs_remove+0xcc>
        lfs_fs_preporphans(lfs, -1);
   132c4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   132c8:	f104 0030 	add.w	r0, r4, #48	; 0x30
   132cc:	f004 fbe9 	bl	17aa2 <lfs_fs_preporphans.isra.0>
        err = lfs_fs_pred(lfs, dir.m.pair, &cwd);
   132d0:	aa06      	add	r2, sp, #24
   132d2:	a910      	add	r1, sp, #64	; 0x40
   132d4:	4620      	mov	r0, r4
   132d6:	f004 fcc6 	bl	17c66 <lfs_fs_pred>
        if (err) {
   132da:	b938      	cbnz	r0, 132ec <lfs_remove+0xcc>
        err = lfs_dir_drop(lfs, &cwd, &dir.m);
   132dc:	aa10      	add	r2, sp, #64	; 0x40
   132de:	a906      	add	r1, sp, #24
   132e0:	4620      	mov	r0, r4
   132e2:	f7ff fd23 	bl	12d2c <lfs_dir_drop>
        if (err) {
   132e6:	e001      	b.n	132ec <lfs_remove+0xcc>
            return LFS_ERR_NOTEMPTY;
   132e8:	f06f 0026 	mvn.w	r0, #38	; 0x26
}
   132ec:	b019      	add	sp, #100	; 0x64
   132ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return (tag < 0) ? (int)tag : LFS_ERR_INVAL;
   132f0:	f06f 0015 	mvn.w	r0, #21
   132f4:	e7fa      	b.n	132ec <lfs_remove+0xcc>
   132f6:	bf00      	nop
   132f8:	700ffc00 	.word	0x700ffc00

000132fc <lfs_rename>:
int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {
   132fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13300:	b0ac      	sub	sp, #176	; 0xb0
   13302:	e9cd 2102 	strd	r2, r1, [sp, #8]
   13306:	4605      	mov	r5, r0
    int err = lfs_fs_forceconsistency(lfs);
   13308:	f7ff fd2e 	bl	12d68 <lfs_fs_forceconsistency>
    if (err) {
   1330c:	4603      	mov	r3, r0
   1330e:	2800      	cmp	r0, #0
   13310:	f040 8105 	bne.w	1351e <lfs_rename+0x222>
    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);
   13314:	f10d 0920 	add.w	r9, sp, #32
   13318:	aa03      	add	r2, sp, #12
   1331a:	4649      	mov	r1, r9
   1331c:	4628      	mov	r0, r5
   1331e:	f7fe fba1 	bl	11a64 <lfs_dir_find>
    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {
   13322:	1e04      	subs	r4, r0, #0
   13324:	db08      	blt.n	13338 <lfs_rename+0x3c>
    return (tag & 0x000ffc00) >> 10;
   13326:	f240 38ff 	movw	r8, #1023	; 0x3ff
   1332a:	f3c4 2789 	ubfx	r7, r4, #10, #10
    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {
   1332e:	4547      	cmp	r7, r8
   13330:	4626      	mov	r6, r4
   13332:	d105      	bne.n	13340 <lfs_rename+0x44>
        return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;
   13334:	f06f 0415 	mvn.w	r4, #21
}
   13338:	4620      	mov	r0, r4
   1333a:	b02c      	add	sp, #176	; 0xb0
   1333c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);
   13340:	f10d 0316 	add.w	r3, sp, #22
   13344:	aa02      	add	r2, sp, #8
   13346:	a910      	add	r1, sp, #64	; 0x40
   13348:	4628      	mov	r0, r5
   1334a:	f7fe fb8b 	bl	11a64 <lfs_dir_find>
    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&
   1334e:	1e04      	subs	r4, r0, #0
   13350:	db26      	blt.n	133a0 <lfs_rename+0xa4>
   13352:	f3c4 2389 	ubfx	r3, r4, #10, #10
   13356:	4543      	cmp	r3, r8
   13358:	d0ec      	beq.n	13334 <lfs_rename+0x38>
    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);
   1335a:	a910      	add	r1, sp, #64	; 0x40
   1335c:	4648      	mov	r0, r9
   1335e:	f004 fb29 	bl	179b4 <lfs_pair_cmp>
    prevdir.next = lfs->mlist;
   13362:	6aab      	ldr	r3, [r5, #40]	; 0x28
   13364:	9318      	str	r3, [sp, #96]	; 0x60
    if (prevtag == LFS_ERR_NOENT) {
   13366:	1ca1      	adds	r1, r4, #2
    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);
   13368:	4680      	mov	r8, r0
    if (prevtag == LFS_ERR_NOENT) {
   1336a:	d162      	bne.n	13432 <lfs_rename+0x136>
        lfs_size_t nlen = strlen(newpath);
   1336c:	9802      	ldr	r0, [sp, #8]
   1336e:	f002 fe32 	bl	15fd6 <strlen>
        if (nlen > lfs->name_max) {
   13372:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   13374:	4283      	cmp	r3, r0
   13376:	f0c0 80d4 	bcc.w	13522 <lfs_rename+0x226>
        if (samepair && newid <= newoldid) {
   1337a:	f1b8 0f00 	cmp.w	r8, #0
   1337e:	d016      	beq.n	133ae <lfs_rename+0xb2>
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   13380:	6b2a      	ldr	r2, [r5, #48]	; 0x30
   13382:	4b6c      	ldr	r3, [pc, #432]	; (13534 <lfs_rename+0x238>)
   13384:	4013      	ands	r3, r2
   13386:	ea43 2387 	orr.w	r3, r3, r7, lsl #10
   1338a:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
   1338e:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
   13392:	632b      	str	r3, [r5, #48]	; 0x30
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
   13394:	9b08      	ldr	r3, [sp, #32]
   13396:	636b      	str	r3, [r5, #52]	; 0x34
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
   13398:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1339a:	63ab      	str	r3, [r5, #56]	; 0x38
   1339c:	46ba      	mov	sl, r7
   1339e:	e00c      	b.n	133ba <lfs_rename+0xbe>
    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&
   133a0:	1ca0      	adds	r0, r4, #2
   133a2:	d1c9      	bne.n	13338 <lfs_rename+0x3c>
            !(prevtag == LFS_ERR_NOENT && newid != 0x3ff)) {
   133a4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   133a8:	4543      	cmp	r3, r8
   133aa:	d1d6      	bne.n	1335a <lfs_rename+0x5e>
   133ac:	e7c4      	b.n	13338 <lfs_rename+0x3c>
        if (samepair && newid <= newoldid) {
   133ae:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   133b2:	42bb      	cmp	r3, r7
   133b4:	d8f2      	bhi.n	1339c <lfs_rename+0xa0>
            newoldid += 1;
   133b6:	f107 0a01 	add.w	sl, r7, #1
    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(
   133ba:	2224      	movs	r2, #36	; 0x24
   133bc:	2100      	movs	r1, #0
   133be:	a823      	add	r0, sp, #140	; 0x8c
   133c0:	f002 fe66 	bl	16090 <memset>
   133c4:	f8bd 0016 	ldrh.w	r0, [sp, #22]
   133c8:	1ca2      	adds	r2, r4, #2
   133ca:	ea4f 2080 	mov.w	r0, r0, lsl #10
   133ce:	bf1a      	itte	ne
   133d0:	f040 439f 	orrne.w	r3, r0, #1333788672	; 0x4f800000
   133d4:	f443 03e0 	orrne.w	r3, r3, #7340032	; 0x700000
   133d8:	2300      	moveq	r3, #0
   133da:	0d36      	lsrs	r6, r6, #20
   133dc:	9322      	str	r3, [sp, #136]	; 0x88
   133de:	0536      	lsls	r6, r6, #20
   133e0:	f040 4380 	orr.w	r3, r0, #1073741824	; 0x40000000
   133e4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   133e8:	4306      	orrs	r6, r0
   133ea:	9802      	ldr	r0, [sp, #8]
   133ec:	9324      	str	r3, [sp, #144]	; 0x90
   133ee:	f002 fdf2 	bl	15fd6 <strlen>
   133f2:	9b02      	ldr	r3, [sp, #8]
   133f4:	9327      	str	r3, [sp, #156]	; 0x9c
   133f6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   133fa:	ea47 2383 	orr.w	r3, r7, r3, lsl #10
   133fe:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   13402:	4306      	orrs	r6, r0
   13404:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   13408:	e9cd 3928 	strd	r3, r9, [sp, #160]	; 0xa0
   1340c:	9626      	str	r6, [sp, #152]	; 0x98
   1340e:	f1b8 0f00 	cmp.w	r8, #0
   13412:	d14b      	bne.n	134ac <lfs_rename+0x1b0>
   13414:	4b48      	ldr	r3, [pc, #288]	; (13538 <lfs_rename+0x23c>)
   13416:	ea43 238a 	orr.w	r3, r3, sl, lsl #10
   1341a:	932a      	str	r3, [sp, #168]	; 0xa8
   1341c:	aa22      	add	r2, sp, #136	; 0x88
   1341e:	2305      	movs	r3, #5
   13420:	a910      	add	r1, sp, #64	; 0x40
   13422:	4628      	mov	r0, r5
   13424:	f7ff faf4 	bl	12a10 <lfs_dir_commit>
    if (err) {
   13428:	2800      	cmp	r0, #0
   1342a:	d041      	beq.n	134b0 <lfs_rename+0x1b4>
        lfs->mlist = prevdir.next;
   1342c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1342e:	62ab      	str	r3, [r5, #40]	; 0x28
   13430:	e03a      	b.n	134a8 <lfs_rename+0x1ac>
    return (tag & 0x7ff00000) >> 20;
   13432:	f3c4 530a 	ubfx	r3, r4, #20, #11
    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {
   13436:	ebb3 5f16 	cmp.w	r3, r6, lsr #20
   1343a:	ea4f 5216 	mov.w	r2, r6, lsr #20
   1343e:	d173      	bne.n	13528 <lfs_rename+0x22c>
    } else if (samepair && newid == newoldid) {
   13440:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   13444:	2800      	cmp	r0, #0
   13446:	d172      	bne.n	1352e <lfs_rename+0x232>
   13448:	429f      	cmp	r7, r3
   1344a:	d101      	bne.n	13450 <lfs_rename+0x154>
        return 0;
   1344c:	2400      	movs	r4, #0
   1344e:	e773      	b.n	13338 <lfs_rename+0x3c>
    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
   13450:	2a02      	cmp	r2, #2
   13452:	d1a3      	bne.n	1339c <lfs_rename+0xa0>
        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),
   13454:	4a39      	ldr	r2, [pc, #228]	; (1353c <lfs_rename+0x240>)
   13456:	f10d 0a88 	add.w	sl, sp, #136	; 0x88
   1345a:	ea42 2383 	orr.w	r3, r2, r3, lsl #10
   1345e:	f8cd a000 	str.w	sl, [sp]
   13462:	4a37      	ldr	r2, [pc, #220]	; (13540 <lfs_rename+0x244>)
   13464:	a910      	add	r1, sp, #64	; 0x40
   13466:	4628      	mov	r0, r5
   13468:	f004 fc26 	bl	17cb8 <lfs_dir_get>
        if (res < 0) {
   1346c:	2800      	cmp	r0, #0
   1346e:	db1b      	blt.n	134a8 <lfs_rename+0x1ac>
        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);
   13470:	4652      	mov	r2, sl
   13472:	a91a      	add	r1, sp, #104	; 0x68
   13474:	4628      	mov	r0, r5
   13476:	f004 fbe9 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   1347a:	b9a8      	cbnz	r0, 134a8 <lfs_rename+0x1ac>
        if (prevdir.m.count > 0 || prevdir.m.split) {
   1347c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1347e:	f433 027f 	bics.w	r2, r3, #16711680	; 0xff0000
   13482:	d10f      	bne.n	134a4 <lfs_rename+0x1a8>
        lfs_fs_preporphans(lfs, +1);
   13484:	2101      	movs	r1, #1
   13486:	f105 0030 	add.w	r0, r5, #48	; 0x30
   1348a:	f004 fb0a 	bl	17aa2 <lfs_fs_preporphans.isra.0>
        lfs->mlist = &prevdir;
   1348e:	ab18      	add	r3, sp, #96	; 0x60
        prevdir.type = 0;
   13490:	f88d 2066 	strb.w	r2, [sp, #102]	; 0x66
        prevdir.id = 0;
   13494:	f8ad 2064 	strh.w	r2, [sp, #100]	; 0x64
        lfs->mlist = &prevdir;
   13498:	62ab      	str	r3, [r5, #40]	; 0x28
    if (!samepair) {
   1349a:	f1b8 0f00 	cmp.w	r8, #0
   1349e:	f43f af7d 	beq.w	1339c <lfs_rename+0xa0>
   134a2:	e76d      	b.n	13380 <lfs_rename+0x84>
            return LFS_ERR_NOTEMPTY;
   134a4:	f06f 0026 	mvn.w	r0, #38	; 0x26
        return err;
   134a8:	4604      	mov	r4, r0
   134aa:	e745      	b.n	13338 <lfs_rename+0x3c>
    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(
   134ac:	2300      	movs	r3, #0
   134ae:	e7b4      	b.n	1341a <lfs_rename+0x11e>
    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {
   134b0:	f1b8 0f00 	cmp.w	r8, #0
   134b4:	d016      	beq.n	134e4 <lfs_rename+0x1e8>
   134b6:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    return (tag & 0x70000000) >> 20;
   134b8:	0d13      	lsrs	r3, r2, #20
    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {
   134ba:	f413 6fe0 	tst.w	r3, #1792	; 0x700
   134be:	d011      	beq.n	134e4 <lfs_rename+0x1e8>
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   134c0:	4b1c      	ldr	r3, [pc, #112]	; (13534 <lfs_rename+0x238>)
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
   134c2:	63a8      	str	r0, [r5, #56]	; 0x38
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
   134c4:	4013      	ands	r3, r2
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
   134c6:	e9c5 300c 	strd	r3, r0, [r5, #48]	; 0x30
        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(
   134ca:	4b1b      	ldr	r3, [pc, #108]	; (13538 <lfs_rename+0x23c>)
   134cc:	9007      	str	r0, [sp, #28]
   134ce:	ea43 2787 	orr.w	r7, r3, r7, lsl #10
   134d2:	aa06      	add	r2, sp, #24
   134d4:	2301      	movs	r3, #1
   134d6:	4649      	mov	r1, r9
   134d8:	4628      	mov	r0, r5
   134da:	9706      	str	r7, [sp, #24]
   134dc:	f7ff fa98 	bl	12a10 <lfs_dir_commit>
        if (err) {
   134e0:	2800      	cmp	r0, #0
   134e2:	d1a3      	bne.n	1342c <lfs_rename+0x130>
    lfs->mlist = prevdir.next;
   134e4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   134e6:	62ab      	str	r3, [r5, #40]	; 0x28
    if (prevtag != LFS_ERR_NOENT && lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
   134e8:	1ca3      	adds	r3, r4, #2
   134ea:	d0af      	beq.n	1344c <lfs_rename+0x150>
   134ec:	f3c4 500a 	ubfx	r0, r4, #20, #11
   134f0:	2802      	cmp	r0, #2
   134f2:	d1ab      	bne.n	1344c <lfs_rename+0x150>
        lfs_fs_preporphans(lfs, -1);
   134f4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   134f8:	f105 0030 	add.w	r0, r5, #48	; 0x30
   134fc:	f004 fad1 	bl	17aa2 <lfs_fs_preporphans.isra.0>
        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);
   13500:	aa10      	add	r2, sp, #64	; 0x40
   13502:	a91a      	add	r1, sp, #104	; 0x68
   13504:	4628      	mov	r0, r5
   13506:	f004 fbae 	bl	17c66 <lfs_fs_pred>
        if (err) {
   1350a:	4604      	mov	r4, r0
   1350c:	2800      	cmp	r0, #0
   1350e:	f47f af13 	bne.w	13338 <lfs_rename+0x3c>
        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);
   13512:	aa1a      	add	r2, sp, #104	; 0x68
   13514:	a910      	add	r1, sp, #64	; 0x40
   13516:	4628      	mov	r0, r5
   13518:	f7ff fc08 	bl	12d2c <lfs_dir_drop>
   1351c:	e7c4      	b.n	134a8 <lfs_rename+0x1ac>
   1351e:	4604      	mov	r4, r0
   13520:	e70a      	b.n	13338 <lfs_rename+0x3c>
            return LFS_ERR_NAMETOOLONG;
   13522:	f06f 0423 	mvn.w	r4, #35	; 0x23
   13526:	e707      	b.n	13338 <lfs_rename+0x3c>
        return LFS_ERR_ISDIR;
   13528:	f06f 0414 	mvn.w	r4, #20
   1352c:	e704      	b.n	13338 <lfs_rename+0x3c>
    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
   1352e:	2a02      	cmp	r2, #2
   13530:	d090      	beq.n	13454 <lfs_rename+0x158>
   13532:	e725      	b.n	13380 <lfs_rename+0x84>
   13534:	800003ff 	.word	0x800003ff
   13538:	4ff00000 	.word	0x4ff00000
   1353c:	20000008 	.word	0x20000008
   13540:	700ffc00 	.word	0x700ffc00

00013544 <lfs_format>:
int lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {
   13544:	b530      	push	{r4, r5, lr}
   13546:	b097      	sub	sp, #92	; 0x5c
   13548:	4605      	mov	r5, r0
        err = lfs_init(lfs, cfg);
   1354a:	f004 fbcc 	bl	17ce6 <lfs_init>
        if (err) {
   1354e:	4604      	mov	r4, r0
   13550:	2800      	cmp	r0, #0
   13552:	d14e      	bne.n	135f2 <lfs_format+0xae>
        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
   13554:	6eab      	ldr	r3, [r5, #104]	; 0x68
   13556:	4601      	mov	r1, r0
   13558:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1355a:	6e68      	ldr	r0, [r5, #100]	; 0x64
   1355c:	f002 fd98 	bl	16090 <memset>
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
   13560:	6eab      	ldr	r3, [r5, #104]	; 0x68
        lfs->free.off = 0;
   13562:	656c      	str	r4, [r5, #84]	; 0x54
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
   13564:	6a1a      	ldr	r2, [r3, #32]
   13566:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13568:	00db      	lsls	r3, r3, #3
    lfs->free.ack = lfs->cfg->block_count;
   1356a:	e9c5 4217 	strd	r4, r2, [r5, #92]	; 0x5c
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
   1356e:	4293      	cmp	r3, r2
   13570:	bf94      	ite	ls
   13572:	65ab      	strls	r3, [r5, #88]	; 0x58
   13574:	65aa      	strhi	r2, [r5, #88]	; 0x58
        err = lfs_dir_alloc(lfs, &root);
   13576:	a90e      	add	r1, sp, #56	; 0x38
   13578:	4628      	mov	r0, r5
   1357a:	f004 ff21 	bl	183c0 <lfs_dir_alloc>
        if (err) {
   1357e:	4604      	mov	r4, r0
   13580:	2800      	cmp	r0, #0
   13582:	d133      	bne.n	135ec <lfs_format+0xa8>
        lfs_superblock_t superblock = {
   13584:	f44f 3300 	mov.w	r3, #131072	; 0x20000
   13588:	9302      	str	r3, [sp, #8]
            .block_size  = lfs->cfg->block_size,
   1358a:	6eab      	ldr	r3, [r5, #104]	; 0x68
        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
   1358c:	9009      	str	r0, [sp, #36]	; 0x24
        lfs_superblock_t superblock = {
   1358e:	69da      	ldr	r2, [r3, #28]
   13590:	6a1b      	ldr	r3, [r3, #32]
   13592:	9304      	str	r3, [sp, #16]
   13594:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   13596:	9305      	str	r3, [sp, #20]
   13598:	6f2b      	ldr	r3, [r5, #112]	; 0x70
   1359a:	9306      	str	r3, [sp, #24]
   1359c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
   1359e:	9307      	str	r3, [sp, #28]
        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
   135a0:	4b15      	ldr	r3, [pc, #84]	; (135f8 <lfs_format+0xb4>)
   135a2:	9308      	str	r3, [sp, #32]
   135a4:	4b15      	ldr	r3, [pc, #84]	; (135fc <lfs_format+0xb8>)
   135a6:	930a      	str	r3, [sp, #40]	; 0x28
   135a8:	4b15      	ldr	r3, [pc, #84]	; (13600 <lfs_format+0xbc>)
   135aa:	930b      	str	r3, [sp, #44]	; 0x2c
   135ac:	4b15      	ldr	r3, [pc, #84]	; (13604 <lfs_format+0xc0>)
   135ae:	930c      	str	r3, [sp, #48]	; 0x30
   135b0:	ab02      	add	r3, sp, #8
        lfs_superblock_t superblock = {
   135b2:	9203      	str	r2, [sp, #12]
        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
   135b4:	930d      	str	r3, [sp, #52]	; 0x34
   135b6:	aa08      	add	r2, sp, #32
   135b8:	2303      	movs	r3, #3
   135ba:	a90e      	add	r1, sp, #56	; 0x38
   135bc:	4628      	mov	r0, r5
   135be:	f7ff fa27 	bl	12a10 <lfs_dir_commit>
        if (err) {
   135c2:	4604      	mov	r4, r0
   135c4:	b990      	cbnz	r0, 135ec <lfs_format+0xa8>
        err = lfs_dir_fetch(lfs, &root, (const lfs_block_t[2]){0, 1});
   135c6:	9000      	str	r0, [sp, #0]
   135c8:	2301      	movs	r3, #1
   135ca:	466a      	mov	r2, sp
   135cc:	a90e      	add	r1, sp, #56	; 0x38
   135ce:	4628      	mov	r0, r5
   135d0:	9301      	str	r3, [sp, #4]
   135d2:	f004 fb3b 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   135d6:	4604      	mov	r4, r0
   135d8:	b940      	cbnz	r0, 135ec <lfs_format+0xa8>
        root.erased = false;
   135da:	f88d 004e 	strb.w	r0, [sp, #78]	; 0x4e
        err = lfs_dir_commit(lfs, &root, NULL, 0);
   135de:	4603      	mov	r3, r0
   135e0:	4602      	mov	r2, r0
   135e2:	a90e      	add	r1, sp, #56	; 0x38
   135e4:	4628      	mov	r0, r5
   135e6:	f7ff fa13 	bl	12a10 <lfs_dir_commit>
   135ea:	4604      	mov	r4, r0
    lfs_deinit(lfs);
   135ec:	4628      	mov	r0, r5
   135ee:	f004 fa42 	bl	17a76 <lfs_deinit>
}
   135f2:	4620      	mov	r0, r4
   135f4:	b017      	add	sp, #92	; 0x5c
   135f6:	bd30      	pop	{r4, r5, pc}
   135f8:	40100000 	.word	0x40100000
   135fc:	0ff00008 	.word	0x0ff00008
   13600:	0001bcfa 	.word	0x0001bcfa
   13604:	20100018 	.word	0x20100018

00013608 <lfs_crc>:
// Only compile if user does not provide custom config
#ifndef LFS_CONFIG


// Software CRC implementation with small lookup table
uint32_t lfs_crc(uint32_t crc, const void *buffer, size_t size) {
   13608:	b530      	push	{r4, r5, lr}
    };

    const uint8_t *data = buffer;

    for (size_t i = 0; i < size; i++) {
        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];
   1360a:	4d0c      	ldr	r5, [pc, #48]	; (1363c <lfs_crc+0x34>)
   1360c:	440a      	add	r2, r1
    for (size_t i = 0; i < size; i++) {
   1360e:	4291      	cmp	r1, r2
   13610:	d100      	bne.n	13614 <lfs_crc+0xc>
        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];
    }

    return crc;
}
   13612:	bd30      	pop	{r4, r5, pc}
        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];
   13614:	f811 3b01 	ldrb.w	r3, [r1], #1
   13618:	ea83 0400 	eor.w	r4, r3, r0
   1361c:	f004 040f 	and.w	r4, r4, #15
   13620:	f855 4024 	ldr.w	r4, [r5, r4, lsl #2]
   13624:	ea84 1010 	eor.w	r0, r4, r0, lsr #4
        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];
   13628:	ea80 1313 	eor.w	r3, r0, r3, lsr #4
   1362c:	f003 030f 	and.w	r3, r3, #15
   13630:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   13634:	ea83 1010 	eor.w	r0, r3, r0, lsr #4
    for (size_t i = 0; i < size; i++) {
   13638:	e7e9      	b.n	1360e <lfs_crc+0x6>
   1363a:	bf00      	nop
   1363c:	00019aec 	.word	0x00019aec

00013640 <z_sys_device_do_config_level>:
#endif
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
   13640:	4b09      	ldr	r3, [pc, #36]	; (13668 <z_sys_device_do_config_level+0x28>)
{
   13642:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
   13644:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   13648:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   1364a:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   1364c:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   13650:	42a5      	cmp	r5, r4
   13652:	d800      	bhi.n	13656 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   13654:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   13656:	6823      	ldr	r3, [r4, #0]
   13658:	4620      	mov	r0, r4
   1365a:	685b      	ldr	r3, [r3, #4]
   1365c:	4798      	blx	r3
		if (retval != 0) {
   1365e:	b100      	cbz	r0, 13662 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   13660:	6066      	str	r6, [r4, #4]
								info++) {
   13662:	340c      	adds	r4, #12
   13664:	e7f4      	b.n	13650 <z_sys_device_do_config_level+0x10>
   13666:	bf00      	nop
   13668:	00019b2c 	.word	0x00019b2c

0001366c <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   1366c:	4b10      	ldr	r3, [pc, #64]	; (136b0 <z_impl_device_get_binding+0x44>)
{
   1366e:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
   13670:	4c10      	ldr	r4, [pc, #64]	; (136b4 <z_impl_device_get_binding+0x48>)
{
   13672:	4605      	mov	r5, r0
   13674:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   13676:	429c      	cmp	r4, r3
   13678:	d104      	bne.n	13684 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   1367a:	4c0e      	ldr	r4, [pc, #56]	; (136b4 <z_impl_device_get_binding+0x48>)
   1367c:	42b4      	cmp	r4, r6
   1367e:	d109      	bne.n	13694 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   13680:	2400      	movs	r4, #0
   13682:	e012      	b.n	136aa <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   13684:	6862      	ldr	r2, [r4, #4]
   13686:	b11a      	cbz	r2, 13690 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   13688:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   1368a:	6812      	ldr	r2, [r2, #0]
   1368c:	42aa      	cmp	r2, r5
   1368e:	d00c      	beq.n	136aa <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   13690:	340c      	adds	r4, #12
   13692:	e7f0      	b.n	13676 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   13694:	6863      	ldr	r3, [r4, #4]
   13696:	b90b      	cbnz	r3, 1369c <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   13698:	340c      	adds	r4, #12
   1369a:	e7ef      	b.n	1367c <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   1369c:	6823      	ldr	r3, [r4, #0]
   1369e:	4628      	mov	r0, r5
   136a0:	6819      	ldr	r1, [r3, #0]
   136a2:	f002 fc9f 	bl	15fe4 <strcmp>
   136a6:	2800      	cmp	r0, #0
   136a8:	d1f6      	bne.n	13698 <z_impl_device_get_binding+0x2c>
}
   136aa:	4620      	mov	r0, r4
   136ac:	bd70      	pop	{r4, r5, r6, pc}
   136ae:	bf00      	nop
   136b0:	2000c28c 	.word	0x2000c28c
   136b4:	2000c160 	.word	0x2000c160

000136b8 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   136b8:	4b01      	ldr	r3, [pc, #4]	; (136c0 <z_impl_z_errno+0x8>)
   136ba:	6898      	ldr	r0, [r3, #8]
}
   136bc:	305c      	adds	r0, #92	; 0x5c
   136be:	4770      	bx	lr
   136c0:	200040e8 	.word	0x200040e8

000136c4 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   136c4:	b510      	push	{r4, lr}
   136c6:	4604      	mov	r4, r0
	z_impl_log_panic();
   136c8:	f7ef fb5e 	bl	2d88 <z_impl_log_panic>
   136cc:	4b06      	ldr	r3, [pc, #24]	; (136e8 <k_sys_fatal_error_handler+0x24>)
   136ce:	4907      	ldr	r1, [pc, #28]	; (136ec <k_sys_fatal_error_handler+0x28>)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   136d0:	4807      	ldr	r0, [pc, #28]	; (136f0 <k_sys_fatal_error_handler+0x2c>)
   136d2:	1ac9      	subs	r1, r1, r3
   136d4:	08c9      	lsrs	r1, r1, #3
   136d6:	0189      	lsls	r1, r1, #6
   136d8:	f041 0101 	orr.w	r1, r1, #1
   136dc:	f001 fdb5 	bl	1524a <log_0>
	arch_system_halt(reason);
   136e0:	4620      	mov	r0, r4
   136e2:	f005 f927 	bl	18934 <arch_system_halt>
   136e6:	bf00      	nop
   136e8:	0001956c 	.word	0x0001956c
   136ec:	0001962c 	.word	0x0001962c
   136f0:	0001c192 	.word	0x0001c192

000136f4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   136f4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   136f8:	4605      	mov	r5, r0
   136fa:	460f      	mov	r7, r1
	__asm__ volatile(
   136fc:	f04f 0320 	mov.w	r3, #32
   13700:	f3ef 8811 	mrs	r8, BASEPRI
   13704:	f383 8811 	msr	BASEPRI, r3
   13708:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   1370c:	f000 fde8 	bl	142e0 <z_impl_k_current_get>
   13710:	4c21      	ldr	r4, [pc, #132]	; (13798 <z_fatal_error+0xa4>)
   13712:	4b22      	ldr	r3, [pc, #136]	; (1379c <z_fatal_error+0xa8>)
   13714:	1ae4      	subs	r4, r4, r3
   13716:	2d04      	cmp	r5, #4
   13718:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   1371c:	bf96      	itet	ls
   1371e:	4a20      	ldrls	r2, [pc, #128]	; (137a0 <z_fatal_error+0xac>)
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   13720:	4a20      	ldrhi	r2, [pc, #128]	; (137a4 <z_fatal_error+0xb0>)
   13722:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
   13726:	01a4      	lsls	r4, r4, #6
   13728:	f044 0301 	orr.w	r3, r4, #1
   1372c:	4606      	mov	r6, r0
   1372e:	f8ad 3000 	strh.w	r3, [sp]
   13732:	481d      	ldr	r0, [pc, #116]	; (137a8 <z_fatal_error+0xb4>)
   13734:	2300      	movs	r3, #0
   13736:	4629      	mov	r1, r5
   13738:	f001 fdc1 	bl	152be <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   1373c:	b147      	cbz	r7, 13750 <z_fatal_error+0x5c>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   1373e:	69fb      	ldr	r3, [r7, #28]
   13740:	f3c3 0308 	ubfx	r3, r3, #0, #9
   13744:	b123      	cbz	r3, 13750 <z_fatal_error+0x5c>
		LOG_ERR("Fault during interrupt handling\n");
   13746:	4819      	ldr	r0, [pc, #100]	; (137ac <z_fatal_error+0xb8>)
   13748:	f044 0101 	orr.w	r1, r4, #1
   1374c:	f001 fd7d 	bl	1524a <log_0>
	const char *thread_name = k_thread_name_get(thread);
   13750:	4630      	mov	r0, r6
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   13752:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = k_thread_name_get(thread);
   13756:	f005 fbf3 	bl	18f40 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   1375a:	b1d0      	cbz	r0, 13792 <z_fatal_error+0x9e>
   1375c:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   1375e:	4b14      	ldr	r3, [pc, #80]	; (137b0 <z_fatal_error+0xbc>)
   13760:	2a00      	cmp	r2, #0
   13762:	bf08      	it	eq
   13764:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   13766:	f7ef f995 	bl	2a94 <log_strdup>
   1376a:	4623      	mov	r3, r4
   1376c:	4602      	mov	r2, r0
   1376e:	4631      	mov	r1, r6
   13770:	4810      	ldr	r0, [pc, #64]	; (137b4 <z_fatal_error+0xc0>)
   13772:	f001 fd8b 	bl	1528c <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   13776:	4639      	mov	r1, r7
   13778:	4628      	mov	r0, r5
   1377a:	f7ff ffa3 	bl	136c4 <k_sys_fatal_error_handler>
	__asm__ volatile(
   1377e:	f388 8811 	msr	BASEPRI, r8
   13782:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   13786:	4630      	mov	r0, r6
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   13788:	b002      	add	sp, #8
   1378a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1378e:	f7f2 bd03 	b.w	6198 <z_impl_k_thread_abort>
		thread_name = "unknown";
   13792:	4807      	ldr	r0, [pc, #28]	; (137b0 <z_fatal_error+0xbc>)
   13794:	e7e7      	b.n	13766 <z_fatal_error+0x72>
   13796:	bf00      	nop
   13798:	0001962c 	.word	0x0001962c
   1379c:	0001956c 	.word	0x0001956c
   137a0:	00019b44 	.word	0x00019b44
   137a4:	0001c1a1 	.word	0x0001c1a1
   137a8:	0001c1b7 	.word	0x0001c1b7
   137ac:	0001c1df 	.word	0x0001c1df
   137b0:	0001c1af 	.word	0x0001c1af
   137b4:	0001c200 	.word	0x0001c200

000137b8 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   137b8:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   137ba:	4d0b      	ldr	r5, [pc, #44]	; (137e8 <idle+0x30>)
	__asm__ volatile(
   137bc:	f04f 0220 	mov.w	r2, #32
   137c0:	f3ef 8311 	mrs	r3, BASEPRI
   137c4:	f382 8811 	msr	BASEPRI, r2
   137c8:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   137cc:	f005 fbd0 	bl	18f70 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   137d0:	2101      	movs	r1, #1
   137d2:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
   137d4:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   137d6:	bfd8      	it	le
   137d8:	4608      	movle	r0, r1
   137da:	f005 fbd9 	bl	18f90 <z_set_timeout_expiry>
	_kernel.idle = ticks;
   137de:	622c      	str	r4, [r5, #32]
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   137e0:	f7f2 fa0e 	bl	5c00 <arch_cpu_idle>
}
   137e4:	e7ea      	b.n	137bc <idle+0x4>
   137e6:	bf00      	nop
   137e8:	200040e8 	.word	0x200040e8

000137ec <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   137ec:	4802      	ldr	r0, [pc, #8]	; (137f8 <z_bss_zero+0xc>)
   137ee:	4a03      	ldr	r2, [pc, #12]	; (137fc <z_bss_zero+0x10>)
   137f0:	2100      	movs	r1, #0
   137f2:	1a12      	subs	r2, r2, r0
   137f4:	f002 bc4c 	b.w	16090 <memset>
   137f8:	20000000 	.word	0x20000000
   137fc:	200087e0 	.word	0x200087e0

00013800 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   13800:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
   13802:	4806      	ldr	r0, [pc, #24]	; (1381c <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
   13804:	4a06      	ldr	r2, [pc, #24]	; (13820 <z_data_copy+0x20>)
   13806:	4907      	ldr	r1, [pc, #28]	; (13824 <z_data_copy+0x24>)
   13808:	1a12      	subs	r2, r2, r0
   1380a:	f002 fc16 	bl	1603a <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   1380e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   13812:	4a05      	ldr	r2, [pc, #20]	; (13828 <z_data_copy+0x28>)
   13814:	4905      	ldr	r1, [pc, #20]	; (1382c <z_data_copy+0x2c>)
   13816:	4806      	ldr	r0, [pc, #24]	; (13830 <z_data_copy+0x30>)
   13818:	f002 bc0f 	b.w	1603a <memcpy>
   1381c:	2000ba38 	.word	0x2000ba38
   13820:	2000c510 	.word	0x2000c510
   13824:	0001c2d1 	.word	0x0001c2d1
   13828:	00000000 	.word	0x00000000
   1382c:	0001c2cc 	.word	0x0001c2cc
   13830:	20000000 	.word	0x20000000

00013834 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   13834:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   13836:	4b0c      	ldr	r3, [pc, #48]	; (13868 <bg_thread_main+0x34>)
   13838:	2201      	movs	r2, #1

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1383a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   1383c:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1383e:	f7ff feff 	bl	13640 <z_sys_device_do_config_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   13842:	4a0a      	ldr	r2, [pc, #40]	; (1386c <bg_thread_main+0x38>)
   13844:	490a      	ldr	r1, [pc, #40]	; (13870 <bg_thread_main+0x3c>)
   13846:	480b      	ldr	r0, [pc, #44]	; (13874 <bg_thread_main+0x40>)
   13848:	f001 f96f 	bl	14b2a <printk>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   1384c:	2003      	movs	r0, #3
   1384e:	f7ff fef7 	bl	13640 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   13852:	f000 fe01 	bl	14458 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   13856:	f7ee fbdf 	bl	2018 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   1385a:	4a07      	ldr	r2, [pc, #28]	; (13878 <bg_thread_main+0x44>)
   1385c:	7b13      	ldrb	r3, [r2, #12]
   1385e:	f023 0301 	bic.w	r3, r3, #1
   13862:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   13864:	bd08      	pop	{r3, pc}
   13866:	bf00      	nop
   13868:	200087de 	.word	0x200087de
   1386c:	00019ce1 	.word	0x00019ce1
   13870:	0001c262 	.word	0x0001c262
   13874:	0001c283 	.word	0x0001c283
   13878:	20003ef4 	.word	0x20003ef4

0001387c <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   1387c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
   13880:	b0a5      	sub	sp, #148	; 0x94
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   13882:	f7ef f85f 	bl	2944 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
   13886:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 13984 <z_cstart+0x108>
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   1388a:	f38a 8808 	msr	MSP, sl
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   1388e:	4d35      	ldr	r5, [pc, #212]	; (13964 <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
   13890:	4e35      	ldr	r6, [pc, #212]	; (13968 <z_cstart+0xec>)
   13892:	696b      	ldr	r3, [r5, #20]
	z_setup_new_thread(&z_main_thread, z_main_stack,
   13894:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 13988 <z_cstart+0x10c>
   13898:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 1398c <z_cstart+0x110>
	z_setup_new_thread(thread, stack,
   1389c:	4f33      	ldr	r7, [pc, #204]	; (1396c <z_cstart+0xf0>)
   1389e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   138a2:	2400      	movs	r4, #0
   138a4:	616b      	str	r3, [r5, #20]
   138a6:	23e0      	movs	r3, #224	; 0xe0
   138a8:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   138ac:	77ec      	strb	r4, [r5, #31]
   138ae:	762c      	strb	r4, [r5, #24]
   138b0:	766c      	strb	r4, [r5, #25]
   138b2:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   138b4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   138b6:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   138ba:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   138bc:	f7f2 fc4a 	bl	6154 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   138c0:	f7f2 f998 	bl	5bf4 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   138c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   138c8:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   138ca:	62eb      	str	r3, [r5, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   138cc:	ab07      	add	r3, sp, #28
   138ce:	2274      	movs	r2, #116	; 0x74
   138d0:	4621      	mov	r1, r4
   138d2:	4618      	mov	r0, r3
   138d4:	f002 fbdc 	bl	16090 <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current_cpu->current = &dummy_thread;
   138d8:	4d25      	ldr	r5, [pc, #148]	; (13970 <z_cstart+0xf4>)
	struct k_thread dummy_thread = {
   138da:	f04f 0801 	mov.w	r8, #1
	_current_cpu->current = &dummy_thread;
   138de:	60a8      	str	r0, [r5, #8]
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   138e0:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
   138e2:	f88d 8029 	strb.w	r8, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   138e6:	f7ff feab 	bl	13640 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   138ea:	4640      	mov	r0, r8
   138ec:	f7ff fea8 	bl	13640 <z_sys_device_do_config_level>
	z_sched_init();
   138f0:	f000 fc74 	bl	141dc <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   138f4:	4b1f      	ldr	r3, [pc, #124]	; (13974 <z_cstart+0xf8>)
	_kernel.ready_q.cache = &z_main_thread;
   138f6:	626e      	str	r6, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   138f8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   138fc:	4649      	mov	r1, r9
   138fe:	e9cd 8304 	strd	r8, r3, [sp, #16]
   13902:	4630      	mov	r0, r6
   13904:	465b      	mov	r3, fp
   13906:	e9cd 4402 	strd	r4, r4, [sp, #8]
   1390a:	e9cd 4400 	strd	r4, r4, [sp]
   1390e:	f000 fd4d 	bl	143ac <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   13912:	7b73      	ldrb	r3, [r6, #13]
	z_ready_thread(&z_main_thread);
   13914:	4630      	mov	r0, r6
   13916:	f023 0304 	bic.w	r3, r3, #4
   1391a:	7373      	strb	r3, [r6, #13]
   1391c:	f005 fa42 	bl	18da4 <z_ready_thread>
	z_setup_new_thread(thread, stack,
   13920:	4b15      	ldr	r3, [pc, #84]	; (13978 <z_cstart+0xfc>)
   13922:	4916      	ldr	r1, [pc, #88]	; (1397c <z_cstart+0x100>)
   13924:	e9cd 8304 	strd	r8, r3, [sp, #16]
   13928:	230f      	movs	r3, #15
   1392a:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1392e:	f44f 72a0 	mov.w	r2, #320	; 0x140
   13932:	4b13      	ldr	r3, [pc, #76]	; (13980 <z_cstart+0x104>)
   13934:	4638      	mov	r0, r7
   13936:	e9cd 4400 	strd	r4, r4, [sp]
   1393a:	f000 fd37 	bl	143ac <z_setup_new_thread>
   1393e:	7b7b      	ldrb	r3, [r7, #13]
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   13940:	60ef      	str	r7, [r5, #12]
   13942:	f023 0304 	bic.w	r3, r3, #4
   13946:	737b      	strb	r3, [r7, #13]
	list->head = (sys_dnode_t *)list;
   13948:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
   1394c:	e9c5 3306 	strd	r3, r3, [r5, #24]
		_kernel.cpus[i].id = i;
   13950:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
   13952:	f8c5 a004 	str.w	sl, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   13956:	465b      	mov	r3, fp
   13958:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1395c:	4649      	mov	r1, r9
   1395e:	4630      	mov	r0, r6
   13960:	f7f2 f92c 	bl	5bbc <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   13964:	e000ed00 	.word	0xe000ed00
   13968:	20003ef4 	.word	0x20003ef4
   1396c:	20003e80 	.word	0x20003e80
   13970:	200040e8 	.word	0x200040e8
   13974:	0001c2aa 	.word	0x0001c2aa
   13978:	0001c2af 	.word	0x0001c2af
   1397c:	2000a320 	.word	0x2000a320
   13980:	000137b9 	.word	0x000137b9
   13984:	2000ac60 	.word	0x2000ac60
   13988:	00013835 	.word	0x00013835
   1398c:	20009b20 	.word	0x20009b20

00013990 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(struct device *unused)
{
   13990:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   13992:	4c06      	ldr	r4, [pc, #24]	; (139ac <statics_init+0x1c>)
   13994:	4d06      	ldr	r5, [pc, #24]	; (139b0 <statics_init+0x20>)
   13996:	42ac      	cmp	r4, r5
   13998:	d301      	bcc.n	1399e <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
   1399a:	2000      	movs	r0, #0
   1399c:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   1399e:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   139a2:	4620      	mov	r0, r4
   139a4:	f004 ffd1 	bl	1894a <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   139a8:	3414      	adds	r4, #20
   139aa:	e7f4      	b.n	13996 <statics_init+0x6>
   139ac:	2000c2f4 	.word	0x2000c2f4
   139b0:	2000c344 	.word	0x2000c344

000139b4 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   139b4:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   139b6:	4b0e      	ldr	r3, [pc, #56]	; (139f0 <init_mem_slab_module+0x3c>)
   139b8:	4c0e      	ldr	r4, [pc, #56]	; (139f4 <init_mem_slab_module+0x40>)
   139ba:	42a3      	cmp	r3, r4
   139bc:	d301      	bcc.n	139c2 <init_mem_slab_module+0xe>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   139be:	2000      	movs	r0, #0
	return rc;
}
   139c0:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   139c2:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   139c6:	ea41 0200 	orr.w	r2, r1, r0
   139ca:	f012 0203 	ands.w	r2, r2, #3
   139ce:	d10b      	bne.n	139e8 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   139d0:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   139d2:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   139d4:	42aa      	cmp	r2, r5
   139d6:	d101      	bne.n	139dc <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   139d8:	331c      	adds	r3, #28
   139da:	e7ee      	b.n	139ba <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   139dc:	695e      	ldr	r6, [r3, #20]
   139de:	600e      	str	r6, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   139e0:	3201      	adds	r2, #1
		slab->free_list = p;
   139e2:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   139e4:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   139e6:	e7f5      	b.n	139d4 <init_mem_slab_module+0x20>
		return -EINVAL;
   139e8:	f06f 0015 	mvn.w	r0, #21
	return rc;
   139ec:	e7e8      	b.n	139c0 <init_mem_slab_module+0xc>
   139ee:	bf00      	nop
   139f0:	2000c2bc 	.word	0x2000c2bc
   139f4:	2000c2f4 	.word	0x2000c2f4

000139f8 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   139f8:	b510      	push	{r4, lr}
   139fa:	4613      	mov	r3, r2
   139fc:	460c      	mov	r4, r1
   139fe:	f04f 0220 	mov.w	r2, #32
   13a02:	f3ef 8111 	mrs	r1, BASEPRI
   13a06:	f382 8811 	msr	BASEPRI, r2
   13a0a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   13a0e:	6942      	ldr	r2, [r0, #20]
   13a10:	b15a      	cbz	r2, 13a2a <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
   13a12:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   13a14:	6813      	ldr	r3, [r2, #0]
   13a16:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   13a18:	6983      	ldr	r3, [r0, #24]
   13a1a:	3301      	adds	r3, #1
   13a1c:	6183      	str	r3, [r0, #24]
		result = 0;
   13a1e:	2000      	movs	r0, #0
	__asm__ volatile(
   13a20:	f381 8811 	msr	BASEPRI, r1
   13a24:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   13a28:	e00d      	b.n	13a46 <k_mem_slab_alloc+0x4e>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   13a2a:	b91b      	cbnz	r3, 13a34 <k_mem_slab_alloc+0x3c>
		*mem = NULL;
   13a2c:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   13a2e:	f06f 000b 	mvn.w	r0, #11
   13a32:	e7f5      	b.n	13a20 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   13a34:	4602      	mov	r2, r0
   13a36:	4804      	ldr	r0, [pc, #16]	; (13a48 <k_mem_slab_alloc+0x50>)
   13a38:	f000 fb78 	bl	1412c <z_pend_curr>
		if (result == 0) {
   13a3c:	b918      	cbnz	r0, 13a46 <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
   13a3e:	4b03      	ldr	r3, [pc, #12]	; (13a4c <k_mem_slab_alloc+0x54>)
   13a40:	689b      	ldr	r3, [r3, #8]
   13a42:	695b      	ldr	r3, [r3, #20]
   13a44:	6023      	str	r3, [r4, #0]
}
   13a46:	bd10      	pop	{r4, pc}
   13a48:	200087df 	.word	0x200087df
   13a4c:	200040e8 	.word	0x200040e8

00013a50 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   13a50:	b570      	push	{r4, r5, r6, lr}
   13a52:	4604      	mov	r4, r0
   13a54:	460d      	mov	r5, r1
	__asm__ volatile(
   13a56:	f04f 0320 	mov.w	r3, #32
   13a5a:	f3ef 8611 	mrs	r6, BASEPRI
   13a5e:	f383 8811 	msr	BASEPRI, r3
   13a62:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   13a66:	f005 fa13 	bl	18e90 <z_unpend_first_thread>

	if (pending_thread != NULL) {
   13a6a:	b158      	cbz	r0, 13a84 <k_mem_slab_free+0x34>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   13a6c:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   13a6e:	6142      	str	r2, [r0, #20]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   13a70:	2100      	movs	r1, #0
   13a72:	6701      	str	r1, [r0, #112]	; 0x70
		z_ready_thread(pending_thread);
   13a74:	f005 f996 	bl	18da4 <z_ready_thread>
		z_reschedule(&lock, key);
   13a78:	4631      	mov	r1, r6
   13a7a:	4809      	ldr	r0, [pc, #36]	; (13aa0 <k_mem_slab_free+0x50>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   13a7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   13a80:	f005 b948 	b.w	18d14 <z_reschedule>
		**(char ***)mem = slab->free_list;
   13a84:	682b      	ldr	r3, [r5, #0]
   13a86:	6962      	ldr	r2, [r4, #20]
   13a88:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   13a8a:	682b      	ldr	r3, [r5, #0]
   13a8c:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   13a8e:	69a3      	ldr	r3, [r4, #24]
   13a90:	3b01      	subs	r3, #1
   13a92:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   13a94:	f386 8811 	msr	BASEPRI, r6
   13a98:	f3bf 8f6f 	isb	sy
}
   13a9c:	bd70      	pop	{r4, r5, r6, pc}
   13a9e:	bf00      	nop
   13aa0:	200087df 	.word	0x200087df

00013aa4 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   13aa4:	b510      	push	{r4, lr}
   13aa6:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   13aa8:	f005 fa3f 	bl	18f2a <k_is_in_isr>
   13aac:	b948      	cbnz	r0, 13ac2 <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   13aae:	4b06      	ldr	r3, [pc, #24]	; (13ac8 <z_thread_malloc+0x24>)
   13ab0:	689b      	ldr	r3, [r3, #8]
   13ab2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	}

	if (pool) {
   13ab4:	b13b      	cbz	r3, 13ac6 <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
   13ab6:	4621      	mov	r1, r4
   13ab8:	4618      	mov	r0, r3
	} else {
		ret = NULL;
	}

	return ret;
}
   13aba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
   13abe:	f004 bfed 	b.w	18a9c <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
   13ac2:	4b02      	ldr	r3, [pc, #8]	; (13acc <z_thread_malloc+0x28>)
   13ac4:	e7f7      	b.n	13ab6 <z_thread_malloc+0x12>
}
   13ac6:	bd10      	pop	{r4, pc}
   13ac8:	200040e8 	.word	0x200040e8
   13acc:	2000c150 	.word	0x2000c150

00013ad0 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   13ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13ad2:	4604      	mov	r4, r0
   13ad4:	460e      	mov	r6, r1
	__asm__ volatile(
   13ad6:	f04f 0320 	mov.w	r3, #32
   13ada:	f3ef 8711 	mrs	r7, BASEPRI
   13ade:	f383 8811 	msr	BASEPRI, r3
   13ae2:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   13ae6:	68c3      	ldr	r3, [r0, #12]
   13ae8:	4a30      	ldr	r2, [pc, #192]	; (13bac <z_impl_k_mutex_lock+0xdc>)
   13aea:	b15b      	cbz	r3, 13b04 <z_impl_k_mutex_lock+0x34>
   13aec:	6880      	ldr	r0, [r0, #8]
   13aee:	6891      	ldr	r1, [r2, #8]
   13af0:	4288      	cmp	r0, r1
   13af2:	d015      	beq.n	13b20 <z_impl_k_mutex_lock+0x50>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   13af4:	b9b6      	cbnz	r6, 13b24 <z_impl_k_mutex_lock+0x54>
	__asm__ volatile(
   13af6:	f387 8811 	msr	BASEPRI, r7
   13afa:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   13afe:	f06f 000f 	mvn.w	r0, #15
   13b02:	e00c      	b.n	13b1e <z_impl_k_mutex_lock+0x4e>
					_current->base.prio :
   13b04:	6891      	ldr	r1, [r2, #8]
   13b06:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   13b0a:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
   13b0c:	3301      	adds	r3, #1
   13b0e:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   13b10:	6893      	ldr	r3, [r2, #8]
   13b12:	60a3      	str	r3, [r4, #8]
   13b14:	f387 8811 	msr	BASEPRI, r7
   13b18:	f3bf 8f6f 	isb	sy
		return 0;
   13b1c:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   13b1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   13b20:	6921      	ldr	r1, [r4, #16]
   13b22:	e7f2      	b.n	13b0a <z_impl_k_mutex_lock+0x3a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   13b24:	f990 300e 	ldrsb.w	r3, [r0, #14]
   13b28:	f991 100e 	ldrsb.w	r1, [r1, #14]
   13b2c:	4299      	cmp	r1, r3
   13b2e:	bfa8      	it	ge
   13b30:	4619      	movge	r1, r3
   13b32:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   13b36:	428b      	cmp	r3, r1
   13b38:	dd2b      	ble.n	13b92 <z_impl_k_mutex_lock+0xc2>
		return z_set_prio(mutex->owner, new_prio);
   13b3a:	f000 fb0b 	bl	14154 <z_set_prio>
   13b3e:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   13b40:	481b      	ldr	r0, [pc, #108]	; (13bb0 <z_impl_k_mutex_lock+0xe0>)
   13b42:	4633      	mov	r3, r6
   13b44:	4622      	mov	r2, r4
   13b46:	4639      	mov	r1, r7
   13b48:	f000 faf0 	bl	1412c <z_pend_curr>
	if (got_mutex == 0) {
   13b4c:	2800      	cmp	r0, #0
   13b4e:	d0e6      	beq.n	13b1e <z_impl_k_mutex_lock+0x4e>
	__asm__ volatile(
   13b50:	f04f 0320 	mov.w	r3, #32
   13b54:	f3ef 8611 	mrs	r6, BASEPRI
   13b58:	f383 8811 	msr	BASEPRI, r3
   13b5c:	f3bf 8f6f 	isb	sy
	return list->head == list;
   13b60:	6823      	ldr	r3, [r4, #0]
   13b62:	6921      	ldr	r1, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   13b64:	429c      	cmp	r4, r3
   13b66:	d007      	beq.n	13b78 <z_impl_k_mutex_lock+0xa8>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   13b68:	b133      	cbz	r3, 13b78 <z_impl_k_mutex_lock+0xa8>
   13b6a:	f993 300e 	ldrsb.w	r3, [r3, #14]
   13b6e:	4299      	cmp	r1, r3
   13b70:	bfa8      	it	ge
   13b72:	4619      	movge	r1, r3
   13b74:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   13b78:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   13b7a:	f990 300e 	ldrsb.w	r3, [r0, #14]
   13b7e:	4299      	cmp	r1, r3
   13b80:	d109      	bne.n	13b96 <z_impl_k_mutex_lock+0xc6>
	if (resched) {
   13b82:	b16d      	cbz	r5, 13ba0 <z_impl_k_mutex_lock+0xd0>
		z_reschedule(&lock, key);
   13b84:	480a      	ldr	r0, [pc, #40]	; (13bb0 <z_impl_k_mutex_lock+0xe0>)
   13b86:	4631      	mov	r1, r6
   13b88:	f005 f8c4 	bl	18d14 <z_reschedule>
	return -EAGAIN;
   13b8c:	f06f 000a 	mvn.w	r0, #10
   13b90:	e7c5      	b.n	13b1e <z_impl_k_mutex_lock+0x4e>
	bool resched = false;
   13b92:	2500      	movs	r5, #0
   13b94:	e7d4      	b.n	13b40 <z_impl_k_mutex_lock+0x70>
		return z_set_prio(mutex->owner, new_prio);
   13b96:	f000 fadd 	bl	14154 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   13b9a:	2800      	cmp	r0, #0
   13b9c:	d1f2      	bne.n	13b84 <z_impl_k_mutex_lock+0xb4>
   13b9e:	e7f0      	b.n	13b82 <z_impl_k_mutex_lock+0xb2>
	__asm__ volatile(
   13ba0:	f386 8811 	msr	BASEPRI, r6
   13ba4:	f3bf 8f6f 	isb	sy
   13ba8:	e7f0      	b.n	13b8c <z_impl_k_mutex_lock+0xbc>
   13baa:	bf00      	nop
   13bac:	200040e8 	.word	0x200040e8
   13bb0:	200087df 	.word	0x200087df

00013bb4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   13bb4:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   13bb6:	6883      	ldr	r3, [r0, #8]
{
   13bb8:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   13bba:	2b00      	cmp	r3, #0
   13bbc:	d036      	beq.n	13c2c <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   13bbe:	4a1e      	ldr	r2, [pc, #120]	; (13c38 <z_impl_k_mutex_unlock+0x84>)
   13bc0:	6892      	ldr	r2, [r2, #8]
   13bc2:	4293      	cmp	r3, r2
   13bc4:	d135      	bne.n	13c32 <z_impl_k_mutex_unlock+0x7e>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   13bc6:	7bda      	ldrb	r2, [r3, #15]
   13bc8:	3a01      	subs	r2, #1
   13bca:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   13bcc:	68c3      	ldr	r3, [r0, #12]
   13bce:	2b01      	cmp	r3, #1
   13bd0:	d005      	beq.n	13bde <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   13bd2:	3b01      	subs	r3, #1
   13bd4:	60c3      	str	r3, [r0, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   13bd6:	f000 f8c3 	bl	13d60 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   13bda:	2000      	movs	r0, #0
}
   13bdc:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   13bde:	f04f 0320 	mov.w	r3, #32
   13be2:	f3ef 8511 	mrs	r5, BASEPRI
   13be6:	f383 8811 	msr	BASEPRI, r3
   13bea:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   13bee:	6901      	ldr	r1, [r0, #16]
   13bf0:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   13bf2:	f990 300e 	ldrsb.w	r3, [r0, #14]
   13bf6:	4299      	cmp	r1, r3
   13bf8:	d001      	beq.n	13bfe <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   13bfa:	f000 faab 	bl	14154 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   13bfe:	4620      	mov	r0, r4
   13c00:	f005 f946 	bl	18e90 <z_unpend_first_thread>
	mutex->owner = new_owner;
   13c04:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   13c06:	b158      	cbz	r0, 13c20 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   13c08:	f990 200e 	ldrsb.w	r2, [r0, #14]
   13c0c:	6122      	str	r2, [r4, #16]
   13c0e:	2200      	movs	r2, #0
   13c10:	6702      	str	r2, [r0, #112]	; 0x70
		z_ready_thread(new_owner);
   13c12:	f005 f8c7 	bl	18da4 <z_ready_thread>
		z_reschedule(&lock, key);
   13c16:	4809      	ldr	r0, [pc, #36]	; (13c3c <z_impl_k_mutex_unlock+0x88>)
   13c18:	4629      	mov	r1, r5
   13c1a:	f005 f87b 	bl	18d14 <z_reschedule>
   13c1e:	e7da      	b.n	13bd6 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   13c20:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   13c22:	f385 8811 	msr	BASEPRI, r5
   13c26:	f3bf 8f6f 	isb	sy
   13c2a:	e7d4      	b.n	13bd6 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   13c2c:	f06f 0015 	mvn.w	r0, #21
   13c30:	e7d4      	b.n	13bdc <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   13c32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13c36:	e7d1      	b.n	13bdc <z_impl_k_mutex_unlock+0x28>
   13c38:	200040e8 	.word	0x200040e8
   13c3c:	200087df 	.word	0x200087df

00013c40 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   13c40:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   13c42:	4c08      	ldr	r4, [pc, #32]	; (13c64 <z_reset_time_slice+0x24>)
   13c44:	6823      	ldr	r3, [r4, #0]
   13c46:	b15b      	cbz	r3, 13c60 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   13c48:	f7f1 fe0a 	bl	5860 <z_clock_elapsed>
   13c4c:	4603      	mov	r3, r0
   13c4e:	6820      	ldr	r0, [r4, #0]
   13c50:	4a05      	ldr	r2, [pc, #20]	; (13c68 <z_reset_time_slice+0x28>)
   13c52:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
	}
}
   13c54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   13c58:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   13c5a:	2100      	movs	r1, #0
   13c5c:	f005 b998 	b.w	18f90 <z_set_timeout_expiry>
}
   13c60:	bd10      	pop	{r4, pc}
   13c62:	bf00      	nop
   13c64:	20004120 	.word	0x20004120
   13c68:	200040e8 	.word	0x200040e8

00013c6c <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
   13c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13c6e:	4605      	mov	r5, r0
   13c70:	460c      	mov	r4, r1
	__asm__ volatile(
   13c72:	f04f 0320 	mov.w	r3, #32
   13c76:	f3ef 8611 	mrs	r6, BASEPRI
   13c7a:	f383 8811 	msr	BASEPRI, r3
   13c7e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   13c82:	4b0d      	ldr	r3, [pc, #52]	; (13cb8 <k_sched_time_slice_set+0x4c>)
   13c84:	2200      	movs	r2, #0
   13c86:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   13c8a:	f240 30e7 	movw	r0, #999	; 0x3e7
   13c8e:	2100      	movs	r1, #0
   13c90:	611a      	str	r2, [r3, #16]
   13c92:	fbe7 0105 	umlal	r0, r1, r7, r5
   13c96:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   13c9a:	2300      	movs	r3, #0
   13c9c:	f7ec fe32 	bl	904 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   13ca0:	4b06      	ldr	r3, [pc, #24]	; (13cbc <k_sched_time_slice_set+0x50>)
   13ca2:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   13ca4:	4b06      	ldr	r3, [pc, #24]	; (13cc0 <k_sched_time_slice_set+0x54>)
   13ca6:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
   13ca8:	f7ff ffca 	bl	13c40 <z_reset_time_slice>
	__asm__ volatile(
   13cac:	f386 8811 	msr	BASEPRI, r6
   13cb0:	f3bf 8f6f 	isb	sy
	}
}
   13cb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13cb6:	bf00      	nop
   13cb8:	200040e8 	.word	0x200040e8
   13cbc:	20004120 	.word	0x20004120
   13cc0:	2000411c 	.word	0x2000411c

00013cc4 <k_sched_lock>:
	__asm__ volatile(
   13cc4:	f04f 0320 	mov.w	r3, #32
   13cc8:	f3ef 8111 	mrs	r1, BASEPRI
   13ccc:	f383 8811 	msr	BASEPRI, r3
   13cd0:	f3bf 8f6f 	isb	sy
   13cd4:	4b04      	ldr	r3, [pc, #16]	; (13ce8 <k_sched_lock+0x24>)
   13cd6:	689a      	ldr	r2, [r3, #8]
   13cd8:	7bd3      	ldrb	r3, [r2, #15]
   13cda:	3b01      	subs	r3, #1
   13cdc:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   13cde:	f381 8811 	msr	BASEPRI, r1
   13ce2:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   13ce6:	4770      	bx	lr
   13ce8:	200040e8 	.word	0x200040e8

00013cec <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   13cec:	4b09      	ldr	r3, [pc, #36]	; (13d14 <z_priq_dumb_remove+0x28>)
   13cee:	f103 0228 	add.w	r2, r3, #40	; 0x28
   13cf2:	4282      	cmp	r2, r0
   13cf4:	d105      	bne.n	13d02 <z_priq_dumb_remove+0x16>
   13cf6:	689b      	ldr	r3, [r3, #8]
   13cf8:	428b      	cmp	r3, r1
   13cfa:	d102      	bne.n	13d02 <z_priq_dumb_remove+0x16>
   13cfc:	7b4b      	ldrb	r3, [r1, #13]
   13cfe:	06db      	lsls	r3, r3, #27
   13d00:	d106      	bne.n	13d10 <z_priq_dumb_remove+0x24>
	node->prev->next = node->next;
   13d02:	e9d1 3200 	ldrd	r3, r2, [r1]
   13d06:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   13d08:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   13d0a:	2300      	movs	r3, #0
	node->prev = NULL;
   13d0c:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   13d10:	4770      	bx	lr
   13d12:	bf00      	nop
   13d14:	200040e8 	.word	0x200040e8

00013d18 <update_cache>:
{
   13d18:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   13d1a:	4c10      	ldr	r4, [pc, #64]	; (13d5c <update_cache+0x44>)
{
   13d1c:	4606      	mov	r6, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   13d1e:	f104 0028 	add.w	r0, r4, #40	; 0x28
   13d22:	f005 f835 	bl	18d90 <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
   13d26:	68a3      	ldr	r3, [r4, #8]
   13d28:	7b59      	ldrb	r1, [r3, #13]
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   13d2a:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
   13d2c:	0688      	lsls	r0, r1, #26
		_current->base.thread_state |= _THREAD_DEAD;
   13d2e:	bf44      	itt	mi
   13d30:	f041 0108 	orrmi.w	r1, r1, #8
   13d34:	7359      	strbmi	r1, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
   13d36:	b905      	cbnz	r5, 13d3a <update_cache+0x22>
   13d38:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   13d3a:	b94e      	cbnz	r6, 13d50 <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
   13d3c:	7b5a      	ldrb	r2, [r3, #13]
   13d3e:	06d2      	lsls	r2, r2, #27
   13d40:	d106      	bne.n	13d50 <update_cache+0x38>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   13d42:	69aa      	ldr	r2, [r5, #24]
   13d44:	b922      	cbnz	r2, 13d50 <update_cache+0x38>
	if (is_preempt(_current) || is_metairq(thread)) {
   13d46:	89da      	ldrh	r2, [r3, #14]
   13d48:	2a7f      	cmp	r2, #127	; 0x7f
   13d4a:	d901      	bls.n	13d50 <update_cache+0x38>
		_kernel.ready_q.cache = _current;
   13d4c:	6263      	str	r3, [r4, #36]	; 0x24
}
   13d4e:	bd70      	pop	{r4, r5, r6, pc}
		if (thread != _current) {
   13d50:	42ab      	cmp	r3, r5
   13d52:	d001      	beq.n	13d58 <update_cache+0x40>
			z_reset_time_slice();
   13d54:	f7ff ff74 	bl	13c40 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   13d58:	6265      	str	r5, [r4, #36]	; 0x24
}
   13d5a:	e7f8      	b.n	13d4e <update_cache+0x36>
   13d5c:	200040e8 	.word	0x200040e8

00013d60 <k_sched_unlock>:
{
   13d60:	b510      	push	{r4, lr}
	__asm__ volatile(
   13d62:	f04f 0320 	mov.w	r3, #32
   13d66:	f3ef 8411 	mrs	r4, BASEPRI
   13d6a:	f383 8811 	msr	BASEPRI, r3
   13d6e:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   13d72:	4b08      	ldr	r3, [pc, #32]	; (13d94 <k_sched_unlock+0x34>)
   13d74:	689a      	ldr	r2, [r3, #8]
   13d76:	7bd3      	ldrb	r3, [r2, #15]
   13d78:	3301      	adds	r3, #1
   13d7a:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   13d7c:	2000      	movs	r0, #0
   13d7e:	f7ff ffcb 	bl	13d18 <update_cache>
	__asm__ volatile(
   13d82:	f384 8811 	msr	BASEPRI, r4
   13d86:	f3bf 8f6f 	isb	sy
}
   13d8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   13d8e:	f004 bfd8 	b.w	18d42 <z_reschedule_unlocked>
   13d92:	bf00      	nop
   13d94:	200040e8 	.word	0x200040e8

00013d98 <ready_thread>:
{
   13d98:	b470      	push	{r4, r5, r6}
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   13d9a:	7b43      	ldrb	r3, [r0, #13]
   13d9c:	06db      	lsls	r3, r3, #27
   13d9e:	d12a      	bne.n	13df6 <ready_thread+0x5e>

int z_abort_timeout(struct _timeout *to);

static inline bool z_is_inactive_timeout(struct _timeout *t)
{
	return !sys_dnode_is_linked(&t->node);
   13da0:	6983      	ldr	r3, [r0, #24]
	if (z_is_thread_ready(thread)) {
   13da2:	bb43      	cbnz	r3, 13df6 <ready_thread+0x5e>
	return list->head == list;
   13da4:	4a15      	ldr	r2, [pc, #84]	; (13dfc <ready_thread+0x64>)
   13da6:	4611      	mov	r1, r2
   13da8:	f851 4f28 	ldr.w	r4, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   13dac:	428c      	cmp	r4, r1
   13dae:	bf18      	it	ne
   13db0:	4623      	movne	r3, r4
   13db2:	2b00      	cmp	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   13db4:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
   13db6:	bf38      	it	cc
   13db8:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   13dba:	b1b3      	cbz	r3, 13dea <ready_thread+0x52>
	if (thread_1->base.prio < thread_2->base.prio) {
   13dbc:	f990 600e 	ldrsb.w	r6, [r0, #14]
   13dc0:	f993 500e 	ldrsb.w	r5, [r3, #14]
   13dc4:	42ae      	cmp	r6, r5
   13dc6:	db03      	blt.n	13dd0 <ready_thread+0x38>
	return (node == list->tail) ? NULL : node->next;
   13dc8:	42a3      	cmp	r3, r4
   13dca:	d00e      	beq.n	13dea <ready_thread+0x52>
   13dcc:	681b      	ldr	r3, [r3, #0]
   13dce:	e7f4      	b.n	13dba <ready_thread+0x22>
	node->prev = successor->prev;
   13dd0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   13dd2:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
   13dd6:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   13dd8:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
   13dda:	7b43      	ldrb	r3, [r0, #13]
   13ddc:	f063 037f 	orn	r3, r3, #127	; 0x7f
   13de0:	7343      	strb	r3, [r0, #13]
}
   13de2:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   13de4:	2000      	movs	r0, #0
   13de6:	f7ff bf97 	b.w	13d18 <update_cache>
	node->prev = list->tail;
   13dea:	e9c0 1400 	strd	r1, r4, [r0]
	list->tail->next = node;
   13dee:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   13df0:	6018      	str	r0, [r3, #0]
	list->tail = node;
   13df2:	62d0      	str	r0, [r2, #44]	; 0x2c
}
   13df4:	e7f1      	b.n	13dda <ready_thread+0x42>
}
   13df6:	bc70      	pop	{r4, r5, r6}
   13df8:	4770      	bx	lr
   13dfa:	bf00      	nop
   13dfc:	200040e8 	.word	0x200040e8

00013e00 <z_sched_start>:
{
   13e00:	b510      	push	{r4, lr}
	__asm__ volatile(
   13e02:	f04f 0220 	mov.w	r2, #32
   13e06:	f3ef 8411 	mrs	r4, BASEPRI
   13e0a:	f382 8811 	msr	BASEPRI, r2
   13e0e:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   13e12:	7b42      	ldrb	r2, [r0, #13]
   13e14:	0751      	lsls	r1, r2, #29
   13e16:	d404      	bmi.n	13e22 <z_sched_start+0x22>
	__asm__ volatile(
   13e18:	f384 8811 	msr	BASEPRI, r4
   13e1c:	f3bf 8f6f 	isb	sy
}
   13e20:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   13e22:	f022 0204 	bic.w	r2, r2, #4
   13e26:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   13e28:	f7ff ffb6 	bl	13d98 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   13e2c:	4621      	mov	r1, r4
   13e2e:	4802      	ldr	r0, [pc, #8]	; (13e38 <z_sched_start+0x38>)
}
   13e30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   13e34:	f004 bf6e 	b.w	18d14 <z_reschedule>
   13e38:	200087df 	.word	0x200087df

00013e3c <z_move_thread_to_end_of_prio_q>:
{
   13e3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13e3e:	4601      	mov	r1, r0
	__asm__ volatile(
   13e40:	f04f 0320 	mov.w	r3, #32
   13e44:	f3ef 8411 	mrs	r4, BASEPRI
   13e48:	f383 8811 	msr	BASEPRI, r3
   13e4c:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   13e50:	f990 300d 	ldrsb.w	r3, [r0, #13]
   13e54:	2b00      	cmp	r3, #0
   13e56:	da02      	bge.n	13e5e <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   13e58:	4819      	ldr	r0, [pc, #100]	; (13ec0 <z_move_thread_to_end_of_prio_q+0x84>)
   13e5a:	f7ff ff47 	bl	13cec <z_priq_dumb_remove>
	return list->head == list;
   13e5e:	4a19      	ldr	r2, [pc, #100]	; (13ec4 <z_move_thread_to_end_of_prio_q+0x88>)
   13e60:	4610      	mov	r0, r2
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   13e62:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
	return list->head == list;
   13e64:	f850 3f28 	ldr.w	r3, [r0, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   13e68:	4283      	cmp	r3, r0
   13e6a:	bf08      	it	eq
   13e6c:	2300      	moveq	r3, #0
   13e6e:	2b00      	cmp	r3, #0
   13e70:	bf38      	it	cc
   13e72:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   13e74:	b1eb      	cbz	r3, 13eb2 <z_move_thread_to_end_of_prio_q+0x76>
	if (thread_1->base.prio < thread_2->base.prio) {
   13e76:	f991 700e 	ldrsb.w	r7, [r1, #14]
   13e7a:	f993 600e 	ldrsb.w	r6, [r3, #14]
   13e7e:	42b7      	cmp	r7, r6
   13e80:	db03      	blt.n	13e8a <z_move_thread_to_end_of_prio_q+0x4e>
	return (node == list->tail) ? NULL : node->next;
   13e82:	429d      	cmp	r5, r3
   13e84:	d015      	beq.n	13eb2 <z_move_thread_to_end_of_prio_q+0x76>
   13e86:	681b      	ldr	r3, [r3, #0]
   13e88:	e7f4      	b.n	13e74 <z_move_thread_to_end_of_prio_q+0x38>
	node->prev = successor->prev;
   13e8a:	6858      	ldr	r0, [r3, #4]
	node->next = successor;
   13e8c:	e9c1 3000 	strd	r3, r0, [r1]
	successor->prev->next = node;
   13e90:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   13e92:	6059      	str	r1, [r3, #4]
	thread->base.thread_state |= states;
   13e94:	7b4b      	ldrb	r3, [r1, #13]
		update_cache(thread == _current);
   13e96:	6890      	ldr	r0, [r2, #8]
   13e98:	f063 037f 	orn	r3, r3, #127	; 0x7f
   13e9c:	734b      	strb	r3, [r1, #13]
   13e9e:	1a43      	subs	r3, r0, r1
   13ea0:	4258      	negs	r0, r3
   13ea2:	4158      	adcs	r0, r3
   13ea4:	f7ff ff38 	bl	13d18 <update_cache>
	__asm__ volatile(
   13ea8:	f384 8811 	msr	BASEPRI, r4
   13eac:	f3bf 8f6f 	isb	sy
}
   13eb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node->prev = list->tail;
   13eb2:	e9c1 0500 	strd	r0, r5, [r1]
	list->tail->next = node;
   13eb6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   13eb8:	6019      	str	r1, [r3, #0]
	list->tail = node;
   13eba:	62d1      	str	r1, [r2, #44]	; 0x2c
}
   13ebc:	e7ea      	b.n	13e94 <z_move_thread_to_end_of_prio_q+0x58>
   13ebe:	bf00      	nop
   13ec0:	20004110 	.word	0x20004110
   13ec4:	200040e8 	.word	0x200040e8

00013ec8 <z_time_slice>:
{
   13ec8:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   13eca:	4a15      	ldr	r2, [pc, #84]	; (13f20 <z_time_slice+0x58>)
   13ecc:	4b15      	ldr	r3, [pc, #84]	; (13f24 <z_time_slice+0x5c>)
   13ece:	6814      	ldr	r4, [r2, #0]
{
   13ed0:	4601      	mov	r1, r0
	if (pending_current == _current) {
   13ed2:	6898      	ldr	r0, [r3, #8]
   13ed4:	42a0      	cmp	r0, r4
   13ed6:	461c      	mov	r4, r3
   13ed8:	d103      	bne.n	13ee2 <z_time_slice+0x1a>
}
   13eda:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   13ede:	f7ff beaf 	b.w	13c40 <z_reset_time_slice>
	pending_current = NULL;
   13ee2:	2500      	movs	r5, #0
   13ee4:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
   13ee6:	4a10      	ldr	r2, [pc, #64]	; (13f28 <z_time_slice+0x60>)
   13ee8:	6812      	ldr	r2, [r2, #0]
   13eea:	b1b2      	cbz	r2, 13f1a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   13eec:	89c2      	ldrh	r2, [r0, #14]
   13eee:	2a7f      	cmp	r2, #127	; 0x7f
   13ef0:	d813      	bhi.n	13f1a <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   13ef2:	4a0e      	ldr	r2, [pc, #56]	; (13f2c <z_time_slice+0x64>)
   13ef4:	f990 500e 	ldrsb.w	r5, [r0, #14]
   13ef8:	6812      	ldr	r2, [r2, #0]
   13efa:	4295      	cmp	r5, r2
   13efc:	db0d      	blt.n	13f1a <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   13efe:	4a0c      	ldr	r2, [pc, #48]	; (13f30 <z_time_slice+0x68>)
   13f00:	4290      	cmp	r0, r2
   13f02:	d00a      	beq.n	13f1a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   13f04:	6982      	ldr	r2, [r0, #24]
   13f06:	b942      	cbnz	r2, 13f1a <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   13f08:	691a      	ldr	r2, [r3, #16]
   13f0a:	428a      	cmp	r2, r1
   13f0c:	dc02      	bgt.n	13f14 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   13f0e:	f7ff ff95 	bl	13e3c <z_move_thread_to_end_of_prio_q>
   13f12:	e7e2      	b.n	13eda <z_time_slice+0x12>
			_current_cpu->slice_ticks -= ticks;
   13f14:	1a52      	subs	r2, r2, r1
   13f16:	611a      	str	r2, [r3, #16]
}
   13f18:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   13f1a:	2300      	movs	r3, #0
   13f1c:	6123      	str	r3, [r4, #16]
   13f1e:	e7fb      	b.n	13f18 <z_time_slice+0x50>
   13f20:	20004118 	.word	0x20004118
   13f24:	200040e8 	.word	0x200040e8
   13f28:	20004120 	.word	0x20004120
   13f2c:	2000411c 	.word	0x2000411c
   13f30:	20003e80 	.word	0x20003e80

00013f34 <z_impl_k_thread_suspend>:
{
   13f34:	b570      	push	{r4, r5, r6, lr}
   13f36:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   13f38:	3018      	adds	r0, #24
   13f3a:	f005 f803 	bl	18f44 <z_abort_timeout>
	__asm__ volatile(
   13f3e:	f04f 0320 	mov.w	r3, #32
   13f42:	f3ef 8611 	mrs	r6, BASEPRI
   13f46:	f383 8811 	msr	BASEPRI, r3
   13f4a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   13f4e:	f994 300d 	ldrsb.w	r3, [r4, #13]
   13f52:	2b00      	cmp	r3, #0
   13f54:	da07      	bge.n	13f66 <z_impl_k_thread_suspend+0x32>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   13f56:	480f      	ldr	r0, [pc, #60]	; (13f94 <z_impl_k_thread_suspend+0x60>)
   13f58:	4621      	mov	r1, r4
   13f5a:	f7ff fec7 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   13f5e:	7b63      	ldrb	r3, [r4, #13]
   13f60:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   13f64:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   13f66:	4d0c      	ldr	r5, [pc, #48]	; (13f98 <z_impl_k_thread_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   13f68:	7b63      	ldrb	r3, [r4, #13]
   13f6a:	68a8      	ldr	r0, [r5, #8]
   13f6c:	f043 0310 	orr.w	r3, r3, #16
   13f70:	7363      	strb	r3, [r4, #13]
   13f72:	1b03      	subs	r3, r0, r4
   13f74:	4258      	negs	r0, r3
   13f76:	4158      	adcs	r0, r3
   13f78:	f7ff fece 	bl	13d18 <update_cache>
	__asm__ volatile(
   13f7c:	f386 8811 	msr	BASEPRI, r6
   13f80:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   13f84:	68ab      	ldr	r3, [r5, #8]
   13f86:	42a3      	cmp	r3, r4
   13f88:	d103      	bne.n	13f92 <z_impl_k_thread_suspend+0x5e>
}
   13f8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   13f8e:	f004 bed8 	b.w	18d42 <z_reschedule_unlocked>
}
   13f92:	bd70      	pop	{r4, r5, r6, pc}
   13f94:	20004110 	.word	0x20004110
   13f98:	200040e8 	.word	0x200040e8

00013f9c <z_thread_single_abort>:
{
   13f9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (thread->fn_abort != NULL) {
   13f9e:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
   13fa0:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   13fa2:	b103      	cbz	r3, 13fa6 <z_thread_single_abort+0xa>
		thread->fn_abort();
   13fa4:	4798      	blx	r3
   13fa6:	f104 0018 	add.w	r0, r4, #24
   13faa:	f004 ffcb 	bl	18f44 <z_abort_timeout>
	__asm__ volatile(
   13fae:	f04f 0320 	mov.w	r3, #32
   13fb2:	f3ef 8511 	mrs	r5, BASEPRI
   13fb6:	f383 8811 	msr	BASEPRI, r3
   13fba:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   13fbe:	7b63      	ldrb	r3, [r4, #13]
   13fc0:	06d8      	lsls	r0, r3, #27
   13fc2:	d122      	bne.n	1400a <z_thread_single_abort+0x6e>
		if (z_is_thread_ready(thread)) {
   13fc4:	69a2      	ldr	r2, [r4, #24]
   13fc6:	bb02      	cbnz	r2, 1400a <z_thread_single_abort+0x6e>
			if (z_is_thread_queued(thread)) {
   13fc8:	0619      	lsls	r1, r3, #24
   13fca:	d507      	bpl.n	13fdc <z_thread_single_abort+0x40>
				_priq_run_remove(&_kernel.ready_q.runq,
   13fcc:	481c      	ldr	r0, [pc, #112]	; (14040 <z_thread_single_abort+0xa4>)
   13fce:	4621      	mov	r1, r4
   13fd0:	f7ff fe8c 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   13fd4:	7b63      	ldrb	r3, [r4, #13]
   13fd6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   13fda:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   13fdc:	4b19      	ldr	r3, [pc, #100]	; (14044 <z_thread_single_abort+0xa8>)
   13fde:	6898      	ldr	r0, [r3, #8]
   13fe0:	1b02      	subs	r2, r0, r4
   13fe2:	4250      	negs	r0, r2
   13fe4:	4150      	adcs	r0, r2
   13fe6:	f7ff fe97 	bl	13d18 <update_cache>
		thread->base.thread_state |= mask;
   13fea:	7b63      	ldrb	r3, [r4, #13]
   13fec:	f043 0308 	orr.w	r3, r3, #8
   13ff0:	7363      	strb	r3, [r4, #13]
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   13ff2:	f104 0728 	add.w	r7, r4, #40	; 0x28
			waiter->base.pended_on = NULL;
   13ff6:	2600      	movs	r6, #0
	return list->head == list;
   13ff8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   13ffa:	42b9      	cmp	r1, r7
   13ffc:	d000      	beq.n	14000 <z_thread_single_abort+0x64>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
   13ffe:	b989      	cbnz	r1, 14024 <z_thread_single_abort+0x88>
	__asm__ volatile(
   14000:	f385 8811 	msr	BASEPRI, r5
   14004:	f3bf 8f6f 	isb	sy
}
   14008:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (z_is_thread_pending(thread)) {
   1400a:	079b      	lsls	r3, r3, #30
   1400c:	d5ed      	bpl.n	13fea <z_thread_single_abort+0x4e>
				_priq_wait_remove(&pended_on(thread)->waitq,
   1400e:	68a0      	ldr	r0, [r4, #8]
   14010:	4621      	mov	r1, r4
   14012:	f7ff fe6b 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   14016:	7b63      	ldrb	r3, [r4, #13]
   14018:	f023 0302 	bic.w	r3, r3, #2
   1401c:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   1401e:	2300      	movs	r3, #0
   14020:	60a3      	str	r3, [r4, #8]
   14022:	e7e2      	b.n	13fea <z_thread_single_abort+0x4e>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
   14024:	6888      	ldr	r0, [r1, #8]
   14026:	f7ff fe61 	bl	13cec <z_priq_dumb_remove>
   1402a:	7b4b      	ldrb	r3, [r1, #13]
			waiter->base.pended_on = NULL;
   1402c:	608e      	str	r6, [r1, #8]
   1402e:	f023 0302 	bic.w	r3, r3, #2
   14032:	734b      	strb	r3, [r1, #13]
   14034:	670e      	str	r6, [r1, #112]	; 0x70
			ready_thread(waiter);
   14036:	4608      	mov	r0, r1
   14038:	f7ff feae 	bl	13d98 <ready_thread>
   1403c:	e7dc      	b.n	13ff8 <z_thread_single_abort+0x5c>
   1403e:	bf00      	nop
   14040:	20004110 	.word	0x20004110
   14044:	200040e8 	.word	0x200040e8

00014048 <unready_thread>:
{
   14048:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   1404a:	f990 300d 	ldrsb.w	r3, [r0, #13]
   1404e:	2b00      	cmp	r3, #0
{
   14050:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   14052:	da06      	bge.n	14062 <unready_thread+0x1a>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   14054:	4807      	ldr	r0, [pc, #28]	; (14074 <unready_thread+0x2c>)
   14056:	f7ff fe49 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1405a:	7b4b      	ldrb	r3, [r1, #13]
   1405c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   14060:	734b      	strb	r3, [r1, #13]
	update_cache(thread == _current);
   14062:	4b05      	ldr	r3, [pc, #20]	; (14078 <unready_thread+0x30>)
   14064:	6898      	ldr	r0, [r3, #8]
   14066:	1a43      	subs	r3, r0, r1
   14068:	4258      	negs	r0, r3
   1406a:	4158      	adcs	r0, r3
}
   1406c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   14070:	f7ff be52 	b.w	13d18 <update_cache>
   14074:	20004110 	.word	0x20004110
   14078:	200040e8 	.word	0x200040e8

0001407c <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
   1407c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	k_timeout_t timeout;

#ifndef CONFIG_LEGACY_TIMEOUT_API
	timeout = Z_TIMEOUT_TICKS(ticks);
#else
	ticks += _TICK_ALIGN;
   1407e:	1c45      	adds	r5, r0, #1
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
   14080:	f004 ffa0 	bl	18fc4 <z_tick_get_32>
   14084:	182c      	adds	r4, r5, r0
	__asm__ volatile(
   14086:	f04f 0320 	mov.w	r3, #32
   1408a:	f3ef 8711 	mrs	r7, BASEPRI
   1408e:	f383 8811 	msr	BASEPRI, r3
   14092:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   14096:	4e0d      	ldr	r6, [pc, #52]	; (140cc <z_tick_sleep.part.0+0x50>)
   14098:	4b0d      	ldr	r3, [pc, #52]	; (140d0 <z_tick_sleep.part.0+0x54>)
   1409a:	68b0      	ldr	r0, [r6, #8]
   1409c:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
   1409e:	f004 febc 	bl	18e1a <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   140a2:	68b0      	ldr	r0, [r6, #8]
   140a4:	490b      	ldr	r1, [pc, #44]	; (140d4 <z_tick_sleep.part.0+0x58>)
   140a6:	462a      	mov	r2, r5
   140a8:	3018      	adds	r0, #24
   140aa:	f000 fa8d 	bl	145c8 <z_add_timeout>
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);
   140ae:	68b2      	ldr	r2, [r6, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   140b0:	7b53      	ldrb	r3, [r2, #13]
   140b2:	f043 0310 	orr.w	r3, r3, #16
   140b6:	7353      	strb	r3, [r2, #13]
   140b8:	4638      	mov	r0, r7
   140ba:	f7f1 fcbf 	bl	5a3c <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
   140be:	f004 ff81 	bl	18fc4 <z_tick_get_32>
   140c2:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
   140c4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   140c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   140ca:	bf00      	nop
   140cc:	200040e8 	.word	0x200040e8
   140d0:	20004118 	.word	0x20004118
   140d4:	00018dc5 	.word	0x00018dc5

000140d8 <pend>:
{
   140d8:	b570      	push	{r4, r5, r6, lr}
   140da:	4605      	mov	r5, r0
   140dc:	4614      	mov	r4, r2
   140de:	f04f 0320 	mov.w	r3, #32
   140e2:	f3ef 8611 	mrs	r6, BASEPRI
   140e6:	f383 8811 	msr	BASEPRI, r3
   140ea:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   140ee:	f004 fea4 	bl	18e3a <add_to_waitq_locked>
	__asm__ volatile(
   140f2:	f386 8811 	msr	BASEPRI, r6
   140f6:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   140fa:	1c63      	adds	r3, r4, #1
   140fc:	d013      	beq.n	14126 <pend+0x4e>
   140fe:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   14102:	f240 30e7 	movw	r0, #999	; 0x3e7
   14106:	2100      	movs	r1, #0
   14108:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1410c:	fbe6 0104 	umlal	r0, r1, r6, r4
   14110:	2300      	movs	r3, #0
   14112:	f7ec fbf7 	bl	904 <__aeabi_uldivmod>
   14116:	4904      	ldr	r1, [pc, #16]	; (14128 <pend+0x50>)
   14118:	1c42      	adds	r2, r0, #1
   1411a:	f105 0018 	add.w	r0, r5, #24
}
   1411e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   14122:	f000 ba51 	b.w	145c8 <z_add_timeout>
   14126:	bd70      	pop	{r4, r5, r6, pc}
   14128:	00018dc5 	.word	0x00018dc5

0001412c <z_pend_curr>:
{
   1412c:	b510      	push	{r4, lr}
   1412e:	460c      	mov	r4, r1
   14130:	4611      	mov	r1, r2
	pending_current = _current;
   14132:	4a06      	ldr	r2, [pc, #24]	; (1414c <z_pend_curr+0x20>)
   14134:	6890      	ldr	r0, [r2, #8]
   14136:	4a06      	ldr	r2, [pc, #24]	; (14150 <z_pend_curr+0x24>)
   14138:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   1413a:	461a      	mov	r2, r3
   1413c:	f7ff ffcc 	bl	140d8 <pend>
   14140:	4620      	mov	r0, r4
}
   14142:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   14146:	f7f1 bc79 	b.w	5a3c <arch_swap>
   1414a:	bf00      	nop
   1414c:	200040e8 	.word	0x200040e8
   14150:	20004118 	.word	0x20004118

00014154 <z_set_prio>:
{
   14154:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14158:	4604      	mov	r4, r0
	__asm__ volatile(
   1415a:	f04f 0320 	mov.w	r3, #32
   1415e:	f3ef 8811 	mrs	r8, BASEPRI
   14162:	f383 8811 	msr	BASEPRI, r3
   14166:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1416a:	7b43      	ldrb	r3, [r0, #13]
   1416c:	06db      	lsls	r3, r3, #27
   1416e:	b24e      	sxtb	r6, r1
   14170:	d12e      	bne.n	141d0 <z_set_prio+0x7c>
	return !sys_dnode_is_linked(&t->node);
   14172:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   14174:	bb65      	cbnz	r5, 141d0 <z_set_prio+0x7c>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   14176:	4f18      	ldr	r7, [pc, #96]	; (141d8 <z_set_prio+0x84>)
   14178:	4621      	mov	r1, r4
   1417a:	f107 0028 	add.w	r0, r7, #40	; 0x28
   1417e:	f7ff fdb5 	bl	13cec <z_priq_dumb_remove>
	return list->head == list;
   14182:	6abb      	ldr	r3, [r7, #40]	; 0x28
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   14184:	6afa      	ldr	r2, [r7, #44]	; 0x2c
				thread->base.prio = prio;
   14186:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14188:	4283      	cmp	r3, r0
   1418a:	bf18      	it	ne
   1418c:	461d      	movne	r5, r3
   1418e:	2d00      	cmp	r5, #0
   14190:	bf38      	it	cc
   14192:	2500      	movcc	r5, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   14194:	b1b5      	cbz	r5, 141c4 <z_set_prio+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
   14196:	f995 100e 	ldrsb.w	r1, [r5, #14]
   1419a:	42b1      	cmp	r1, r6
   1419c:	dc03      	bgt.n	141a6 <z_set_prio+0x52>
	return (node == list->tail) ? NULL : node->next;
   1419e:	42aa      	cmp	r2, r5
   141a0:	d010      	beq.n	141c4 <z_set_prio+0x70>
   141a2:	682d      	ldr	r5, [r5, #0]
   141a4:	e7f6      	b.n	14194 <z_set_prio+0x40>
	node->prev = successor->prev;
   141a6:	686a      	ldr	r2, [r5, #4]
	node->next = successor;
   141a8:	e9c4 5200 	strd	r5, r2, [r4]
	successor->prev->next = node;
   141ac:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   141ae:	606c      	str	r4, [r5, #4]
			update_cache(1);
   141b0:	2001      	movs	r0, #1
   141b2:	f7ff fdb1 	bl	13d18 <update_cache>
   141b6:	2001      	movs	r0, #1
	__asm__ volatile(
   141b8:	f388 8811 	msr	BASEPRI, r8
   141bc:	f3bf 8f6f 	isb	sy
}
   141c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node->prev = list->tail;
   141c4:	e9c4 0200 	strd	r0, r2, [r4]
	list->tail->next = node;
   141c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   141ca:	601c      	str	r4, [r3, #0]
	list->tail = node;
   141cc:	62fc      	str	r4, [r7, #44]	; 0x2c
}
   141ce:	e7ef      	b.n	141b0 <z_set_prio+0x5c>
			thread->base.prio = prio;
   141d0:	73a6      	strb	r6, [r4, #14]
   141d2:	2000      	movs	r0, #0
   141d4:	e7f0      	b.n	141b8 <z_set_prio+0x64>
   141d6:	bf00      	nop
   141d8:	200040e8 	.word	0x200040e8

000141dc <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   141dc:	4b04      	ldr	r3, [pc, #16]	; (141f0 <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   141de:	2100      	movs	r1, #0
   141e0:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   141e4:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   141e8:	4608      	mov	r0, r1
   141ea:	f7ff bd3f 	b.w	13c6c <k_sched_time_slice_set>
   141ee:	bf00      	nop
   141f0:	200040e8 	.word	0x200040e8

000141f4 <z_impl_k_yield>:
{
   141f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
   141f6:	4c24      	ldr	r4, [pc, #144]	; (14288 <z_impl_k_yield+0x94>)
   141f8:	4b24      	ldr	r3, [pc, #144]	; (1428c <z_impl_k_yield+0x98>)
   141fa:	68a2      	ldr	r2, [r4, #8]
   141fc:	429a      	cmp	r2, r3
   141fe:	d030      	beq.n	14262 <z_impl_k_yield+0x6e>
	__asm__ volatile(
   14200:	f04f 0320 	mov.w	r3, #32
   14204:	f3ef 8511 	mrs	r5, BASEPRI
   14208:	f383 8811 	msr	BASEPRI, r3
   1420c:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
   14210:	68a1      	ldr	r1, [r4, #8]
   14212:	f104 0028 	add.w	r0, r4, #40	; 0x28
   14216:	f7ff fd69 	bl	13cec <z_priq_dumb_remove>
	return list->head == list;
   1421a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
   1421c:	68a2      	ldr	r2, [r4, #8]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1421e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14220:	4283      	cmp	r3, r0
   14222:	bf08      	it	eq
   14224:	2300      	moveq	r3, #0
   14226:	2b00      	cmp	r3, #0
   14228:	bf38      	it	cc
   1422a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1422c:	b32b      	cbz	r3, 1427a <z_impl_k_yield+0x86>
	if (thread_1->base.prio < thread_2->base.prio) {
   1422e:	f992 700e 	ldrsb.w	r7, [r2, #14]
   14232:	f993 600e 	ldrsb.w	r6, [r3, #14]
   14236:	42b7      	cmp	r7, r6
   14238:	db03      	blt.n	14242 <z_impl_k_yield+0x4e>
	return (node == list->tail) ? NULL : node->next;
   1423a:	428b      	cmp	r3, r1
   1423c:	d01d      	beq.n	1427a <z_impl_k_yield+0x86>
   1423e:	681b      	ldr	r3, [r3, #0]
   14240:	e7f4      	b.n	1422c <z_impl_k_yield+0x38>
	node->prev = successor->prev;
   14242:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   14244:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
   14248:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   1424a:	605a      	str	r2, [r3, #4]
	thread->base.thread_state |= states;
   1424c:	7b53      	ldrb	r3, [r2, #13]
   1424e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   14252:	7353      	strb	r3, [r2, #13]
			update_cache(1);
   14254:	2001      	movs	r0, #1
   14256:	f7ff fd5f 	bl	13d18 <update_cache>
	__asm__ volatile(
   1425a:	f385 8811 	msr	BASEPRI, r5
   1425e:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   14262:	f04f 0320 	mov.w	r3, #32
   14266:	f3ef 8011 	mrs	r0, BASEPRI
   1426a:	f383 8811 	msr	BASEPRI, r3
   1426e:	f3bf 8f6f 	isb	sy
}
   14272:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   14276:	f7f1 bbe1 	b.w	5a3c <arch_swap>
	node->prev = list->tail;
   1427a:	e9c2 0100 	strd	r0, r1, [r2]
	list->tail->next = node;
   1427e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   14280:	601a      	str	r2, [r3, #0]
	list->tail = node;
   14282:	62e2      	str	r2, [r4, #44]	; 0x2c
}
   14284:	e7e2      	b.n	1424c <z_impl_k_yield+0x58>
   14286:	bf00      	nop
   14288:	200040e8 	.word	0x200040e8
   1428c:	20003e80 	.word	0x20003e80

00014290 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
   14290:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   14292:	1c43      	adds	r3, r0, #1
{
   14294:	4604      	mov	r4, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   14296:	d105      	bne.n	142a4 <z_impl_k_sleep+0x14>
		k_thread_suspend(_current);
   14298:	4b10      	ldr	r3, [pc, #64]	; (142dc <z_impl_k_sleep+0x4c>)
   1429a:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   1429c:	f7ff fe4a 	bl	13f34 <z_impl_k_thread_suspend>
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   142a0:	4620      	mov	r0, r4
   142a2:	bd38      	pop	{r3, r4, r5, pc}
   142a4:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   142a8:	f240 30e7 	movw	r0, #999	; 0x3e7
   142ac:	2100      	movs	r1, #0
   142ae:	fbe5 0104 	umlal	r0, r1, r5, r4
   142b2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   142b6:	2300      	movs	r3, #0
   142b8:	f7ec fb24 	bl	904 <__aeabi_uldivmod>
	if (ticks == 0) {
   142bc:	4604      	mov	r4, r0
   142be:	b948      	cbnz	r0, 142d4 <z_impl_k_sleep+0x44>
	z_impl_k_yield();
   142c0:	f7ff ff98 	bl	141f4 <z_impl_k_yield>
		} else {
			return (t * to_hz + off) / from_hz;
   142c4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   142c8:	fba4 0100 	umull	r0, r1, r4, r0
   142cc:	0bc4      	lsrs	r4, r0, #15
   142ce:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   142d2:	e7e5      	b.n	142a0 <z_impl_k_sleep+0x10>
   142d4:	f7ff fed2 	bl	1407c <z_tick_sleep.part.0>
   142d8:	4604      	mov	r4, r0
   142da:	e7f3      	b.n	142c4 <z_impl_k_sleep+0x34>
   142dc:	200040e8 	.word	0x200040e8

000142e0 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   142e0:	4b01      	ldr	r3, [pc, #4]	; (142e8 <z_impl_k_current_get+0x8>)
   142e2:	6898      	ldr	r0, [r3, #8]
   142e4:	4770      	bx	lr
   142e6:	bf00      	nop
   142e8:	200040e8 	.word	0x200040e8

000142ec <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   142ec:	b538      	push	{r3, r4, r5, lr}
   142ee:	4604      	mov	r4, r0
   142f0:	f04f 0320 	mov.w	r3, #32
   142f4:	f3ef 8511 	mrs	r5, BASEPRI
   142f8:	f383 8811 	msr	BASEPRI, r3
   142fc:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   14300:	f004 fdc6 	bl	18e90 <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   14304:	b148      	cbz	r0, 1431a <z_impl_k_sem_give+0x2e>
   14306:	2200      	movs	r2, #0
   14308:	6702      	str	r2, [r0, #112]	; 0x70
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   1430a:	f004 fd4b 	bl	18da4 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   1430e:	4629      	mov	r1, r5
   14310:	4808      	ldr	r0, [pc, #32]	; (14334 <z_impl_k_sem_give+0x48>)
}
   14312:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   14316:	f004 bcfd 	b.w	18d14 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   1431a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   1431e:	429a      	cmp	r2, r3
   14320:	bf18      	it	ne
   14322:	3301      	addne	r3, #1
   14324:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   14326:	2102      	movs	r1, #2
   14328:	f104 0010 	add.w	r0, r4, #16
   1432c:	f004 ffb4 	bl	19298 <z_handle_obj_poll_events>
}
   14330:	e7ed      	b.n	1430e <z_impl_k_sem_give+0x22>
   14332:	bf00      	nop
   14334:	200087df 	.word	0x200087df

00014338 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   14338:	4602      	mov	r2, r0
   1433a:	460b      	mov	r3, r1
   1433c:	f04f 0020 	mov.w	r0, #32
   14340:	f3ef 8111 	mrs	r1, BASEPRI
   14344:	f380 8811 	msr	BASEPRI, r0
   14348:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   1434c:	6890      	ldr	r0, [r2, #8]
   1434e:	b138      	cbz	r0, 14360 <z_impl_k_sem_take+0x28>
		sem->count--;
   14350:	3801      	subs	r0, #1
   14352:	6090      	str	r0, [r2, #8]
	__asm__ volatile(
   14354:	f381 8811 	msr	BASEPRI, r1
   14358:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   1435c:	2000      	movs	r0, #0
		goto out;
   1435e:	4770      	bx	lr
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   14360:	b933      	cbnz	r3, 14370 <z_impl_k_sem_take+0x38>
   14362:	f381 8811 	msr	BASEPRI, r1
   14366:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
   1436a:	f06f 000f 	mvn.w	r0, #15
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   1436e:	4770      	bx	lr
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   14370:	4801      	ldr	r0, [pc, #4]	; (14378 <z_impl_k_sem_take+0x40>)
   14372:	f7ff bedb 	b.w	1412c <z_pend_curr>
   14376:	bf00      	nop
   14378:	200087df 	.word	0x200087df

0001437c <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   1437c:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   1437e:	4c08      	ldr	r4, [pc, #32]	; (143a0 <k_sys_work_q_init+0x24>)
   14380:	4908      	ldr	r1, [pc, #32]	; (143a4 <k_sys_work_q_init+0x28>)
   14382:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14386:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1438a:	4620      	mov	r0, r4
   1438c:	f000 f8be 	bl	1450c <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   14390:	4905      	ldr	r1, [pc, #20]	; (143a8 <k_sys_work_q_init+0x2c>)
   14392:	f104 0010 	add.w	r0, r4, #16
   14396:	f004 fdd0 	bl	18f3a <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   1439a:	2000      	movs	r0, #0
   1439c:	bd10      	pop	{r4, pc}
   1439e:	bf00      	nop
   143a0:	20004124 	.word	0x20004124
   143a4:	2000ac60 	.word	0x2000ac60
   143a8:	0001c2b7 	.word	0x0001c2b7

000143ac <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   143ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   143ae:	b087      	sub	sp, #28
   143b0:	e9dd 670f 	ldrd	r6, r7, [sp, #60]	; 0x3c
	sys_dlist_init(&w->waitq);
   143b4:	f100 0528 	add.w	r5, r0, #40	; 0x28
#endif
#endif
	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   143b8:	e9cd 6703 	strd	r6, r7, [sp, #12]
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
   143bc:	7386      	strb	r6, [r0, #14]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   143be:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   143c0:	9602      	str	r6, [sp, #8]
	list->tail = (sys_dnode_t *)list;
   143c2:	e9c0 550a 	strd	r5, r5, [r0, #40]	; 0x28
   143c6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   143c8:	9601      	str	r6, [sp, #4]
	thread_base->thread_state = (u8_t)initial_state;
   143ca:	2504      	movs	r5, #4
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   143cc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	thread_base->thread_state = (u8_t)initial_state;
   143ce:	7345      	strb	r5, [r0, #13]

	thread_base->sched_locked = 0U;
   143d0:	2500      	movs	r5, #0
	node->prev = NULL;
   143d2:	e9c0 5506 	strd	r5, r5, [r0, #24]
	thread_base->user_options = (u8_t)options;
   143d6:	7307      	strb	r7, [r0, #12]
	thread_base->sched_locked = 0U;
   143d8:	73c5      	strb	r5, [r0, #15]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   143da:	9600      	str	r6, [sp, #0]
{
   143dc:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   143de:	f7f1 fbd3 	bl	5b88 <arch_new_thread>
	if (!_current) {
   143e2:	4b04      	ldr	r3, [pc, #16]	; (143f4 <z_setup_new_thread+0x48>)
   143e4:	689b      	ldr	r3, [r3, #8]
	new_thread->fn_abort = NULL;
   143e6:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
	if (!_current) {
   143ea:	b103      	cbz	r3, 143ee <z_setup_new_thread+0x42>
	new_thread->resource_pool = _current->resource_pool;
   143ec:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   143ee:	66a3      	str	r3, [r4, #104]	; 0x68
}
   143f0:	b007      	add	sp, #28
   143f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   143f4:	200040e8 	.word	0x200040e8

000143f8 <z_impl_k_thread_create>:
{
   143f8:	b570      	push	{r4, r5, r6, lr}
   143fa:	b086      	sub	sp, #24
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   143fc:	2600      	movs	r6, #0
   143fe:	9605      	str	r6, [sp, #20]
   14400:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   14402:	9604      	str	r6, [sp, #16]
   14404:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   14406:	9603      	str	r6, [sp, #12]
   14408:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1440a:	9602      	str	r6, [sp, #8]
   1440c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
   1440e:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   14410:	9601      	str	r6, [sp, #4]
   14412:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   14414:	9600      	str	r6, [sp, #0]
{
   14416:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   14418:	f7ff ffc8 	bl	143ac <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   1441c:	1c6b      	adds	r3, r5, #1
   1441e:	d003      	beq.n	14428 <z_impl_k_thread_create+0x30>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   14420:	b92d      	cbnz	r5, 1442e <z_impl_k_thread_create+0x36>
	z_sched_start(thread);
   14422:	4620      	mov	r0, r4
   14424:	f7ff fcec 	bl	13e00 <z_sched_start>
}
   14428:	4620      	mov	r0, r4
   1442a:	b006      	add	sp, #24
   1442c:	bd70      	pop	{r4, r5, r6, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   1442e:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   14432:	f240 30e7 	movw	r0, #999	; 0x3e7
   14436:	2100      	movs	r1, #0
   14438:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1443c:	2300      	movs	r3, #0
   1443e:	fbe6 0105 	umlal	r0, r1, r6, r5
   14442:	f7ec fa5f 	bl	904 <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   14446:	4903      	ldr	r1, [pc, #12]	; (14454 <z_impl_k_thread_create+0x5c>)
   14448:	1c42      	adds	r2, r0, #1
   1444a:	f104 0018 	add.w	r0, r4, #24
   1444e:	f000 f8bb 	bl	145c8 <z_add_timeout>
}
   14452:	e7e9      	b.n	14428 <z_impl_k_thread_create+0x30>
   14454:	00018dc5 	.word	0x00018dc5

00014458 <z_init_static_threads>:
{
   14458:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   1445c:	4e28      	ldr	r6, [pc, #160]	; (14500 <z_init_static_threads+0xa8>)
   1445e:	4d29      	ldr	r5, [pc, #164]	; (14504 <z_init_static_threads+0xac>)
{
   14460:	b087      	sub	sp, #28
   14462:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
   14464:	42b5      	cmp	r5, r6
   14466:	f105 0430 	add.w	r4, r5, #48	; 0x30
   1446a:	d310      	bcc.n	1448e <z_init_static_threads+0x36>
	k_sched_lock();
   1446c:	f7ff fc2a 	bl	13cc4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   14470:	4c24      	ldr	r4, [pc, #144]	; (14504 <z_init_static_threads+0xac>)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   14472:	f8df a094 	ldr.w	sl, [pc, #148]	; 14508 <z_init_static_threads+0xb0>
   14476:	f44f 4900 	mov.w	r9, #32768	; 0x8000
   1447a:	f240 36e7 	movw	r6, #999	; 0x3e7
   1447e:	2700      	movs	r7, #0
   14480:	4544      	cmp	r4, r8
   14482:	d321      	bcc.n	144c8 <z_init_static_threads+0x70>
}
   14484:	b007      	add	sp, #28
   14486:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
   1448a:	f7ff bc69 	b.w	13d60 <k_sched_unlock>
		z_setup_new_thread(
   1448e:	f854 3c04 	ldr.w	r3, [r4, #-4]
   14492:	9305      	str	r3, [sp, #20]
   14494:	f854 3c10 	ldr.w	r3, [r4, #-16]
   14498:	9304      	str	r3, [sp, #16]
   1449a:	f854 3c14 	ldr.w	r3, [r4, #-20]
   1449e:	9303      	str	r3, [sp, #12]
   144a0:	f854 3c18 	ldr.w	r3, [r4, #-24]
   144a4:	9302      	str	r3, [sp, #8]
   144a6:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   144aa:	9301      	str	r3, [sp, #4]
   144ac:	f854 3c20 	ldr.w	r3, [r4, #-32]
   144b0:	9300      	str	r3, [sp, #0]
   144b2:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   144b6:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   144ba:	f7ff ff77 	bl	143ac <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   144be:	f854 3c30 	ldr.w	r3, [r4, #-48]
   144c2:	655d      	str	r5, [r3, #84]	; 0x54
   144c4:	4625      	mov	r5, r4
   144c6:	e7cd      	b.n	14464 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   144c8:	6a61      	ldr	r1, [r4, #36]	; 0x24
   144ca:	1c4b      	adds	r3, r1, #1
   144cc:	d004      	beq.n	144d8 <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
   144ce:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   144d0:	b921      	cbnz	r1, 144dc <z_init_static_threads+0x84>
	z_sched_start(thread);
   144d2:	4628      	mov	r0, r5
   144d4:	f7ff fc94 	bl	13e00 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   144d8:	3430      	adds	r4, #48	; 0x30
   144da:	e7d1      	b.n	14480 <z_init_static_threads+0x28>
   144dc:	46b3      	mov	fp, r6
   144de:	46bc      	mov	ip, r7
   144e0:	fbe9 bc01 	umlal	fp, ip, r9, r1
   144e4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   144e8:	2300      	movs	r3, #0
   144ea:	4658      	mov	r0, fp
   144ec:	4661      	mov	r1, ip
   144ee:	f7ec fa09 	bl	904 <__aeabi_uldivmod>
   144f2:	4651      	mov	r1, sl
   144f4:	1c42      	adds	r2, r0, #1
   144f6:	f105 0018 	add.w	r0, r5, #24
   144fa:	f000 f865 	bl	145c8 <z_add_timeout>
}
   144fe:	e7eb      	b.n	144d8 <z_init_static_threads+0x80>
   14500:	2000c2bc 	.word	0x2000c2bc
   14504:	2000c28c 	.word	0x2000c28c
   14508:	00018dc5 	.word	0x00018dc5

0001450c <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   1450c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14510:	4604      	mov	r4, r0
   14512:	b086      	sub	sp, #24
   14514:	460d      	mov	r5, r1
   14516:	4616      	mov	r6, r2
   14518:	461f      	mov	r7, r3
	z_impl_k_queue_init(queue);
   1451a:	f004 fb3c 	bl	18b96 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   1451e:	f104 0810 	add.w	r8, r4, #16
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   14522:	2000      	movs	r0, #0
   14524:	e9cd 0004 	strd	r0, r0, [sp, #16]
   14528:	e9cd 0702 	strd	r0, r7, [sp, #8]
   1452c:	e9cd 4000 	strd	r4, r0, [sp]
   14530:	4b06      	ldr	r3, [pc, #24]	; (1454c <k_work_q_start+0x40>)
   14532:	4632      	mov	r2, r6
   14534:	4629      	mov	r1, r5
   14536:	4640      	mov	r0, r8
   14538:	f7ff ff5e 	bl	143f8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   1453c:	4904      	ldr	r1, [pc, #16]	; (14550 <k_work_q_start+0x44>)
   1453e:	4640      	mov	r0, r8
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   14540:	b006      	add	sp, #24
   14542:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   14546:	f004 bcf8 	b.w	18f3a <z_impl_k_thread_name_set>
   1454a:	bf00      	nop
   1454c:	00014b73 	.word	0x00014b73
   14550:	0001c2c0 	.word	0x0001c2c0

00014554 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   14554:	4b03      	ldr	r3, [pc, #12]	; (14564 <elapsed+0x10>)
   14556:	681b      	ldr	r3, [r3, #0]
   14558:	b90b      	cbnz	r3, 1455e <elapsed+0xa>
   1455a:	f7f1 b981 	b.w	5860 <z_clock_elapsed>
}
   1455e:	2000      	movs	r0, #0
   14560:	4770      	bx	lr
   14562:	bf00      	nop
   14564:	200041a8 	.word	0x200041a8

00014568 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   14568:	6803      	ldr	r3, [r0, #0]
   1456a:	b140      	cbz	r0, 1457e <remove_timeout+0x16>
   1456c:	4a07      	ldr	r2, [pc, #28]	; (1458c <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   1456e:	6852      	ldr	r2, [r2, #4]
   14570:	4290      	cmp	r0, r2
   14572:	d004      	beq.n	1457e <remove_timeout+0x16>
	if (next(t) != NULL) {
   14574:	b11b      	cbz	r3, 1457e <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   14576:	689a      	ldr	r2, [r3, #8]
   14578:	6881      	ldr	r1, [r0, #8]
   1457a:	440a      	add	r2, r1
   1457c:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   1457e:	6842      	ldr	r2, [r0, #4]
   14580:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   14582:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   14584:	2300      	movs	r3, #0
	node->prev = NULL;
   14586:	e9c0 3300 	strd	r3, r3, [r0]
}
   1458a:	4770      	bx	lr
   1458c:	2000c154 	.word	0x2000c154

00014590 <next_timeout>:
	return list->head == list;
   14590:	4b0b      	ldr	r3, [pc, #44]	; (145c0 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   14592:	b510      	push	{r4, lr}
   14594:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14596:	429c      	cmp	r4, r3
   14598:	bf08      	it	eq
   1459a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   1459c:	f7ff ffda 	bl	14554 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   145a0:	b154      	cbz	r4, 145b8 <next_timeout+0x28>
   145a2:	68a3      	ldr	r3, [r4, #8]
   145a4:	1a18      	subs	r0, r3, r0
   145a6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   145aa:	4b06      	ldr	r3, [pc, #24]	; (145c4 <next_timeout+0x34>)
   145ac:	691b      	ldr	r3, [r3, #16]
   145ae:	b113      	cbz	r3, 145b6 <next_timeout+0x26>
   145b0:	4298      	cmp	r0, r3
   145b2:	bfa8      	it	ge
   145b4:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   145b6:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   145b8:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   145bc:	e7f5      	b.n	145aa <next_timeout+0x1a>
   145be:	bf00      	nop
   145c0:	2000c154 	.word	0x2000c154
   145c4:	200040e8 	.word	0x200040e8

000145c8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   145c8:	1c53      	adds	r3, r2, #1
{
   145ca:	b570      	push	{r4, r5, r6, lr}
   145cc:	4604      	mov	r4, r0
   145ce:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   145d0:	d035      	beq.n	1463e <z_add_timeout+0x76>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   145d2:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
   145d4:	f04f 0320 	mov.w	r3, #32
   145d8:	f3ef 8511 	mrs	r5, BASEPRI
   145dc:	f383 8811 	msr	BASEPRI, r3
   145e0:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   145e4:	f7ff ffb6 	bl	14554 <elapsed>
	return list->head == list;
   145e8:	4b18      	ldr	r3, [pc, #96]	; (1464c <z_add_timeout+0x84>)
   145ea:	681a      	ldr	r2, [r3, #0]
   145ec:	2e01      	cmp	r6, #1
   145ee:	bf2c      	ite	cs
   145f0:	1986      	addcs	r6, r0, r6
   145f2:	1c46      	addcc	r6, r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
   145f4:	429a      	cmp	r2, r3
   145f6:	60a6      	str	r6, [r4, #8]
   145f8:	d001      	beq.n	145fe <z_add_timeout+0x36>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   145fa:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
   145fc:	b932      	cbnz	r2, 1460c <z_add_timeout+0x44>
	node->prev = list->tail;
   145fe:	685a      	ldr	r2, [r3, #4]
   14600:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
   14602:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   14604:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
   14606:	6014      	str	r4, [r2, #0]
	list->tail = node;
   14608:	605c      	str	r4, [r3, #4]
}
   1460a:	e00a      	b.n	14622 <z_add_timeout+0x5a>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
   1460c:	6890      	ldr	r0, [r2, #8]
   1460e:	68a1      	ldr	r1, [r4, #8]
   14610:	4288      	cmp	r0, r1
   14612:	dd15      	ble.n	14640 <z_add_timeout+0x78>
				t->dticks -= to->dticks;
   14614:	1a41      	subs	r1, r0, r1
   14616:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
   14618:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   1461a:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
   1461e:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   14620:	6054      	str	r4, [r2, #4]
	return list->head == list;
   14622:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14624:	429a      	cmp	r2, r3
   14626:	d006      	beq.n	14636 <z_add_timeout+0x6e>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   14628:	4294      	cmp	r4, r2
   1462a:	d104      	bne.n	14636 <z_add_timeout+0x6e>
			z_clock_set_timeout(next_timeout(), false);
   1462c:	f7ff ffb0 	bl	14590 <next_timeout>
   14630:	2100      	movs	r1, #0
   14632:	f7f1 f8bd 	bl	57b0 <z_clock_set_timeout>
	__asm__ volatile(
   14636:	f385 8811 	msr	BASEPRI, r5
   1463a:	f3bf 8f6f 	isb	sy
		}
	}
}
   1463e:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
   14640:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   14642:	4296      	cmp	r6, r2
   14644:	60a1      	str	r1, [r4, #8]
   14646:	d0da      	beq.n	145fe <z_add_timeout+0x36>
   14648:	6812      	ldr	r2, [r2, #0]
   1464a:	e7d7      	b.n	145fc <z_add_timeout+0x34>
   1464c:	2000c154 	.word	0x2000c154

00014650 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
   14650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14654:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   14656:	f7ff fc37 	bl	13ec8 <z_time_slice>
	__asm__ volatile(
   1465a:	f04f 0320 	mov.w	r3, #32
   1465e:	f3ef 8411 	mrs	r4, BASEPRI
   14662:	f383 8811 	msr	BASEPRI, r3
   14666:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   1466a:	4d20      	ldr	r5, [pc, #128]	; (146ec <z_clock_announce+0x9c>)
   1466c:	f8df 8080 	ldr.w	r8, [pc, #128]	; 146f0 <z_clock_announce+0xa0>
	return list->head == list;
   14670:	f8df a080 	ldr.w	sl, [pc, #128]	; 146f4 <z_clock_announce+0xa4>
   14674:	602e      	str	r6, [r5, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
   14676:	46c1      	mov	r9, r8
   14678:	f8da 0000 	ldr.w	r0, [sl]
   1467c:	682a      	ldr	r2, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1467e:	4550      	cmp	r0, sl
   14680:	e9d8 6700 	ldrd	r6, r7, [r8]
   14684:	d005      	beq.n	14692 <z_clock_announce+0x42>
   14686:	b120      	cbz	r0, 14692 <z_clock_announce+0x42>
   14688:	6883      	ldr	r3, [r0, #8]
   1468a:	4293      	cmp	r3, r2
   1468c:	dd13      	ble.n	146b6 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   1468e:	1a9b      	subs	r3, r3, r2
   14690:	6083      	str	r3, [r0, #8]
	}

	curr_tick += announce_remaining;
   14692:	18b6      	adds	r6, r6, r2
   14694:	eb47 77e2 	adc.w	r7, r7, r2, asr #31
   14698:	e9c9 6700 	strd	r6, r7, [r9]
	announce_remaining = 0;
   1469c:	2600      	movs	r6, #0
   1469e:	602e      	str	r6, [r5, #0]

	z_clock_set_timeout(next_timeout(), false);
   146a0:	f7ff ff76 	bl	14590 <next_timeout>
   146a4:	4631      	mov	r1, r6
   146a6:	f7f1 f883 	bl	57b0 <z_clock_set_timeout>
	__asm__ volatile(
   146aa:	f384 8811 	msr	BASEPRI, r4
   146ae:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   146b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_tick += dt;
   146b6:	18f6      	adds	r6, r6, r3
   146b8:	eb47 77e3 	adc.w	r7, r7, r3, asr #31
		announce_remaining -= dt;
   146bc:	1ad3      	subs	r3, r2, r3
   146be:	602b      	str	r3, [r5, #0]
		t->dticks = 0;
   146c0:	2300      	movs	r3, #0
   146c2:	6083      	str	r3, [r0, #8]
		curr_tick += dt;
   146c4:	e9c8 6700 	strd	r6, r7, [r8]
		remove_timeout(t);
   146c8:	f7ff ff4e 	bl	14568 <remove_timeout>
   146cc:	f384 8811 	msr	BASEPRI, r4
   146d0:	f3bf 8f6f 	isb	sy
		t->fn(t);
   146d4:	68c3      	ldr	r3, [r0, #12]
   146d6:	4798      	blx	r3
	__asm__ volatile(
   146d8:	f04f 0320 	mov.w	r3, #32
   146dc:	f3ef 8411 	mrs	r4, BASEPRI
   146e0:	f383 8811 	msr	BASEPRI, r3
   146e4:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   146e8:	e7c6      	b.n	14678 <z_clock_announce+0x28>
   146ea:	bf00      	nop
   146ec:	200041a8 	.word	0x200041a8
   146f0:	20000000 	.word	0x20000000
   146f4:	2000c154 	.word	0x2000c154

000146f8 <z_tick_get>:

s64_t z_tick_get(void)
{
   146f8:	b510      	push	{r4, lr}
   146fa:	f04f 0320 	mov.w	r3, #32
   146fe:	f3ef 8411 	mrs	r4, BASEPRI
   14702:	f383 8811 	msr	BASEPRI, r3
   14706:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   1470a:	f7f1 f8a9 	bl	5860 <z_clock_elapsed>
   1470e:	4b06      	ldr	r3, [pc, #24]	; (14728 <z_tick_get+0x30>)
   14710:	e9d3 2300 	ldrd	r2, r3, [r3]
   14714:	1812      	adds	r2, r2, r0
   14716:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   1471a:	f384 8811 	msr	BASEPRI, r4
   1471e:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   14722:	4610      	mov	r0, r2
   14724:	4619      	mov	r1, r3
   14726:	bd10      	pop	{r4, pc}
   14728:	20000000 	.word	0x20000000

0001472c <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   1472c:	6a02      	ldr	r2, [r0, #32]
{
   1472e:	b538      	push	{r3, r4, r5, lr}
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   14730:	1c53      	adds	r3, r2, #1
   14732:	2b01      	cmp	r3, #1
{
   14734:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   14736:	d902      	bls.n	1473e <z_timer_expiration_handler+0x12>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   14738:	490b      	ldr	r1, [pc, #44]	; (14768 <z_timer_expiration_handler+0x3c>)
   1473a:	f7ff ff45 	bl	145c8 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   1473e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   14740:	3301      	adds	r3, #1
   14742:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   14744:	69a3      	ldr	r3, [r4, #24]
   14746:	b10b      	cbz	r3, 1474c <z_timer_expiration_handler+0x20>
		timer->expiry_fn(timer);
   14748:	4620      	mov	r0, r4
   1474a:	4798      	blx	r3
	return list->head == list;
   1474c:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14750:	42a5      	cmp	r5, r4
   14752:	d008      	beq.n	14766 <z_timer_expiration_handler+0x3a>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   14754:	b13d      	cbz	r5, 14766 <z_timer_expiration_handler+0x3a>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   14756:	4628      	mov	r0, r5
   14758:	f004 fac3 	bl	18ce2 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
   1475c:	4628      	mov	r0, r5
   1475e:	f004 fb21 	bl	18da4 <z_ready_thread>
   14762:	2300      	movs	r3, #0
   14764:	672b      	str	r3, [r5, #112]	; 0x70

	arch_thread_return_value_set(thread, 0);
}
   14766:	bd38      	pop	{r3, r4, r5, pc}
   14768:	0001472d 	.word	0x0001472d

0001476c <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   1476c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   14770:	f240 38e7 	movw	r8, #999	; 0x3e7
   14774:	f04f 0900 	mov.w	r9, #0
   14778:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   1477c:	46c3      	mov	fp, r8
   1477e:	46cc      	mov	ip, r9
   14780:	fbe7 bc01 	umlal	fp, ip, r7, r1
   14784:	4604      	mov	r4, r0
   14786:	4616      	mov	r6, r2
   14788:	4661      	mov	r1, ip
   1478a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1478e:	2300      	movs	r3, #0
   14790:	4658      	mov	r0, fp
   14792:	f7ec f8b7 	bl	904 <__aeabi_uldivmod>
   14796:	4649      	mov	r1, r9
   14798:	4605      	mov	r5, r0
   1479a:	4640      	mov	r0, r8
   1479c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   147a0:	2300      	movs	r3, #0
   147a2:	fbe7 0106 	umlal	r0, r1, r7, r6
   147a6:	f7ec f8ad 	bl	904 <__aeabi_uldivmod>
   147aa:	4606      	mov	r6, r0
	if (Z_TICK_ABS(duration.ticks) < 0) {
		duration.ticks = MAX(duration.ticks - 1, 0);
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
   147ac:	4620      	mov	r0, r4
   147ae:	f004 fbc9 	bl	18f44 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   147b2:	2300      	movs	r3, #0
	period = k_ms_to_ticks_ceil32(period);
   147b4:	6226      	str	r6, [r4, #32]
	timer->status = 0U;
   147b6:	6263      	str	r3, [r4, #36]	; 0x24

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   147b8:	462a      	mov	r2, r5
   147ba:	4620      	mov	r0, r4
   147bc:	4902      	ldr	r1, [pc, #8]	; (147c8 <z_impl_k_timer_start+0x5c>)
		     duration);
}
   147be:	e8bd 4bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   147c2:	f7ff bf01 	b.w	145c8 <z_add_timeout>
   147c6:	bf00      	nop
   147c8:	0001472d 	.word	0x0001472d

000147cc <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   147cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   147d0:	b086      	sub	sp, #24
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   147d2:	2301      	movs	r3, #1
   147d4:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   147d8:	4b23      	ldr	r3, [pc, #140]	; (14868 <z_impl_k_poll+0x9c>)
	struct _poller poller = { .is_polling = true,
   147da:	689b      	ldr	r3, [r3, #8]
   147dc:	9304      	str	r3, [sp, #16]
   147de:	4b23      	ldr	r3, [pc, #140]	; (1486c <z_impl_k_poll+0xa0>)
   147e0:	9305      	str	r3, [sp, #20]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
   147e2:	fab2 f382 	clz	r3, r2
   147e6:	4690      	mov	r8, r2
   147e8:	095b      	lsrs	r3, r3, #5
   147ea:	aa03      	add	r2, sp, #12
{
   147ec:	4605      	mov	r5, r0
	events_registered = register_events(events, num_events, &poller,
   147ee:	f004 fcdd 	bl	191ac <register_events>
   147f2:	4606      	mov	r6, r0
	__asm__ volatile(
   147f4:	f04f 0320 	mov.w	r3, #32
   147f8:	f3ef 8711 	mrs	r7, BASEPRI
   147fc:	f383 8811 	msr	BASEPRI, r3
   14800:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   14804:	f89d 300c 	ldrb.w	r3, [sp, #12]
   14808:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   1480c:	b94b      	cbnz	r3, 14822 <z_impl_k_poll+0x56>
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
   1480e:	463a      	mov	r2, r7
   14810:	4631      	mov	r1, r6
   14812:	4628      	mov	r0, r5
   14814:	f004 fc31 	bl	1907a <clear_event_registrations>
	__asm__ volatile(
   14818:	f387 8811 	msr	BASEPRI, r7
   1481c:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	return swap_rc;
   14820:	e00b      	b.n	1483a <z_impl_k_poll+0x6e>
	poller.is_polling = false;
   14822:	2300      	movs	r3, #0
   14824:	f88d 300c 	strb.w	r3, [sp, #12]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   14828:	f1b8 0f00 	cmp.w	r8, #0
   1482c:	d109      	bne.n	14842 <z_impl_k_poll+0x76>
   1482e:	f387 8811 	msr	BASEPRI, r7
   14832:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   14836:	f06f 040a 	mvn.w	r4, #10
}
   1483a:	4620      	mov	r0, r4
   1483c:	b006      	add	sp, #24
   1483e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   14842:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   14844:	4643      	mov	r3, r8
   14846:	4639      	mov	r1, r7
   14848:	4809      	ldr	r0, [pc, #36]	; (14870 <z_impl_k_poll+0xa4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   1484a:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   1484e:	f7ff fc6d 	bl	1412c <z_pend_curr>
   14852:	4604      	mov	r4, r0
	__asm__ volatile(
   14854:	f04f 0320 	mov.w	r3, #32
   14858:	f3ef 8711 	mrs	r7, BASEPRI
   1485c:	f383 8811 	msr	BASEPRI, r3
   14860:	f3bf 8f6f 	isb	sy
   14864:	e7d3      	b.n	1480e <z_impl_k_poll+0x42>
   14866:	bf00      	nop
   14868:	200040e8 	.word	0x200040e8
   1486c:	00019107 	.word	0x00019107
   14870:	200087df 	.word	0x200087df

00014874 <z_impl_gpio_pin_interrupt_configure.constprop.0>:
static inline int z_impl_gpio_pin_interrupt_configure(struct device *port,
   14874:	b410      	push	{r4}
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   14876:	040c      	lsls	r4, r1, #16
	const struct gpio_driver_api *api =
   14878:	6843      	ldr	r3, [r0, #4]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   1487a:	d505      	bpl.n	14888 <z_impl_gpio_pin_interrupt_configure.constprop.0+0x14>
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
   1487c:	6882      	ldr	r2, [r0, #8]
   1487e:	6812      	ldr	r2, [r2, #0]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   14880:	0512      	lsls	r2, r2, #20
		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
   14882:	bf48      	it	mi
   14884:	f481 21c0 	eormi.w	r1, r1, #393216	; 0x60000
	return api->pin_interrupt_configure(port, pin, mode, trig);
   14888:	699c      	ldr	r4, [r3, #24]
   1488a:	f401 32b0 	and.w	r2, r1, #90112	; 0x16000
   1488e:	f401 23c0 	and.w	r3, r1, #393216	; 0x60000
   14892:	46a4      	mov	ip, r4
   14894:	210b      	movs	r1, #11
}
   14896:	bc10      	pop	{r4}
	return api->pin_interrupt_configure(port, pin, mode, trig);
   14898:	4760      	bx	ip

0001489a <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1489a:	2301      	movs	r3, #1
   1489c:	fa03 f101 	lsl.w	r1, r3, r1
   148a0:	6883      	ldr	r3, [r0, #8]
   148a2:	681b      	ldr	r3, [r3, #0]
   148a4:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   148a6:	bf18      	it	ne
   148a8:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   148ac:	b112      	cbz	r2, 148b4 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   148ae:	6843      	ldr	r3, [r0, #4]
   148b0:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   148b2:	4718      	bx	r3
   148b4:	6843      	ldr	r3, [r0, #4]
   148b6:	691b      	ldr	r3, [r3, #16]
   148b8:	e7fb      	b.n	148b2 <gpio_pin_set+0x18>

000148ba <blink>:

void blink(struct led *led, uint8_t blink) 
{
   148ba:	b538      	push	{r3, r4, r5, lr}
   148bc:	4605      	mov	r5, r0
   148be:	460c      	mov	r4, r1
    while(blink--) {
   148c0:	3c01      	subs	r4, #1
   148c2:	b2e4      	uxtb	r4, r4
   148c4:	2cff      	cmp	r4, #255	; 0xff
   148c6:	d100      	bne.n	148ca <blink+0x10>
        gpio_pin_set(led->dev, led->gpio_pin, 1);
        k_msleep(200);
        gpio_pin_set(led->dev, led->gpio_pin, 0);
        k_msleep(200);
    }
}
   148c8:	bd38      	pop	{r3, r4, r5, pc}
        gpio_pin_set(led->dev, led->gpio_pin, 1);
   148ca:	7a29      	ldrb	r1, [r5, #8]
   148cc:	6928      	ldr	r0, [r5, #16]
   148ce:	2201      	movs	r2, #1
   148d0:	f7ff ffe3 	bl	1489a <gpio_pin_set>
	return z_impl_k_sleep(timeout);
   148d4:	20c8      	movs	r0, #200	; 0xc8
   148d6:	f7ff fcdb 	bl	14290 <z_impl_k_sleep>
        gpio_pin_set(led->dev, led->gpio_pin, 0);
   148da:	7a29      	ldrb	r1, [r5, #8]
   148dc:	6928      	ldr	r0, [r5, #16]
   148de:	2200      	movs	r2, #0
   148e0:	f7ff ffdb 	bl	1489a <gpio_pin_set>
   148e4:	20c8      	movs	r0, #200	; 0xc8
   148e6:	f7ff fcd3 	bl	14290 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline s32_t k_msleep(s32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
   148ea:	e7e9      	b.n	148c0 <blink+0x6>

000148ec <flash>:

void flash(struct led *led)
{
   148ec:	b510      	push	{r4, lr}
    gpio_pin_set(led->dev, led->gpio_pin, 1);
   148ee:	7a01      	ldrb	r1, [r0, #8]
{
   148f0:	4604      	mov	r4, r0
    gpio_pin_set(led->dev, led->gpio_pin, 1);
   148f2:	2201      	movs	r2, #1
   148f4:	6900      	ldr	r0, [r0, #16]
   148f6:	f7ff ffd0 	bl	1489a <gpio_pin_set>
   148fa:	2014      	movs	r0, #20
   148fc:	f7ff fcc8 	bl	14290 <z_impl_k_sleep>
    k_msleep(20);
    gpio_pin_set(led->dev, led->gpio_pin, 0);
   14900:	7a21      	ldrb	r1, [r4, #8]
   14902:	6920      	ldr	r0, [r4, #16]
   14904:	2200      	movs	r2, #0
}
   14906:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    gpio_pin_set(led->dev, led->gpio_pin, 0);
   1490a:	f7ff bfc6 	b.w	1489a <gpio_pin_set>

0001490e <z_impl_uart_irq_tx_enable>:
	if (api->irq_tx_enable) {
   1490e:	6843      	ldr	r3, [r0, #4]
   14910:	69db      	ldr	r3, [r3, #28]
   14912:	b103      	cbz	r3, 14916 <z_impl_uart_irq_tx_enable+0x8>
		api->irq_tx_enable(dev);
   14914:	4718      	bx	r3
}
   14916:	4770      	bx	lr

00014918 <data_cb_local>:
{
   14918:	b508      	push	{r3, lr}
   1491a:	4603      	mov	r3, r0
   1491c:	4608      	mov	r0, r1
    switch (data->type) {
   1491e:	781a      	ldrb	r2, [r3, #0]
   14920:	2a03      	cmp	r2, #3
   14922:	d105      	bne.n	14930 <data_cb_local+0x18>
        memcpy(uuid16, data->data, 2);
   14924:	6859      	ldr	r1, [r3, #4]
   14926:	2202      	movs	r2, #2
   14928:	f001 fb87 	bl	1603a <memcpy>
   1492c:	2000      	movs	r0, #0
}
   1492e:	bd08      	pop	{r3, pc}
        return true;
   14930:	2001      	movs	r0, #1
   14932:	e7fc      	b.n	1492e <data_cb_local+0x16>

00014934 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
   14934:	b570      	push	{r4, r5, r6, lr}
   14936:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   14938:	f990 000b 	ldrsb.w	r0, [r0, #11]
   1493c:	240c      	movs	r4, #12
{
   1493e:	460d      	mov	r5, r1
   14940:	434c      	muls	r4, r1
		p->levels[level].bits : p->levels[level].bits_p;
   14942:	42a8      	cmp	r0, r5
   14944:	eb06 0104 	add.w	r1, r6, r4
   14948:	bfb8      	it	lt
   1494a:	5931      	ldrlt	r1, [r6, r4]

	*word = &bitarray[bn / 32];
   1494c:	2a00      	cmp	r2, #0
   1494e:	4610      	mov	r0, r2
   14950:	bfb8      	it	lt
   14952:	f102 001f 	addlt.w	r0, r2, #31
   14956:	1140      	asrs	r0, r0, #5
   14958:	eb01 0180 	add.w	r1, r1, r0, lsl #2
   1495c:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
   1495e:	f002 001f 	and.w	r0, r2, #31
   14962:	bd70      	pop	{r4, r5, r6, pc}

00014964 <pool_irq_lock.isra.0.part.0>:
   14964:	f04f 0320 	mov.w	r3, #32
   14968:	f3ef 8011 	mrs	r0, BASEPRI
   1496c:	f383 8811 	msr	BASEPRI, r3
   14970:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
   14974:	4770      	bx	lr

00014976 <pool_irq_unlock.isra.0>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   14976:	07c3      	lsls	r3, r0, #31
   14978:	d503      	bpl.n	14982 <pool_irq_unlock.isra.0+0xc>
	__asm__ volatile(
   1497a:	f381 8811 	msr	BASEPRI, r1
   1497e:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
   14982:	4770      	bx	lr

00014984 <z_sys_mem_pool_block_free>:
	return 0;
}

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   14984:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14988:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   1498a:	7a83      	ldrb	r3, [r0, #10]
   1498c:	009b      	lsls	r3, r3, #2
   1498e:	3307      	adds	r3, #7
   14990:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
   14994:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   14996:	ebad 0d03 	sub.w	sp, sp, r3
   1499a:	46e8      	mov	r8, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   1499c:	6843      	ldr	r3, [r0, #4]
   1499e:	f8c8 3000 	str.w	r3, [r8]
{
   149a2:	4605      	mov	r5, r0
   149a4:	460e      	mov	r6, r1
	for (i = 1; i <= level; i++) {
   149a6:	4640      	mov	r0, r8
   149a8:	2101      	movs	r1, #1
   149aa:	42b1      	cmp	r1, r6
   149ac:	d912      	bls.n	149d4 <z_sys_mem_pool_block_free+0x50>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   149ae:	7c2c      	ldrb	r4, [r5, #16]
   149b0:	f014 0401 	ands.w	r4, r4, #1
   149b4:	d002      	beq.n	149bc <z_sys_mem_pool_block_free+0x38>
   149b6:	f7ff ffd5 	bl	14964 <pool_irq_lock.isra.0.part.0>
   149ba:	4604      	mov	r4, r0
	while (level >= 0) {
   149bc:	2e00      	cmp	r6, #0
   149be:	da11      	bge.n	149e4 <z_sys_mem_pool_block_free+0x60>
	return -1;
   149c0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
   149c4:	7c28      	ldrb	r0, [r5, #16]
   149c6:	4621      	mov	r1, r4
   149c8:	f7ff ffd5 	bl	14976 <pool_irq_unlock.isra.0>
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
}
   149cc:	3714      	adds	r7, #20
   149ce:	46bd      	mov	sp, r7
   149d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   149d4:	6803      	ldr	r3, [r0, #0]
   149d6:	089b      	lsrs	r3, r3, #2
   149d8:	f023 0303 	bic.w	r3, r3, #3
   149dc:	f840 3f04 	str.w	r3, [r0, #4]!
	for (i = 1; i <= level; i++) {
   149e0:	3101      	adds	r1, #1
   149e2:	e7e2      	b.n	149aa <z_sys_mem_pool_block_free+0x26>
		int i, lsz = lsizes[level];
   149e4:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
   149e8:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   149ea:	fb03 fa02 	mul.w	sl, r3, r2
	int bit = get_bit_ptr(p, level, bn, &word);
   149ee:	4631      	mov	r1, r6
   149f0:	f107 030c 	add.w	r3, r7, #12
   149f4:	4628      	mov	r0, r5
	return (u8_t *)p->buf + lsz * block;
   149f6:	f8d5 b000 	ldr.w	fp, [r5]
	int bit = get_bit_ptr(p, level, bn, &word);
   149fa:	f7ff ff9b 	bl	14934 <get_bit_ptr>
	*word &= ~(1<<bit);
   149fe:	68f9      	ldr	r1, [r7, #12]
   14a00:	2301      	movs	r3, #1
   14a02:	fa03 f000 	lsl.w	r0, r3, r0
   14a06:	680b      	ldr	r3, [r1, #0]
   14a08:	ea23 0300 	bic.w	r3, r3, r0
   14a0c:	600b      	str	r3, [r1, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   14a0e:	68eb      	ldr	r3, [r5, #12]
   14a10:	210c      	movs	r1, #12
   14a12:	fb01 3306 	mla	r3, r1, r6, r3
	return (u8_t *)p->buf + lsz * block;
   14a16:	eb0b 090a 	add.w	r9, fp, sl
		sys_dlist_append(&p->levels[level].free_list, block);
   14a1a:	1d19      	adds	r1, r3, #4
	node->next = list;
   14a1c:	f84b 100a 	str.w	r1, [fp, sl]
	node->prev = list->tail;
   14a20:	6899      	ldr	r1, [r3, #8]
   14a22:	f8c9 1004 	str.w	r1, [r9, #4]
	list->tail->next = node;
   14a26:	6899      	ldr	r1, [r3, #8]
   14a28:	f8c1 9000 	str.w	r9, [r1]
	list->tail = node;
   14a2c:	f8c3 9008 	str.w	r9, [r3, #8]
		pool_irq_unlock(p, key);
   14a30:	4621      	mov	r1, r4
   14a32:	7c28      	ldrb	r0, [r5, #16]
   14a34:	f7ff ff9f 	bl	14976 <pool_irq_unlock.isra.0>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   14a38:	7c2c      	ldrb	r4, [r5, #16]
   14a3a:	f014 0401 	ands.w	r4, r4, #1
   14a3e:	d002      	beq.n	14a46 <z_sys_mem_pool_block_free+0xc2>
   14a40:	f7ff ff90 	bl	14964 <pool_irq_lock.isra.0.part.0>
   14a44:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   14a46:	2e00      	cmp	r6, #0
   14a48:	d0bc      	beq.n	149c4 <z_sys_mem_pool_block_free+0x40>
	int bit = get_bit_ptr(p, level, bn, &word);
   14a4a:	f107 030c 	add.w	r3, r7, #12
   14a4e:	4631      	mov	r1, r6
   14a50:	4628      	mov	r0, r5
   14a52:	f7ff ff6f 	bl	14934 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   14a56:	68fb      	ldr	r3, [r7, #12]
   14a58:	2800      	cmp	r0, #0
   14a5a:	681b      	ldr	r3, [r3, #0]
   14a5c:	bfb8      	it	lt
   14a5e:	3003      	addlt	r0, #3
   14a60:	f020 0003 	bic.w	r0, r0, #3
   14a64:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   14a68:	f010 030f 	ands.w	r3, r0, #15
   14a6c:	d1aa      	bne.n	149c4 <z_sys_mem_pool_block_free+0x40>
			int b = (bn & ~3) + i;
   14a6e:	f022 0b03 	bic.w	fp, r2, #3
	node->next = NULL;
   14a72:	469e      	mov	lr, r3
	return (u8_t *)p->buf + lsz * block;
   14a74:	6878      	ldr	r0, [r7, #4]
			int b = (bn & ~3) + i;
   14a76:	eb0b 0103 	add.w	r1, fp, r3
	return (u8_t *)p->buf + lsz * block;
   14a7a:	4341      	muls	r1, r0
   14a7c:	6828      	ldr	r0, [r5, #0]
   14a7e:	eb00 0c01 	add.w	ip, r0, r1
	node->prev->next = node->next;
   14a82:	f850 9001 	ldr.w	r9, [r0, r1]
   14a86:	f8dc a004 	ldr.w	sl, [ip, #4]
		for (i = 0; i < 4; i++) {
   14a8a:	3301      	adds	r3, #1
   14a8c:	2b04      	cmp	r3, #4
   14a8e:	f8ca 9000 	str.w	r9, [sl]
	node->next->prev = node->prev;
   14a92:	f8c9 a004 	str.w	sl, [r9, #4]
	node->next = NULL;
   14a96:	f840 e001 	str.w	lr, [r0, r1]
	node->prev = NULL;
   14a9a:	f8cc e004 	str.w	lr, [ip, #4]
   14a9e:	d1e9      	bne.n	14a74 <z_sys_mem_pool_block_free+0xf0>
		bn = bn / 4;
   14aa0:	2a00      	cmp	r2, #0
   14aa2:	bfb8      	it	lt
   14aa4:	3203      	addlt	r2, #3
		level = level - 1;
   14aa6:	3e01      	subs	r6, #1
		bn = bn / 4;
   14aa8:	1092      	asrs	r2, r2, #2
   14aaa:	e787      	b.n	149bc <z_sys_mem_pool_block_free+0x38>

00014aac <sys_mem_pool_free>:
	sys_mutex_unlock(&p->mutex);
	return ret;
}

void sys_mem_pool_free(void *ptr)
{
   14aac:	b570      	push	{r4, r5, r6, lr}
	struct sys_mem_pool_block *blk;
	struct sys_mem_pool *p;

	if (ptr == NULL) {
   14aae:	4604      	mov	r4, r0
   14ab0:	b1b8      	cbz	r0, 14ae2 <sys_mem_pool_free+0x36>
		return;
	}

	ptr = (char *)ptr - WB_UP(sizeof(struct sys_mem_pool_block));
	blk = (struct sys_mem_pool_block *)ptr;
	p = blk->pool;
   14ab2:	f850 6c08 	ldr.w	r6, [r0, #-8]

	sys_mutex_lock(&p->mutex, K_FOREVER);
   14ab6:	f106 0514 	add.w	r5, r6, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   14aba:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   14abe:	4628      	mov	r0, r5
   14ac0:	f7ff f806 	bl	13ad0 <z_impl_k_mutex_lock>
	z_sys_mem_pool_block_free(&p->base, blk->level, blk->block);
   14ac4:	f854 2c04 	ldr.w	r2, [r4, #-4]
   14ac8:	f814 1c04 	ldrb.w	r1, [r4, #-4]
   14acc:	4630      	mov	r0, r6
   14ace:	0912      	lsrs	r2, r2, #4
   14ad0:	f001 010f 	and.w	r1, r1, #15
   14ad4:	f7ff ff56 	bl	14984 <z_sys_mem_pool_block_free>
	sys_mutex_unlock(&p->mutex);
   14ad8:	4628      	mov	r0, r5
}
   14ada:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	sys_mutex_unlock(&p->mutex);
   14ade:	f7ed bcef 	b.w	24c0 <sys_mutex_unlock>
}
   14ae2:	bd70      	pop	{r4, r5, r6, pc}

00014ae4 <arch_printk_char_out>:
}
   14ae4:	2000      	movs	r0, #0
   14ae6:	4770      	bx	lr

00014ae8 <print_err>:
{
   14ae8:	b570      	push	{r4, r5, r6, lr}
   14aea:	4604      	mov	r4, r0
   14aec:	460d      	mov	r5, r1
	out('E', ctx);
   14aee:	2045      	movs	r0, #69	; 0x45
   14af0:	47a0      	blx	r4
	out('R', ctx);
   14af2:	4629      	mov	r1, r5
   14af4:	2052      	movs	r0, #82	; 0x52
   14af6:	47a0      	blx	r4
	out('R', ctx);
   14af8:	4629      	mov	r1, r5
   14afa:	4623      	mov	r3, r4
   14afc:	2052      	movs	r0, #82	; 0x52
}
   14afe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   14b02:	4718      	bx	r3

00014b04 <str_out>:
{
   14b04:	b530      	push	{r4, r5, lr}
   14b06:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   14b08:	680c      	ldr	r4, [r1, #0]
   14b0a:	1c55      	adds	r5, r2, #1
   14b0c:	b114      	cbz	r4, 14b14 <str_out+0x10>
   14b0e:	684b      	ldr	r3, [r1, #4]
   14b10:	4293      	cmp	r3, r2
   14b12:	dc01      	bgt.n	14b18 <str_out+0x14>
		ctx->count++;
   14b14:	608d      	str	r5, [r1, #8]
}
   14b16:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   14b18:	3b01      	subs	r3, #1
   14b1a:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   14b1c:	bf08      	it	eq
   14b1e:	2200      	moveq	r2, #0
   14b20:	608d      	str	r5, [r1, #8]
   14b22:	bf0c      	ite	eq
   14b24:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   14b26:	54a0      	strbne	r0, [r4, r2]
   14b28:	e7f5      	b.n	14b16 <str_out+0x12>

00014b2a <printk>:
{
   14b2a:	b40f      	push	{r0, r1, r2, r3}
   14b2c:	b507      	push	{r0, r1, r2, lr}
   14b2e:	a904      	add	r1, sp, #16
   14b30:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   14b34:	9101      	str	r1, [sp, #4]
		log_printk(fmt, ap);
   14b36:	f000 fbe9 	bl	1530c <log_printk>
}
   14b3a:	b003      	add	sp, #12
   14b3c:	f85d eb04 	ldr.w	lr, [sp], #4
   14b40:	b004      	add	sp, #16
   14b42:	4770      	bx	lr

00014b44 <snprintk>:
{
   14b44:	b40c      	push	{r2, r3}
   14b46:	b507      	push	{r0, r1, r2, lr}
   14b48:	ab04      	add	r3, sp, #16
   14b4a:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   14b4e:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   14b50:	f7ed feb4 	bl	28bc <vsnprintk>
}
   14b54:	b003      	add	sp, #12
   14b56:	f85d eb04 	ldr.w	lr, [sp], #4
   14b5a:	b002      	add	sp, #8
   14b5c:	4770      	bx	lr

00014b5e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   14b5e:	4604      	mov	r4, r0
   14b60:	b508      	push	{r3, lr}
   14b62:	4608      	mov	r0, r1
   14b64:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   14b66:	461a      	mov	r2, r3
   14b68:	47a0      	blx	r4
	return z_impl_k_current_get();
   14b6a:	f7ff fbb9 	bl	142e0 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   14b6e:	f7f1 fb13 	bl	6198 <z_impl_k_thread_abort>

00014b72 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   14b72:	b510      	push	{r4, lr}
   14b74:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   14b76:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   14b7a:	4620      	mov	r0, r4
   14b7c:	f004 f842 	bl	18c04 <z_impl_k_queue_get>
   14b80:	4603      	mov	r3, r0
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   14b82:	2800      	cmp	r0, #0
   14b84:	d0f7      	beq.n	14b76 <z_work_q_main+0x4>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   14b86:	3308      	adds	r3, #8
			continue;
		}

		handler = work->handler;
   14b88:	6842      	ldr	r2, [r0, #4]
   14b8a:	f3bf 8f5b 	dmb	ish
   14b8e:	e853 1f00 	ldrex	r1, [r3]
   14b92:	f021 0c01 	bic.w	ip, r1, #1
   14b96:	e843 ce00 	strex	lr, ip, [r3]
   14b9a:	f1be 0f00 	cmp.w	lr, #0
   14b9e:	d1f6      	bne.n	14b8e <z_work_q_main+0x1c>
   14ba0:	f3bf 8f5b 	dmb	ish

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   14ba4:	07cb      	lsls	r3, r1, #31
   14ba6:	d500      	bpl.n	14baa <z_work_q_main+0x38>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   14ba8:	4790      	blx	r2
	z_impl_k_yield();
   14baa:	f7ff fb23 	bl	141f4 <z_impl_k_yield>
}
   14bae:	e7e2      	b.n	14b76 <z_work_q_main+0x4>

00014bb0 <chunk_field>:
}

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
	void *cmem = &h->buf[c];
   14bb0:	6803      	ldr	r3, [r0, #0]
   14bb2:	eb03 01c1 	add.w	r1, r3, r1, lsl #3

	if (big_heap(h)) {
   14bb6:	6883      	ldr	r3, [r0, #8]
   14bb8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((u32_t *)cmem)[f];
   14bbc:	bf2c      	ite	cs
   14bbe:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((u16_t *)cmem)[f];
   14bc2:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
   14bc6:	4770      	bx	lr

00014bc8 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
   14bc8:	b510      	push	{r4, lr}
	CHECK(c >= h->chunk0 && c < h->len);
	CHECK((val & ~((h->size_mask << 1) + 1)) == 0);
	CHECK((val & h->size_mask) < h->len);

	void *cmem = &h->buf[c];
   14bca:	6804      	ldr	r4, [r0, #0]

	if (big_heap(h)) {
   14bcc:	6880      	ldr	r0, [r0, #8]
	void *cmem = &h->buf[c];
   14bce:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	if (big_heap(h)) {
   14bd2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		((u32_t *)cmem)[f] = (u32_t) val;
   14bd6:	bf2c      	ite	cs
   14bd8:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		((u16_t *)cmem)[f] = (u16_t) val;
   14bdc:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
   14be0:	bd10      	pop	{r4, pc}

00014be2 <right_chunk>:
{
	return c - left_size(h, c);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
   14be2:	b538      	push	{r3, r4, r5, lr}
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14be4:	2200      	movs	r2, #0
{
   14be6:	4605      	mov	r5, r0
   14be8:	460c      	mov	r4, r1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14bea:	f7ff ffe1 	bl	14bb0 <chunk_field>
   14bee:	68eb      	ldr	r3, [r5, #12]
   14bf0:	4018      	ands	r0, r3
	return c + size(h, c);
}
   14bf2:	4420      	add	r0, r4
   14bf4:	bd38      	pop	{r3, r4, r5, pc}

00014bf6 <free_list_remove>:
	return ret;
}

static void free_list_remove(struct z_heap *h, int bidx,
			     chunkid_t c)
{
   14bf6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct z_heap_bucket *b = &h->buckets[bidx];
   14bfa:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
   14bfe:	4616      	mov	r6, r2
	struct z_heap_bucket *b = &h->buckets[bidx];
   14c00:	eb08 02c1 	add.w	r2, r8, r1, lsl #3
{
   14c04:	4604      	mov	r4, r0
	CHECK(b->next != 0);
	CHECK(b->list_size > 0);
	CHECK((((h->avail_buckets & (1 << bidx)) == 0)
	       == (h->buckets[bidx].next == 0)));

	b->list_size--;
   14c06:	6853      	ldr	r3, [r2, #4]
   14c08:	3b01      	subs	r3, #1
{
   14c0a:	460d      	mov	r5, r1
	b->list_size--;
   14c0c:	6053      	str	r3, [r2, #4]

	if (b->list_size == 0) {
   14c0e:	b953      	cbnz	r3, 14c26 <free_list_remove+0x30>
		h->avail_buckets &= ~(1 << bidx);
   14c10:	2201      	movs	r2, #1
   14c12:	fa02 f101 	lsl.w	r1, r2, r1
   14c16:	6942      	ldr	r2, [r0, #20]
   14c18:	ea22 0201 	bic.w	r2, r2, r1
   14c1c:	6142      	str	r2, [r0, #20]
		b->next = 0;
   14c1e:	f848 3035 	str.w	r3, [r8, r5, lsl #3]

		b->next = second;
		chunk_set(h, first, FREE_NEXT, second);
		chunk_set(h, second, FREE_PREV, first);
	}
}
   14c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return chunk_field(h, c, FREE_PREV);
   14c26:	4631      	mov	r1, r6
   14c28:	2202      	movs	r2, #2
   14c2a:	f7ff ffc1 	bl	14bb0 <chunk_field>
	return chunk_field(h, c, FREE_NEXT);
   14c2e:	4631      	mov	r1, r6
	return chunk_field(h, c, FREE_PREV);
   14c30:	4607      	mov	r7, r0
	return chunk_field(h, c, FREE_NEXT);
   14c32:	2203      	movs	r2, #3
   14c34:	4620      	mov	r0, r4
   14c36:	f7ff ffbb 	bl	14bb0 <chunk_field>
		chunk_set(h, first, FREE_NEXT, second);
   14c3a:	4639      	mov	r1, r7
		b->next = second;
   14c3c:	f848 0035 	str.w	r0, [r8, r5, lsl #3]
   14c40:	4606      	mov	r6, r0
		chunk_set(h, first, FREE_NEXT, second);
   14c42:	4603      	mov	r3, r0
   14c44:	2203      	movs	r2, #3
   14c46:	4620      	mov	r0, r4
   14c48:	f7ff ffbe 	bl	14bc8 <chunk_set>
		chunk_set(h, second, FREE_PREV, first);
   14c4c:	463b      	mov	r3, r7
   14c4e:	4631      	mov	r1, r6
   14c50:	4620      	mov	r0, r4
   14c52:	2202      	movs	r2, #2
}
   14c54:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, first);
   14c58:	f7ff bfb6 	b.w	14bc8 <chunk_set>

00014c5c <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   14c5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14c60:	2200      	movs	r2, #0
   14c62:	4604      	mov	r4, r0
   14c64:	460d      	mov	r5, r1
   14c66:	f7ff ffa3 	bl	14bb0 <chunk_field>
   14c6a:	68e2      	ldr	r2, [r4, #12]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14c6c:	68a3      	ldr	r3, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14c6e:	4010      	ands	r0, r2
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14c70:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
}

static int bucket_idx(struct z_heap *h, size_t sz)
{
	/* A chunk of size 2 is the minimum size on big heaps */
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   14c74:	fab0 f280 	clz	r2, r0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14c78:	bf34      	ite	cc
   14c7a:	2000      	movcc	r0, #0
   14c7c:	2001      	movcs	r0, #1
	int b = bucket_idx(h, size(h, c));

	if (h->buckets[b].list_size++ == 0) {
   14c7e:	6863      	ldr	r3, [r4, #4]
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   14c80:	f1c0 001f 	rsb	r0, r0, #31
   14c84:	1a80      	subs	r0, r0, r2
   14c86:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
   14c8a:	684a      	ldr	r2, [r1, #4]
   14c8c:	1c56      	adds	r6, r2, #1
   14c8e:	604e      	str	r6, [r1, #4]
   14c90:	b9a2      	cbnz	r2, 14cbc <free_list_add+0x60>
		CHECK(h->buckets[b].next == 0);
		CHECK((h->avail_buckets & (1 << b)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << b);
   14c92:	2201      	movs	r2, #1
   14c94:	fa02 f100 	lsl.w	r1, r2, r0
   14c98:	6962      	ldr	r2, [r4, #20]
   14c9a:	430a      	orrs	r2, r1
   14c9c:	6162      	str	r2, [r4, #20]
		h->buckets[b].next = c;
		chunk_set(h, c, FREE_PREV, c);
   14c9e:	4629      	mov	r1, r5
		h->buckets[b].next = c;
   14ca0:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
		chunk_set(h, c, FREE_PREV, c);
   14ca4:	2202      	movs	r2, #2
   14ca6:	462b      	mov	r3, r5
   14ca8:	4620      	mov	r0, r4
   14caa:	f7ff ff8d 	bl	14bc8 <chunk_set>
		chunk_set(h, c, FREE_NEXT, c);
   14cae:	2203      	movs	r2, #3
   14cb0:	4629      	mov	r1, r5
		chunkid_t first = free_prev(h, second);

		chunk_set(h, c, FREE_PREV, first);
		chunk_set(h, c, FREE_NEXT, second);
		chunk_set(h, first, FREE_NEXT, c);
		chunk_set(h, second, FREE_PREV, c);
   14cb2:	4620      	mov	r0, r4
	}

	CHECK(h->avail_buckets & (1 << bucket_idx(h, size(h, c))));
}
   14cb4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, c);
   14cb8:	f7ff bf86 	b.w	14bc8 <chunk_set>
		chunkid_t second = h->buckets[b].next;
   14cbc:	f853 7030 	ldr.w	r7, [r3, r0, lsl #3]
	return chunk_field(h, c, FREE_PREV);
   14cc0:	2202      	movs	r2, #2
   14cc2:	4639      	mov	r1, r7
   14cc4:	4620      	mov	r0, r4
   14cc6:	f7ff ff73 	bl	14bb0 <chunk_field>
		chunk_set(h, c, FREE_PREV, first);
   14cca:	2202      	movs	r2, #2
   14ccc:	4603      	mov	r3, r0
   14cce:	4606      	mov	r6, r0
   14cd0:	4629      	mov	r1, r5
   14cd2:	4620      	mov	r0, r4
   14cd4:	f7ff ff78 	bl	14bc8 <chunk_set>
		chunk_set(h, c, FREE_NEXT, second);
   14cd8:	463b      	mov	r3, r7
   14cda:	2203      	movs	r2, #3
   14cdc:	4629      	mov	r1, r5
   14cde:	4620      	mov	r0, r4
   14ce0:	f7ff ff72 	bl	14bc8 <chunk_set>
		chunk_set(h, first, FREE_NEXT, c);
   14ce4:	2203      	movs	r2, #3
   14ce6:	4631      	mov	r1, r6
   14ce8:	462b      	mov	r3, r5
   14cea:	4620      	mov	r0, r4
   14cec:	f7ff ff6c 	bl	14bc8 <chunk_set>
		chunk_set(h, second, FREE_PREV, c);
   14cf0:	2202      	movs	r2, #2
   14cf2:	4639      	mov	r1, r7
   14cf4:	e7dd      	b.n	14cb2 <free_list_add+0x56>

00014cf6 <split_alloc>:

/* Allocates (fit check has already been perfomred) from the next
 * chunk at the specified bucket level
 */
static void *split_alloc(struct z_heap *h, int bidx, size_t sz)
{
   14cf6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	CHECK(h->buckets[bidx].next != 0
	      && sz <= size(h, h->buckets[bidx].next));

	chunkid_t c = h->buckets[bidx].next;
   14cfa:	6843      	ldr	r3, [r0, #4]
   14cfc:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]
{
   14d00:	4604      	mov	r4, r0
   14d02:	4617      	mov	r7, r2

	free_list_remove(h, bidx, c);
   14d04:	462a      	mov	r2, r5
   14d06:	f7ff ff76 	bl	14bf6 <free_list_remove>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14d0a:	2200      	movs	r2, #0
   14d0c:	4629      	mov	r1, r5
   14d0e:	4620      	mov	r0, r4
   14d10:	f7ff ff4e 	bl	14bb0 <chunk_field>
	/* Split off remainder if it's usefully large */
	size_t rem = size(h, c) - sz;

	CHECK(rem < h->len);

	if (rem >= (big_heap(h) ? 2 : 1)) {
   14d14:	68a3      	ldr	r3, [r4, #8]
   14d16:	68e6      	ldr	r6, [r4, #12]
   14d18:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   14d1c:	ea06 0600 	and.w	r6, r6, r0
	size_t rem = size(h, c) - sz;
   14d20:	eba6 0607 	sub.w	r6, r6, r7
	if (rem >= (big_heap(h) ? 2 : 1)) {
   14d24:	bf2c      	ite	cs
   14d26:	2302      	movcs	r3, #2
   14d28:	2301      	movcc	r3, #1
   14d2a:	42b3      	cmp	r3, r6
   14d2c:	d82d      	bhi.n	14d8a <split_alloc+0x94>
		chunkid_t c2 = c + sz;
		chunkid_t c3 = right_chunk(h, c);
   14d2e:	4629      	mov	r1, r5
   14d30:	4620      	mov	r0, r4
   14d32:	f7ff ff56 	bl	14be2 <right_chunk>
		chunkid_t c2 = c + sz;
   14d36:	eb05 0807 	add.w	r8, r5, r7

		chunk_set(h, c, SIZE_AND_USED, sz);
   14d3a:	463b      	mov	r3, r7
   14d3c:	2200      	movs	r2, #0
   14d3e:	4629      	mov	r1, r5
		chunkid_t c3 = right_chunk(h, c);
   14d40:	4681      	mov	r9, r0
		chunk_set(h, c, SIZE_AND_USED, sz);
   14d42:	4620      	mov	r0, r4
   14d44:	f7ff ff40 	bl	14bc8 <chunk_set>
		chunk_set(h, c2, SIZE_AND_USED, rem);
   14d48:	4633      	mov	r3, r6
   14d4a:	2200      	movs	r2, #0
   14d4c:	4641      	mov	r1, r8
   14d4e:	4620      	mov	r0, r4
   14d50:	f7ff ff3a 	bl	14bc8 <chunk_set>
		chunk_set(h, c2, LEFT_SIZE, sz);
   14d54:	463b      	mov	r3, r7
   14d56:	2201      	movs	r2, #1
   14d58:	4641      	mov	r1, r8
   14d5a:	4620      	mov	r0, r4
   14d5c:	f7ff ff34 	bl	14bc8 <chunk_set>
   14d60:	2200      	movs	r2, #0
   14d62:	4641      	mov	r1, r8
   14d64:	4620      	mov	r0, r4
   14d66:	f7ff ff23 	bl	14bb0 <chunk_field>
   14d6a:	68e3      	ldr	r3, [r4, #12]
		if (!last_chunk(h, c2)) {
   14d6c:	68a2      	ldr	r2, [r4, #8]
   14d6e:	4003      	ands	r3, r0
	return (c + size(h, c)) == h->len;
   14d70:	4443      	add	r3, r8
		if (!last_chunk(h, c2)) {
   14d72:	4293      	cmp	r3, r2
   14d74:	d005      	beq.n	14d82 <split_alloc+0x8c>
			chunk_set(h, c3, LEFT_SIZE, rem);
   14d76:	4633      	mov	r3, r6
   14d78:	2201      	movs	r2, #1
   14d7a:	4649      	mov	r1, r9
   14d7c:	4620      	mov	r0, r4
   14d7e:	f7ff ff23 	bl	14bc8 <chunk_set>
		}
		free_list_add(h, c2);
   14d82:	4641      	mov	r1, r8
   14d84:	4620      	mov	r0, r4
   14d86:	f7ff ff69 	bl	14c5c <free_list_add>
   14d8a:	4629      	mov	r1, r5
   14d8c:	2200      	movs	r2, #0
   14d8e:	4620      	mov	r0, r4
   14d90:	f7ff ff0e 	bl	14bb0 <chunk_field>
   14d94:	68e2      	ldr	r2, [r4, #12]
   14d96:	ea00 0302 	and.w	r3, r0, r2
		  size(h, c) | (used ? (h->size_mask + 1) : 0));
   14d9a:	3201      	adds	r2, #1
	chunk_set(h, c, SIZE_AND_USED,
   14d9c:	4313      	orrs	r3, r2
   14d9e:	4629      	mov	r1, r5
   14da0:	4620      	mov	r0, r4
   14da2:	2200      	movs	r2, #0
   14da4:	f7ff ff10 	bl	14bc8 <chunk_set>
	return big_heap(h) ? 8 : 4;
   14da8:	68a3      	ldr	r3, [r4, #8]
	u8_t *ret = ((u8_t *)&h->buf[c]) + chunk_header_bytes(h);
   14daa:	6820      	ldr	r0, [r4, #0]
   14dac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   14db0:	bf2c      	ite	cs
   14db2:	2308      	movcs	r3, #8
   14db4:	2304      	movcc	r3, #4
   14db6:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	}

	chunk_set_used(h, c, true);

	return chunk_mem(h, c);
}
   14dba:	4428      	add	r0, r5
   14dbc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00014dc0 <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
   14dc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (mem == NULL) {
   14dc4:	2900      	cmp	r1, #0
   14dc6:	f000 80ac 	beq.w	14f22 <sys_heap_free+0x162>
		return; /* ISO C free() semantics */
	}

	struct z_heap *h = heap->heap;
   14dca:	6804      	ldr	r4, [r0, #0]
   14dcc:	68a7      	ldr	r7, [r4, #8]
   14dce:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
   14dd2:	bf2c      	ite	cs
   14dd4:	2508      	movcs	r5, #8
   14dd6:	2504      	movcc	r5, #4
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
   14dd8:	1b4d      	subs	r5, r1, r5
		       - (u8_t *)h->buf) / CHUNK_UNIT;
   14dda:	6821      	ldr	r1, [r4, #0]
   14ddc:	1a6d      	subs	r5, r5, r1
   14dde:	bf48      	it	mi
   14de0:	3507      	addmi	r5, #7
   14de2:	10ed      	asrs	r5, r5, #3
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14de4:	2200      	movs	r2, #0
   14de6:	4629      	mov	r1, r5
   14de8:	4620      	mov	r0, r4
   14dea:	f7ff fee1 	bl	14bb0 <chunk_field>
   14dee:	68e6      	ldr	r6, [r4, #12]
   14df0:	ea06 0800 	and.w	r8, r6, r0
	return (c + size(h, c)) == h->len;
   14df4:	eb05 0308 	add.w	r3, r5, r8

	/* Merge with right chunk?  We can just absorb it. */
	if (!last_chunk(h, c) && !used(h, right_chunk(h, c))) {
   14df8:	42bb      	cmp	r3, r7
   14dfa:	d036      	beq.n	14e6a <sys_heap_free+0xaa>
   14dfc:	4629      	mov	r1, r5
   14dfe:	4620      	mov	r0, r4
   14e00:	f7ff feef 	bl	14be2 <right_chunk>
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
   14e04:	2200      	movs	r2, #0
   14e06:	4601      	mov	r1, r0
   14e08:	4682      	mov	sl, r0
   14e0a:	4620      	mov	r0, r4
   14e0c:	f7ff fed0 	bl	14bb0 <chunk_field>
   14e10:	ea30 0906 	bics.w	r9, r0, r6
   14e14:	d129      	bne.n	14e6a <sys_heap_free+0xaa>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14e16:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
   14e1a:	bf34      	ite	cc
   14e1c:	2700      	movcc	r7, #0
   14e1e:	2701      	movcs	r7, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14e20:	4006      	ands	r6, r0
		chunkid_t rc = right_chunk(h, c);
		size_t newsz = size(h, c) + size(h, rc);
   14e22:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   14e24:	f1c7 071f 	rsb	r7, r7, #31
   14e28:	fab6 f686 	clz	r6, r6

		free_list_remove(h, bucket_idx(h, size(h, rc)), rc);
   14e2c:	4652      	mov	r2, sl
   14e2e:	1bb9      	subs	r1, r7, r6
   14e30:	4620      	mov	r0, r4
   14e32:	f7ff fee0 	bl	14bf6 <free_list_remove>
		chunk_set(h, c, SIZE_AND_USED, newsz);
   14e36:	4643      	mov	r3, r8
   14e38:	464a      	mov	r2, r9
   14e3a:	4629      	mov	r1, r5
   14e3c:	4620      	mov	r0, r4
   14e3e:	f7ff fec3 	bl	14bc8 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14e42:	4629      	mov	r1, r5
   14e44:	4620      	mov	r0, r4
   14e46:	f7ff feb3 	bl	14bb0 <chunk_field>
   14e4a:	68e3      	ldr	r3, [r4, #12]
   14e4c:	4018      	ands	r0, r3
		if (!last_chunk(h, c)) {
   14e4e:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
   14e50:	4428      	add	r0, r5
		if (!last_chunk(h, c)) {
   14e52:	4283      	cmp	r3, r0
   14e54:	d009      	beq.n	14e6a <sys_heap_free+0xaa>
			chunk_set(h, right_chunk(h, c), LEFT_SIZE, newsz);
   14e56:	4629      	mov	r1, r5
   14e58:	4620      	mov	r0, r4
   14e5a:	f7ff fec2 	bl	14be2 <right_chunk>
   14e5e:	4643      	mov	r3, r8
   14e60:	4601      	mov	r1, r0
   14e62:	2201      	movs	r2, #1
   14e64:	4620      	mov	r0, r4
   14e66:	f7ff feaf 	bl	14bc8 <chunk_set>
		}
	}

	/* Merge with left chunk?  It absorbs us. */
	if (c != h->chunk0 && !used(h, left_chunk(h, c))) {
   14e6a:	6923      	ldr	r3, [r4, #16]
   14e6c:	42ab      	cmp	r3, r5
   14e6e:	d046      	beq.n	14efe <sys_heap_free+0x13e>
	return chunk_field(h, c, LEFT_SIZE);
   14e70:	2201      	movs	r2, #1
   14e72:	4629      	mov	r1, r5
   14e74:	4620      	mov	r0, r4
   14e76:	f7ff fe9b 	bl	14bb0 <chunk_field>
	return c - left_size(h, c);
   14e7a:	1a2f      	subs	r7, r5, r0
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
   14e7c:	2200      	movs	r2, #0
   14e7e:	4639      	mov	r1, r7
   14e80:	4620      	mov	r0, r4
   14e82:	f7ff fe95 	bl	14bb0 <chunk_field>
   14e86:	f8d4 800c 	ldr.w	r8, [r4, #12]
   14e8a:	ea30 0908 	bics.w	r9, r0, r8
   14e8e:	4606      	mov	r6, r0
   14e90:	d135      	bne.n	14efe <sys_heap_free+0x13e>
   14e92:	464a      	mov	r2, r9
   14e94:	4629      	mov	r1, r5
   14e96:	4620      	mov	r0, r4
   14e98:	f7ff fe8a 	bl	14bb0 <chunk_field>
		chunkid_t lc = left_chunk(h, c);
		chunkid_t rc = right_chunk(h, c);
   14e9c:	4629      	mov	r1, r5
   14e9e:	4682      	mov	sl, r0
   14ea0:	4620      	mov	r0, r4
   14ea2:	f7ff fe9e 	bl	14be2 <right_chunk>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14ea6:	68a1      	ldr	r1, [r4, #8]
   14ea8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   14eac:	bf34      	ite	cc
   14eae:	2100      	movcc	r1, #0
   14eb0:	2101      	movcs	r1, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14eb2:	ea06 0608 	and.w	r6, r6, r8
   14eb6:	ea08 080a 	and.w	r8, r8, sl
		size_t csz = size(h, c);
		size_t merged_sz = csz + size(h, lc);
   14eba:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   14ebc:	f1c1 011f 	rsb	r1, r1, #31
   14ec0:	fab6 f686 	clz	r6, r6

		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
   14ec4:	463a      	mov	r2, r7
   14ec6:	1b89      	subs	r1, r1, r6
		chunkid_t rc = right_chunk(h, c);
   14ec8:	4605      	mov	r5, r0
		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
   14eca:	4620      	mov	r0, r4
   14ecc:	f7ff fe93 	bl	14bf6 <free_list_remove>
		chunk_set(h, lc, SIZE_AND_USED, merged_sz);
   14ed0:	4643      	mov	r3, r8
   14ed2:	464a      	mov	r2, r9
   14ed4:	4639      	mov	r1, r7
   14ed6:	4620      	mov	r0, r4
   14ed8:	f7ff fe76 	bl	14bc8 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14edc:	4639      	mov	r1, r7
   14ede:	4620      	mov	r0, r4
   14ee0:	f7ff fe66 	bl	14bb0 <chunk_field>
   14ee4:	68e3      	ldr	r3, [r4, #12]
   14ee6:	4018      	ands	r0, r3
		if (!last_chunk(h, lc)) {
   14ee8:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
   14eea:	4438      	add	r0, r7
		if (!last_chunk(h, lc)) {
   14eec:	4298      	cmp	r0, r3
   14eee:	d005      	beq.n	14efc <sys_heap_free+0x13c>
			chunk_set(h, rc, LEFT_SIZE, merged_sz);
   14ef0:	4643      	mov	r3, r8
   14ef2:	2201      	movs	r2, #1
   14ef4:	4629      	mov	r1, r5
   14ef6:	4620      	mov	r0, r4
   14ef8:	f7ff fe66 	bl	14bc8 <chunk_set>
		}

		c = lc;
   14efc:	463d      	mov	r5, r7
   14efe:	4629      	mov	r1, r5
   14f00:	2200      	movs	r2, #0
   14f02:	4620      	mov	r0, r4
   14f04:	f7ff fe54 	bl	14bb0 <chunk_field>
   14f08:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
   14f0a:	4629      	mov	r1, r5
   14f0c:	4003      	ands	r3, r0
   14f0e:	2200      	movs	r2, #0
   14f10:	4620      	mov	r0, r4
   14f12:	f7ff fe59 	bl	14bc8 <chunk_set>
	}

	chunk_set_used(h, c, false);
	free_list_add(h, c);
   14f16:	4629      	mov	r1, r5
   14f18:	4620      	mov	r0, r4
}
   14f1a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	free_list_add(h, c);
   14f1e:	f7ff be9d 	b.w	14c5c <free_list_add>
}
   14f22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00014f26 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   14f26:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct z_heap *h = heap->heap;
   14f2a:	6804      	ldr	r4, [r0, #0]
	return big_heap(h) ? 8 : 4;
   14f2c:	68a2      	ldr	r2, [r4, #8]
   14f2e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   14f32:	bf2c      	ite	cs
   14f34:	2308      	movcs	r3, #8
   14f36:	2304      	movcc	r3, #4
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   14f38:	1dcd      	adds	r5, r1, #7
   14f3a:	441d      	add	r5, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14f3c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   14f40:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   14f44:	fab5 f685 	clz	r6, r5
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14f48:	bf34      	ite	cc
   14f4a:	2300      	movcc	r3, #0
   14f4c:	2301      	movcs	r3, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   14f4e:	441e      	add	r6, r3
   14f50:	f1c6 081f 	rsb	r8, r6, #31
	size_t sz = bytes_to_chunksz(h, bytes);
	int bi = bucket_idx(h, sz);
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bytes == 0 || bi > bucket_idx(h, h->len)) {
   14f54:	2900      	cmp	r1, #0
   14f56:	d03b      	beq.n	14fd0 <sys_heap_alloc+0xaa>
   14f58:	fab2 f282 	clz	r2, r2
   14f5c:	f1c3 031f 	rsb	r3, r3, #31
   14f60:	1a9b      	subs	r3, r3, r2
   14f62:	4598      	cmp	r8, r3
   14f64:	dc34      	bgt.n	14fd0 <sys_heap_alloc+0xaa>
	struct z_heap_bucket *b = &h->buckets[bi];
   14f66:	6867      	ldr	r7, [r4, #4]
   14f68:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);

	for (int i = 0; i < loops; i++) {
   14f6c:	f04f 0a00 	mov.w	sl, #0
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);
   14f70:	687b      	ldr	r3, [r7, #4]
   14f72:	2b03      	cmp	r3, #3
   14f74:	bf28      	it	cs
   14f76:	2303      	movcs	r3, #3
   14f78:	4699      	mov	r9, r3
	for (int i = 0; i < loops; i++) {
   14f7a:	45ca      	cmp	sl, r9
   14f7c:	db0d      	blt.n	14f9a <sys_heap_alloc+0x74>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
   14f7e:	6963      	ldr	r3, [r4, #20]
   14f80:	f1c6 0620 	rsb	r6, r6, #32
   14f84:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   14f88:	40b1      	lsls	r1, r6

	if ((bmask & h->avail_buckets) != 0) {
   14f8a:	4019      	ands	r1, r3
   14f8c:	d020      	beq.n	14fd0 <sys_heap_alloc+0xaa>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);

		return split_alloc(h, minbucket, sz);
   14f8e:	fa91 f1a1 	rbit	r1, r1
   14f92:	462a      	mov	r2, r5
   14f94:	fab1 f181 	clz	r1, r1
   14f98:	e00c      	b.n	14fb4 <sys_heap_alloc+0x8e>
		if (size(h, b->next) >= sz) {
   14f9a:	f8d7 b000 	ldr.w	fp, [r7]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   14f9e:	2200      	movs	r2, #0
   14fa0:	4659      	mov	r1, fp
   14fa2:	4620      	mov	r0, r4
   14fa4:	f7ff fe04 	bl	14bb0 <chunk_field>
   14fa8:	68e3      	ldr	r3, [r4, #12]
   14faa:	4018      	ands	r0, r3
   14fac:	42a8      	cmp	r0, r5
   14fae:	d306      	bcc.n	14fbe <sys_heap_alloc+0x98>
			return split_alloc(h, bi, sz);
   14fb0:	462a      	mov	r2, r5
   14fb2:	4641      	mov	r1, r8
		return split_alloc(h, minbucket, sz);
   14fb4:	4620      	mov	r0, r4
	}

	return NULL;
}
   14fb6:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return split_alloc(h, minbucket, sz);
   14fba:	f7ff be9c 	b.w	14cf6 <split_alloc>
	return chunk_field(h, c, FREE_NEXT);
   14fbe:	2203      	movs	r2, #3
   14fc0:	4659      	mov	r1, fp
   14fc2:	4620      	mov	r0, r4
   14fc4:	f7ff fdf4 	bl	14bb0 <chunk_field>
	for (int i = 0; i < loops; i++) {
   14fc8:	f10a 0a01 	add.w	sl, sl, #1
		b->next = free_next(h, b->next);
   14fcc:	6038      	str	r0, [r7, #0]
	for (int i = 0; i < loops; i++) {
   14fce:	e7d4      	b.n	14f7a <sys_heap_alloc+0x54>
}
   14fd0:	2000      	movs	r0, #0
   14fd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00014fd6 <sys_heap_init>:

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   14fd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	CHECK(bytes < 0x800000000ULL);
#endif

	/* Round the start up, the end down */
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
   14fd8:	188b      	adds	r3, r1, r2
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
   14fda:	1dcc      	adds	r4, r1, #7
   14fdc:	f024 0407 	bic.w	r4, r4, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
   14fe0:	f023 0307 	bic.w	r3, r3, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
   14fe4:	1b1b      	subs	r3, r3, r4
   14fe6:	08db      	lsrs	r3, r3, #3

	heap->heap = (struct z_heap *)addr;
	h->buf = (u64_t *)addr;
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
	h->len = buf_sz;
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   14fe8:	f647 72ff 	movw	r2, #32767	; 0x7fff
   14fec:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   14ff0:	bf2c      	ite	cs
   14ff2:	f06f 4100 	mvncs.w	r1, #2147483648	; 0x80000000
   14ff6:	4611      	movcc	r1, r2
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   14ff8:	4293      	cmp	r3, r2
	heap->heap = (struct z_heap *)addr;
   14ffa:	6004      	str	r4, [r0, #0]
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   14ffc:	60e1      	str	r1, [r4, #12]
   14ffe:	bf94      	ite	ls
   15000:	2100      	movls	r1, #0
   15002:	2101      	movhi	r1, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   15004:	fab3 f683 	clz	r6, r3
	h->avail_buckets = 0;

	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
   15008:	f1c1 0120 	rsb	r1, r1, #32
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
   1500c:	f104 0518 	add.w	r5, r4, #24
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
   15010:	1b89      	subs	r1, r1, r6
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   15012:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
	h->len = buf_sz;
   15016:	e9c4 5301 	strd	r5, r3, [r4, #4]
	h->avail_buckets = 0;
   1501a:	2000      	movs	r0, #0
				* sizeof(struct z_heap_bucket));

	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
   1501c:	3103      	adds	r1, #3
	h->buf = (u64_t *)addr;
   1501e:	6024      	str	r4, [r4, #0]
	h->avail_buckets = 0;
   15020:	6160      	str	r0, [r4, #20]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
   15022:	6121      	str	r1, [r4, #16]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   15024:	4617      	mov	r7, r2

	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
		heap->heap->buckets[i].list_size = 0;
   15026:	4684      	mov	ip, r0
   15028:	68a2      	ldr	r2, [r4, #8]
   1502a:	42ba      	cmp	r2, r7
   1502c:	bf94      	ite	ls
   1502e:	2200      	movls	r2, #0
   15030:	2201      	movhi	r2, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   15032:	f1c2 021f 	rsb	r2, r2, #31
   15036:	1b92      	subs	r2, r2, r6
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   15038:	4290      	cmp	r0, r2
   1503a:	dd0a      	ble.n	15052 <sys_heap_init+0x7c>
		heap->heap->buckets[i].next = 0;
	}

	chunk_set(h, h->chunk0, SIZE_AND_USED, buf_sz - h->chunk0);
   1503c:	1a5b      	subs	r3, r3, r1
   1503e:	4620      	mov	r0, r4
   15040:	2200      	movs	r2, #0
   15042:	f7ff fdc1 	bl	14bc8 <chunk_set>
	free_list_add(h, h->chunk0);
   15046:	6921      	ldr	r1, [r4, #16]
   15048:	4620      	mov	r0, r4
}
   1504a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, h->chunk0);
   1504e:	f7ff be05 	b.w	14c5c <free_list_add>
		heap->heap->buckets[i].list_size = 0;
   15052:	f8c5 c004 	str.w	ip, [r5, #4]
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   15056:	3001      	adds	r0, #1
		heap->heap->buckets[i].next = 0;
   15058:	f845 cb08 	str.w	ip, [r5], #8
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   1505c:	e7e4      	b.n	15028 <sys_heap_init+0x52>

0001505e <ring_buf_space_get>:
 *
 * @return Ring buffer free space (in 32-bit words or bytes).
 */
static inline u32_t ring_buf_space_get(struct ring_buf *buf)
{
	return z_ring_buf_custom_space_get(buf->size, buf->head, buf->tail);
   1505e:	6903      	ldr	r3, [r0, #16]
   15060:	e9d0 2000 	ldrd	r2, r0, [r0]
	if (tail < head) {
   15064:	4282      	cmp	r2, r0
	return (size - tail) + head - 1;
   15066:	bf96      	itet	ls
   15068:	189b      	addls	r3, r3, r2
		return head - tail - 1;
   1506a:	f102 33ff 	addhi.w	r3, r2, #4294967295	; 0xffffffff
	return (size - tail) + head - 1;
   1506e:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
   15072:	1a18      	subs	r0, r3, r0
}
   15074:	4770      	bx	lr

00015076 <ring_buf_put_claim>:

u32_t ring_buf_put_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
	u32_t space, trail_size, allocated;

	space = z_ring_buf_custom_space_get(buf->size, buf->head,
   15076:	6803      	ldr	r3, [r0, #0]
{
   15078:	b570      	push	{r4, r5, r6, lr}
	space = z_ring_buf_custom_space_get(buf->size, buf->head,
   1507a:	6884      	ldr	r4, [r0, #8]
   1507c:	6906      	ldr	r6, [r0, #16]
	if (tail < head) {
   1507e:	42a3      	cmp	r3, r4
{
   15080:	4605      	mov	r5, r0
	return (size - tail) + head - 1;
   15082:	bf98      	it	ls
   15084:	199b      	addls	r3, r3, r6
					    buf->misc.byte_mode.tmp_tail);

	/* Limit requested size to available size. */
	size = MIN(size, space);
	trail_size = buf->size - buf->misc.byte_mode.tmp_tail;
   15086:	1b30      	subs	r0, r6, r4

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
   15088:	4290      	cmp	r0, r2
   1508a:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   1508e:	eba3 0304 	sub.w	r3, r3, r4
   15092:	bf28      	it	cs
   15094:	4610      	movcs	r0, r2
   15096:	4298      	cmp	r0, r3
   15098:	bf28      	it	cs
   1509a:	4618      	movcs	r0, r3

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
   1509c:	696b      	ldr	r3, [r5, #20]
   1509e:	4423      	add	r3, r4
	buf->misc.byte_mode.tmp_tail =
		wrap(buf->misc.byte_mode.tmp_tail + allocated, buf->size);
   150a0:	4404      	add	r4, r0
	return val >= max ? (val - max) : val;
   150a2:	42a6      	cmp	r6, r4
   150a4:	bf98      	it	ls
   150a6:	1ba4      	subls	r4, r4, r6
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
   150a8:	600b      	str	r3, [r1, #0]
	buf->misc.byte_mode.tmp_tail =
   150aa:	60ac      	str	r4, [r5, #8]

	return allocated;
}
   150ac:	bd70      	pop	{r4, r5, r6, pc}

000150ae <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, u32_t size)
{
   150ae:	b510      	push	{r4, lr}
   150b0:	4604      	mov	r4, r0
	if (size > ring_buf_space_get(buf)) {
   150b2:	f7ff ffd4 	bl	1505e <ring_buf_space_get>
   150b6:	4288      	cmp	r0, r1
   150b8:	d309      	bcc.n	150ce <ring_buf_put_finish+0x20>
		return -EINVAL;
	}

	buf->tail = wrap(buf->tail + size, buf->size);
   150ba:	6863      	ldr	r3, [r4, #4]
   150bc:	4419      	add	r1, r3
   150be:	6923      	ldr	r3, [r4, #16]
	return val >= max ? (val - max) : val;
   150c0:	4299      	cmp	r1, r3
   150c2:	bf28      	it	cs
   150c4:	1ac9      	subcs	r1, r1, r3
	buf->misc.byte_mode.tmp_tail = buf->tail;
   150c6:	e9c4 1101 	strd	r1, r1, [r4, #4]

	return 0;
   150ca:	2000      	movs	r0, #0
}
   150cc:	bd10      	pop	{r4, pc}
		return -EINVAL;
   150ce:	f06f 0015 	mvn.w	r0, #21
   150d2:	e7fb      	b.n	150cc <ring_buf_put_finish+0x1e>

000150d4 <ring_buf_put>:

u32_t ring_buf_put(struct ring_buf *buf, const u8_t *data, u32_t size)
{
   150d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   150d8:	4680      	mov	r8, r0
   150da:	460e      	mov	r6, r1
   150dc:	4615      	mov	r5, r2
	u8_t *dst;
	u32_t partial_size;
	u32_t total_size = 0U;
   150de:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
   150e0:	462a      	mov	r2, r5
   150e2:	a901      	add	r1, sp, #4
   150e4:	4640      	mov	r0, r8
   150e6:	f7ff ffc6 	bl	15076 <ring_buf_put_claim>
		memcpy(dst, data, partial_size);
   150ea:	4631      	mov	r1, r6
		partial_size = ring_buf_put_claim(buf, &dst, size);
   150ec:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
   150ee:	4602      	mov	r2, r0
   150f0:	9801      	ldr	r0, [sp, #4]
   150f2:	f000 ffa2 	bl	1603a <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   150f6:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
   150f8:	4427      	add	r7, r4
		data += partial_size;
   150fa:	4426      	add	r6, r4
	} while (size && partial_size);
   150fc:	d001      	beq.n	15102 <ring_buf_put+0x2e>
   150fe:	2c00      	cmp	r4, #0
   15100:	d1ee      	bne.n	150e0 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
   15102:	4639      	mov	r1, r7
   15104:	4640      	mov	r0, r8
   15106:	f7ff ffd2 	bl	150ae <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
   1510a:	4638      	mov	r0, r7
   1510c:	b002      	add	sp, #8
   1510e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00015112 <ring_buf_get_claim>:

u32_t ring_buf_get_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
   15112:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t space, granted_size, trail_size;

	space = (buf->size - 1) -
		z_ring_buf_custom_space_get(buf->size,
   15114:	e9d0 3603 	ldrd	r3, r6, [r0, #12]
   15118:	6845      	ldr	r5, [r0, #4]
	if (tail < head) {
   1511a:	42ab      	cmp	r3, r5
{
   1511c:	4604      	mov	r4, r0
	return (size - tail) + head - 1;
   1511e:	bf94      	ite	ls
   15120:	18f0      	addls	r0, r6, r3
		return head - tail - 1;
   15122:	f103 30ff 	addhi.w	r0, r3, #4294967295	; 0xffffffff
   15126:	4617      	mov	r7, r2
	return (size - tail) + head - 1;
   15128:	bf98      	it	ls
   1512a:	f100 30ff 	addls.w	r0, r0, #4294967295	; 0xffffffff
					    buf->misc.byte_mode.tmp_head,
					    buf->tail);
	trail_size = buf->size - buf->misc.byte_mode.tmp_head;
   1512e:	1af2      	subs	r2, r6, r3

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
   15130:	42ba      	cmp	r2, r7
   15132:	eba0 0505 	sub.w	r5, r0, r5
	space = (buf->size - 1) -
   15136:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
   1513a:	eba0 0005 	sub.w	r0, r0, r5
	granted_size = MIN(trail_size, granted_size);
   1513e:	bf28      	it	cs
   15140:	463a      	movcs	r2, r7
   15142:	4290      	cmp	r0, r2
   15144:	bf28      	it	cs
   15146:	4610      	movcs	r0, r2

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
   15148:	6962      	ldr	r2, [r4, #20]
   1514a:	441a      	add	r2, r3
	buf->misc.byte_mode.tmp_head =
		wrap(buf->misc.byte_mode.tmp_head + granted_size, buf->size);
   1514c:	4403      	add	r3, r0
	return val >= max ? (val - max) : val;
   1514e:	429e      	cmp	r6, r3
   15150:	bf98      	it	ls
   15152:	1b9b      	subls	r3, r3, r6
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
   15154:	600a      	str	r2, [r1, #0]
	buf->misc.byte_mode.tmp_head =
   15156:	60e3      	str	r3, [r4, #12]

	return granted_size;
}
   15158:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001515a <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, u32_t size)
{
   1515a:	b538      	push	{r3, r4, r5, lr}
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
   1515c:	6905      	ldr	r5, [r0, #16]
{
   1515e:	4604      	mov	r4, r0
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
   15160:	f7ff ff7d 	bl	1505e <ring_buf_space_get>
   15164:	1e6b      	subs	r3, r5, #1
   15166:	1a1b      	subs	r3, r3, r0

	if (size > allocated) {
   15168:	428b      	cmp	r3, r1
   1516a:	d308      	bcc.n	1517e <ring_buf_get_finish+0x24>
		return -EINVAL;
	}

	buf->head = wrap(buf->head + size, buf->size);
   1516c:	6823      	ldr	r3, [r4, #0]
   1516e:	4419      	add	r1, r3
	return val >= max ? (val - max) : val;
   15170:	428d      	cmp	r5, r1
   15172:	bf98      	it	ls
   15174:	1b49      	subls	r1, r1, r5
	buf->head = wrap(buf->head + size, buf->size);
   15176:	6021      	str	r1, [r4, #0]
	buf->misc.byte_mode.tmp_head = buf->head;
   15178:	60e1      	str	r1, [r4, #12]

	return 0;
   1517a:	2000      	movs	r0, #0
}
   1517c:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   1517e:	f06f 0015 	mvn.w	r0, #21
   15182:	e7fb      	b.n	1517c <ring_buf_get_finish+0x22>

00015184 <ring_buf_get>:

u32_t ring_buf_get(struct ring_buf *buf, u8_t *data, u32_t size)
{
   15184:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   15188:	4680      	mov	r8, r0
   1518a:	460e      	mov	r6, r1
   1518c:	4615      	mov	r5, r2
	u8_t *src;
	u32_t partial_size;
	u32_t total_size = 0U;
   1518e:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
   15190:	462a      	mov	r2, r5
   15192:	a901      	add	r1, sp, #4
   15194:	4640      	mov	r0, r8
   15196:	f7ff ffbc 	bl	15112 <ring_buf_get_claim>
		memcpy(data, src, partial_size);
   1519a:	9901      	ldr	r1, [sp, #4]
		partial_size = ring_buf_get_claim(buf, &src, size);
   1519c:	4604      	mov	r4, r0
		memcpy(data, src, partial_size);
   1519e:	4602      	mov	r2, r0
   151a0:	4630      	mov	r0, r6
   151a2:	f000 ff4a 	bl	1603a <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   151a6:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
   151a8:	4427      	add	r7, r4
		data += partial_size;
   151aa:	4426      	add	r6, r4
	} while (size && partial_size);
   151ac:	d001      	beq.n	151b2 <ring_buf_get+0x2e>
   151ae:	2c00      	cmp	r4, #0
   151b0:	d1ee      	bne.n	15190 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
   151b2:	4639      	mov	r1, r7
   151b4:	4640      	mov	r0, r8
   151b6:	f7ff ffd0 	bl	1515a <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
   151ba:	4638      	mov	r0, r7
   151bc:	b002      	add	sp, #8
   151be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000151c2 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   151c2:	4770      	bx	lr

000151c4 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   151c4:	2300      	movs	r3, #0
	list->head = NULL;
   151c6:	e9c0 3300 	strd	r3, r3, [r0]
}
   151ca:	4770      	bx	lr

000151cc <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   151cc:	6803      	ldr	r3, [r0, #0]
   151ce:	b923      	cbnz	r3, 151da <log_list_add_tail+0xe>
		list->head = msg;
   151d0:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   151d2:	2300      	movs	r3, #0
	list->tail = msg;
   151d4:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   151d6:	600b      	str	r3, [r1, #0]
}
   151d8:	4770      	bx	lr
		list->tail->next = msg;
   151da:	6843      	ldr	r3, [r0, #4]
   151dc:	6019      	str	r1, [r3, #0]
   151de:	e7f8      	b.n	151d2 <log_list_add_tail+0x6>

000151e0 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   151e0:	6800      	ldr	r0, [r0, #0]
   151e2:	4770      	bx	lr

000151e4 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   151e4:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   151e6:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   151e8:	b108      	cbz	r0, 151ee <log_list_head_get+0xa>
		list->head = list->head->next;
   151ea:	6802      	ldr	r2, [r0, #0]
   151ec:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   151ee:	4770      	bx	lr

000151f0 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   151f0:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   151f2:	f7ed fe29 	bl	2e48 <log_msg_chunk_alloc>

	if (msg != NULL) {
   151f6:	b118      	cbz	r0, 15200 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   151f8:	2301      	movs	r3, #1
   151fa:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   151fc:	2300      	movs	r3, #0
   151fe:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
   15200:	bd08      	pop	{r3, pc}

00015202 <k_cycle_get_32_wrapper>:
   15202:	f7f0 bb47 	b.w	5894 <z_timer_cycle_get_32>

00015206 <dummy_timestamp>:
   15206:	2000      	movs	r0, #0
   15208:	4770      	bx	lr

0001520a <z_log_get_s_mask>:
{
   1520a:	b5f0      	push	{r4, r5, r6, r7, lr}
   1520c:	4605      	mov	r5, r0
	u32_t mask = 0;
   1520e:	2000      	movs	r0, #0
	u32_t arg = 0;
   15210:	4603      	mov	r3, r0
	bool arm = false;
   15212:	4602      	mov	r2, r0
				mask |= BIT(arg);
   15214:	2701      	movs	r7, #1
	while ((curr = *str++) && arg < nargs) {
   15216:	f815 4b01 	ldrb.w	r4, [r5], #1
   1521a:	b10c      	cbz	r4, 15220 <z_log_get_s_mask+0x16>
   1521c:	428b      	cmp	r3, r1
   1521e:	d300      	bcc.n	15222 <z_log_get_s_mask+0x18>
}
   15220:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   15222:	2c25      	cmp	r4, #37	; 0x25
   15224:	d102      	bne.n	1522c <z_log_get_s_mask+0x22>
			arm = !arm;
   15226:	f082 0201 	eor.w	r2, r2, #1
   1522a:	e7f4      	b.n	15216 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
   1522c:	2a00      	cmp	r2, #0
   1522e:	d0f2      	beq.n	15216 <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   15230:	f044 0620 	orr.w	r6, r4, #32
   15234:	3e61      	subs	r6, #97	; 0x61
   15236:	2e19      	cmp	r6, #25
   15238:	d8ed      	bhi.n	15216 <z_log_get_s_mask+0xc>
			if (curr == 's') {
   1523a:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
   1523c:	bf04      	itt	eq
   1523e:	fa07 f203 	lsleq.w	r2, r7, r3
   15242:	4310      	orreq	r0, r2
			arg++;
   15244:	3301      	adds	r3, #1
			arm = false;
   15246:	2200      	movs	r2, #0
   15248:	e7e5      	b.n	15216 <z_log_get_s_mask+0xc>

0001524a <log_0>:
{
   1524a:	b538      	push	{r3, r4, r5, lr}
   1524c:	4605      	mov	r5, r0
   1524e:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   15250:	f7ff ffce 	bl	151f0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   15254:	b128      	cbz	r0, 15262 <log_0+0x18>
		msg->str = str;
   15256:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
   15258:	4621      	mov	r1, r4
}
   1525a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   1525e:	f7ed bd15 	b.w	2c8c <msg_finalize>
}
   15262:	bd38      	pop	{r3, r4, r5, pc}

00015264 <log_1>:
{
   15264:	b570      	push	{r4, r5, r6, lr}
   15266:	4606      	mov	r6, r0
   15268:	460d      	mov	r5, r1
   1526a:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   1526c:	f7ff ffc0 	bl	151f0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   15270:	b158      	cbz	r0, 1528a <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   15272:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   15274:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   15276:	2101      	movs	r1, #1
   15278:	f361 1207 	bfi	r2, r1, #4, #4
   1527c:	7242      	strb	r2, [r0, #9]
		msg->payload.single.args[0] = arg1;
   1527e:	6145      	str	r5, [r0, #20]
		msg_finalize(msg, src_level);
   15280:	4621      	mov	r1, r4
}
   15282:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   15286:	f7ed bd01 	b.w	2c8c <msg_finalize>
}
   1528a:	bd70      	pop	{r4, r5, r6, pc}

0001528c <log_2>:
{
   1528c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15290:	4680      	mov	r8, r0
   15292:	460f      	mov	r7, r1
   15294:	4616      	mov	r6, r2
   15296:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   15298:	f7ff ffaa 	bl	151f0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   1529c:	b168      	cbz	r0, 152ba <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   1529e:	7a43      	ldrb	r3, [r0, #9]
		msg->str = str;
   152a0:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
   152a4:	2202      	movs	r2, #2
   152a6:	f362 1307 	bfi	r3, r2, #4, #4
   152aa:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   152ac:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg_finalize(msg, src_level);
   152b0:	4629      	mov	r1, r5
}
   152b2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   152b6:	f7ed bce9 	b.w	2c8c <msg_finalize>
}
   152ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000152be <log_3>:
{
   152be:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   152c2:	4680      	mov	r8, r0
   152c4:	f8bd 9020 	ldrh.w	r9, [sp, #32]
   152c8:	460f      	mov	r7, r1
   152ca:	4616      	mov	r6, r2
   152cc:	461d      	mov	r5, r3
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   152ce:	f7ff ff8f 	bl	151f0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   152d2:	b170      	cbz	r0, 152f2 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   152d4:	7a43      	ldrb	r3, [r0, #9]
		msg->str = str;
   152d6:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
   152da:	2203      	movs	r2, #3
   152dc:	f362 1307 	bfi	r3, r2, #4, #4
   152e0:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   152e2:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->payload.single.args[2] = arg3;
   152e6:	61c5      	str	r5, [r0, #28]
		msg_finalize(msg, src_level);
   152e8:	4649      	mov	r1, r9
}
   152ea:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   152ee:	f7ed bccd 	b.w	2c8c <msg_finalize>
}
   152f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000152f6 <log_n>:
{
   152f6:	b510      	push	{r4, lr}
   152f8:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
   152fa:	f000 f8b6 	bl	1546a <log_msg_create_n>
		if (msg == NULL) {
   152fe:	b120      	cbz	r0, 1530a <log_n+0x14>
		msg_finalize(msg, src_level);
   15300:	4621      	mov	r1, r4
}
   15302:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   15306:	f7ed bcc1 	b.w	2c8c <msg_finalize>
}
   1530a:	bd10      	pop	{r4, pc}

0001530c <log_printk>:
{
   1530c:	b500      	push	{lr}
   1530e:	b0a3      	sub	sp, #140	; 0x8c
   15310:	4602      	mov	r2, r0
   15312:	460b      	mov	r3, r1
			length = vsnprintk(str, sizeof(str), fmt, ap);
   15314:	a801      	add	r0, sp, #4
   15316:	2181      	movs	r1, #129	; 0x81
   15318:	f7ed fad0 	bl	28bc <vsnprintk>
			msg = log_msg_hexdump_create(NULL, str, length);
   1531c:	2881      	cmp	r0, #129	; 0x81
   1531e:	4602      	mov	r2, r0
   15320:	a901      	add	r1, sp, #4
   15322:	bf28      	it	cs
   15324:	2281      	movcs	r2, #129	; 0x81
   15326:	2000      	movs	r0, #0
   15328:	f000 f8f3 	bl	15512 <log_msg_hexdump_create>
			if (msg == NULL) {
   1532c:	b118      	cbz	r0, 15336 <log_printk+0x2a>
			msg_finalize(msg, src_level_union.structure);
   1532e:	f04f 0100 	mov.w	r1, #0
   15332:	f7ed fcab 	bl	2c8c <msg_finalize>
}
   15336:	b023      	add	sp, #140	; 0x8c
   15338:	f85d fb04 	ldr.w	pc, [sp], #4

0001533c <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   1533c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15340:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
   15342:	8903      	ldrh	r3, [r0, #8]
{
   15344:	f89d 7020 	ldrb.w	r7, [sp, #32]
   15348:	460e      	mov	r6, r1
   1534a:	4611      	mov	r1, r2
	u32_t available_len = msg->hdr.params.hexdump.length;
   1534c:	f3c3 028d 	ubfx	r2, r3, #2, #14
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
   15350:	42a2      	cmp	r2, r4
   15352:	d803      	bhi.n	1535c <log_msg_hexdump_data_op+0x20>
		*length = 0;
   15354:	2300      	movs	r3, #0
   15356:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   15358:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   1535c:	680b      	ldr	r3, [r1, #0]
   1535e:	4423      	add	r3, r4
   15360:	4293      	cmp	r3, r2
		*length = available_len - offset;
   15362:	bf84      	itt	hi
   15364:	1b13      	subhi	r3, r2, r4
   15366:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   15368:	2a0c      	cmp	r2, #12
	req_len = *length;
   1536a:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   1536e:	d927      	bls.n	153c0 <log_msg_hexdump_data_op+0x84>
	if (offset < chunk_len) {
   15370:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   15372:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   15376:	d82a      	bhi.n	153ce <log_msg_hexdump_data_op+0x92>
		head_data = msg->payload.ext.data.bytes;
   15378:	3018      	adds	r0, #24
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   1537a:	2208      	movs	r2, #8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   1537c:	454a      	cmp	r2, r9
   1537e:	bf28      	it	cs
   15380:	464a      	movcs	r2, r9
   15382:	4615      	mov	r5, r2
		if (put_op) {
   15384:	4420      	add	r0, r4
   15386:	b1ff      	cbz	r7, 153c8 <log_msg_hexdump_data_op+0x8c>
			(void)memcpy(&head_data[offset], data, cpy_len);
   15388:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   1538a:	f000 fe56 	bl	1603a <memcpy>
		req_len -= cpy_len;
   1538e:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   15392:	442e      	add	r6, r5
	while (req_len > 0) {
   15394:	f1b9 0f00 	cmp.w	r9, #0
   15398:	d0de      	beq.n	15358 <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   1539a:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   1539e:	454d      	cmp	r5, r9
   153a0:	bf28      	it	cs
   153a2:	464d      	movcs	r5, r9
		if (put_op) {
   153a4:	1d20      	adds	r0, r4, #4
   153a6:	4440      	add	r0, r8
			(void)memcpy(&cont->payload.bytes[offset],
   153a8:	462a      	mov	r2, r5
		if (put_op) {
   153aa:	b1bf      	cbz	r7, 153dc <log_msg_hexdump_data_op+0xa0>
			(void)memcpy(&cont->payload.bytes[offset],
   153ac:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   153ae:	f000 fe44 	bl	1603a <memcpy>
		req_len -= cpy_len;
   153b2:	eba9 0905 	sub.w	r9, r9, r5
		cont = cont->next;
   153b6:	f8d8 8000 	ldr.w	r8, [r8]
		data += cpy_len;
   153ba:	442e      	add	r6, r5
		offset = 0;
   153bc:	2400      	movs	r4, #0
   153be:	e7e9      	b.n	15394 <log_msg_hexdump_data_op+0x58>
		head_data = msg->payload.single.bytes;
   153c0:	3014      	adds	r0, #20
	struct log_msg_cont *cont = NULL;
   153c2:	f04f 0800 	mov.w	r8, #0
   153c6:	e7d9      	b.n	1537c <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   153c8:	4601      	mov	r1, r0
   153ca:	4630      	mov	r0, r6
   153cc:	e7dd      	b.n	1538a <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
   153ce:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   153d0:	2c1b      	cmp	r4, #27
   153d2:	d9df      	bls.n	15394 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
   153d4:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   153d8:	3c1c      	subs	r4, #28
   153da:	e7f9      	b.n	153d0 <log_msg_hexdump_data_op+0x94>
			(void)memcpy(data, &cont->payload.bytes[offset],
   153dc:	4601      	mov	r1, r0
   153de:	4630      	mov	r0, r6
   153e0:	e7e5      	b.n	153ae <log_msg_hexdump_data_op+0x72>

000153e2 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   153e2:	3004      	adds	r0, #4
   153e4:	f3bf 8f5b 	dmb	ish
   153e8:	e850 3f00 	ldrex	r3, [r0]
   153ec:	3301      	adds	r3, #1
   153ee:	e840 3200 	strex	r2, r3, [r0]
   153f2:	2a00      	cmp	r2, #0
   153f4:	d1f8      	bne.n	153e8 <log_msg_get+0x6>
   153f6:	f3bf 8f5b 	dmb	ish
}
   153fa:	4770      	bx	lr

000153fc <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   153fc:	7a40      	ldrb	r0, [r0, #9]
}
   153fe:	0900      	lsrs	r0, r0, #4
   15400:	4770      	bx	lr

00015402 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   15402:	7a43      	ldrb	r3, [r0, #9]
   15404:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   15408:	ea4f 1213 	mov.w	r2, r3, lsr #4
   1540c:	d216      	bcs.n	1543c <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   1540e:	2a03      	cmp	r2, #3
   15410:	d803      	bhi.n	1541a <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   15412:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   15416:	6948      	ldr	r0, [r1, #20]
   15418:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   1541a:	2901      	cmp	r1, #1
   1541c:	d803      	bhi.n	15426 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   1541e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   15422:	6988      	ldr	r0, [r1, #24]
   15424:	4770      	bx	lr
	cont = msg->payload.ext.next;
   15426:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   15428:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   1542a:	2906      	cmp	r1, #6
   1542c:	d803      	bhi.n	15436 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   1542e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   15432:	6848      	ldr	r0, [r1, #4]
   15434:	4770      	bx	lr
		cont = cont->next;
   15436:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   15438:	3907      	subs	r1, #7
		cont = cont->next;
   1543a:	e7f6      	b.n	1542a <log_msg_arg_get+0x28>
		return 0;
   1543c:	2000      	movs	r0, #0
}
   1543e:	4770      	bx	lr

00015440 <log_msg_put>:
{
   15440:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   15442:	1d02      	adds	r2, r0, #4
   15444:	f3bf 8f5b 	dmb	ish
   15448:	e852 1f00 	ldrex	r1, [r2]
   1544c:	3901      	subs	r1, #1
   1544e:	e842 1c00 	strex	ip, r1, [r2]
   15452:	f1bc 0f00 	cmp.w	ip, #0
   15456:	d1f7      	bne.n	15448 <log_msg_put+0x8>
   15458:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
   1545c:	685b      	ldr	r3, [r3, #4]
   1545e:	b90b      	cbnz	r3, 15464 <log_msg_put+0x24>
		msg_free(msg);
   15460:	f7ed bd04 	b.w	2e6c <msg_free>
}
   15464:	4770      	bx	lr

00015466 <log_msg_str_get>:
}
   15466:	6900      	ldr	r0, [r0, #16]
   15468:	4770      	bx	lr

0001546a <log_msg_create_n>:
{
   1546a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1546e:	4681      	mov	r9, r0
   15470:	4688      	mov	r8, r1
   15472:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   15474:	f7ed fce8 	bl	2e48 <log_msg_chunk_alloc>
	if (msg != NULL) {
   15478:	4604      	mov	r4, r0
   1547a:	b330      	cbz	r0, 154ca <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
   1547c:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
   1547e:	2700      	movs	r7, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   15480:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
   15482:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   15484:	8107      	strh	r7, [r0, #8]
   15486:	d909      	bls.n	1549c <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
   15488:	2202      	movs	r2, #2
   1548a:	8102      	strh	r2, [r0, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
   1548c:	f1a5 0a02 	sub.w	sl, r5, #2
	next = &msg->payload.ext.next;
   15490:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
   15494:	6147      	str	r7, [r0, #20]
	while (n > 0) {
   15496:	f1ba 0f00 	cmp.w	sl, #0
   1549a:	dc0e      	bgt.n	154ba <log_msg_create_n+0x50>
		msg->hdr.params.std.nargs = nargs;
   1549c:	7a63      	ldrb	r3, [r4, #9]
		msg->str = str;
   1549e:	f8c4 9010 	str.w	r9, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
   154a2:	f365 1307 	bfi	r3, r5, #4, #4
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   154a6:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
   154a8:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   154aa:	d818      	bhi.n	154de <log_msg_create_n+0x74>
		(void)memcpy(msg->payload.single.args, args,
   154ac:	00aa      	lsls	r2, r5, #2
   154ae:	4641      	mov	r1, r8
   154b0:	f104 0014 	add.w	r0, r4, #20
   154b4:	f000 fdc1 	bl	1603a <memcpy>
	while (nargs != 0U) {
   154b8:	e007      	b.n	154ca <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   154ba:	f7ed fcc5 	bl	2e48 <log_msg_chunk_alloc>
		if (cont == NULL) {
   154be:	4606      	mov	r6, r0
   154c0:	b930      	cbnz	r0, 154d0 <log_msg_create_n+0x66>
			msg_free(msg);
   154c2:	4620      	mov	r0, r4
   154c4:	f7ed fcd2 	bl	2e6c <msg_free>
			return NULL;
   154c8:	4634      	mov	r4, r6
}
   154ca:	4620      	mov	r0, r4
   154cc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
   154d0:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
   154d4:	f1aa 0a07 	sub.w	sl, sl, #7
   154d8:	6007      	str	r7, [r0, #0]
		next = &cont->next;
   154da:	4683      	mov	fp, r0
		n -= ARGS_CONT_MSG;
   154dc:	e7db      	b.n	15496 <log_msg_create_n+0x2c>
		(void)memcpy(msg->payload.ext.data.args, args,
   154de:	4641      	mov	r1, r8
   154e0:	2208      	movs	r2, #8
   154e2:	f104 0018 	add.w	r0, r4, #24
	struct log_msg_cont *cont = msg->payload.ext.next;
   154e6:	6967      	ldr	r7, [r4, #20]
		(void)memcpy(msg->payload.ext.data.args, args,
   154e8:	f000 fda7 	bl	1603a <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
   154ec:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
   154ee:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
   154f2:	2d07      	cmp	r5, #7
   154f4:	462e      	mov	r6, r5
   154f6:	bf28      	it	cs
   154f8:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
   154fa:	ea4f 0986 	mov.w	r9, r6, lsl #2
   154fe:	4641      	mov	r1, r8
   15500:	1d38      	adds	r0, r7, #4
   15502:	464a      	mov	r2, r9
   15504:	f000 fd99 	bl	1603a <memcpy>
	while (nargs != 0U) {
   15508:	1bad      	subs	r5, r5, r6
		cont = cont->next;
   1550a:	683f      	ldr	r7, [r7, #0]
		args += cpy_args;
   1550c:	44c8      	add	r8, r9
	while (nargs != 0U) {
   1550e:	d1f0      	bne.n	154f2 <log_msg_create_n+0x88>
   15510:	e7db      	b.n	154ca <log_msg_create_n+0x60>

00015512 <log_msg_hexdump_create>:
{
   15512:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   15516:	f643 75ff 	movw	r5, #16383	; 0x3fff
   1551a:	4295      	cmp	r5, r2
{
   1551c:	4680      	mov	r8, r0
   1551e:	460e      	mov	r6, r1
   15520:	4617      	mov	r7, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   15522:	bf28      	it	cs
   15524:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
   15526:	f7ed fc8f 	bl	2e48 <log_msg_chunk_alloc>
	if (msg == NULL) {
   1552a:	4604      	mov	r4, r0
   1552c:	b380      	cbz	r0, 15590 <log_msg_hexdump_create+0x7e>
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   1552e:	8902      	ldrh	r2, [r0, #8]
	msg->str = str;
   15530:	f8c0 8010 	str.w	r8, [r0, #16]
	msg->hdr.ref_cnt = 1;
   15534:	2301      	movs	r3, #1
   15536:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   15538:	00ab      	lsls	r3, r5, #2
   1553a:	f043 0301 	orr.w	r3, r3, #1
   1553e:	f002 0202 	and.w	r2, r2, #2
   15542:	4313      	orrs	r3, r2
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   15544:	2f0c      	cmp	r7, #12
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   15546:	8103      	strh	r3, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   15548:	f100 0814 	add.w	r8, r0, #20
   1554c:	d917      	bls.n	1557e <log_msg_hexdump_create+0x6c>
		(void)memcpy(msg->payload.ext.data.bytes,
   1554e:	2208      	movs	r2, #8
   15550:	4631      	mov	r1, r6
   15552:	3018      	adds	r0, #24
   15554:	f000 fd71 	bl	1603a <memcpy>
		msg->hdr.params.generic.ext = 1;
   15558:	7a22      	ldrb	r2, [r4, #8]
		msg->payload.ext.next = NULL;
   1555a:	2300      	movs	r3, #0
		msg->hdr.params.generic.ext = 1;
   1555c:	f042 0202 	orr.w	r2, r2, #2
		msg->payload.ext.next = NULL;
   15560:	6163      	str	r3, [r4, #20]
		msg->hdr.params.generic.ext = 1;
   15562:	7222      	strb	r2, [r4, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   15564:	3608      	adds	r6, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   15566:	3d08      	subs	r5, #8
	while (length > 0) {
   15568:	4699      	mov	r9, r3
   1556a:	b18d      	cbz	r5, 15590 <log_msg_hexdump_create+0x7e>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   1556c:	f7ed fc6c 	bl	2e48 <log_msg_chunk_alloc>
		if (cont == NULL) {
   15570:	4607      	mov	r7, r0
   15572:	b980      	cbnz	r0, 15596 <log_msg_hexdump_create+0x84>
			msg_free(msg);
   15574:	4620      	mov	r0, r4
   15576:	f7ed fc79 	bl	2e6c <msg_free>
			return NULL;
   1557a:	463c      	mov	r4, r7
   1557c:	e008      	b.n	15590 <log_msg_hexdump_create+0x7e>
		(void)memcpy(msg->payload.single.bytes, data, length);
   1557e:	462a      	mov	r2, r5
   15580:	4631      	mov	r1, r6
   15582:	4640      	mov	r0, r8
   15584:	f000 fd59 	bl	1603a <memcpy>
		msg->hdr.params.generic.ext = 0;
   15588:	7a23      	ldrb	r3, [r4, #8]
   1558a:	f36f 0341 	bfc	r3, #1, #1
   1558e:	7223      	strb	r3, [r4, #8]
}
   15590:	4620      	mov	r0, r4
   15592:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
   15596:	2d1c      	cmp	r5, #28
   15598:	462f      	mov	r7, r5
   1559a:	bf28      	it	cs
   1559c:	271c      	movcs	r7, #28
		*prev_cont = cont;
   1559e:	f8c8 0000 	str.w	r0, [r8]
		(void)memcpy(cont->payload.bytes, data, chunk_length);
   155a2:	4631      	mov	r1, r6
		cont->next = NULL;
   155a4:	f8c0 9000 	str.w	r9, [r0]
		prev_cont = &cont->next;
   155a8:	4680      	mov	r8, r0
		(void)memcpy(cont->payload.bytes, data, chunk_length);
   155aa:	463a      	mov	r2, r7
   155ac:	3004      	adds	r0, #4
   155ae:	f000 fd44 	bl	1603a <memcpy>
		data += chunk_length;
   155b2:	443e      	add	r6, r7
		length -= chunk_length;
   155b4:	1bed      	subs	r5, r5, r7
   155b6:	e7d8      	b.n	1556a <log_msg_hexdump_create+0x58>

000155b8 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
   155b8:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   155ba:	2400      	movs	r4, #0
   155bc:	9400      	str	r4, [sp, #0]
   155be:	f7ff febd 	bl	1533c <log_msg_hexdump_data_op>
}
   155c2:	b002      	add	sp, #8
   155c4:	bd10      	pop	{r4, pc}

000155c6 <buffer_write>:
{
   155c6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   155c8:	4606      	mov	r6, r0
   155ca:	460d      	mov	r5, r1
   155cc:	4614      	mov	r4, r2
   155ce:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   155d0:	4621      	mov	r1, r4
   155d2:	4628      	mov	r0, r5
   155d4:	463a      	mov	r2, r7
   155d6:	47b0      	blx	r6
	} while (len != 0);
   155d8:	1a24      	subs	r4, r4, r0
		buf += processed;
   155da:	4405      	add	r5, r0
	} while (len != 0);
   155dc:	d1f8      	bne.n	155d0 <buffer_write+0xa>
}
   155de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000155e0 <std_print>:
{
   155e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   155e4:	b08e      	sub	sp, #56	; 0x38
   155e6:	af0e      	add	r7, sp, #56	; 0x38
   155e8:	4680      	mov	r8, r0
   155ea:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   155ec:	f7ff ff3b 	bl	15466 <log_msg_str_get>
   155f0:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
   155f2:	4640      	mov	r0, r8
   155f4:	f7ff ff02 	bl	153fc <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   155f8:	0083      	lsls	r3, r0, #2
   155fa:	3307      	adds	r3, #7
   155fc:	f023 0307 	bic.w	r3, r3, #7
   15600:	ebad 0d03 	sub.w	sp, sp, r3
	u32_t nargs = log_msg_nargs_get(msg);
   15604:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   15606:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   15608:	f04f 0900 	mov.w	r9, #0
   1560c:	45d1      	cmp	r9, sl
   1560e:	d116      	bne.n	1563e <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   15610:	4640      	mov	r0, r8
   15612:	f7ff fef3 	bl	153fc <log_msg_nargs_get>
   15616:	280f      	cmp	r0, #15
   15618:	d81e      	bhi.n	15658 <std_print+0x78>
   1561a:	e8df f010 	tbh	[pc, r0, lsl #1]
   1561e:	0019      	.short	0x0019
   15620:	00260020 	.word	0x00260020
   15624:	0036002d 	.word	0x0036002d
   15628:	004e0041 	.word	0x004e0041
   1562c:	006e005d 	.word	0x006e005d
   15630:	00960081 	.word	0x00960081
   15634:	00c600ad 	.word	0x00c600ad
   15638:	00fe00e1 	.word	0x00fe00e1
   1563c:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
   1563e:	4649      	mov	r1, r9
   15640:	4640      	mov	r0, r8
   15642:	f7ff fede 	bl	15402 <log_msg_arg_get>
   15646:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   1564a:	f109 0901 	add.w	r9, r9, #1
   1564e:	e7dd      	b.n	1560c <std_print+0x2c>
		print_formatted(log_output, str);
   15650:	4631      	mov	r1, r6
   15652:	4628      	mov	r0, r5
   15654:	f7ed fc48 	bl	2ee8 <print_formatted>
}
   15658:	46bd      	mov	sp, r7
   1565a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
   1565e:	6822      	ldr	r2, [r4, #0]
   15660:	4631      	mov	r1, r6
   15662:	4628      	mov	r0, r5
   15664:	f7ed fc40 	bl	2ee8 <print_formatted>
		break;
   15668:	e7f6      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
   1566a:	e9d4 2300 	ldrd	r2, r3, [r4]
   1566e:	4631      	mov	r1, r6
   15670:	4628      	mov	r0, r5
   15672:	f7ed fc39 	bl	2ee8 <print_formatted>
		break;
   15676:	e7ef      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
   15678:	68a3      	ldr	r3, [r4, #8]
   1567a:	9300      	str	r3, [sp, #0]
   1567c:	e9d4 2300 	ldrd	r2, r3, [r4]
   15680:	4631      	mov	r1, r6
   15682:	4628      	mov	r0, r5
   15684:	f7ed fc30 	bl	2ee8 <print_formatted>
		break;
   15688:	e7e6      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   1568a:	68e3      	ldr	r3, [r4, #12]
   1568c:	9301      	str	r3, [sp, #4]
   1568e:	68a3      	ldr	r3, [r4, #8]
   15690:	9300      	str	r3, [sp, #0]
   15692:	e9d4 2300 	ldrd	r2, r3, [r4]
   15696:	4631      	mov	r1, r6
   15698:	4628      	mov	r0, r5
   1569a:	f7ed fc25 	bl	2ee8 <print_formatted>
		break;
   1569e:	e7db      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   156a0:	6923      	ldr	r3, [r4, #16]
   156a2:	9302      	str	r3, [sp, #8]
   156a4:	68e3      	ldr	r3, [r4, #12]
   156a6:	9301      	str	r3, [sp, #4]
   156a8:	68a3      	ldr	r3, [r4, #8]
   156aa:	9300      	str	r3, [sp, #0]
   156ac:	e9d4 2300 	ldrd	r2, r3, [r4]
   156b0:	4631      	mov	r1, r6
   156b2:	4628      	mov	r0, r5
   156b4:	f7ed fc18 	bl	2ee8 <print_formatted>
		break;
   156b8:	e7ce      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   156ba:	6963      	ldr	r3, [r4, #20]
   156bc:	9303      	str	r3, [sp, #12]
   156be:	6923      	ldr	r3, [r4, #16]
   156c0:	9302      	str	r3, [sp, #8]
   156c2:	68e3      	ldr	r3, [r4, #12]
   156c4:	9301      	str	r3, [sp, #4]
   156c6:	68a3      	ldr	r3, [r4, #8]
   156c8:	9300      	str	r3, [sp, #0]
   156ca:	e9d4 2300 	ldrd	r2, r3, [r4]
   156ce:	4631      	mov	r1, r6
   156d0:	4628      	mov	r0, r5
   156d2:	f7ed fc09 	bl	2ee8 <print_formatted>
		break;
   156d6:	e7bf      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   156d8:	69a3      	ldr	r3, [r4, #24]
   156da:	9304      	str	r3, [sp, #16]
   156dc:	6963      	ldr	r3, [r4, #20]
   156de:	9303      	str	r3, [sp, #12]
   156e0:	6923      	ldr	r3, [r4, #16]
   156e2:	9302      	str	r3, [sp, #8]
   156e4:	68e3      	ldr	r3, [r4, #12]
   156e6:	9301      	str	r3, [sp, #4]
   156e8:	68a3      	ldr	r3, [r4, #8]
   156ea:	9300      	str	r3, [sp, #0]
   156ec:	e9d4 2300 	ldrd	r2, r3, [r4]
   156f0:	4631      	mov	r1, r6
   156f2:	4628      	mov	r0, r5
   156f4:	f7ed fbf8 	bl	2ee8 <print_formatted>
		break;
   156f8:	e7ae      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   156fa:	69e3      	ldr	r3, [r4, #28]
   156fc:	9305      	str	r3, [sp, #20]
   156fe:	69a3      	ldr	r3, [r4, #24]
   15700:	9304      	str	r3, [sp, #16]
   15702:	6963      	ldr	r3, [r4, #20]
   15704:	9303      	str	r3, [sp, #12]
   15706:	6923      	ldr	r3, [r4, #16]
   15708:	9302      	str	r3, [sp, #8]
   1570a:	68e3      	ldr	r3, [r4, #12]
   1570c:	9301      	str	r3, [sp, #4]
   1570e:	68a3      	ldr	r3, [r4, #8]
   15710:	9300      	str	r3, [sp, #0]
   15712:	e9d4 2300 	ldrd	r2, r3, [r4]
   15716:	4631      	mov	r1, r6
   15718:	4628      	mov	r0, r5
   1571a:	f7ed fbe5 	bl	2ee8 <print_formatted>
		break;
   1571e:	e79b      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   15720:	6a23      	ldr	r3, [r4, #32]
   15722:	9306      	str	r3, [sp, #24]
   15724:	69e3      	ldr	r3, [r4, #28]
   15726:	9305      	str	r3, [sp, #20]
   15728:	69a3      	ldr	r3, [r4, #24]
   1572a:	9304      	str	r3, [sp, #16]
   1572c:	6963      	ldr	r3, [r4, #20]
   1572e:	9303      	str	r3, [sp, #12]
   15730:	6923      	ldr	r3, [r4, #16]
   15732:	9302      	str	r3, [sp, #8]
   15734:	68e3      	ldr	r3, [r4, #12]
   15736:	9301      	str	r3, [sp, #4]
   15738:	68a3      	ldr	r3, [r4, #8]
   1573a:	9300      	str	r3, [sp, #0]
   1573c:	e9d4 2300 	ldrd	r2, r3, [r4]
   15740:	4631      	mov	r1, r6
   15742:	4628      	mov	r0, r5
   15744:	f7ed fbd0 	bl	2ee8 <print_formatted>
		break;
   15748:	e786      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   1574a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1574c:	9307      	str	r3, [sp, #28]
   1574e:	6a23      	ldr	r3, [r4, #32]
   15750:	9306      	str	r3, [sp, #24]
   15752:	69e3      	ldr	r3, [r4, #28]
   15754:	9305      	str	r3, [sp, #20]
   15756:	69a3      	ldr	r3, [r4, #24]
   15758:	9304      	str	r3, [sp, #16]
   1575a:	6963      	ldr	r3, [r4, #20]
   1575c:	9303      	str	r3, [sp, #12]
   1575e:	6923      	ldr	r3, [r4, #16]
   15760:	9302      	str	r3, [sp, #8]
   15762:	68e3      	ldr	r3, [r4, #12]
   15764:	9301      	str	r3, [sp, #4]
   15766:	68a3      	ldr	r3, [r4, #8]
   15768:	9300      	str	r3, [sp, #0]
   1576a:	e9d4 2300 	ldrd	r2, r3, [r4]
   1576e:	4631      	mov	r1, r6
   15770:	4628      	mov	r0, r5
   15772:	f7ed fbb9 	bl	2ee8 <print_formatted>
		break;
   15776:	e76f      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   15778:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1577a:	9308      	str	r3, [sp, #32]
   1577c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1577e:	9307      	str	r3, [sp, #28]
   15780:	6a23      	ldr	r3, [r4, #32]
   15782:	9306      	str	r3, [sp, #24]
   15784:	69e3      	ldr	r3, [r4, #28]
   15786:	9305      	str	r3, [sp, #20]
   15788:	69a3      	ldr	r3, [r4, #24]
   1578a:	9304      	str	r3, [sp, #16]
   1578c:	6963      	ldr	r3, [r4, #20]
   1578e:	9303      	str	r3, [sp, #12]
   15790:	6923      	ldr	r3, [r4, #16]
   15792:	9302      	str	r3, [sp, #8]
   15794:	68e3      	ldr	r3, [r4, #12]
   15796:	9301      	str	r3, [sp, #4]
   15798:	68a3      	ldr	r3, [r4, #8]
   1579a:	9300      	str	r3, [sp, #0]
   1579c:	e9d4 2300 	ldrd	r2, r3, [r4]
   157a0:	4631      	mov	r1, r6
   157a2:	4628      	mov	r0, r5
   157a4:	f7ed fba0 	bl	2ee8 <print_formatted>
		break;
   157a8:	e756      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   157aa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   157ac:	9309      	str	r3, [sp, #36]	; 0x24
   157ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   157b0:	9308      	str	r3, [sp, #32]
   157b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   157b4:	9307      	str	r3, [sp, #28]
   157b6:	6a23      	ldr	r3, [r4, #32]
   157b8:	9306      	str	r3, [sp, #24]
   157ba:	69e3      	ldr	r3, [r4, #28]
   157bc:	9305      	str	r3, [sp, #20]
   157be:	69a3      	ldr	r3, [r4, #24]
   157c0:	9304      	str	r3, [sp, #16]
   157c2:	6963      	ldr	r3, [r4, #20]
   157c4:	9303      	str	r3, [sp, #12]
   157c6:	6923      	ldr	r3, [r4, #16]
   157c8:	9302      	str	r3, [sp, #8]
   157ca:	68e3      	ldr	r3, [r4, #12]
   157cc:	9301      	str	r3, [sp, #4]
   157ce:	68a3      	ldr	r3, [r4, #8]
   157d0:	9300      	str	r3, [sp, #0]
   157d2:	e9d4 2300 	ldrd	r2, r3, [r4]
   157d6:	4631      	mov	r1, r6
   157d8:	4628      	mov	r0, r5
   157da:	f7ed fb85 	bl	2ee8 <print_formatted>
		break;
   157de:	e73b      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   157e0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   157e2:	930a      	str	r3, [sp, #40]	; 0x28
   157e4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   157e6:	9309      	str	r3, [sp, #36]	; 0x24
   157e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   157ea:	9308      	str	r3, [sp, #32]
   157ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
   157ee:	9307      	str	r3, [sp, #28]
   157f0:	6a23      	ldr	r3, [r4, #32]
   157f2:	9306      	str	r3, [sp, #24]
   157f4:	69e3      	ldr	r3, [r4, #28]
   157f6:	9305      	str	r3, [sp, #20]
   157f8:	69a3      	ldr	r3, [r4, #24]
   157fa:	9304      	str	r3, [sp, #16]
   157fc:	6963      	ldr	r3, [r4, #20]
   157fe:	9303      	str	r3, [sp, #12]
   15800:	6923      	ldr	r3, [r4, #16]
   15802:	9302      	str	r3, [sp, #8]
   15804:	68e3      	ldr	r3, [r4, #12]
   15806:	9301      	str	r3, [sp, #4]
   15808:	68a3      	ldr	r3, [r4, #8]
   1580a:	9300      	str	r3, [sp, #0]
   1580c:	e9d4 2300 	ldrd	r2, r3, [r4]
   15810:	4631      	mov	r1, r6
   15812:	4628      	mov	r0, r5
   15814:	f7ed fb68 	bl	2ee8 <print_formatted>
		break;
   15818:	e71e      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   1581a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1581c:	930b      	str	r3, [sp, #44]	; 0x2c
   1581e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   15820:	930a      	str	r3, [sp, #40]	; 0x28
   15822:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   15824:	9309      	str	r3, [sp, #36]	; 0x24
   15826:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   15828:	9308      	str	r3, [sp, #32]
   1582a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1582c:	9307      	str	r3, [sp, #28]
   1582e:	6a23      	ldr	r3, [r4, #32]
   15830:	9306      	str	r3, [sp, #24]
   15832:	69e3      	ldr	r3, [r4, #28]
   15834:	9305      	str	r3, [sp, #20]
   15836:	69a3      	ldr	r3, [r4, #24]
   15838:	9304      	str	r3, [sp, #16]
   1583a:	6963      	ldr	r3, [r4, #20]
   1583c:	9303      	str	r3, [sp, #12]
   1583e:	6923      	ldr	r3, [r4, #16]
   15840:	9302      	str	r3, [sp, #8]
   15842:	68e3      	ldr	r3, [r4, #12]
   15844:	9301      	str	r3, [sp, #4]
   15846:	68a3      	ldr	r3, [r4, #8]
   15848:	9300      	str	r3, [sp, #0]
   1584a:	e9d4 2300 	ldrd	r2, r3, [r4]
   1584e:	4631      	mov	r1, r6
   15850:	4628      	mov	r0, r5
   15852:	f7ed fb49 	bl	2ee8 <print_formatted>
		break;
   15856:	e6ff      	b.n	15658 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   15858:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1585a:	930c      	str	r3, [sp, #48]	; 0x30
   1585c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1585e:	930b      	str	r3, [sp, #44]	; 0x2c
   15860:	6b23      	ldr	r3, [r4, #48]	; 0x30
   15862:	930a      	str	r3, [sp, #40]	; 0x28
   15864:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   15866:	9309      	str	r3, [sp, #36]	; 0x24
   15868:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1586a:	9308      	str	r3, [sp, #32]
   1586c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1586e:	9307      	str	r3, [sp, #28]
   15870:	6a23      	ldr	r3, [r4, #32]
   15872:	9306      	str	r3, [sp, #24]
   15874:	69e3      	ldr	r3, [r4, #28]
   15876:	9305      	str	r3, [sp, #20]
   15878:	69a3      	ldr	r3, [r4, #24]
   1587a:	9304      	str	r3, [sp, #16]
   1587c:	6963      	ldr	r3, [r4, #20]
   1587e:	9303      	str	r3, [sp, #12]
   15880:	6923      	ldr	r3, [r4, #16]
   15882:	9302      	str	r3, [sp, #8]
   15884:	68e3      	ldr	r3, [r4, #12]
   15886:	9301      	str	r3, [sp, #4]
   15888:	68a3      	ldr	r3, [r4, #8]
   1588a:	9300      	str	r3, [sp, #0]
   1588c:	e9d4 2300 	ldrd	r2, r3, [r4]
   15890:	4631      	mov	r1, r6
   15892:	4628      	mov	r0, r5
   15894:	f7ed fb28 	bl	2ee8 <print_formatted>
}
   15898:	e6de      	b.n	15658 <std_print+0x78>

0001589a <log_output_flush>:
		     log_output->control_block->offset,
   1589a:	6842      	ldr	r2, [r0, #4]
	buffer_write(log_output->func, log_output->buf,
   1589c:	6881      	ldr	r1, [r0, #8]
{
   1589e:	b510      	push	{r4, lr}
   158a0:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   158a2:	e9d2 2300 	ldrd	r2, r3, [r2]
   158a6:	6800      	ldr	r0, [r0, #0]
   158a8:	f7ff fe8d 	bl	155c6 <buffer_write>
	log_output->control_block->offset = 0;
   158ac:	6863      	ldr	r3, [r4, #4]
   158ae:	2200      	movs	r2, #0
   158b0:	601a      	str	r2, [r3, #0]
}
   158b2:	bd10      	pop	{r4, pc}

000158b4 <out_func>:
{
   158b4:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   158b6:	684b      	ldr	r3, [r1, #4]
   158b8:	681a      	ldr	r2, [r3, #0]
   158ba:	68cb      	ldr	r3, [r1, #12]
   158bc:	429a      	cmp	r2, r3
{
   158be:	4605      	mov	r5, r0
   158c0:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   158c2:	d102      	bne.n	158ca <out_func+0x16>
		log_output_flush(out_ctx);
   158c4:	4608      	mov	r0, r1
   158c6:	f7ff ffe8 	bl	1589a <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   158ca:	6863      	ldr	r3, [r4, #4]
   158cc:	f3bf 8f5b 	dmb	ish
   158d0:	e853 2f00 	ldrex	r2, [r3]
   158d4:	1c51      	adds	r1, r2, #1
   158d6:	e843 1000 	strex	r0, r1, [r3]
   158da:	2800      	cmp	r0, #0
   158dc:	d1f8      	bne.n	158d0 <out_func+0x1c>
   158de:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (u8_t)c;
   158e2:	68a3      	ldr	r3, [r4, #8]
   158e4:	549d      	strb	r5, [r3, r2]
}
   158e6:	2000      	movs	r0, #0
   158e8:	bd38      	pop	{r3, r4, r5, pc}

000158ea <char_out>:
{
   158ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   158ec:	460d      	mov	r5, r1
   158ee:	4616      	mov	r6, r2
	for (size_t i = 0; i < length; i++) {
   158f0:	4604      	mov	r4, r0
   158f2:	1847      	adds	r7, r0, r1
   158f4:	42bc      	cmp	r4, r7
   158f6:	d101      	bne.n	158fc <char_out+0x12>
}
   158f8:	4628      	mov	r0, r5
   158fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uart_poll_out(dev, data[i]);
   158fc:	f814 1b01 	ldrb.w	r1, [r4], #1
   15900:	6873      	ldr	r3, [r6, #4]
   15902:	4630      	mov	r0, r6
   15904:	685b      	ldr	r3, [r3, #4]
   15906:	4798      	blx	r3
	for (size_t i = 0; i < length; i++) {
   15908:	e7f4      	b.n	158f4 <char_out+0xa>

0001590a <usb_write>:
{
   1590a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1590e:	4606      	mov	r6, r0
   15910:	460f      	mov	r7, r1
   15912:	4690      	mov	r8, r2
   15914:	4699      	mov	r9, r3
   15916:	2504      	movs	r5, #4
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   15918:	464b      	mov	r3, r9
   1591a:	4642      	mov	r2, r8
   1591c:	4639      	mov	r1, r7
   1591e:	4630      	mov	r0, r6
   15920:	f7ef fd8a 	bl	5438 <usb_dc_ep_write>
		if (ret == -EAGAIN) {
   15924:	f110 0f0b 	cmn.w	r0, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   15928:	4604      	mov	r4, r0
		if (ret == -EAGAIN) {
   1592a:	d103      	bne.n	15934 <usb_write+0x2a>
	z_impl_k_yield();
   1592c:	f7fe fc62 	bl	141f4 <z_impl_k_yield>
	} while (ret == -EAGAIN && tries--);
   15930:	3d01      	subs	r5, #1
   15932:	d1f1      	bne.n	15918 <usb_write+0xe>
}
   15934:	4620      	mov	r0, r4
   15936:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001593a <usb_get_dev_data_by_cfg>:
struct usb_dev_data *usb_get_dev_data_by_cfg(sys_slist_t *list,
					     struct usb_cfg_data *cfg)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   1593a:	6800      	ldr	r0, [r0, #0]
   1593c:	b160      	cbz	r0, 15958 <usb_get_dev_data_by_cfg+0x1e>
   1593e:	3804      	subs	r0, #4
   15940:	b900      	cbnz	r0, 15944 <usb_get_dev_data_by_cfg+0xa>
   15942:	4770      	bx	lr
		struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg_cur = dev->config->config_info;
   15944:	6803      	ldr	r3, [r0, #0]
   15946:	681b      	ldr	r3, [r3, #0]

		if (cfg_cur == cfg) {
   15948:	689b      	ldr	r3, [r3, #8]
   1594a:	428b      	cmp	r3, r1
   1594c:	d004      	beq.n	15958 <usb_get_dev_data_by_cfg+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1594e:	1d03      	adds	r3, r0, #4
   15950:	d001      	beq.n	15956 <usb_get_dev_data_by_cfg+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   15952:	6840      	ldr	r0, [r0, #4]
   15954:	e7f2      	b.n	1593c <usb_get_dev_data_by_cfg+0x2>
		}
	}

	LOG_DBG("Device data not found for cfg %p", cfg);

	return NULL;
   15956:	4618      	mov	r0, r3
}
   15958:	4770      	bx	lr

0001595a <usb_get_dev_data_by_iface>:
struct usb_dev_data *usb_get_dev_data_by_iface(sys_slist_t *list,
					       u8_t iface_num)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   1595a:	6800      	ldr	r0, [r0, #0]
   1595c:	b170      	cbz	r0, 1597c <usb_get_dev_data_by_iface+0x22>
   1595e:	3804      	subs	r0, #4
   15960:	b900      	cbnz	r0, 15964 <usb_get_dev_data_by_iface+0xa>
   15962:	4770      	bx	lr
		struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config->config_info;
   15964:	6803      	ldr	r3, [r0, #0]
   15966:	681b      	ldr	r3, [r3, #0]
		const struct usb_if_descriptor *if_desc =
   15968:	689b      	ldr	r3, [r3, #8]
						cfg->interface_descriptor;

		if (if_desc->bInterfaceNumber == iface_num) {
   1596a:	685b      	ldr	r3, [r3, #4]
   1596c:	789b      	ldrb	r3, [r3, #2]
   1596e:	428b      	cmp	r3, r1
   15970:	d004      	beq.n	1597c <usb_get_dev_data_by_iface+0x22>
Z_GENLIST_PEEK_NEXT(slist, snode)
   15972:	1d03      	adds	r3, r0, #4
   15974:	d001      	beq.n	1597a <usb_get_dev_data_by_iface+0x20>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   15976:	6840      	ldr	r0, [r0, #4]
   15978:	e7f0      	b.n	1595c <usb_get_dev_data_by_iface+0x2>
		}
	}

	LOG_DBG("Device data not found for iface number %u", iface_num);

	return NULL;
   1597a:	4618      	mov	r0, r3
}
   1597c:	4770      	bx	lr

0001597e <usb_get_dev_data_by_ep>:

struct usb_dev_data *usb_get_dev_data_by_ep(sys_slist_t *list, u8_t ep)
{
   1597e:	b530      	push	{r4, r5, lr}
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   15980:	6800      	ldr	r0, [r0, #0]
   15982:	b1a0      	cbz	r0, 159ae <usb_get_dev_data_by_ep+0x30>
   15984:	3804      	subs	r0, #4
   15986:	b190      	cbz	r0, 159ae <usb_get_dev_data_by_ep+0x30>
		struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config->config_info;
   15988:	6803      	ldr	r3, [r0, #0]
   1598a:	681b      	ldr	r3, [r3, #0]
   1598c:	689b      	ldr	r3, [r3, #8]
		const struct usb_ep_cfg_data *ep_data = cfg->endpoint;
   1598e:	6a1a      	ldr	r2, [r3, #32]

		for (u8_t i = 0; i < cfg->num_endpoints; i++) {
   15990:	7f1d      	ldrb	r5, [r3, #28]
			if (ep_data[i].ep_addr == ep) {
   15992:	3a04      	subs	r2, #4
		for (u8_t i = 0; i < cfg->num_endpoints; i++) {
   15994:	2300      	movs	r3, #0
   15996:	b2dc      	uxtb	r4, r3
   15998:	42a5      	cmp	r5, r4
   1599a:	d803      	bhi.n	159a4 <usb_get_dev_data_by_ep+0x26>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1599c:	1d03      	adds	r3, r0, #4
   1599e:	d007      	beq.n	159b0 <usb_get_dev_data_by_ep+0x32>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   159a0:	6840      	ldr	r0, [r0, #4]
   159a2:	e7ee      	b.n	15982 <usb_get_dev_data_by_ep+0x4>
			if (ep_data[i].ep_addr == ep) {
   159a4:	3301      	adds	r3, #1
   159a6:	f812 4033 	ldrb.w	r4, [r2, r3, lsl #3]
   159aa:	428c      	cmp	r4, r1
   159ac:	d1f3      	bne.n	15996 <usb_get_dev_data_by_ep+0x18>
	}

	LOG_DBG("Device data not found for ep %u", ep);

	return NULL;
}
   159ae:	bd30      	pop	{r4, r5, pc}
	return NULL;
   159b0:	4618      	mov	r0, r3
   159b2:	e7fc      	b.n	159ae <usb_get_dev_data_by_ep+0x30>

000159b4 <cdc_interface_config>:
	desc->if0.bInterfaceNumber = bInterfaceNumber;
   159b4:	7081      	strb	r1, [r0, #2]
	desc->if0_union.bControlInterface = bInterfaceNumber;
   159b6:	7681      	strb	r1, [r0, #26]
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   159b8:	3101      	adds	r1, #1
   159ba:	b2c9      	uxtb	r1, r1
   159bc:	f880 1025 	strb.w	r1, [r0, #37]	; 0x25
	desc->if0_union.bSubordinateInterface0 = bInterfaceNumber + 1;
   159c0:	76c1      	strb	r1, [r0, #27]
}
   159c2:	4770      	bx	lr

000159c4 <cdc_acm_irq_callback_work_handler>:
	dev_data->cb(dev_data->cb_data);
   159c4:	e950 3002 	ldrd	r3, r0, [r0, #-8]
   159c8:	4718      	bx	r3

000159ca <cdc_acm_irq_tx_disable>:
	dev_data->tx_irq_ena = false;
   159ca:	6883      	ldr	r3, [r0, #8]
   159cc:	2200      	movs	r2, #0
   159ce:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
}
   159d2:	4770      	bx	lr

000159d4 <cdc_acm_irq_tx_ready>:
	if (dev_data->tx_ready) {
   159d4:	6883      	ldr	r3, [r0, #8]
}
   159d6:	f893 0024 	ldrb.w	r0, [r3, #36]	; 0x24
   159da:	4770      	bx	lr

000159dc <cdc_acm_irq_rx_disable>:
	dev_data->rx_irq_ena = false;
   159dc:	6883      	ldr	r3, [r0, #8]
   159de:	2200      	movs	r2, #0
   159e0:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
}
   159e4:	4770      	bx	lr

000159e6 <cdc_acm_irq_rx_ready>:
	if (dev_data->rx_ready) {
   159e6:	6883      	ldr	r3, [r0, #8]
}
   159e8:	f893 0025 	ldrb.w	r0, [r3, #37]	; 0x25
   159ec:	4770      	bx	lr

000159ee <cdc_acm_irq_is_pending>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   159ee:	6883      	ldr	r3, [r0, #8]
	if (dev_data->tx_ready && dev_data->tx_irq_ena) {
   159f0:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   159f4:	b112      	cbz	r2, 159fc <cdc_acm_irq_is_pending+0xe>
   159f6:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
   159fa:	b92a      	cbnz	r2, 15a08 <cdc_acm_irq_is_pending+0x1a>
	} else if (dev_data->rx_ready && dev_data->rx_irq_ena) {
   159fc:	f893 0025 	ldrb.w	r0, [r3, #37]	; 0x25
   15a00:	b118      	cbz	r0, 15a0a <cdc_acm_irq_is_pending+0x1c>
		return 0;
   15a02:	f893 0027 	ldrb.w	r0, [r3, #39]	; 0x27
   15a06:	4770      	bx	lr
		return 1;
   15a08:	2001      	movs	r0, #1
}
   15a0a:	4770      	bx	lr

00015a0c <cdc_acm_irq_update>:
}
   15a0c:	2001      	movs	r0, #1
   15a0e:	4770      	bx	lr

00015a10 <cdc_acm_irq_callback_set>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   15a10:	6883      	ldr	r3, [r0, #8]
	dev_data->cb_data = cb_data;
   15a12:	e9c3 1201 	strd	r1, r2, [r3, #4]
}
   15a16:	4770      	bx	lr

00015a18 <cdc_acm_line_ctrl_get>:
	switch (ctrl) {
   15a18:	2902      	cmp	r1, #2
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   15a1a:	6883      	ldr	r3, [r0, #8]
	switch (ctrl) {
   15a1c:	d007      	beq.n	15a2e <cdc_acm_line_ctrl_get+0x16>
   15a1e:	2904      	cmp	r1, #4
   15a20:	d00a      	beq.n	15a38 <cdc_acm_line_ctrl_get+0x20>
   15a22:	2901      	cmp	r1, #1
   15a24:	d10d      	bne.n	15a42 <cdc_acm_line_ctrl_get+0x2a>
		*val = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
   15a26:	6f1b      	ldr	r3, [r3, #112]	; 0x70
		*val = (dev_data->line_state &
   15a28:	6013      	str	r3, [r2, #0]
		return 0;
   15a2a:	2000      	movs	r0, #0
   15a2c:	4770      	bx	lr
			SET_CONTROL_LINE_STATE_RTS) ? 1 : 0;
   15a2e:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
   15a32:	f3c3 0340 	ubfx	r3, r3, #1, #1
   15a36:	e7f7      	b.n	15a28 <cdc_acm_line_ctrl_get+0x10>
			SET_CONTROL_LINE_STATE_DTR) ? 1 : 0;
   15a38:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
   15a3c:	f003 0301 	and.w	r3, r3, #1
   15a40:	e7f2      	b.n	15a28 <cdc_acm_line_ctrl_get+0x10>
	switch (ctrl) {
   15a42:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
   15a46:	4770      	bx	lr

00015a48 <cdc_acm_poll_in>:
}
   15a48:	f06f 0022 	mvn.w	r0, #34	; 0x22
   15a4c:	4770      	bx	lr

00015a4e <cdc_acm_fifo_read>:
{
   15a4e:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   15a50:	6884      	ldr	r4, [r0, #8]
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   15a52:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   15a54:	f7ff fb96 	bl	15184 <ring_buf_get>
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   15a58:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   15a5a:	e9d3 2300 	ldrd	r2, r3, [r3]
   15a5e:	429a      	cmp	r2, r3
		dev_data->rx_ready = false;
   15a60:	bf04      	itt	eq
   15a62:	2300      	moveq	r3, #0
   15a64:	f884 3025 	strbeq.w	r3, [r4, #37]	; 0x25
}
   15a68:	bd10      	pop	{r4, pc}

00015a6a <cdc_acm_line_ctrl_set>:
	switch (ctrl) {
   15a6a:	2940      	cmp	r1, #64	; 0x40
{
   15a6c:	b508      	push	{r3, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   15a6e:	6883      	ldr	r3, [r0, #8]
	switch (ctrl) {
   15a70:	d042      	beq.n	15af8 <cdc_acm_line_ctrl_set+0x8e>
   15a72:	d813      	bhi.n	15a9c <cdc_acm_line_ctrl_set+0x32>
   15a74:	2910      	cmp	r1, #16
   15a76:	d032      	beq.n	15ade <cdc_acm_line_ctrl_set+0x74>
   15a78:	d806      	bhi.n	15a88 <cdc_acm_line_ctrl_set+0x1e>
   15a7a:	2901      	cmp	r1, #1
   15a7c:	d01e      	beq.n	15abc <cdc_acm_line_ctrl_set+0x52>
   15a7e:	2908      	cmp	r1, #8
   15a80:	d01f      	beq.n	15ac2 <cdc_acm_line_ctrl_set+0x58>
   15a82:	f06f 0012 	mvn.w	r0, #18
}
   15a86:	bd08      	pop	{r3, pc}
	switch (ctrl) {
   15a88:	2920      	cmp	r1, #32
   15a8a:	d1fa      	bne.n	15a82 <cdc_acm_line_ctrl_set+0x18>
		dev_data->serial_state &= ~SERIAL_STATE_BREAK;
   15a8c:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15a90:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
		if (val) {
   15a94:	b342      	cbz	r2, 15ae8 <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_BREAK;
   15a96:	f041 0104 	orr.w	r1, r1, #4
   15a9a:	e025      	b.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
	switch (ctrl) {
   15a9c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   15aa0:	d033      	beq.n	15b0a <cdc_acm_line_ctrl_set+0xa0>
   15aa2:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   15aa6:	d039      	beq.n	15b1c <cdc_acm_line_ctrl_set+0xb2>
   15aa8:	2980      	cmp	r1, #128	; 0x80
   15aaa:	d1ea      	bne.n	15a82 <cdc_acm_line_ctrl_set+0x18>
		dev_data->serial_state &= ~SERIAL_STATE_FRAMING;
   15aac:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15ab0:	f001 01ef 	and.w	r1, r1, #239	; 0xef
		if (val) {
   15ab4:	b1c2      	cbz	r2, 15ae8 <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_FRAMING;
   15ab6:	f041 0110 	orr.w	r1, r1, #16
   15aba:	e015      	b.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
	dev_data->line_coding.dwDTERate = sys_cpu_to_le32(baudrate);
   15abc:	671a      	str	r2, [r3, #112]	; 0x70
		return 0;
   15abe:	2000      	movs	r0, #0
   15ac0:	e7e1      	b.n	15a86 <cdc_acm_line_ctrl_set+0x1c>
		dev_data->serial_state &= ~SERIAL_STATE_RX_CARRIER;
   15ac2:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15ac6:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
		if (val) {
   15aca:	b92a      	cbnz	r2, 15ad8 <cdc_acm_line_ctrl_set+0x6e>
			dev_data->serial_state |= SERIAL_STATE_RX_CARRIER;
   15acc:	f883 1078 	strb.w	r1, [r3, #120]	; 0x78
		cdc_acm_send_notification(dev, SERIAL_STATE_RX_CARRIER);
   15ad0:	2101      	movs	r1, #1
		cdc_acm_send_notification(dev, dev_data->serial_state);
   15ad2:	f7ee fc4b 	bl	436c <cdc_acm_send_notification>
   15ad6:	e7f2      	b.n	15abe <cdc_acm_line_ctrl_set+0x54>
			dev_data->serial_state |= SERIAL_STATE_RX_CARRIER;
   15ad8:	f041 0101 	orr.w	r1, r1, #1
   15adc:	e7f6      	b.n	15acc <cdc_acm_line_ctrl_set+0x62>
		dev_data->serial_state &= ~SERIAL_STATE_TX_CARRIER;
   15ade:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15ae2:	f001 01fd 	and.w	r1, r1, #253	; 0xfd
		if (val) {
   15ae6:	b922      	cbnz	r2, 15af2 <cdc_acm_line_ctrl_set+0x88>
			dev_data->serial_state |= SERIAL_STATE_OVER_RUN;
   15ae8:	f883 1078 	strb.w	r1, [r3, #120]	; 0x78
		cdc_acm_send_notification(dev, dev_data->serial_state);
   15aec:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15af0:	e7ef      	b.n	15ad2 <cdc_acm_line_ctrl_set+0x68>
			dev_data->serial_state |= SERIAL_STATE_TX_CARRIER;
   15af2:	f041 0102 	orr.w	r1, r1, #2
   15af6:	e7f7      	b.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
		dev_data->serial_state &= ~SERIAL_STATE_RING_SIGNAL;
   15af8:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15afc:	f001 01f7 	and.w	r1, r1, #247	; 0xf7
		if (val) {
   15b00:	2a00      	cmp	r2, #0
   15b02:	d0f1      	beq.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_RING_SIGNAL;
   15b04:	f041 0108 	orr.w	r1, r1, #8
   15b08:	e7ee      	b.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
		dev_data->serial_state &= ~SERIAL_STATE_PARITY;
   15b0a:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15b0e:	f001 01df 	and.w	r1, r1, #223	; 0xdf
		if (val) {
   15b12:	2a00      	cmp	r2, #0
   15b14:	d0e8      	beq.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_PARITY;
   15b16:	f041 0120 	orr.w	r1, r1, #32
   15b1a:	e7e5      	b.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
		dev_data->serial_state &= ~SERIAL_STATE_OVER_RUN;
   15b1c:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
   15b20:	f001 01bf 	and.w	r1, r1, #191	; 0xbf
		if (val) {
   15b24:	2a00      	cmp	r2, #0
   15b26:	d0df      	beq.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_OVER_RUN;
   15b28:	f041 0140 	orr.w	r1, r1, #64	; 0x40
   15b2c:	e7dc      	b.n	15ae8 <cdc_acm_line_ctrl_set+0x7e>

00015b2e <cdc_acm_irq_tx_enable>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   15b2e:	6880      	ldr	r0, [r0, #8]
	dev_data->tx_irq_ena = true;
   15b30:	2301      	movs	r3, #1
   15b32:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
	if (dev_data->cb && dev_data->tx_ready) {
   15b36:	6843      	ldr	r3, [r0, #4]
   15b38:	b12b      	cbz	r3, 15b46 <cdc_acm_irq_tx_enable+0x18>
   15b3a:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   15b3e:	b113      	cbz	r3, 15b46 <cdc_acm_irq_tx_enable+0x18>
	k_work_submit_to_queue(&k_sys_work_q, work);
   15b40:	300c      	adds	r0, #12
   15b42:	f7ee bc63 	b.w	440c <k_work_submit_to_queue.constprop.0>
}
   15b46:	4770      	bx	lr

00015b48 <cdc_acm_irq_rx_enable>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
   15b48:	6880      	ldr	r0, [r0, #8]
	dev_data->rx_irq_ena = true;
   15b4a:	2301      	movs	r3, #1
   15b4c:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
	if (dev_data->cb && dev_data->rx_ready) {
   15b50:	6843      	ldr	r3, [r0, #4]
   15b52:	b12b      	cbz	r3, 15b60 <cdc_acm_irq_rx_enable+0x18>
   15b54:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
   15b58:	b113      	cbz	r3, 15b60 <cdc_acm_irq_rx_enable+0x18>
   15b5a:	300c      	adds	r0, #12
   15b5c:	f7ee bc56 	b.w	440c <k_work_submit_to_queue.constprop.0>
}
   15b60:	4770      	bx	lr

00015b62 <z_impl_flash_write_protection_set>:
						   bool enable)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_protection(dev, enable);
   15b62:	6843      	ldr	r3, [r0, #4]
   15b64:	68db      	ldr	r3, [r3, #12]
   15b66:	4718      	bx	r3

00015b68 <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
   15b68:	4770      	bx	lr

00015b6a <flash_area_read>:
}
#endif /* CONFIG_FLASH_PAGE_LAYOUT */

int flash_area_read(const struct flash_area *fa, off_t off, void *dst,
		    size_t len)
{
   15b6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15b6e:	461e      	mov	r6, r3
	struct device *dev;

	if (!is_in_flash_area_bounds(fa, off, len)) {
   15b70:	6883      	ldr	r3, [r0, #8]
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   15b72:	428b      	cmp	r3, r1
{
   15b74:	4605      	mov	r5, r0
   15b76:	460c      	mov	r4, r1
   15b78:	4617      	mov	r7, r2
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   15b7a:	d30f      	bcc.n	15b9c <flash_area_read+0x32>
   15b7c:	1872      	adds	r2, r6, r1
   15b7e:	4293      	cmp	r3, r2
   15b80:	d30c      	bcc.n	15b9c <flash_area_read+0x32>
		return -EINVAL;
	}

	dev = device_get_binding(fa->fa_dev_name);
   15b82:	68c0      	ldr	r0, [r0, #12]
   15b84:	f7fd fd72 	bl	1366c <z_impl_device_get_binding>

	return flash_read(dev, fa->fa_off + off, dst, len);
   15b88:	6869      	ldr	r1, [r5, #4]
   15b8a:	4421      	add	r1, r4
	return api->read(dev, offset, data, len);
   15b8c:	6843      	ldr	r3, [r0, #4]
   15b8e:	681c      	ldr	r4, [r3, #0]
   15b90:	463a      	mov	r2, r7
   15b92:	4633      	mov	r3, r6
   15b94:	46a4      	mov	ip, r4
}
   15b96:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   15b9a:	4760      	bx	ip
   15b9c:	f06f 0015 	mvn.w	r0, #21
   15ba0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00015ba4 <flash_area_write>:

int flash_area_write(const struct flash_area *fa, off_t off, const void *src,
		     size_t len)
{
   15ba4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15ba8:	4698      	mov	r8, r3
	struct device *flash_dev;
	int rc;

	if (!is_in_flash_area_bounds(fa, off, len)) {
   15baa:	6883      	ldr	r3, [r0, #8]
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   15bac:	428b      	cmp	r3, r1
{
   15bae:	4607      	mov	r7, r0
   15bb0:	460d      	mov	r5, r1
   15bb2:	4691      	mov	r9, r2
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   15bb4:	d31c      	bcc.n	15bf0 <flash_area_write+0x4c>
   15bb6:	eb08 0201 	add.w	r2, r8, r1
   15bba:	4293      	cmp	r3, r2
   15bbc:	d318      	bcc.n	15bf0 <flash_area_write+0x4c>
		return -EINVAL;
	}

	flash_dev = device_get_binding(fa->fa_dev_name);
   15bbe:	68c0      	ldr	r0, [r0, #12]
   15bc0:	f7fd fd54 	bl	1366c <z_impl_device_get_binding>
   15bc4:	4606      	mov	r6, r0
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&enable, K_SYSCALL_FLASH_WRITE_PROTECTION_SET);
	}
#endif
	compiler_barrier();
	return z_impl_flash_write_protection_set(dev, enable);
   15bc6:	2100      	movs	r1, #0
   15bc8:	f7ff ffcb 	bl	15b62 <z_impl_flash_write_protection_set>

	rc = flash_write_protection_set(flash_dev, false);
	if (rc) {
   15bcc:	4604      	mov	r4, r0
   15bce:	b960      	cbnz	r0, 15bea <flash_area_write+0x46>
		return rc;
	}

	rc = flash_write(flash_dev, fa->fa_off + off, (void *)src, len);
   15bd0:	6879      	ldr	r1, [r7, #4]
   15bd2:	4429      	add	r1, r5
	return api->write(dev, offset, data, len);
   15bd4:	6873      	ldr	r3, [r6, #4]
   15bd6:	464a      	mov	r2, r9
   15bd8:	685c      	ldr	r4, [r3, #4]
   15bda:	4630      	mov	r0, r6
   15bdc:	4643      	mov	r3, r8
   15bde:	47a0      	blx	r4
   15be0:	4604      	mov	r4, r0
   15be2:	2101      	movs	r1, #1
   15be4:	4630      	mov	r0, r6
   15be6:	f7ff ffbc 	bl	15b62 <z_impl_flash_write_protection_set>

	/* Ignore errors here - this does not affect write operation */
	(void) flash_write_protection_set(flash_dev, true);

	return rc;
}
   15bea:	4620      	mov	r0, r4
   15bec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EINVAL;
   15bf0:	f06f 0415 	mvn.w	r4, #21
   15bf4:	e7f9      	b.n	15bea <flash_area_write+0x46>

00015bf6 <flash_area_erase>:
int flash_area_erase(const struct flash_area *fa, off_t off, size_t len)
{
	struct device *flash_dev;
	int rc;

	if (!is_in_flash_area_bounds(fa, off, len)) {
   15bf6:	6883      	ldr	r3, [r0, #8]
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   15bf8:	428b      	cmp	r3, r1
{
   15bfa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15bfe:	4607      	mov	r7, r0
   15c00:	460d      	mov	r5, r1
   15c02:	4690      	mov	r8, r2
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   15c04:	d31a      	bcc.n	15c3c <flash_area_erase+0x46>
   15c06:	440a      	add	r2, r1
   15c08:	4293      	cmp	r3, r2
   15c0a:	d317      	bcc.n	15c3c <flash_area_erase+0x46>
		return -EINVAL;
	}

	flash_dev = device_get_binding(fa->fa_dev_name);
   15c0c:	68c0      	ldr	r0, [r0, #12]
   15c0e:	f7fd fd2d 	bl	1366c <z_impl_device_get_binding>
   15c12:	4606      	mov	r6, r0
   15c14:	2100      	movs	r1, #0
   15c16:	f7ff ffa4 	bl	15b62 <z_impl_flash_write_protection_set>

	rc = flash_write_protection_set(flash_dev, false);
	if (rc) {
   15c1a:	4604      	mov	r4, r0
   15c1c:	b958      	cbnz	r0, 15c36 <flash_area_erase+0x40>
		return rc;
	}

	rc = flash_erase(flash_dev, fa->fa_off + off, len);
   15c1e:	6879      	ldr	r1, [r7, #4]
   15c20:	4429      	add	r1, r5
	return api->erase(dev, offset, size);
   15c22:	6873      	ldr	r3, [r6, #4]
   15c24:	4642      	mov	r2, r8
   15c26:	689b      	ldr	r3, [r3, #8]
   15c28:	4630      	mov	r0, r6
   15c2a:	4798      	blx	r3
   15c2c:	4604      	mov	r4, r0
   15c2e:	2101      	movs	r1, #1
   15c30:	4630      	mov	r0, r6
   15c32:	f7ff ff96 	bl	15b62 <z_impl_flash_write_protection_set>

	/* Ignore errors here - this does not affect write operation */
	(void) flash_write_protection_set(flash_dev, true);

	return rc;
}
   15c36:	4620      	mov	r0, r4
   15c38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EINVAL;
   15c3c:	f06f 0415 	mvn.w	r4, #21
   15c40:	e7f9      	b.n	15c36 <flash_area_erase+0x40>

00015c42 <flash_area_get_device>:
	return 1;
}

struct device *flash_area_get_device(const struct flash_area *fa)
{
	return device_get_binding(fa->fa_dev_name);
   15c42:	68c0      	ldr	r0, [r0, #12]
   15c44:	f7fd bd12 	b.w	1366c <z_impl_device_get_binding>

00015c48 <get_status>:
	data = get_sub_data(dev, type);
   15c48:	6883      	ldr	r3, [r0, #8]
	return &data->subsys[type];
   15c4a:	b2c9      	uxtb	r1, r1
	if (data->started) {
   15c4c:	220c      	movs	r2, #12
   15c4e:	fb02 3101 	mla	r1, r2, r1, r3
   15c52:	7a4b      	ldrb	r3, [r1, #9]
   15c54:	b923      	cbnz	r3, 15c60 <get_status+0x18>
	if (data->ref > 0) {
   15c56:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   15c58:	fab0 f080 	clz	r0, r0
   15c5c:	0940      	lsrs	r0, r0, #5
   15c5e:	4770      	bx	lr
   15c60:	2002      	movs	r0, #2
}
   15c62:	4770      	bx	lr

00015c64 <clock_stop>:
	const struct nrf_clock_control_config *config =
   15c64:	6803      	ldr	r3, [r0, #0]
{
   15c66:	b570      	push	{r4, r5, r6, lr}
   15c68:	b2c9      	uxtb	r1, r1
	const struct nrf_clock_control_config *config =
   15c6a:	689c      	ldr	r4, [r3, #8]
	data = get_sub_data(dev, type);
   15c6c:	6885      	ldr	r5, [r0, #8]
	__asm__ volatile(
   15c6e:	f04f 0320 	mov.w	r3, #32
   15c72:	f3ef 8611 	mrs	r6, BASEPRI
   15c76:	f383 8811 	msr	BASEPRI, r3
   15c7a:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   15c7e:	220c      	movs	r2, #12
   15c80:	434a      	muls	r2, r1
   15c82:	18ab      	adds	r3, r5, r2
   15c84:	7a18      	ldrb	r0, [r3, #8]
   15c86:	b190      	cbz	r0, 15cae <clock_stop+0x4a>
	data->ref--;
   15c88:	3801      	subs	r0, #1
   15c8a:	b2c0      	uxtb	r0, r0
   15c8c:	7218      	strb	r0, [r3, #8]
	if (data->ref == 0) {
   15c8e:	b988      	cbnz	r0, 15cb4 <clock_stop+0x50>
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   15c90:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	list->head = NULL;
   15c94:	50a8      	str	r0, [r5, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   15c96:	78ca      	ldrb	r2, [r1, #3]
	list->tail = NULL;
   15c98:	6058      	str	r0, [r3, #4]
   15c9a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   15c9e:	2101      	movs	r1, #1
   15ca0:	6011      	str	r1, [r2, #0]
		data->started = false;
   15ca2:	7258      	strb	r0, [r3, #9]
	__asm__ volatile(
   15ca4:	f386 8811 	msr	BASEPRI, r6
   15ca8:	f3bf 8f6f 	isb	sy
}
   15cac:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
   15cae:	f06f 0044 	mvn.w	r0, #68	; 0x44
   15cb2:	e7f7      	b.n	15ca4 <clock_stop+0x40>
	int err = 0;
   15cb4:	2000      	movs	r0, #0
   15cb6:	e7f5      	b.n	15ca4 <clock_stop+0x40>

00015cb8 <clock_async_start>:
{
   15cb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct nrf_clock_control_config *config =
   15cbc:	6803      	ldr	r3, [r0, #0]
	clk_data = get_sub_data(dev, type);
   15cbe:	f8d0 e008 	ldr.w	lr, [r0, #8]
	const struct nrf_clock_control_config *config =
   15cc2:	689e      	ldr	r6, [r3, #8]
	return &config->subsys[type];
   15cc4:	b2cf      	uxtb	r7, r1
	if ((data != NULL)
   15cc6:	b14a      	cbz	r2, 15cdc <clock_async_start+0x24>
	sys_snode_t *item = sys_slist_peek_head(list);
   15cc8:	230c      	movs	r3, #12
   15cca:	437b      	muls	r3, r7
   15ccc:	f85e 3003 	ldr.w	r3, [lr, r3]
		if (item == node) {
   15cd0:	429a      	cmp	r2, r3
   15cd2:	d053      	beq.n	15d7c <clock_async_start+0xc4>
Z_GENLIST_PEEK_NEXT(slist, snode)
   15cd4:	b113      	cbz	r3, 15cdc <clock_async_start+0x24>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   15cd6:	681b      	ldr	r3, [r3, #0]
	} while (item);
   15cd8:	2b00      	cmp	r3, #0
   15cda:	d1f9      	bne.n	15cd0 <clock_async_start+0x18>
	__asm__ volatile(
   15cdc:	f04f 0320 	mov.w	r3, #32
   15ce0:	f3ef 8c11 	mrs	ip, BASEPRI
   15ce4:	f383 8811 	msr	BASEPRI, r3
   15ce8:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   15cec:	250c      	movs	r5, #12
   15cee:	437d      	muls	r5, r7
   15cf0:	eb0e 0305 	add.w	r3, lr, r5
   15cf4:	7a1c      	ldrb	r4, [r3, #8]
   15cf6:	3401      	adds	r4, #1
   15cf8:	b2e4      	uxtb	r4, r4
   15cfa:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
   15cfc:	f38c 8811 	msr	BASEPRI, ip
   15d00:	f3bf 8f6f 	isb	sy
	if (data) {
   15d04:	b362      	cbz	r2, 15d60 <clock_async_start+0xa8>
    p_reg->INTENCLR = mask;
   15d06:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
   15d0a:	f240 3883 	movw	r8, #899	; 0x383
   15d0e:	f8cc 8308 	str.w	r8, [ip, #776]	; 0x308
		already_started = clk_data->started;
   15d12:	f893 c009 	ldrb.w	ip, [r3, #9]
		if (!already_started) {
   15d16:	f1bc 0f00 	cmp.w	ip, #0
   15d1a:	d115      	bne.n	15d48 <clock_async_start+0x90>
	__asm__ volatile(
   15d1c:	f04f 0820 	mov.w	r8, #32
   15d20:	f3ef 8911 	mrs	r9, BASEPRI
   15d24:	f388 8811 	msr	BASEPRI, r8
   15d28:	f3bf 8f6f 	isb	sy
	parent->next = child;
   15d2c:	f8c2 c000 	str.w	ip, [r2]
Z_GENLIST_APPEND(slist, snode)
   15d30:	f8d3 8004 	ldr.w	r8, [r3, #4]
   15d34:	f1b8 0f00 	cmp.w	r8, #0
   15d38:	d11c      	bne.n	15d74 <clock_async_start+0xbc>
	list->tail = node;
   15d3a:	605a      	str	r2, [r3, #4]
	list->head = node;
   15d3c:	f84e 2005 	str.w	r2, [lr, r5]
	__asm__ volatile(
   15d40:	f389 8811 	msr	BASEPRI, r9
   15d44:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   15d48:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   15d4c:	f240 3583 	movw	r5, #899	; 0x383
   15d50:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
		if (already_started) {
   15d54:	f1bc 0f00 	cmp.w	ip, #0
   15d58:	d002      	beq.n	15d60 <clock_async_start+0xa8>
			data->cb(dev, subsys, data->user_data);
   15d5a:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
   15d5e:	4798      	blx	r3
	if (ref == 1) {
   15d60:	2c01      	cmp	r4, #1
   15d62:	d105      	bne.n	15d70 <clock_async_start+0xb8>
		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
   15d64:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   15d68:	78b3      	ldrb	r3, [r6, #2]
   15d6a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   15d6e:	601c      	str	r4, [r3, #0]
	return 0;
   15d70:	2000      	movs	r0, #0
   15d72:	e005      	b.n	15d80 <clock_async_start+0xc8>
	parent->next = child;
   15d74:	f8c8 2000 	str.w	r2, [r8]
	list->tail = node;
   15d78:	605a      	str	r2, [r3, #4]
}
   15d7a:	e7e1      	b.n	15d40 <clock_async_start+0x88>
		return -EBUSY;
   15d7c:	f06f 000f 	mvn.w	r0, #15
}
   15d80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00015d84 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   15d84:	2200      	movs	r2, #0
   15d86:	f7ff bf97 	b.w	15cb8 <clock_async_start>

00015d8a <clk_init>:
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   15d8a:	2200      	movs	r2, #0
{
   15d8c:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   15d8e:	2101      	movs	r1, #1
{
   15d90:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   15d92:	4610      	mov	r0, r2
   15d94:	f7ef fed2 	bl	5b3c <z_arm_irq_priority_set>
	irq_enable(DT_INST_IRQN(0));
   15d98:	2000      	movs	r0, #0
   15d9a:	f7ef fe9d 	bl	5ad8 <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   15d9e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   15da2:	2201      	movs	r2, #1
   15da4:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   15da8:	f240 3283 	movw	r2, #899	; 0x383
   15dac:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		sys_slist_init(&(get_sub_data(dev, i)->list));
   15db0:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
   15db2:	2000      	movs	r0, #0
	list->tail = NULL;
   15db4:	e9c3 0000 	strd	r0, r0, [r3]
   15db8:	68a3      	ldr	r3, [r4, #8]
   15dba:	e9c3 0003 	strd	r0, r0, [r3, #12]
}
   15dbe:	bd10      	pop	{r4, pc}

00015dc0 <power_event_check_and_clean>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   15dc0:	f100 4280 	add.w	r2, r0, #1073741824	; 0x40000000
{
   15dc4:	b082      	sub	sp, #8
   15dc6:	6810      	ldr	r0, [r2, #0]
	bool ret = nrf_power_event_check(NRF_POWER, evt) &&
   15dc8:	b158      	cbz	r0, 15de2 <power_event_check_and_clean+0x22>
    return p_reg->INTENSET & mask;
   15dca:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   15dce:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
	if (ret) {
   15dd2:	4008      	ands	r0, r1
   15dd4:	d005      	beq.n	15de2 <power_event_check_and_clean+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   15dd6:	2300      	movs	r3, #0
   15dd8:	6013      	str	r3, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   15dda:	6813      	ldr	r3, [r2, #0]
   15ddc:	9301      	str	r3, [sp, #4]
    (void)dummy;
   15dde:	9b01      	ldr	r3, [sp, #4]
	bool ret = nrf_power_event_check(NRF_POWER, evt) &&
   15de0:	2001      	movs	r0, #1
}
   15de2:	b002      	add	sp, #8
   15de4:	4770      	bx	lr

00015de6 <nrf5_power_usb_power_int_enable>:

	mask = NRF_POWER_INT_USBDETECTED_MASK |
	       NRF_POWER_INT_USBREMOVED_MASK |
	       NRF_POWER_INT_USBPWRRDY_MASK;

	if (enable) {
   15de6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   15dea:	f44f 7260 	mov.w	r2, #896	; 0x380
   15dee:	b120      	cbz	r0, 15dfa <nrf5_power_usb_power_int_enable+0x14>
    p_reg->INTENSET = mask;
   15df0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_power_int_enable(NRF_POWER, mask);
		irq_enable(DT_INST_IRQN(0));
   15df4:	2000      	movs	r0, #0
   15df6:	f7ef be6f 	b.w	5ad8 <arch_irq_enable>
    p_reg->INTENCLR = mask;
   15dfa:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	} else {
		nrf_power_int_disable(NRF_POWER, mask);
	}
}
   15dfe:	4770      	bx	lr

00015e00 <k_mutex_unlock>:
	return z_impl_k_mutex_unlock(mutex);
   15e00:	f7fd bed8 	b.w	13bb4 <z_impl_k_mutex_unlock>

00015e04 <k_mutex_lock.constprop.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
   15e04:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   15e08:	f7fd be62 	b.w	13ad0 <z_impl_k_mutex_lock>

00015e0c <usb_dc_ep_read>:
{
   15e0c:	b570      	push	{r4, r5, r6, lr}
   15e0e:	4604      	mov	r4, r0
   15e10:	460e      	mov	r6, r1
   15e12:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
   15e14:	f7ef fb98 	bl	5548 <usb_dc_ep_read_wait>
	if (ret) {
   15e18:	b930      	cbnz	r0, 15e28 <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
   15e1a:	b906      	cbnz	r6, 15e1e <usb_dc_ep_read+0x12>
   15e1c:	b125      	cbz	r5, 15e28 <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
   15e1e:	4620      	mov	r0, r4
}
   15e20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
   15e24:	f7ef bbe8 	b.w	55f8 <usb_dc_ep_read_continue>
}
   15e28:	bd70      	pop	{r4, r5, r6, pc}

00015e2a <z_impl_hwinfo_get_device_id>:
struct nrf_uid {
	u32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(u8_t *buffer, size_t length)
{
   15e2a:	b573      	push	{r0, r1, r4, r5, r6, lr}
NRF_STATIC_INLINE uint32_t nrf_ficr_deviceid_get(NRF_FICR_Type const * p_reg, uint32_t reg_id)
{
#if defined(FICR_INFO_DEVICEID_DEVICEID_Msk)
    return p_reg->INFO.DEVICEID[reg_id];
#else
    return p_reg->DEVICEID[reg_id];
   15e2c:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
   15e30:	2908      	cmp	r1, #8
   15e32:	6e66      	ldr	r6, [r4, #100]	; 0x64
   15e34:	6e65      	ldr	r5, [r4, #100]	; 0x64
   15e36:	6e62      	ldr	r2, [r4, #100]	; 0x64
   15e38:	6e63      	ldr	r3, [r4, #100]	; 0x64
	struct nrf_uid dev_id;

	dev_id.id[0] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 1));
   15e3a:	ea4f 2515 	mov.w	r5, r5, lsr #8
   15e3e:	ea4f 6303 	mov.w	r3, r3, lsl #24
   15e42:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
   15e46:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
   15e4a:	ea4f 2202 	mov.w	r2, r2, lsl #8
   15e4e:	ea43 0305 	orr.w	r3, r3, r5
   15e52:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
   15e56:	ea43 0302 	orr.w	r3, r3, r2
   15e5a:	9300      	str	r3, [sp, #0]
   15e5c:	6e26      	ldr	r6, [r4, #96]	; 0x60
   15e5e:	6e25      	ldr	r5, [r4, #96]	; 0x60
   15e60:	6e22      	ldr	r2, [r4, #96]	; 0x60
   15e62:	6e23      	ldr	r3, [r4, #96]	; 0x60
	dev_id.id[1] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 0));
   15e64:	ea4f 2415 	mov.w	r4, r5, lsr #8
   15e68:	ea4f 6303 	mov.w	r3, r3, lsl #24
   15e6c:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
   15e70:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
   15e74:	ea43 0304 	orr.w	r3, r3, r4
   15e78:	ea4f 2402 	mov.w	r4, r2, lsl #8
   15e7c:	bf28      	it	cs
   15e7e:	2108      	movcs	r1, #8
   15e80:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
   15e84:	4323      	orrs	r3, r4

	if (length > sizeof(dev_id.id)) {
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
   15e86:	460a      	mov	r2, r1
   15e88:	460c      	mov	r4, r1
   15e8a:	4669      	mov	r1, sp
	dev_id.id[1] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 0));
   15e8c:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
   15e8e:	f000 f8d4 	bl	1603a <memcpy>

	return length;
}
   15e92:	4620      	mov	r0, r4
   15e94:	b002      	add	sp, #8
   15e96:	bd70      	pop	{r4, r5, r6, pc}

00015e98 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   15e98:	4770      	bx	lr

00015e9a <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   15e9a:	4770      	bx	lr

00015e9c <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
   15e9c:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
   15e9e:	68c1      	ldr	r1, [r0, #12]
  if (RdOff <= WrOff) {
   15ea0:	428b      	cmp	r3, r1
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   15ea2:	bf9d      	ittte	ls
   15ea4:	6882      	ldrls	r2, [r0, #8]
   15ea6:	18d2      	addls	r2, r2, r3
   15ea8:	f102 32ff 	addls.w	r2, r2, #4294967295	; 0xffffffff
    r = RdOff - WrOff - 1u;
   15eac:	f103 33ff 	addhi.w	r3, r3, #4294967295	; 0xffffffff
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   15eb0:	bf94      	ite	ls
   15eb2:	1a50      	subls	r0, r2, r1
    r = RdOff - WrOff - 1u;
   15eb4:	1a58      	subhi	r0, r3, r1
}
   15eb6:	4770      	bx	lr

00015eb8 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
   15eb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  Rem = pRing->SizeOfBuffer - WrOff;
   15ebc:	e9d0 9402 	ldrd	r9, r4, [r0, #8]
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
   15ec0:	4605      	mov	r5, r0
  Rem = pRing->SizeOfBuffer - WrOff;
   15ec2:	eba9 0804 	sub.w	r8, r9, r4
  if (Rem > NumBytes) {
   15ec6:	6840      	ldr	r0, [r0, #4]
   15ec8:	4590      	cmp	r8, r2
   15eca:	4420      	add	r0, r4
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
   15ecc:	460f      	mov	r7, r1
   15ece:	4414      	add	r4, r2
  if (Rem > NumBytes) {
   15ed0:	d904      	bls.n	15edc <_WriteNoCheck+0x24>
    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
   15ed2:	f000 f8b2 	bl	1603a <memcpy>
    pRing->WrOff = NumBytesAtOnce;
   15ed6:	60ec      	str	r4, [r5, #12]
}
   15ed8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   15edc:	4642      	mov	r2, r8
    NumBytesAtOnce = NumBytes - Rem;
   15ede:	eba4 0409 	sub.w	r4, r4, r9
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   15ee2:	f000 f8aa 	bl	1603a <memcpy>
    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
   15ee6:	6868      	ldr	r0, [r5, #4]
   15ee8:	4622      	mov	r2, r4
   15eea:	eb07 0108 	add.w	r1, r7, r8
   15eee:	e7f0      	b.n	15ed2 <_WriteNoCheck+0x1a>

00015ef0 <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
   15ef0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  WrOff = pRing->WrOff;
   15ef4:	68c5      	ldr	r5, [r0, #12]
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
   15ef6:	4606      	mov	r6, r0
   15ef8:	4689      	mov	r9, r1
   15efa:	4617      	mov	r7, r2
  NumBytesWritten = 0u;
   15efc:	f04f 0800 	mov.w	r8, #0
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
   15f00:	6934      	ldr	r4, [r6, #16]
    if (RdOff > WrOff) {
   15f02:	68b3      	ldr	r3, [r6, #8]
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   15f04:	6870      	ldr	r0, [r6, #4]
    if (RdOff > WrOff) {
   15f06:	42a5      	cmp	r5, r4
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
   15f08:	bf28      	it	cs
   15f0a:	18e4      	addcs	r4, r4, r3
   15f0c:	3c01      	subs	r4, #1
   15f0e:	1b62      	subs	r2, r4, r5
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
   15f10:	1b5c      	subs	r4, r3, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
   15f12:	42bc      	cmp	r4, r7
   15f14:	bf28      	it	cs
   15f16:	463c      	movcs	r4, r7
   15f18:	4294      	cmp	r4, r2
   15f1a:	bf28      	it	cs
   15f1c:	4614      	movcs	r4, r2
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   15f1e:	4649      	mov	r1, r9
   15f20:	4428      	add	r0, r5
   15f22:	4622      	mov	r2, r4
   15f24:	f000 f889 	bl	1603a <memcpy>
    if (WrOff == pRing->SizeOfBuffer) {
   15f28:	68b3      	ldr	r3, [r6, #8]
    WrOff           += NumBytesToWrite;
   15f2a:	4425      	add	r5, r4
      WrOff = 0u;
   15f2c:	42ab      	cmp	r3, r5
   15f2e:	bf08      	it	eq
   15f30:	2500      	moveq	r5, #0
  } while (NumBytes);
   15f32:	1b3f      	subs	r7, r7, r4
    NumBytesWritten += NumBytesToWrite;
   15f34:	44a0      	add	r8, r4
    pBuffer         += NumBytesToWrite;
   15f36:	44a1      	add	r9, r4
    pRing->WrOff = WrOff;
   15f38:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
   15f3a:	d1e1      	bne.n	15f00 <_WriteBlocking+0x10>
}
   15f3c:	4640      	mov	r0, r8
   15f3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00015f42 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   15f42:	f7ef bcc1 	b.w	58c8 <_DoInit>

00015f46 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
   15f46:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   15f48:	f7ff fffb 	bl	15f42 <SEGGER_RTT_Init>

	return 0;
}
   15f4c:	2000      	movs	r0, #0
   15f4e:	bd08      	pop	{r3, pc}

00015f50 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   15f50:	2100      	movs	r1, #0
   15f52:	2001      	movs	r0, #1
   15f54:	f7ef be62 	b.w	5c1c <z_arm_fatal_error>

00015f58 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   15f58:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   15f5a:	6800      	ldr	r0, [r0, #0]
   15f5c:	f7ef be5e 	b.w	5c1c <z_arm_fatal_error>

00015f60 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   15f60:	b508      	push	{r3, lr}
	handler();
   15f62:	f7ef fe93 	bl	5c8c <z_SysNmiOnReset>
	z_arm_int_exit();
}
   15f66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   15f6a:	f7f0 b8fb 	b.w	6164 <z_arm_exc_exit>

00015f6e <malloc>:
}

SYS_INIT(malloc_prepare, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
   15f6e:	b508      	push	{r3, lr}
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   15f70:	f7fd fba2 	bl	136b8 <z_impl_z_errno>
	ARG_UNUSED(size);

	LOG_DBG("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
	errno = ENOMEM;
   15f74:	230c      	movs	r3, #12
   15f76:	6003      	str	r3, [r0, #0]

	return NULL;
}
   15f78:	2000      	movs	r0, #0
   15f7a:	bd08      	pop	{r3, pc}

00015f7c <free>:
	return new_ptr;
}

void free(void *ptr)
{
	sys_mem_pool_free(ptr);
   15f7c:	f7fe bd96 	b.w	14aac <sys_mem_pool_free>

00015f80 <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   15f80:	3901      	subs	r1, #1
   15f82:	4603      	mov	r3, r0
   15f84:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   15f88:	b90a      	cbnz	r2, 15f8e <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   15f8a:	701a      	strb	r2, [r3, #0]

	return dest;
}
   15f8c:	4770      	bx	lr
		*d = *s;
   15f8e:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   15f92:	e7f7      	b.n	15f84 <strcpy+0x4>

00015f94 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
   15f94:	b570      	push	{r4, r5, r6, lr}
   15f96:	3901      	subs	r1, #1
   15f98:	4605      	mov	r5, r0
   15f9a:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   15f9c:	b142      	cbz	r2, 15fb0 <strncpy+0x1c>
   15f9e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   15fa2:	1e56      	subs	r6, r2, #1
   15fa4:	b92b      	cbnz	r3, 15fb2 <strncpy+0x1e>
   15fa6:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   15fa8:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   15fac:	42a2      	cmp	r2, r4
   15fae:	d1fb      	bne.n	15fa8 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   15fb0:	bd70      	pop	{r4, r5, r6, pc}
		*d = *s;
   15fb2:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   15fb6:	4632      	mov	r2, r6
   15fb8:	e7ef      	b.n	15f9a <strncpy+0x6>

00015fba <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
   15fba:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
   15fbc:	4603      	mov	r3, r0
   15fbe:	781a      	ldrb	r2, [r3, #0]
   15fc0:	428a      	cmp	r2, r1
   15fc2:	4618      	mov	r0, r3
   15fc4:	f103 0301 	add.w	r3, r3, #1
   15fc8:	d004      	beq.n	15fd4 <strchr+0x1a>
   15fca:	2a00      	cmp	r2, #0
   15fcc:	d1f7      	bne.n	15fbe <strchr+0x4>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
   15fce:	2900      	cmp	r1, #0
   15fd0:	bf18      	it	ne
   15fd2:	2000      	movne	r0, #0
}
   15fd4:	4770      	bx	lr

00015fd6 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   15fd6:	4603      	mov	r3, r0
	size_t n = 0;
   15fd8:	2000      	movs	r0, #0

	while (*s != '\0') {
   15fda:	5c1a      	ldrb	r2, [r3, r0]
   15fdc:	b902      	cbnz	r2, 15fe0 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   15fde:	4770      	bx	lr
		n++;
   15fe0:	3001      	adds	r0, #1
   15fe2:	e7fa      	b.n	15fda <strlen+0x4>

00015fe4 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   15fe4:	1e43      	subs	r3, r0, #1
   15fe6:	3901      	subs	r1, #1
   15fe8:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   15fec:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   15ff0:	4282      	cmp	r2, r0
   15ff2:	d101      	bne.n	15ff8 <strcmp+0x14>
   15ff4:	2a00      	cmp	r2, #0
   15ff6:	d1f7      	bne.n	15fe8 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   15ff8:	1a10      	subs	r0, r2, r0
   15ffa:	4770      	bx	lr

00015ffc <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   15ffc:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   15ffe:	2400      	movs	r4, #0
   16000:	42a2      	cmp	r2, r4
   16002:	d008      	beq.n	16016 <strncmp+0x1a>
   16004:	5d03      	ldrb	r3, [r0, r4]
   16006:	5d0d      	ldrb	r5, [r1, r4]
   16008:	42ab      	cmp	r3, r5
   1600a:	d102      	bne.n	16012 <strncmp+0x16>
   1600c:	3401      	adds	r4, #1
   1600e:	2b00      	cmp	r3, #0
   16010:	d1f6      	bne.n	16000 <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   16012:	1b58      	subs	r0, r3, r5
   16014:	e000      	b.n	16018 <strncmp+0x1c>
   16016:	2000      	movs	r0, #0
}
   16018:	bd30      	pop	{r4, r5, pc}

0001601a <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   1601a:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   1601c:	b15a      	cbz	r2, 16036 <memcmp+0x1c>
   1601e:	3901      	subs	r1, #1
   16020:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   16022:	f810 2b01 	ldrb.w	r2, [r0], #1
   16026:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1602a:	42a0      	cmp	r0, r4
   1602c:	d001      	beq.n	16032 <memcmp+0x18>
   1602e:	429a      	cmp	r2, r3
   16030:	d0f7      	beq.n	16022 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   16032:	1ad0      	subs	r0, r2, r3
}
   16034:	bd10      	pop	{r4, pc}
		return 0;
   16036:	4610      	mov	r0, r2
   16038:	e7fc      	b.n	16034 <memcmp+0x1a>

0001603a <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   1603a:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   1603c:	ea81 0400 	eor.w	r4, r1, r0
   16040:	07a5      	lsls	r5, r4, #30
   16042:	4603      	mov	r3, r0
   16044:	d00b      	beq.n	1605e <memcpy+0x24>
   16046:	3b01      	subs	r3, #1
   16048:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   1604a:	4291      	cmp	r1, r2
   1604c:	d11b      	bne.n	16086 <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   1604e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
   16050:	2a00      	cmp	r2, #0
   16052:	d0fc      	beq.n	1604e <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
   16054:	f811 4b01 	ldrb.w	r4, [r1], #1
   16058:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
   1605c:	3a01      	subs	r2, #1
		while (((uintptr_t)d_byte) & mask) {
   1605e:	079c      	lsls	r4, r3, #30
   16060:	d1f6      	bne.n	16050 <memcpy+0x16>
   16062:	f022 0403 	bic.w	r4, r2, #3
   16066:	1f1d      	subs	r5, r3, #4
   16068:	0896      	lsrs	r6, r2, #2
   1606a:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
   1606c:	42b9      	cmp	r1, r7
   1606e:	d105      	bne.n	1607c <memcpy+0x42>
   16070:	f06f 0503 	mvn.w	r5, #3
   16074:	fb05 2206 	mla	r2, r5, r6, r2
   16078:	4423      	add	r3, r4
   1607a:	e7e4      	b.n	16046 <memcpy+0xc>
			*(d_word++) = *(s_word++);
   1607c:	f851 cb04 	ldr.w	ip, [r1], #4
   16080:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
   16084:	e7f2      	b.n	1606c <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
   16086:	f811 4b01 	ldrb.w	r4, [r1], #1
   1608a:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   1608e:	e7dc      	b.n	1604a <memcpy+0x10>

00016090 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
   16090:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   16092:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
   16094:	4603      	mov	r3, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   16096:	079c      	lsls	r4, r3, #30
   16098:	d111      	bne.n	160be <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
   1609a:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   1609e:	f022 0603 	bic.w	r6, r2, #3
   160a2:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   160a6:	441e      	add	r6, r3
   160a8:	0894      	lsrs	r4, r2, #2
   160aa:	42b3      	cmp	r3, r6
   160ac:	d10d      	bne.n	160ca <memset+0x3a>
   160ae:	f06f 0503 	mvn.w	r5, #3
   160b2:	fb05 2204 	mla	r2, r5, r4, r2
   160b6:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   160b8:	4293      	cmp	r3, r2
   160ba:	d109      	bne.n	160d0 <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   160bc:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   160be:	2a00      	cmp	r2, #0
   160c0:	d0fc      	beq.n	160bc <memset+0x2c>
		*(d_byte++) = c_byte;
   160c2:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   160c6:	3a01      	subs	r2, #1
   160c8:	e7e5      	b.n	16096 <memset+0x6>
		*(d_word++) = c_word;
   160ca:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
   160ce:	e7ec      	b.n	160aa <memset+0x1a>
		*(d_byte++) = c_byte;
   160d0:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   160d4:	e7f0      	b.n	160b8 <memset+0x28>

000160d6 <strspn>:
#include <string.h>
#include <string.h>

size_t strspn(const char *s,
	      const char *accept)
{
   160d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   160d8:	4604      	mov	r4, r0
   160da:	460e      	mov	r6, r1
   160dc:	4607      	mov	r7, r0
   160de:	463d      	mov	r5, r7
	const char *ins = s;

	while ((*s != '\0') && (strchr(accept, *s) != NULL)) {
   160e0:	f817 1b01 	ldrb.w	r1, [r7], #1
   160e4:	b909      	cbnz	r1, 160ea <strspn+0x14>
		++s;
	}

	return s - ins;
   160e6:	1b28      	subs	r0, r5, r4
}
   160e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	while ((*s != '\0') && (strchr(accept, *s) != NULL)) {
   160ea:	4630      	mov	r0, r6
   160ec:	f7ff ff65 	bl	15fba <strchr>
   160f0:	2800      	cmp	r0, #0
   160f2:	d1f4      	bne.n	160de <strspn+0x8>
   160f4:	e7f7      	b.n	160e6 <strspn+0x10>

000160f6 <strcspn>:

size_t strcspn(const char *s,
	       const char *reject)
{
   160f6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   160f8:	4604      	mov	r4, r0
   160fa:	460e      	mov	r6, r1
   160fc:	4607      	mov	r7, r0
   160fe:	463d      	mov	r5, r7
	const char *ins = s;

	while ((*s != '\0') && (strchr(reject, *s) == NULL)) {
   16100:	f817 1b01 	ldrb.w	r1, [r7], #1
   16104:	b909      	cbnz	r1, 1610a <strcspn+0x14>
		++s;
	}

	return s - ins;
   16106:	1b28      	subs	r0, r5, r4
}
   16108:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	while ((*s != '\0') && (strchr(reject, *s) == NULL)) {
   1610a:	4630      	mov	r0, r6
   1610c:	f7ff ff55 	bl	15fba <strchr>
   16110:	2800      	cmp	r0, #0
   16112:	d0f4      	beq.n	160fe <strcspn+0x8>
   16114:	e7f7      	b.n	16106 <strcspn+0x10>

00016116 <_to_x>:
{
   16116:	b5f0      	push	{r4, r5, r6, r7, lr}
   16118:	4603      	mov	r3, r0
   1611a:	4614      	mov	r4, r2
   1611c:	4602      	mov	r2, r0
		unsigned int d = n % base;
   1611e:	fbb1 f0f4 	udiv	r0, r1, r4
   16122:	fb04 1510 	mls	r5, r4, r0, r1
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   16126:	2d09      	cmp	r5, #9
   16128:	460f      	mov	r7, r1
   1612a:	bf8c      	ite	hi
   1612c:	2627      	movhi	r6, #39	; 0x27
   1612e:	2600      	movls	r6, #0
		n /= base;
   16130:	4601      	mov	r1, r0
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   16132:	3530      	adds	r5, #48	; 0x30
   16134:	4610      	mov	r0, r2
   16136:	4435      	add	r5, r6
	} while (n);
   16138:	42a7      	cmp	r7, r4
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   1613a:	f800 5b01 	strb.w	r5, [r0], #1
	} while (n);
   1613e:	d205      	bcs.n	1614c <_to_x+0x36>
	*buf = 0;
   16140:	2100      	movs	r1, #0
   16142:	7001      	strb	r1, [r0, #0]
	len = buf - start;
   16144:	1ac0      	subs	r0, r0, r3
	for (buf--; buf > start; buf--, start++) {
   16146:	429a      	cmp	r2, r3
   16148:	d802      	bhi.n	16150 <_to_x+0x3a>
}
   1614a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1614c:	4602      	mov	r2, r0
   1614e:	e7e6      	b.n	1611e <_to_x+0x8>
		char tmp = *buf;
   16150:	7811      	ldrb	r1, [r2, #0]
		*buf = *start;
   16152:	781c      	ldrb	r4, [r3, #0]
   16154:	f802 4901 	strb.w	r4, [r2], #-1
		*start = tmp;
   16158:	f803 1b01 	strb.w	r1, [r3], #1
	for (buf--; buf > start; buf--, start++) {
   1615c:	e7f3      	b.n	16146 <_to_x+0x30>

0001615e <_rlrshift>:
{
   1615e:	b570      	push	{r4, r5, r6, lr}
	*v = (*v & 1) + (*v >> 1);
   16160:	e9d0 6500 	ldrd	r6, r5, [r0]
   16164:	0872      	lsrs	r2, r6, #1
   16166:	f006 0301 	and.w	r3, r6, #1
   1616a:	ea42 72c5 	orr.w	r2, r2, r5, lsl #31
   1616e:	189b      	adds	r3, r3, r2
   16170:	f04f 0100 	mov.w	r1, #0
   16174:	ea4f 0455 	mov.w	r4, r5, lsr #1
   16178:	eb44 0101 	adc.w	r1, r4, r1
   1617c:	e9c0 3100 	strd	r3, r1, [r0]
}
   16180:	bd70      	pop	{r4, r5, r6, pc}

00016182 <_ldiv5>:
	uint64_t rem = *v, quot = 0U, q;
   16182:	e9d0 3200 	ldrd	r3, r2, [r0]
{
   16186:	b5f0      	push	{r4, r5, r6, r7, lr}
	rem += 2U;
   16188:	3302      	adds	r3, #2
		q = (uint64_t)(hi / 5U) << shifts[i];
   1618a:	f04f 0705 	mov.w	r7, #5
   1618e:	f04f 0c00 	mov.w	ip, #0
	rem += 2U;
   16192:	f142 0200 	adc.w	r2, r2, #0
		rem -= q * 5U;
   16196:	ebb3 060c 	subs.w	r6, r3, ip
		q = (uint64_t)(hi / 5U) << shifts[i];
   1619a:	fbb2 fef7 	udiv	lr, r2, r7
		rem -= q * 5U;
   1619e:	fb07 f10e 	mul.w	r1, r7, lr
   161a2:	eb62 0101 	sbc.w	r1, r2, r1
		hi = rem >> shifts[i];
   161a6:	08f2      	lsrs	r2, r6, #3
   161a8:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
		q = (uint64_t)(hi / 5U) << shifts[i];
   161ac:	fbb2 f1f7 	udiv	r1, r2, r7
   161b0:	00ca      	lsls	r2, r1, #3
		quot += q;
   161b2:	eb1c 0402 	adds.w	r4, ip, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   161b6:	ea4f 7351 	mov.w	r3, r1, lsr #29
		quot += q;
   161ba:	eb4e 0503 	adc.w	r5, lr, r3
		rem -= q * 5U;
   161be:	fba2 2307 	umull	r2, r3, r2, r7
   161c2:	1ab3      	subs	r3, r6, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   161c4:	fbb3 f3f7 	udiv	r3, r3, r7
		quot += q;
   161c8:	18e4      	adds	r4, r4, r3
   161ca:	f145 0500 	adc.w	r5, r5, #0
	*v = quot;
   161ce:	e9c0 4500 	strd	r4, r5, [r0]
}
   161d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000161d4 <_get_digit>:
	if (*digit_count > 0) {
   161d4:	680b      	ldr	r3, [r1, #0]
   161d6:	2b00      	cmp	r3, #0
{
   161d8:	b570      	push	{r4, r5, r6, lr}
   161da:	4604      	mov	r4, r0
	if (*digit_count > 0) {
   161dc:	dd0f      	ble.n	161fe <_get_digit+0x2a>
		*fr = *fr * 10U;
   161de:	6822      	ldr	r2, [r4, #0]
   161e0:	6840      	ldr	r0, [r0, #4]
		*digit_count -= 1;
   161e2:	3b01      	subs	r3, #1
   161e4:	600b      	str	r3, [r1, #0]
		*fr = *fr * 10U;
   161e6:	210a      	movs	r1, #10
   161e8:	fba2 5601 	umull	r5, r6, r2, r1
   161ec:	fb01 6600 	mla	r6, r1, r0, r6
		*fr &= 0x0FFFFFFFFFFFFFFFull;
   161f0:	f026 4370 	bic.w	r3, r6, #4026531840	; 0xf0000000
   161f4:	e9c4 5300 	strd	r5, r3, [r4]
		rval = ((*fr >> 60) & 0xF) + '0';
   161f8:	0f30      	lsrs	r0, r6, #28
   161fa:	3030      	adds	r0, #48	; 0x30
}
   161fc:	bd70      	pop	{r4, r5, r6, pc}
		rval = '0';
   161fe:	2030      	movs	r0, #48	; 0x30
   16200:	e7fc      	b.n	161fc <_get_digit+0x28>

00016202 <_stdout_hook_default>:
}
   16202:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   16206:	4770      	bx	lr

00016208 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   16208:	684b      	ldr	r3, [r1, #4]
   1620a:	2b01      	cmp	r3, #1
   1620c:	dd07      	ble.n	1621e <sprintf_out+0x16>
		*(p->ptr) = c;
   1620e:	680b      	ldr	r3, [r1, #0]
   16210:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   16212:	680b      	ldr	r3, [r1, #0]
   16214:	3301      	adds	r3, #1
   16216:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   16218:	684b      	ldr	r3, [r1, #4]
   1621a:	3b01      	subs	r3, #1
   1621c:	604b      	str	r3, [r1, #4]
}
   1621e:	2000      	movs	r0, #0
   16220:	4770      	bx	lr

00016222 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   16222:	f7f9 b9b9 	b.w	f598 <SystemInit>

00016226 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   16226:	f3bf 8f5b 	dmb	ish
   1622a:	6800      	ldr	r0, [r0, #0]
   1622c:	f3bf 8f5b 	dmb	ish
}
   16230:	4770      	bx	lr

00016232 <bt_addr_le_copy>:
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
   16232:	2207      	movs	r2, #7
   16234:	f7ff bf01 	b.w	1603a <memcpy>

00016238 <atomic_and>:
{
   16238:	4603      	mov	r3, r0
}
   1623a:	f3bf 8f5b 	dmb	ish
   1623e:	e853 0f00 	ldrex	r0, [r3]
   16242:	ea00 0201 	and.w	r2, r0, r1
   16246:	e843 2c00 	strex	ip, r2, [r3]
   1624a:	f1bc 0f00 	cmp.w	ip, #0
   1624e:	d1f6      	bne.n	1623e <atomic_and+0x6>
   16250:	f3bf 8f5b 	dmb	ish
   16254:	4770      	bx	lr

00016256 <atomic_set_bit_to>:
 * @param val true for 1, false for 0.
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
   16256:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
   16258:	2301      	movs	r3, #1
   1625a:	f001 041f 	and.w	r4, r1, #31
   1625e:	0949      	lsrs	r1, r1, #5
   16260:	40a3      	lsls	r3, r4

	if (val) {
   16262:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   16266:	b162      	cbz	r2, 16282 <atomic_set_bit_to+0x2c>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   16268:	f3bf 8f5b 	dmb	ish
   1626c:	e850 2f00 	ldrex	r2, [r0]
   16270:	431a      	orrs	r2, r3
   16272:	e840 2100 	strex	r1, r2, [r0]
   16276:	2900      	cmp	r1, #0
   16278:	d1f8      	bne.n	1626c <atomic_set_bit_to+0x16>
   1627a:	f3bf 8f5b 	dmb	ish
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
	}
}
   1627e:	bc10      	pop	{r4}
   16280:	4770      	bx	lr
   16282:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   16284:	43d9      	mvns	r1, r3
   16286:	f7ff bfd7 	b.w	16238 <atomic_and>

0001628a <le_adv_set_private_addr.isra.0>:
static int le_adv_set_private_addr(struct bt_le_ext_adv *adv)
   1628a:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   1628c:	2106      	movs	r1, #6
   1628e:	4668      	mov	r0, sp
   16290:	f000 fb20 	bl	168d4 <bt_rand>
	if (err) {
   16294:	b940      	cbnz	r0, 162a8 <le_adv_set_private_addr.isra.0+0x1e>
	nrpa.val[5] &= 0x3f;
   16296:	f89d 3005 	ldrb.w	r3, [sp, #5]
		return set_random_address(addr);
   1629a:	4668      	mov	r0, sp
	nrpa.val[5] &= 0x3f;
   1629c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   162a0:	f88d 3005 	strb.w	r3, [sp, #5]
		return set_random_address(addr);
   162a4:	f7f1 f99e 	bl	75e4 <set_random_address>
}
   162a8:	b003      	add	sp, #12
   162aa:	f85d fb04 	ldr.w	pc, [sp], #4

000162ae <bt_addr_le_create_static>:
	addr->type = BT_ADDR_LE_RANDOM;
   162ae:	2301      	movs	r3, #1
{
   162b0:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   162b2:	2106      	movs	r1, #6
{
   162b4:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   162b6:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   162ba:	f000 fb0b 	bl	168d4 <bt_rand>
	if (err) {
   162be:	b918      	cbnz	r0, 162c8 <bt_addr_le_create_static+0x1a>
	BT_ADDR_SET_STATIC(&addr->a);
   162c0:	79a3      	ldrb	r3, [r4, #6]
   162c2:	f063 033f 	orn	r3, r3, #63	; 0x3f
   162c6:	71a3      	strb	r3, [r4, #6]
}
   162c8:	bd10      	pop	{r4, pc}

000162ca <bt_le_adv_start>:
	return bt_le_adv_start_legacy(param, ad, ad_len, sd, sd_len);
   162ca:	f7f2 b8c1 	b.w	8450 <bt_le_adv_start_legacy>

000162ce <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
   162ce:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
   162d0:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   162d2:	1dc3      	adds	r3, r0, #7
   162d4:	f023 0303 	bic.w	r3, r3, #3
{
   162d8:	460e      	mov	r6, r1
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   162da:	801a      	strh	r2, [r3, #0]

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   162dc:	3a01      	subs	r2, #1
   162de:	b294      	uxth	r4, r2
{
   162e0:	4605      	mov	r5, r0
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   162e2:	2204      	movs	r2, #4
   162e4:	2100      	movs	r1, #0
   162e6:	fb06 0004 	mla	r0, r6, r4, r0
   162ea:	f7ff fed1 	bl	16090 <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   162ee:	f64f 77ff 	movw	r7, #65535	; 0xffff
   162f2:	3c01      	subs	r4, #1
   162f4:	b2a4      	uxth	r4, r4
   162f6:	42bc      	cmp	r4, r7
   162f8:	d101      	bne.n	162fe <mem_init+0x30>
		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   162fa:	b003      	add	sp, #12
   162fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
   162fe:	fb04 6006 	mla	r0, r4, r6, r6
		next = (u32_t)((u8_t *) mem_pool +
   16302:	182b      	adds	r3, r5, r0
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   16304:	2204      	movs	r2, #4
   16306:	1b80      	subs	r0, r0, r6
   16308:	eb0d 0102 	add.w	r1, sp, r2
   1630c:	4428      	add	r0, r5
		next = (u32_t)((u8_t *) mem_pool +
   1630e:	9301      	str	r3, [sp, #4]
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   16310:	f7ff fe93 	bl	1603a <memcpy>
   16314:	e7ed      	b.n	162f2 <mem_init+0x24>

00016316 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   16316:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
   16318:	6804      	ldr	r4, [r0, #0]
{
   1631a:	4605      	mov	r5, r0
	if (*mem_head) {
   1631c:	b18c      	cbz	r4, 16342 <mem_acquire+0x2c>
		u16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   1631e:	1de3      	adds	r3, r4, #7
   16320:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   16324:	2204      	movs	r2, #4
   16326:	4621      	mov	r1, r4
   16328:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   1632c:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   1632e:	f7ff fe84 	bl	1603a <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   16332:	9b01      	ldr	r3, [sp, #4]
   16334:	b123      	cbz	r3, 16340 <mem_acquire+0x2a>
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   16336:	1dda      	adds	r2, r3, #7
   16338:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
   1633c:	3e01      	subs	r6, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   1633e:	8016      	strh	r6, [r2, #0]
				free_count;
		}

		*mem_head = head;
   16340:	602b      	str	r3, [r5, #0]
		return mem;
	}

	return NULL;
}
   16342:	4620      	mov	r0, r4
   16344:	b002      	add	sp, #8
   16346:	bd70      	pop	{r4, r5, r6, pc}

00016348 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   16348:	b570      	push	{r4, r5, r6, lr}
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   1634a:	680c      	ldr	r4, [r1, #0]
{
   1634c:	4606      	mov	r6, r0
   1634e:	460d      	mov	r5, r1
	if (*mem_head) {
   16350:	b11c      	cbz	r4, 1635a <mem_release+0x12>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   16352:	1de3      	adds	r3, r4, #7
   16354:	f023 0303 	bic.w	r3, r3, #3
   16358:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
   1635a:	2204      	movs	r2, #4
   1635c:	4629      	mov	r1, r5
   1635e:	4630      	mov	r0, r6
   16360:	f7ff fe6b 	bl	1603a <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   16364:	1df2      	adds	r2, r6, #7
   16366:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
   1636a:	1c63      	adds	r3, r4, #1
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   1636c:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   1636e:	602e      	str	r6, [r5, #0]
}
   16370:	bd70      	pop	{r4, r5, r6, pc}

00016372 <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
   16372:	b510      	push	{r4, lr}
	src += len;
   16374:	4411      	add	r1, r2
	while (len--) {
   16376:	3801      	subs	r0, #1
   16378:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1637c:	3a01      	subs	r2, #1
   1637e:	b292      	uxth	r2, r2
   16380:	429a      	cmp	r2, r3
   16382:	d100      	bne.n	16386 <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   16384:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   16386:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   1638a:	f800 4f01 	strb.w	r4, [r0, #1]!
   1638e:	e7f5      	b.n	1637c <mem_rcopy+0xa>

00016390 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
   16390:	4401      	add	r1, r0
   16392:	4288      	cmp	r0, r1
   16394:	d101      	bne.n	1639a <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   16396:	2000      	movs	r0, #0
   16398:	4770      	bx	lr
		if (*src++) {
   1639a:	f810 3b01 	ldrb.w	r3, [r0], #1
   1639e:	2b00      	cmp	r3, #0
   163a0:	d0f7      	beq.n	16392 <mem_nz+0x2>
			return 1;
   163a2:	2001      	movs	r0, #1
}
   163a4:	4770      	bx	lr

000163a6 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   163a6:	6010      	str	r0, [r2, #0]
   163a8:	6008      	str	r0, [r1, #0]

	return link;
}
   163aa:	4770      	bx	lr

000163ac <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   163ac:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   163ae:	6814      	ldr	r4, [r2, #0]
   163b0:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   163b2:	6814      	ldr	r4, [r2, #0]
   163b4:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;
   163b6:	6010      	str	r0, [r2, #0]

	return link;
}
   163b8:	bd10      	pop	{r4, pc}

000163ba <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   163ba:	4288      	cmp	r0, r1
   163bc:	d003      	beq.n	163c6 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   163be:	b11a      	cbz	r2, 163c8 <memq_peek+0xe>
		*mem = head->mem;
   163c0:	6843      	ldr	r3, [r0, #4]
   163c2:	6013      	str	r3, [r2, #0]
   163c4:	4770      	bx	lr
		return NULL;
   163c6:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   163c8:	4770      	bx	lr

000163ca <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   163ca:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   163cc:	4283      	cmp	r3, r0
   163ce:	d009      	beq.n	163e4 <memq_dequeue+0x1a>
	if (mem) {
   163d0:	b122      	cbz	r2, 163dc <memq_dequeue+0x12>
		*mem = head->mem;
   163d2:	6858      	ldr	r0, [r3, #4]
   163d4:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   163d6:	681a      	ldr	r2, [r3, #0]
   163d8:	600a      	str	r2, [r1, #0]

	return old_head;
   163da:	e001      	b.n	163e0 <memq_dequeue+0x16>
	if (old_head == NULL) {
   163dc:	2b00      	cmp	r3, #0
   163de:	d1fa      	bne.n	163d6 <memq_dequeue+0xc>
}
   163e0:	4618      	mov	r0, r3
   163e2:	4770      	bx	lr
		return NULL; /* queue is empty */
   163e4:	2300      	movs	r3, #0
   163e6:	e7fb      	b.n	163e0 <memq_dequeue+0x16>

000163e8 <util_ones_count_get>:
{
   163e8:	b510      	push	{r4, lr}
   163ea:	1e42      	subs	r2, r0, #1
	u8_t one_count = 0U;
   163ec:	2000      	movs	r0, #0
	while (octets_len--) {
   163ee:	3901      	subs	r1, #1
   163f0:	b2c9      	uxtb	r1, r1
   163f2:	29ff      	cmp	r1, #255	; 0xff
   163f4:	d100      	bne.n	163f8 <util_ones_count_get+0x10>
}
   163f6:	bd10      	pop	{r4, pc}
		bite = *octets;
   163f8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		while (bite) {
   163fc:	2b00      	cmp	r3, #0
   163fe:	d0f6      	beq.n	163ee <util_ones_count_get+0x6>
			bite &= (bite - 1);
   16400:	b25b      	sxtb	r3, r3
   16402:	1e5c      	subs	r4, r3, #1
   16404:	4023      	ands	r3, r4
			one_count++;
   16406:	3001      	adds	r0, #1
			bite &= (bite - 1);
   16408:	b2db      	uxtb	r3, r3
			one_count++;
   1640a:	b2c0      	uxtb	r0, r0
   1640c:	e7f6      	b.n	163fc <util_ones_count_get+0x14>

0001640e <ticks_to_expire_prep>:
{
   1640e:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   16410:	1a55      	subs	r5, r2, r1
   16412:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	u32_t ticks_to_expire = ticker->ticks_to_expire;
   16416:	6883      	ldr	r3, [r0, #8]
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   16418:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   1641a:	d109      	bne.n	16430 <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1641c:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   16420:	442b      	add	r3, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
   16422:	42a3      	cmp	r3, r4
   16424:	d90e      	bls.n	16444 <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   16426:	1b1b      	subs	r3, r3, r4
		ticks_to_expire_minus = 0U;
   16428:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   1642a:	6083      	str	r3, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   1642c:	6144      	str	r4, [r0, #20]
}
   1642e:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   16430:	1a8a      	subs	r2, r1, r2
   16432:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   16436:	4293      	cmp	r3, r2
   16438:	d901      	bls.n	1643e <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   1643a:	1a9b      	subs	r3, r3, r2
   1643c:	e7f1      	b.n	16422 <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   1643e:	4414      	add	r4, r2
   16440:	1ae4      	subs	r4, r4, r3
			ticks_to_expire = 0U;
   16442:	2300      	movs	r3, #0
		ticks_to_expire_minus -= ticks_to_expire;
   16444:	1ae4      	subs	r4, r4, r3
		ticks_to_expire = 0U;
   16446:	2300      	movs	r3, #0
   16448:	e7ef      	b.n	1642a <ticks_to_expire_prep+0x1c>

0001644a <ticker_job_op_cb>:
{
   1644a:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   1644c:	2200      	movs	r2, #0
   1644e:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   16450:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	user_op->status = status;
   16452:	6299      	str	r1, [r3, #40]	; 0x28
{
   16454:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   16456:	b10a      	cbz	r2, 1645c <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   16458:	6b19      	ldr	r1, [r3, #48]	; 0x30
   1645a:	4710      	bx	r2
}
   1645c:	4770      	bx	lr

0001645e <ticker_job_list_insert>:
{
   1645e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16462:	b089      	sub	sp, #36	; 0x24
	node = &instance->nodes[0];
   16464:	6803      	ldr	r3, [r0, #0]
   16466:	9301      	str	r3, [sp, #4]
	count_user = instance->count_user;
   16468:	f890 a009 	ldrb.w	sl, [r0, #9]
	users = &instance->users[0];
   1646c:	6843      	ldr	r3, [r0, #4]
   1646e:	9305      	str	r3, [sp, #20]
{
   16470:	4605      	mov	r5, r0
   16472:	4688      	mov	r8, r1
	while (count_user--) {
   16474:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   16478:	fa5f fa83 	uxtb.w	sl, r3
   1647c:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   16480:	d102      	bne.n	16488 <ticker_job_list_insert+0x2a>
}
   16482:	b009      	add	sp, #36	; 0x24
   16484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		user = &users[count_user];
   16488:	9b05      	ldr	r3, [sp, #20]
   1648a:	eb03 09ca 	add.w	r9, r3, sl, lsl #3
		user_ops = (void *)&user->user_op[0];
   1648e:	f8d9 3004 	ldr.w	r3, [r9, #4]
		user_ops_first = user->first;
   16492:	f899 6001 	ldrb.w	r6, [r9, #1]
		user_ops = (void *)&user->user_op[0];
   16496:	9304      	str	r3, [sp, #16]
		while ((insert_head != TICKER_NULL) ||
   16498:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   1649c:	d06c      	beq.n	16578 <ticker_job_list_insert+0x11a>
				ticker = &node[id_insert];
   1649e:	eb08 0048 	add.w	r0, r8, r8, lsl #1
   164a2:	9a01      	ldr	r2, [sp, #4]
   164a4:	0103      	lsls	r3, r0, #4
   164a6:	46c3      	mov	fp, r8
				insert_head = ticker->next;
   164a8:	f812 8003 	ldrb.w	r8, [r2, r3]
				ticker = &node[id_insert];
   164ac:	eb02 1000 	add.w	r0, r2, r0, lsl #4
				user_op = NULL;
   164b0:	2400      	movs	r4, #0
	ticker->next = TICKER_NULL;
   164b2:	23ff      	movs	r3, #255	; 0xff
   164b4:	7003      	strb	r3, [r0, #0]
	node = &instance->nodes[0];
   164b6:	682f      	ldr	r7, [r5, #0]
	previous = TICKER_NULL;
   164b8:	9303      	str	r3, [sp, #12]
	ticker_new = &node[id];
   164ba:	fa0f fc8b 	sxth.w	ip, fp
   164be:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   164c2:	ea4f 120c 	mov.w	r2, ip, lsl #4
   164c6:	eb07 1c0c 	add.w	ip, r7, ip, lsl #4
   164ca:	9206      	str	r2, [sp, #24]
	ticks_to_expire = ticker_new->ticks_to_expire;
   164cc:	f8dc 1008 	ldr.w	r1, [ip, #8]
	current = instance->ticker_id_head;
   164d0:	7f6a      	ldrb	r2, [r5, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   164d2:	2aff      	cmp	r2, #255	; 0xff
   164d4:	d00b      	beq.n	164ee <ticker_job_list_insert+0x90>
		(ticker_current = &node[current])->ticks_to_expire))) {
   164d6:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
   164da:	ea4f 130e 	mov.w	r3, lr, lsl #4
   164de:	eb07 1e0e 	add.w	lr, r7, lr, lsl #4
   164e2:	9307      	str	r3, [sp, #28]
		(ticks_to_expire_current =
   164e4:	f8de 3008 	ldr.w	r3, [lr, #8]
   164e8:	9302      	str	r3, [sp, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   164ea:	4299      	cmp	r1, r3
   164ec:	d26e      	bcs.n	165cc <ticker_job_list_insert+0x16e>
	ticker_new->next = current;
   164ee:	9b06      	ldr	r3, [sp, #24]
	ticker_new->ticks_to_expire = ticks_to_expire;
   164f0:	f8cc 1008 	str.w	r1, [ip, #8]
	ticker_new->next = current;
   164f4:	54fa      	strb	r2, [r7, r3]
	if (previous == TICKER_NULL) {
   164f6:	9b03      	ldr	r3, [sp, #12]
   164f8:	2bff      	cmp	r3, #255	; 0xff
		node[previous].next = id;
   164fa:	bf17      	itett	ne
   164fc:	f9bd 300c 	ldrshne.w	r3, [sp, #12]
		instance->ticker_id_head = id;
   16500:	f885 b01d 	strbeq.w	fp, [r5, #29]
		node[previous].next = id;
   16504:	eb03 0343 	addne.w	r3, r3, r3, lsl #1
   16508:	011b      	lslne	r3, r3, #4
   1650a:	bf18      	it	ne
   1650c:	f807 b003 	strbne.w	fp, [r7, r3]
	if (current != TICKER_NULL) {
   16510:	2aff      	cmp	r2, #255	; 0xff
   16512:	d006      	beq.n	16522 <ticker_job_list_insert+0xc4>
		node[current].ticks_to_expire -= ticks_to_expire;
   16514:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   16518:	eb07 1202 	add.w	r2, r7, r2, lsl #4
   1651c:	6893      	ldr	r3, [r2, #8]
   1651e:	1a59      	subs	r1, r3, r1
   16520:	6091      	str	r1, [r2, #8]
	ticker->req = ticker->ack + 1;
   16522:	7883      	ldrb	r3, [r0, #2]
   16524:	3301      	adds	r3, #1
   16526:	7043      	strb	r3, [r0, #1]
			if (user_op) {
   16528:	2c00      	cmp	r4, #0
   1652a:	d0b5      	beq.n	16498 <ticker_job_list_insert+0x3a>
				ticker_job_op_cb(user_op, status);
   1652c:	2100      	movs	r1, #0
   1652e:	4620      	mov	r0, r4
   16530:	f7ff ff8b 	bl	1644a <ticker_job_op_cb>
   16534:	e7b0      	b.n	16498 <ticker_job_list_insert+0x3a>
				user_op = &user_ops[user_ops_first];
   16536:	9a04      	ldr	r2, [sp, #16]
   16538:	2334      	movs	r3, #52	; 0x34
   1653a:	fb16 f303 	smulbb	r3, r6, r3
   1653e:	18d4      	adds	r4, r2, r3
				first = user_ops_first + 1;
   16540:	3601      	adds	r6, #1
				if (first == user->count_user_op) {
   16542:	f899 2000 	ldrb.w	r2, [r9]
				first = user_ops_first + 1;
   16546:	b2f6      	uxtb	r6, r6
					first = 0U;
   16548:	42b2      	cmp	r2, r6
   1654a:	bf08      	it	eq
   1654c:	2600      	moveq	r6, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   1654e:	9a04      	ldr	r2, [sp, #16]
   16550:	5cd3      	ldrb	r3, [r2, r3]
   16552:	2b04      	cmp	r3, #4
   16554:	d110      	bne.n	16578 <ticker_job_list_insert+0x11a>
				id_insert = user_op->id;
   16556:	f894 b001 	ldrb.w	fp, [r4, #1]
				ticker = &node[id_insert];
   1655a:	9b01      	ldr	r3, [sp, #4]
   1655c:	eb0b 004b 	add.w	r0, fp, fp, lsl #1
   16560:	eb03 1000 	add.w	r0, r3, r0, lsl #4
				if (((ticker->req -
   16564:	7847      	ldrb	r7, [r0, #1]
				      ticker->ack) & 0xff) != 0U) {
   16566:	7883      	ldrb	r3, [r0, #2]
				if (((ticker->req -
   16568:	1aff      	subs	r7, r7, r3
   1656a:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
   1656e:	d008      	beq.n	16582 <ticker_job_list_insert+0x124>
					ticker_job_op_cb(user_op,
   16570:	2101      	movs	r1, #1
   16572:	4620      	mov	r0, r4
   16574:	f7ff ff69 	bl	1644a <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
   16578:	f899 3002 	ldrb.w	r3, [r9, #2]
   1657c:	42b3      	cmp	r3, r6
   1657e:	d1da      	bne.n	16536 <ticker_job_list_insert+0xd8>
   16580:	e778      	b.n	16474 <ticker_job_list_insert+0x16>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
   16582:	8aa2      	ldrh	r2, [r4, #20]
				ticker_job_op_start(ticker, user_op,
   16584:	6969      	ldr	r1, [r5, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
   16586:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1658a:	429a      	cmp	r2, r3
   1658c:	bf0c      	ite	eq
   1658e:	2301      	moveq	r3, #1
   16590:	2300      	movne	r3, #0
   16592:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
   16596:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16598:	6283      	str	r3, [r0, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
   1659a:	68e3      	ldr	r3, [r4, #12]
   1659c:	6043      	str	r3, [r0, #4]
	ticker->remainder_periodic = start->remainder_periodic;
   1659e:	6923      	ldr	r3, [r4, #16]
   165a0:	6203      	str	r3, [r0, #32]
	ticker->ticks_slot = start->ticks_slot;
   165a2:	69a3      	ldr	r3, [r4, #24]
   165a4:	6183      	str	r3, [r0, #24]
	ticker->timeout_func = start->fp_timeout_func;
   165a6:	69e3      	ldr	r3, [r4, #28]
   165a8:	60c3      	str	r3, [r0, #12]
	ticker->context = start->context;
   165aa:	6a23      	ldr	r3, [r4, #32]
   165ac:	6103      	str	r3, [r0, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   165ae:	bf08      	it	eq
   165b0:	2200      	moveq	r2, #0
	ticker->ticks_to_expire = start->ticks_first;
   165b2:	68a3      	ldr	r3, [r4, #8]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   165b4:	8382      	strh	r2, [r0, #28]
	ticker->ticks_to_expire = start->ticks_first;
   165b6:	6083      	str	r3, [r0, #8]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   165b8:	6862      	ldr	r2, [r4, #4]
	ticker->ticks_to_expire_minus = 0U;
   165ba:	6147      	str	r7, [r0, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   165bc:	f7ff ff27 	bl	1640e <ticks_to_expire_prep>
	ticker->force = 1U;
   165c0:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
   165c4:	6247      	str	r7, [r0, #36]	; 0x24
	ticker->lazy_current = 0U;
   165c6:	83c7      	strh	r7, [r0, #30]
	ticker->force = 1U;
   165c8:	70c3      	strb	r3, [r0, #3]
}
   165ca:	e772      	b.n	164b2 <ticker_job_list_insert+0x54>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
   165cc:	9b02      	ldr	r3, [sp, #8]
   165ce:	1ac9      	subs	r1, r1, r3
   165d0:	d105      	bne.n	165de <ticker_job_list_insert+0x180>
   165d2:	f8bc 301e 	ldrh.w	r3, [ip, #30]
   165d6:	f8be e01e 	ldrh.w	lr, [lr, #30]
   165da:	4573      	cmp	r3, lr
   165dc:	d803      	bhi.n	165e6 <ticker_job_list_insert+0x188>
		current = ticker_current->next;
   165de:	9b07      	ldr	r3, [sp, #28]
   165e0:	9203      	str	r2, [sp, #12]
   165e2:	5cfa      	ldrb	r2, [r7, r3]
   165e4:	e775      	b.n	164d2 <ticker_job_list_insert+0x74>
		(ticks_to_expire_current =
   165e6:	9902      	ldr	r1, [sp, #8]
   165e8:	e781      	b.n	164ee <ticker_job_list_insert+0x90>

000165ea <ticker_worker>:
{
   165ea:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   165ee:	7f87      	ldrb	r7, [r0, #30]
	instance->worker_trigger = 1U;
   165f0:	2301      	movs	r3, #1
{
   165f2:	b089      	sub	sp, #36	; 0x24
   165f4:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
   165f6:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   165f8:	b91f      	cbnz	r7, 16602 <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
   165fa:	7f43      	ldrb	r3, [r0, #29]
   165fc:	2bff      	cmp	r3, #255	; 0xff
   165fe:	d103      	bne.n	16608 <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
   16600:	77c7      	strb	r7, [r0, #31]
}
   16602:	b009      	add	sp, #36	; 0x24
   16604:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   16608:	f7f5 fdb0 	bl	c16c <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1660c:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
   1660e:	f895 801d 	ldrb.w	r8, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   16612:	1ac0      	subs	r0, r0, r3
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   16614:	7f2b      	ldrb	r3, [r5, #28]
   16616:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   16618:	f020 4b7f 	bic.w	fp, r0, #4278190080	; 0xff000000
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   1661c:	d027      	beq.n	1666e <ticker_worker+0x84>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   1661e:	69af      	ldr	r7, [r5, #24]
	u8_t slot_reserved = 0;
   16620:	455f      	cmp	r7, fp
   16622:	bf94      	ite	ls
   16624:	2300      	movls	r3, #0
   16626:	2301      	movhi	r3, #1
   16628:	9301      	str	r3, [sp, #4]
	node = &instance->nodes[0];
   1662a:	f8d5 a000 	ldr.w	sl, [r5]
	ticks_expired = 0U;
   1662e:	f04f 0900 	mov.w	r9, #0
	while (ticker_id_head != TICKER_NULL) {
   16632:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   16636:	d11c      	bne.n	16672 <ticker_worker+0x88>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   16638:	7aea      	ldrb	r2, [r5, #11]
   1663a:	7aab      	ldrb	r3, [r5, #10]
   1663c:	4293      	cmp	r3, r2
   1663e:	d105      	bne.n	1664c <ticker_worker+0x62>
	u8_t idx = *ticks_elapsed_index + 1;
   16640:	3301      	adds	r3, #1
   16642:	b2db      	uxtb	r3, r3
		idx = 0U;
   16644:	2b02      	cmp	r3, #2
   16646:	bf08      	it	eq
   16648:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   1664a:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   1664c:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1664e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   16650:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   16654:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   16656:	f8c3 900c 	str.w	r9, [r3, #12]
	instance->worker_trigger = 0U;
   1665a:	2300      	movs	r3, #0
   1665c:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1665e:	2104      	movs	r1, #4
   16660:	462b      	mov	r3, r5
   16662:	2003      	movs	r0, #3
   16664:	46a4      	mov	ip, r4
}
   16666:	b009      	add	sp, #36	; 0x24
   16668:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   1666c:	4760      	bx	ip
	u8_t slot_reserved = 0;
   1666e:	9701      	str	r7, [sp, #4]
   16670:	e7db      	b.n	1662a <ticker_worker+0x40>
		ticker = &node[ticker_id_head];
   16672:	eb08 0848 	add.w	r8, r8, r8, lsl #1
   16676:	eb0a 1408 	add.w	r4, sl, r8, lsl #4
   1667a:	ea4f 1208 	mov.w	r2, r8, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
   1667e:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   16680:	459b      	cmp	fp, r3
   16682:	d3d9      	bcc.n	16638 <ticker_worker+0x4e>
		if (ticker->ticks_slot != 0U &&
   16684:	69a6      	ldr	r6, [r4, #24]
		ticker_id_head = ticker->next;
   16686:	f81a 8002 	ldrb.w	r8, [sl, r2]
		ticks_elapsed -= ticks_to_expire;
   1668a:	ebab 0b03 	sub.w	fp, fp, r3
		ticks_expired += ticks_to_expire;
   1668e:	4499      	add	r9, r3
		if (ticker->ticks_slot != 0U &&
   16690:	2e00      	cmp	r6, #0
   16692:	d034      	beq.n	166fe <ticker_worker+0x114>
   16694:	9b01      	ldr	r3, [sp, #4]
   16696:	2b00      	cmp	r3, #0
   16698:	f040 8089 	bne.w	167ae <ticker_worker+0x1c4>
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
   1669c:	f994 302d 	ldrsb.w	r3, [r4, #45]	; 0x2d
   166a0:	461f      	mov	r7, r3
   166a2:	3380      	adds	r3, #128	; 0x80
   166a4:	d02a      	beq.n	166fc <ticker_worker+0x112>
   166a6:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   166aa:	d027      	beq.n	166fc <ticker_worker+0x112>
		s32_t lazy_current = ticker->lazy_current;
   166ac:	8be3      	ldrh	r3, [r4, #30]
		if (lazy_current >= ticker->lazy_periodic) {
   166ae:	8ba2      	ldrh	r2, [r4, #28]
   166b0:	4293      	cmp	r3, r2
			lazy_current -= ticker->lazy_periodic;
   166b2:	bf28      	it	cs
   166b4:	1a9b      	subcs	r3, r3, r2
		u32_t current_age = ticker->ticks_periodic +
   166b6:	6862      	ldr	r2, [r4, #4]
   166b8:	fb03 2202 	mla	r2, r3, r2, r2
   166bc:	9204      	str	r2, [sp, #16]
				(lazy_current - ticker->priority);
   166be:	1bdb      	subs	r3, r3, r7
		u32_t acc_ticks_to_expire = 0U;
   166c0:	2200      	movs	r2, #0
		u32_t current_age = ticker->ticks_periodic +
   166c2:	46c6      	mov	lr, r8
		u32_t acc_ticks_to_expire = 0U;
   166c4:	9202      	str	r2, [sp, #8]
				(lazy_current - ticker->priority);
   166c6:	9307      	str	r3, [sp, #28]
			struct ticker_node *ticker_next = &nodes[id_head];
   166c8:	fa0f fe8e 	sxth.w	lr, lr
   166cc:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   166d0:	ea4f 130e 	mov.w	r3, lr, lsl #4
   166d4:	eb0a 1e0e 	add.w	lr, sl, lr, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   166d8:	9a02      	ldr	r2, [sp, #8]
			struct ticker_node *ticker_next = &nodes[id_head];
   166da:	9306      	str	r3, [sp, #24]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   166dc:	f8de 3008 	ldr.w	r3, [lr, #8]
   166e0:	441a      	add	r2, r3
			if (acc_ticks_to_expire > ticker->ticks_slot) {
   166e2:	4296      	cmp	r6, r2
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   166e4:	9202      	str	r2, [sp, #8]
			if (acc_ticks_to_expire > ticker->ticks_slot) {
   166e6:	d309      	bcc.n	166fc <ticker_worker+0x112>
			if (ticker_next->ticks_slot == 0U) {
   166e8:	f8de 2018 	ldr.w	r2, [lr, #24]
   166ec:	2a00      	cmp	r2, #0
   166ee:	d130      	bne.n	16752 <ticker_worker+0x168>
			id_head = ticker_next->next;
   166f0:	9b06      	ldr	r3, [sp, #24]
   166f2:	f81a e003 	ldrb.w	lr, [sl, r3]
		while (id_head != TICKER_NULL) {
   166f6:	f1be 0fff 	cmp.w	lr, #255	; 0xff
   166fa:	d1e5      	bne.n	166c8 <ticker_worker+0xde>
		must_expire_skip = 0U;
   166fc:	2600      	movs	r6, #0
		if (ticker->ext_data) {
   166fe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   16700:	b113      	cbz	r3, 16708 <ticker_worker+0x11e>
			ticker->ext_data->ticks_drift = 0U;
   16702:	2200      	movs	r2, #0
   16704:	605a      	str	r2, [r3, #4]
			ticker->ext_data->reschedule_state =
   16706:	721a      	strb	r2, [r3, #8]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   16708:	78a2      	ldrb	r2, [r4, #2]
   1670a:	7863      	ldrb	r3, [r4, #1]
   1670c:	1a9b      	subs	r3, r3, r2
   1670e:	b2db      	uxtb	r3, r3
   16710:	2b01      	cmp	r3, #1
   16712:	d18e      	bne.n	16632 <ticker_worker+0x48>
		if (ticker->timeout_func) {
   16714:	68e3      	ldr	r3, [r4, #12]
		ticker->ack--;
   16716:	3a01      	subs	r2, #1
   16718:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
   1671a:	461f      	mov	r7, r3
   1671c:	2b00      	cmp	r3, #0
   1671e:	d088      	beq.n	16632 <ticker_worker+0x48>
					   ticks_expired -
   16720:	6960      	ldr	r0, [r4, #20]
   16722:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
   16724:	6a61      	ldr	r1, [r4, #36]	; 0x24
					   ticks_expired -
   16726:	eba9 0000 	sub.w	r0, r9, r0
   1672a:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
   1672c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   16730:	2e00      	cmp	r6, #0
   16732:	d160      	bne.n	167f6 <ticker_worker+0x20c>
   16734:	8be2      	ldrh	r2, [r4, #30]
   16736:	6923      	ldr	r3, [r4, #16]
   16738:	47b8      	blx	r7
			if (must_expire_skip == 0U) {
   1673a:	2e00      	cmp	r6, #0
   1673c:	f47f af79 	bne.w	16632 <ticker_worker+0x48>
				if (ticker->ticks_slot != 0U) {
   16740:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
   16742:	83e6      	strh	r6, [r4, #30]
					slot_reserved = 1U;
   16744:	2b00      	cmp	r3, #0
   16746:	9b01      	ldr	r3, [sp, #4]
				ticker->force = 0U;
   16748:	70e6      	strb	r6, [r4, #3]
					slot_reserved = 1U;
   1674a:	bf18      	it	ne
   1674c:	2301      	movne	r3, #1
   1674e:	9301      	str	r3, [sp, #4]
   16750:	e76f      	b.n	16632 <ticker_worker+0x48>
			s32_t lazy_next = ticker_next->lazy_current;
   16752:	f8be 001e 	ldrh.w	r0, [lr, #30]
				ticker_next->lazy_periodic > lazy_next;
   16756:	f8be c01c 	ldrh.w	ip, [lr, #28]
				ticker_next->priority;
   1675a:	f99e 102d 	ldrsb.w	r1, [lr, #45]	; 0x2d
   1675e:	9103      	str	r1, [sp, #12]
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   16760:	f8de 1004 	ldr.w	r1, [lr, #4]
			if (!lazy_next_periodic_skip) {
   16764:	4560      	cmp	r0, ip
			s32_t lazy_next = ticker_next->lazy_current;
   16766:	4602      	mov	r2, r0
				lazy_next -= ticker_next->lazy_periodic;
   16768:	bf28      	it	cs
   1676a:	eba0 020c 	subcs.w	r2, r0, ip
					  0U :
   1676e:	2900      	cmp	r1, #0
   16770:	d03c      	beq.n	167ec <ticker_worker+0x202>
   16772:	1acb      	subs	r3, r1, r3
   16774:	9305      	str	r3, [sp, #20]
			if (!lazy_next_periodic_skip &&
   16776:	4560      	cmp	r0, ip
			u8_t next_force = (ticker_next->force > ticker->force);
   16778:	f89e 3003 	ldrb.w	r3, [lr, #3]
   1677c:	f894 e003 	ldrb.w	lr, [r4, #3]
			if (!lazy_next_periodic_skip &&
   16780:	d3b6      	bcc.n	166f0 <ticker_worker+0x106>
   16782:	4573      	cmp	r3, lr
   16784:	d813      	bhi.n	167ae <ticker_worker+0x1c4>
			    (next_force ||
   16786:	9b03      	ldr	r3, [sp, #12]
   16788:	3380      	adds	r3, #128	; 0x80
   1678a:	d010      	beq.n	167ae <ticker_worker+0x1c4>
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   1678c:	9b05      	ldr	r3, [sp, #20]
   1678e:	fb01 3302 	mla	r3, r1, r2, r3
				(lazy_next - ticker_next->priority) >
   16792:	9903      	ldr	r1, [sp, #12]
   16794:	1a52      	subs	r2, r2, r1
			     next_is_critical ||
   16796:	9907      	ldr	r1, [sp, #28]
   16798:	428a      	cmp	r2, r1
   1679a:	dd02      	ble.n	167a2 <ticker_worker+0x1b8>
			    (next_has_priority && !current_is_older) ||
   1679c:	9a04      	ldr	r2, [sp, #16]
   1679e:	429a      	cmp	r2, r3
   167a0:	d905      	bls.n	167ae <ticker_worker+0x1c4>
   167a2:	9903      	ldr	r1, [sp, #12]
   167a4:	428f      	cmp	r7, r1
   167a6:	d1a3      	bne.n	166f0 <ticker_worker+0x106>
			    (equal_priority && next_is_older))) {
   167a8:	9a04      	ldr	r2, [sp, #16]
   167aa:	429a      	cmp	r2, r3
   167ac:	d2a0      	bcs.n	166f0 <ticker_worker+0x106>
			struct ticker_ext *ext_data = ticker->ext_data;
   167ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			if (ext_data &&
   167b0:	8be2      	ldrh	r2, [r4, #30]
   167b2:	b143      	cbz	r3, 167c6 <ticker_worker+0x1dc>
   167b4:	6819      	ldr	r1, [r3, #0]
   167b6:	b1d9      	cbz	r1, 167f0 <ticker_worker+0x206>
			    ext_data->ticks_slot_window != 0U &&
   167b8:	7a19      	ldrb	r1, [r3, #8]
   167ba:	b9c9      	cbnz	r1, 167f0 <ticker_worker+0x206>
			    TICKER_RESCHEDULE_STATE_NONE &&
   167bc:	8ba1      	ldrh	r1, [r4, #28]
   167be:	4291      	cmp	r1, r2
   167c0:	d816      	bhi.n	167f0 <ticker_worker+0x206>
				ext_data->reschedule_state =
   167c2:	2101      	movs	r1, #1
				ext_data->reschedule_state =
   167c4:	7219      	strb	r1, [r3, #8]
			ticker->lazy_current++;
   167c6:	3201      	adds	r2, #1
			if ((ticker->must_expire == 0U) ||
   167c8:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
			ticker->lazy_current++;
   167cc:	b292      	uxth	r2, r2
   167ce:	83e2      	strh	r2, [r4, #30]
			if ((ticker->must_expire == 0U) ||
   167d0:	2900      	cmp	r1, #0
   167d2:	f43f af2e 	beq.w	16632 <ticker_worker+0x48>
   167d6:	8ba1      	ldrh	r1, [r4, #28]
   167d8:	4291      	cmp	r1, r2
   167da:	f4bf af2a 	bcs.w	16632 <ticker_worker+0x48>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
   167de:	b11b      	cbz	r3, 167e8 <ticker_worker+0x1fe>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
   167e0:	7a1b      	ldrb	r3, [r3, #8]
   167e2:	2b01      	cmp	r3, #1
   167e4:	f43f af25 	beq.w	16632 <ticker_worker+0x48>
			must_expire_skip = 1U;
   167e8:	2601      	movs	r6, #1
   167ea:	e788      	b.n	166fe <ticker_worker+0x114>
					  0U :
   167ec:	9105      	str	r1, [sp, #20]
   167ee:	e7c2      	b.n	16776 <ticker_worker+0x18c>
				ext_data->reschedule_state =
   167f0:	f04f 0100 	mov.w	r1, #0
   167f4:	e7e6      	b.n	167c4 <ticker_worker+0x1da>
			ticker->timeout_func(ticks_at_expire,
   167f6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   167fa:	e79c      	b.n	16736 <ticker_worker+0x14c>

000167fc <ticker_start>:
{
   167fc:	b510      	push	{r4, lr}
   167fe:	b08a      	sub	sp, #40	; 0x28
	return ticker_start_ext(instance_index, user_id, ticker_id,
   16800:	2400      	movs	r4, #0
   16802:	9409      	str	r4, [sp, #36]	; 0x24
   16804:	9c14      	ldr	r4, [sp, #80]	; 0x50
   16806:	9408      	str	r4, [sp, #32]
   16808:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   1680a:	9407      	str	r4, [sp, #28]
   1680c:	9c12      	ldr	r4, [sp, #72]	; 0x48
   1680e:	9406      	str	r4, [sp, #24]
   16810:	9c11      	ldr	r4, [sp, #68]	; 0x44
   16812:	9405      	str	r4, [sp, #20]
   16814:	9c10      	ldr	r4, [sp, #64]	; 0x40
   16816:	9404      	str	r4, [sp, #16]
   16818:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
   1681c:	9403      	str	r4, [sp, #12]
   1681e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   16820:	9402      	str	r4, [sp, #8]
   16822:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   16824:	9401      	str	r4, [sp, #4]
   16826:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   16828:	9400      	str	r4, [sp, #0]
   1682a:	f7f2 fdb9 	bl	93a0 <ticker_start_ext>
}
   1682e:	b00a      	add	sp, #40	; 0x28
   16830:	bd10      	pop	{r4, pc}

00016832 <ticker_ticks_now_get>:
	return cntr_cnt_get();
   16832:	f7f5 bc9b 	b.w	c16c <cntr_cnt_get>

00016836 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   16836:	1a40      	subs	r0, r0, r1
}
   16838:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   1683c:	4770      	bx	lr

0001683e <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   1683e:	2300      	movs	r3, #0
   16840:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   16842:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   16844:	4770      	bx	lr

00016846 <sys_get_le64>:
{
   16846:	4603      	mov	r3, r0
}
   16848:	6800      	ldr	r0, [r0, #0]
   1684a:	6859      	ldr	r1, [r3, #4]
   1684c:	4770      	bx	lr

0001684e <hci_evt_create>:
{
   1684e:	b538      	push	{r3, r4, r5, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
   16850:	3008      	adds	r0, #8
{
   16852:	460d      	mov	r5, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
   16854:	2102      	movs	r1, #2
{
   16856:	4614      	mov	r4, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
   16858:	f000 fc2c 	bl	170b4 <net_buf_simple_add>
	hdr->evt = evt;
   1685c:	7005      	strb	r5, [r0, #0]
	hdr->len = len;
   1685e:	7044      	strb	r4, [r0, #1]
}
   16860:	bd38      	pop	{r3, r4, r5, pc}

00016862 <bt_hci_evt_create>:
{
   16862:	b570      	push	{r4, r5, r6, lr}
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   16864:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   16868:	460e      	mov	r6, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   1686a:	2100      	movs	r1, #0
{
   1686c:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   1686e:	f7f2 f801 	bl	8874 <bt_buf_get_evt>
	hci_evt_create(buf, evt, len);
   16872:	4632      	mov	r2, r6
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   16874:	4604      	mov	r4, r0
	hci_evt_create(buf, evt, len);
   16876:	4629      	mov	r1, r5
   16878:	f7ff ffe9 	bl	1684e <hci_evt_create>
}
   1687c:	4620      	mov	r0, r4
   1687e:	bd70      	pop	{r4, r5, r6, pc}

00016880 <bt_hci_cmd_complete_create>:
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   16880:	3103      	adds	r1, #3
{
   16882:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   16884:	b2c9      	uxtb	r1, r1
{
   16886:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   16888:	200e      	movs	r0, #14
   1688a:	f7ff ffea 	bl	16862 <bt_hci_evt_create>
	cc = net_buf_add(buf, sizeof(*cc));
   1688e:	2103      	movs	r1, #3
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   16890:	4604      	mov	r4, r0
	cc = net_buf_add(buf, sizeof(*cc));
   16892:	3008      	adds	r0, #8
   16894:	f000 fc0e 	bl	170b4 <net_buf_simple_add>
	cc->ncmd = 1U;
   16898:	2301      	movs	r3, #1
   1689a:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(op);
   1689c:	f8a0 5001 	strh.w	r5, [r0, #1]
}
   168a0:	4620      	mov	r0, r4
   168a2:	bd38      	pop	{r3, r4, r5, pc}

000168a4 <bt_hci_cmd_status_create>:
{
   168a4:	b570      	push	{r4, r5, r6, lr}
   168a6:	4605      	mov	r5, r0
   168a8:	460e      	mov	r6, r1
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   168aa:	200f      	movs	r0, #15
   168ac:	2104      	movs	r1, #4
   168ae:	f7ff ffd8 	bl	16862 <bt_hci_evt_create>
	cs = net_buf_add(buf, sizeof(*cs));
   168b2:	2104      	movs	r1, #4
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   168b4:	4604      	mov	r4, r0
	cs = net_buf_add(buf, sizeof(*cs));
   168b6:	3008      	adds	r0, #8
   168b8:	f000 fbfc 	bl	170b4 <net_buf_simple_add>
	cs->ncmd = 1U;
   168bc:	2201      	movs	r2, #1
	cs->status = status;
   168be:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
   168c0:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
   168c2:	8045      	strh	r5, [r0, #2]
}
   168c4:	4620      	mov	r0, r4
   168c6:	bd70      	pop	{r4, r5, r6, pc}

000168c8 <hci_get_class>:
		switch (node_rx->hdr.type) {
   168c8:	7903      	ldrb	r3, [r0, #4]
   168ca:	2b04      	cmp	r3, #4
}
   168cc:	bf0c      	ite	eq
   168ce:	2002      	moveq	r0, #2
   168d0:	2000      	movne	r0, #0
   168d2:	4770      	bx	lr

000168d4 <bt_rand>:

#include "hal/ecb.h"

int bt_rand(void *buf, size_t len)
{
	return util_rand(buf, len);
   168d4:	f7f2 b926 	b.w	8b24 <util_rand>

000168d8 <disabled_cb>:
	z_impl_k_sem_give(sem);
   168d8:	f7fd bd08 	b.w	142ec <z_impl_k_sem_give>

000168dc <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   168dc:	2300      	movs	r3, #0
   168de:	7003      	strb	r3, [r0, #0]
	*user_id = (TICKER_NODES - FLASH_TICKER_NODES);
   168e0:	2305      	movs	r3, #5
   168e2:	700b      	strb	r3, [r1, #0]
}
   168e4:	4770      	bx	lr

000168e6 <ull_adv_init>:
}
   168e6:	2000      	movs	r0, #0
   168e8:	4770      	bx	lr

000168ea <ull_adv_reset>:
{
   168ea:	b508      	push	{r3, lr}
		(void)disable(handle);
   168ec:	f7f4 f966 	bl	abbc <disable.constprop.0>
}
   168f0:	2000      	movs	r0, #0
   168f2:	bd08      	pop	{r3, pc}

000168f4 <ull_adv_is_enabled>:
{
   168f4:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   168f6:	f7f4 f953 	bl	aba0 <ull_adv_is_enabled_get>
}
   168fa:	3800      	subs	r0, #0
   168fc:	bf18      	it	ne
   168fe:	2001      	movne	r0, #1
   16900:	bd08      	pop	{r3, pc}

00016902 <ull_adv_filter_pol_get>:
{
   16902:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   16904:	f7f4 f94c 	bl	aba0 <ull_adv_is_enabled_get>
	if (!adv) {
   16908:	b110      	cbz	r0, 16910 <ull_adv_filter_pol_get+0xe>
	return adv->lll.filter_policy;
   1690a:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
   1690e:	0980      	lsrs	r0, r0, #6
}
   16910:	bd08      	pop	{r3, pc}

00016912 <ull_scan_init>:
}
   16912:	2000      	movs	r0, #0
   16914:	4770      	bx	lr

00016916 <disable.constprop.0>:

static u8_t disable(u16_t handle)
   16916:	b510      	push	{r4, lr}
{
	struct ll_scan_set *scan;
	u8_t ret;

	scan = ull_scan_is_enabled_get(handle);
   16918:	2000      	movs	r0, #0
   1691a:	f7f4 fa75 	bl	ae08 <ull_scan_is_enabled_get>
	if (!scan) {
   1691e:	4604      	mov	r4, r0
   16920:	b158      	cbz	r0, 1693a <disable.constprop.0+0x24>
	if (scan->lll.conn) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
   16922:	4601      	mov	r1, r0
   16924:	2000      	movs	r0, #0
   16926:	f7f4 f9fb 	bl	ad20 <ull_scan_disable>
	if (ret) {
   1692a:	b928      	cbnz	r0, 16938 <disable.constprop.0+0x22>
		return ret;
	}

	scan->is_enabled = 0U;
   1692c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   16930:	f360 0300 	bfi	r3, r0, #0, #1
   16934:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
}
   16938:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1693a:	200c      	movs	r0, #12
   1693c:	e7fc      	b.n	16938 <disable.constprop.0+0x22>

0001693e <ull_scan_reset>:
{
   1693e:	b508      	push	{r3, lr}
		(void)disable(handle);
   16940:	f7ff ffe9 	bl	16916 <disable.constprop.0>
}
   16944:	2000      	movs	r0, #0
   16946:	bd08      	pop	{r3, pc}

00016948 <ll_scan_enable>:
{
   16948:	b510      	push	{r4, lr}
	if (!enable) {
   1694a:	b918      	cbnz	r0, 16954 <ll_scan_enable+0xc>
}
   1694c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return disable(0);
   16950:	f7ff bfe1 	b.w	16916 <disable.constprop.0>
	scan = ull_scan_is_disabled_get(0);
   16954:	2000      	movs	r0, #0
   16956:	f7f4 fa65 	bl	ae24 <ull_scan_is_disabled_get>
	if (!scan) {
   1695a:	4604      	mov	r4, r0
   1695c:	b198      	cbz	r0, 16986 <ll_scan_enable+0x3e>
	if (scan->own_addr_type & 0x1) {
   1695e:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
   16962:	079b      	lsls	r3, r3, #30
   16964:	d404      	bmi.n	16970 <ll_scan_enable+0x28>
	return ull_scan_enable(scan);
   16966:	4620      	mov	r0, r4
}
   16968:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
   1696c:	f7ea ba38 	b.w	de0 <ull_scan_enable>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
   16970:	2100      	movs	r1, #0
   16972:	2001      	movs	r0, #1
   16974:	f7f2 fde4 	bl	9540 <ll_addr_get>
   16978:	2106      	movs	r1, #6
   1697a:	f7ff fd09 	bl	16390 <mem_nz>
   1697e:	2800      	cmp	r0, #0
   16980:	d1f1      	bne.n	16966 <ll_scan_enable+0x1e>
			return BT_HCI_ERR_INVALID_PARAM;
   16982:	2012      	movs	r0, #18
}
   16984:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   16986:	200c      	movs	r0, #12
   16988:	e7fc      	b.n	16984 <ll_scan_enable+0x3c>

0001698a <ull_scan_is_enabled>:
{
   1698a:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   1698c:	f7f4 fa3c 	bl	ae08 <ull_scan_is_enabled_get>
	if (!scan) {
   16990:	b140      	cbz	r0, 169a4 <ull_scan_is_enabled+0x1a>
	return (((u32_t)scan->is_enabled << scan->lll.type) |
   16992:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
   16996:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
   1699a:	f003 0301 	and.w	r3, r3, #1
   1699e:	09c0      	lsrs	r0, r0, #7
   169a0:	fa03 f000 	lsl.w	r0, r3, r0
}
   169a4:	bd08      	pop	{r3, pc}

000169a6 <ull_scan_filter_pol_get>:
{
   169a6:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   169a8:	f7f4 fa2e 	bl	ae08 <ull_scan_is_enabled_get>
	if (!scan) {
   169ac:	b118      	cbz	r0, 169b6 <ull_scan_filter_pol_get+0x10>
	return scan->lll.filter_policy;
   169ae:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
   169b2:	f3c0 00c1 	ubfx	r0, r0, #3, #2
}
   169b6:	bd08      	pop	{r3, pc}

000169b8 <ll_wl_size_get>:
}
   169b8:	2008      	movs	r0, #8
   169ba:	4770      	bx	lr

000169bc <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   169bc:	2000      	movs	r0, #0
   169be:	f7f1 bff3 	b.w	89a8 <mayfly_run>

000169c2 <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   169c2:	4668      	mov	r0, sp
   169c4:	f020 0107 	bic.w	r1, r0, #7
   169c8:	468d      	mov	sp, r1
   169ca:	b501      	push	{r0, lr}
	isr_radio();
   169cc:	f7f5 fc7e 	bl	c2cc <isr_radio>
	ISR_DIRECT_PM();
   169d0:	f7ef f8cc 	bl	5b6c <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   169d4:	f7ef fbc6 	bl	6164 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   169d8:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   169dc:	4685      	mov	sp, r0
   169de:	4770      	bx	lr

000169e0 <lll_reset>:
}
   169e0:	2000      	movs	r0, #0
   169e2:	4770      	bx	lr

000169e4 <lll_prepare>:
{
   169e4:	b513      	push	{r0, r1, r4, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
   169e6:	2400      	movs	r4, #0
   169e8:	9401      	str	r4, [sp, #4]
   169ea:	9c04      	ldr	r4, [sp, #16]
   169ec:	9400      	str	r4, [sp, #0]
   169ee:	f7f4 fbcf 	bl	b190 <prepare>
}
   169f2:	b002      	add	sp, #8
   169f4:	bd10      	pop	{r4, pc}

000169f6 <lll_prepare_done>:
}
   169f6:	2000      	movs	r0, #0
   169f8:	4770      	bx	lr

000169fa <lll_evt_offset_get>:
{
   169fa:	4603      	mov	r3, r0
   169fc:	e9d0 2000 	ldrd	r2, r0, [r0]
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
   16a00:	2a00      	cmp	r2, #0
   16a02:	da04      	bge.n	16a0e <lll_evt_offset_get+0x14>
		return MAX(evt->ticks_active_to_start,
   16a04:	689b      	ldr	r3, [r3, #8]
   16a06:	4298      	cmp	r0, r3
   16a08:	bf38      	it	cc
   16a0a:	4618      	movcc	r0, r3
   16a0c:	4770      	bx	lr
		return MAX(evt->ticks_active_to_start,
   16a0e:	4290      	cmp	r0, r2
   16a10:	bf38      	it	cc
   16a12:	4610      	movcc	r0, r2
}
   16a14:	4770      	bx	lr

00016a16 <lll_preempt_calc>:
{
   16a16:	b510      	push	{r4, lr}
   16a18:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
   16a1a:	f7ff ff0a 	bl	16832 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
   16a1e:	4621      	mov	r1, r4
   16a20:	f7ff ff09 	bl	16836 <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   16a24:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
   16a26:	0203      	lsls	r3, r0, #8
   16a28:	d404      	bmi.n	16a34 <lll_preempt_calc+0x1e>
   16a2a:	2809      	cmp	r0, #9
   16a2c:	bf94      	ite	ls
   16a2e:	2000      	movls	r0, #0
   16a30:	2001      	movhi	r0, #1
}
   16a32:	bd10      	pop	{r4, pc}
	return 0;
   16a34:	2000      	movs	r0, #0
   16a36:	e7fc      	b.n	16a32 <lll_preempt_calc+0x1c>

00016a38 <is_abort_cb>:
}
   16a38:	f06f 0047 	mvn.w	r0, #71	; 0x47
   16a3c:	4770      	bx	lr

00016a3e <isr_race>:
	radio_status_reset();
   16a3e:	f7f5 bd35 	b.w	c4ac <radio_status_reset>

00016a42 <isr_abort>:
{
   16a42:	b510      	push	{r4, lr}
   16a44:	4604      	mov	r4, r0
	radio_status_reset();
   16a46:	f7f5 fd31 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
   16a4a:	f7f5 fdf7 	bl	c63c <radio_tmr_status_reset>
	radio_filter_status_reset();
   16a4e:	f7f5 fddd 	bl	c60c <radio_filter_status_reset>
	radio_ar_status_reset();
   16a52:	f7f5 fed1 	bl	c7f8 <radio_ar_status_reset>
	radio_rssi_status_reset();
   16a56:	f7f5 fda1 	bl	c59c <radio_rssi_status_reset>
	radio_filter_disable();
   16a5a:	f7f5 fdcd 	bl	c5f8 <radio_filter_disable>
	isr_cleanup(param);
   16a5e:	4620      	mov	r0, r4
}
   16a60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   16a64:	f7f4 bd4c 	b.w	b500 <isr_cleanup>

00016a68 <isr_done>:
{
   16a68:	b510      	push	{r4, lr}
   16a6a:	4604      	mov	r4, r0
	radio_status_reset();
   16a6c:	f7f5 fd1e 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
   16a70:	f7f5 fde4 	bl	c63c <radio_tmr_status_reset>
	radio_filter_status_reset();
   16a74:	f7f5 fdca 	bl	c60c <radio_filter_status_reset>
	radio_ar_status_reset();
   16a78:	f7f5 febe 	bl	c7f8 <radio_ar_status_reset>
	radio_rssi_status_reset();
   16a7c:	f7f5 fd8e 	bl	c59c <radio_rssi_status_reset>
	if (lll->chan_map_curr) {
   16a80:	7a23      	ldrb	r3, [r4, #8]
   16a82:	f013 0f38 	tst.w	r3, #56	; 0x38
   16a86:	d008      	beq.n	16a9a <isr_done+0x32>
		chan_prepare(lll);
   16a88:	4620      	mov	r0, r4
   16a8a:	f7f4 fe4d 	bl	b728 <chan_prepare>
		radio_tx_enable();
   16a8e:	f7f5 fcf5 	bl	c47c <radio_tx_enable>
}
   16a92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   16a96:	f7f5 be9b 	b.w	c7d0 <radio_tmr_end_capture>
	radio_filter_disable();
   16a9a:	f7f5 fdad 	bl	c5f8 <radio_filter_disable>
	isr_cleanup(param);
   16a9e:	4620      	mov	r0, r4
}
   16aa0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   16aa4:	f7f4 bd2c 	b.w	b500 <isr_cleanup>

00016aa8 <lll_adv_init>:
}
   16aa8:	2000      	movs	r0, #0
   16aaa:	4770      	bx	lr

00016aac <lll_adv_reset>:
   16aac:	2000      	movs	r0, #0
   16aae:	4770      	bx	lr

00016ab0 <isr_race>:
	radio_status_reset();
   16ab0:	f7f5 bcfc 	b.w	c4ac <radio_status_reset>

00016ab4 <isr_done>:
{
   16ab4:	b508      	push	{r3, lr}
	isr_common_done(param);
   16ab6:	f7f5 f84b 	bl	bb50 <isr_common_done>
	radio_rx_enable();
   16aba:	f7f5 fcd9 	bl	c470 <radio_rx_enable>
}
   16abe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   16ac2:	f7f5 be85 	b.w	c7d0 <radio_tmr_end_capture>

00016ac6 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   16ac6:	68c3      	ldr	r3, [r0, #12]
{
   16ac8:	b570      	push	{r4, r5, r6, lr}
   16aca:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   16acc:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   16ace:	f7ff feb0 	bl	16832 <ticker_ticks_now_get>
   16ad2:	4605      	mov	r5, r0
   16ad4:	4630      	mov	r0, r6
   16ad6:	f7ff ff90 	bl	169fa <lll_evt_offset_get>
	p->remainder = 0;
   16ada:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   16adc:	1a2d      	subs	r5, r5, r0
   16ade:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
   16ae0:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   16ae2:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   16ae4:	4620      	mov	r0, r4
}
   16ae6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   16aea:	f7f4 bf55 	b.w	b998 <prepare_cb>

00016aee <isr_window>:
{
   16aee:	b508      	push	{r3, lr}
	isr_common_done(param);
   16af0:	f7f5 f82e 	bl	bb50 <isr_common_done>
	ticks_at_start = ticker_ticks_now_get() +
   16af4:	f7ff fe9d 	bl	16832 <ticker_ticks_now_get>
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
   16af8:	1cc1      	adds	r1, r0, #3
   16afa:	2000      	movs	r0, #0
   16afc:	f7f5 fe2a 	bl	c754 <radio_tmr_start_tick>
}
   16b00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   16b04:	f7f5 be64 	b.w	c7d0 <radio_tmr_end_capture>

00016b08 <isr_abort>:
{
   16b08:	b513      	push	{r0, r1, r4, lr}
   16b0a:	4604      	mov	r4, r0
	radio_status_reset();
   16b0c:	f7f5 fcce 	bl	c4ac <radio_status_reset>
	radio_tmr_status_reset();
   16b10:	f7f5 fd94 	bl	c63c <radio_tmr_status_reset>
	radio_filter_status_reset();
   16b14:	f7f5 fd7a 	bl	c60c <radio_filter_status_reset>
	radio_ar_status_reset();
   16b18:	f7f5 fe6e 	bl	c7f8 <radio_ar_status_reset>
	radio_rssi_status_reset();
   16b1c:	f7f5 fd3e 	bl	c59c <radio_rssi_status_reset>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   16b20:	2300      	movs	r3, #0
   16b22:	9300      	str	r3, [sp, #0]
   16b24:	2203      	movs	r2, #3
   16b26:	4619      	mov	r1, r3
   16b28:	4618      	mov	r0, r3
   16b2a:	f7f2 fccf 	bl	94cc <ticker_stop>
	radio_disable();
   16b2e:	f7f5 fcab 	bl	c488 <radio_disable>
	isr_cleanup(param);
   16b32:	4620      	mov	r0, r4
}
   16b34:	b002      	add	sp, #8
   16b36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   16b3a:	f7f5 b921 	b.w	bd80 <isr_cleanup>

00016b3e <lll_scan_init>:
}
   16b3e:	2000      	movs	r0, #0
   16b40:	4770      	bx	lr

00016b42 <lll_scan_reset>:
   16b42:	2000      	movs	r0, #0
   16b44:	4770      	bx	lr

00016b46 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
   16b46:	b570      	push	{r4, r5, r6, lr}
   16b48:	b08c      	sub	sp, #48	; 0x30
   16b4a:	460e      	mov	r6, r1
   16b4c:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   16b4e:	4601      	mov	r1, r0
   16b50:	2210      	movs	r2, #16
   16b52:	4668      	mov	r0, sp
{
   16b54:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   16b56:	f7ff fc0c 	bl	16372 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   16b5a:	2210      	movs	r2, #16
   16b5c:	eb0d 0002 	add.w	r0, sp, r2
   16b60:	4631      	mov	r1, r6
   16b62:	f7ff fc06 	bl	16372 <mem_rcopy>

	do_ecb(&ecb);
   16b66:	4668      	mov	r0, sp
   16b68:	f7f5 fb0e 	bl	c188 <do_ecb>

	if (cipher_text_le) {
   16b6c:	b125      	cbz	r5, 16b78 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   16b6e:	2210      	movs	r2, #16
   16b70:	a908      	add	r1, sp, #32
   16b72:	4628      	mov	r0, r5
   16b74:	f7ff fbfd 	bl	16372 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   16b78:	b124      	cbz	r4, 16b84 <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   16b7a:	2210      	movs	r2, #16
   16b7c:	a908      	add	r1, sp, #32
   16b7e:	4620      	mov	r0, r4
   16b80:	f7ff fa5b 	bl	1603a <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   16b84:	b00c      	add	sp, #48	; 0x30
   16b86:	bd70      	pop	{r4, r5, r6, pc}

00016b88 <radio_tx_chain_delay_get>:
}
   16b88:	2001      	movs	r0, #1
   16b8a:	4770      	bx	lr

00016b8c <radio_rx_chain_delay_get>:
	switch (phy) {
   16b8c:	2802      	cmp	r0, #2
}
   16b8e:	bf14      	ite	ne
   16b90:	200a      	movne	r0, #10
   16b92:	2005      	moveq	r0, #5
   16b94:	4770      	bx	lr

00016b96 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   16b96:	4288      	cmp	r0, r1
   16b98:	d00c      	beq.n	16bb4 <mayfly_prio_is_equal+0x1e>
	return (caller_id == callee_id) ||
   16b9a:	b978      	cbnz	r0, 16bbc <mayfly_prio_is_equal+0x26>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
   16b9c:	1e48      	subs	r0, r1, #1
   16b9e:	2801      	cmp	r0, #1
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   16ba0:	bf8c      	ite	hi
   16ba2:	2000      	movhi	r0, #0
   16ba4:	2001      	movls	r0, #1
   16ba6:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   16ba8:	f011 0ffd 	tst.w	r1, #253	; 0xfd
   16bac:	bf0c      	ite	eq
   16bae:	2001      	moveq	r0, #1
   16bb0:	2000      	movne	r0, #0
   16bb2:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   16bb4:	2001      	movs	r0, #1
   16bb6:	4770      	bx	lr
   16bb8:	2000      	movs	r0, #0
}
   16bba:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   16bbc:	2801      	cmp	r0, #1
   16bbe:	d0f3      	beq.n	16ba8 <mayfly_prio_is_equal+0x12>
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
   16bc0:	2802      	cmp	r0, #2
   16bc2:	d1f9      	bne.n	16bb8 <mayfly_prio_is_equal+0x22>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   16bc4:	2901      	cmp	r1, #1
   16bc6:	e7eb      	b.n	16ba0 <mayfly_prio_is_equal+0xa>

00016bc8 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
   16bc8:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
   16bca:	2000      	movs	r0, #0
   16bcc:	f7f5 bad4 	b.w	c178 <cntr_cmp_set>

00016bd0 <sys_put_le32>:
	dst[1] = val >> 8;
   16bd0:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   16bd4:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   16bd6:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   16bd8:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   16bda:	0a00      	lsrs	r0, r0, #8
   16bdc:	704b      	strb	r3, [r1, #1]
   16bde:	70c8      	strb	r0, [r1, #3]
}
   16be0:	4770      	bx	lr

00016be2 <hci_vendor_read_static_addr>:
				 u8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   16be2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
{
   16be6:	b510      	push	{r4, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   16be8:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   16bec:	3201      	adds	r2, #1
{
   16bee:	4604      	mov	r4, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   16bf0:	d106      	bne.n	16c00 <hci_vendor_read_static_addr+0x1e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   16bf2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   16bf6:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   16bfa:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   16bfc:	4293      	cmp	r3, r2
   16bfe:	d044      	beq.n	16c8a <hci_vendor_read_static_addr+0xa8>
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   16c00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16c04:	f8d2 00a0 	ldr.w	r0, [r2, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   16c08:	f010 0001 	ands.w	r0, r0, #1
   16c0c:	d036      	beq.n	16c7c <hci_vendor_read_static_addr+0x9a>
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
   16c0e:	4621      	mov	r1, r4
   16c10:	f8d2 00a4 	ldr.w	r0, [r2, #164]	; 0xa4
   16c14:	f7ff ffdc 	bl	16bd0 <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
   16c18:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
	dst[0] = val;
   16c1c:	7123      	strb	r3, [r4, #4]
	dst[1] = val >> 8;
   16c1e:	f3c3 2307 	ubfx	r3, r3, #8, #8

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
   16c22:	f063 033f 	orn	r3, r3, #63	; 0x3f
   16c26:	7163      	strb	r3, [r4, #5]

		/* If no public address is provided and a static address is
		 * available, then it is recommended to return an identity root
		 * key (if available) from this command.
		 */
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   16c28:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
   16c2c:	3101      	adds	r1, #1
   16c2e:	f104 0306 	add.w	r3, r4, #6
   16c32:	d024      	beq.n	16c7e <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   16c34:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   16c38:	3101      	adds	r1, #1
   16c3a:	d020      	beq.n	16c7e <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   16c3c:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   16c40:	3101      	adds	r1, #1
   16c42:	d01c      	beq.n	16c7e <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
   16c44:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   16c48:	3101      	adds	r1, #1
   16c4a:	d018      	beq.n	16c7e <hci_vendor_read_static_addr+0x9c>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   16c4c:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
   16c50:	4619      	mov	r1, r3
   16c52:	f7ff ffbd 	bl	16bd0 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
   16c56:	f104 010a 	add.w	r1, r4, #10
   16c5a:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
   16c5e:	f7ff ffb7 	bl	16bd0 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
   16c62:	f104 010e 	add.w	r1, r4, #14
   16c66:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
   16c6a:	f7ff ffb1 	bl	16bd0 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
   16c6e:	f104 0112 	add.w	r1, r4, #18
   16c72:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
   16c76:	f7ff ffab 	bl	16bd0 <sys_put_le32>
		} else {
			/* Mark IR as invalid */
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
		}

		return 1;
   16c7a:	2001      	movs	r0, #1
	}

	return 0;
}
   16c7c:	bd10      	pop	{r4, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
   16c7e:	2210      	movs	r2, #16
   16c80:	2100      	movs	r1, #0
   16c82:	4618      	mov	r0, r3
   16c84:	f7ff fa04 	bl	16090 <memset>
   16c88:	e7f7      	b.n	16c7a <hci_vendor_read_static_addr+0x98>
	return 0;
   16c8a:	2000      	movs	r0, #0
   16c8c:	e7f6      	b.n	16c7c <hci_vendor_read_static_addr+0x9a>

00016c8e <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(u8_t ir[16], u8_t er[16])
{
   16c8e:	b510      	push	{r4, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
   16c90:	2210      	movs	r2, #16
{
   16c92:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
   16c94:	2100      	movs	r1, #0
   16c96:	f7ff f9fb 	bl	16090 <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   16c9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16c9e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   16ca2:	3301      	adds	r3, #1
   16ca4:	d023      	beq.n	16cee <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   16ca6:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   16caa:	3301      	adds	r3, #1
   16cac:	d01f      	beq.n	16cee <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   16cae:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   16cb2:	3301      	adds	r3, #1
   16cb4:	d01b      	beq.n	16cee <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   16cb6:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   16cba:	3301      	adds	r3, #1
   16cbc:	d017      	beq.n	16cee <hci_vendor_read_key_hierarchy_roots+0x60>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
   16cbe:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
   16cc2:	4621      	mov	r1, r4
   16cc4:	f7ff ff84 	bl	16bd0 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
   16cc8:	1d21      	adds	r1, r4, #4
   16cca:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
   16cce:	f7ff ff7f 	bl	16bd0 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
   16cd2:	f104 0108 	add.w	r1, r4, #8
   16cd6:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
   16cda:	f7ff ff79 	bl	16bd0 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   16cde:	f104 010c 	add.w	r1, r4, #12
   16ce2:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
   16ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   16cea:	f7ff bf71 	b.w	16bd0 <sys_put_le32>
		(void)memset(er, 0x00, 16);
   16cee:	4620      	mov	r0, r4
   16cf0:	2210      	movs	r2, #16
}
   16cf2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
   16cf6:	2100      	movs	r1, #0
   16cf8:	f7ff b9ca 	b.w	16090 <memset>

00016cfc <lfs_api_sync>:
}
   16cfc:	2000      	movs	r0, #0
   16cfe:	4770      	bx	lr

00016d00 <get_page_cb>:
{
   16d00:	b530      	push	{r4, r5, lr}
	size_t info_end = info_start + info->size - 1U;
   16d02:	e9d0 4200 	ldrd	r4, r2, [r0]
	size_t area_start = ctx->area->fa_off;
   16d06:	680b      	ldr	r3, [r1, #0]
	size_t info_end = info_start + info->size - 1U;
   16d08:	1e50      	subs	r0, r2, #1
	size_t area_start = ctx->area->fa_off;
   16d0a:	685d      	ldr	r5, [r3, #4]
	size_t info_end = info_start + info->size - 1U;
   16d0c:	4420      	add	r0, r4
	if (info_end < area_start) {
   16d0e:	42a8      	cmp	r0, r5
   16d10:	d308      	bcc.n	16d24 <get_page_cb+0x24>
	size_t area_end = area_start + ctx->area->fa_size - 1U;
   16d12:	689b      	ldr	r3, [r3, #8]
   16d14:	3b01      	subs	r3, #1
   16d16:	442b      	add	r3, r5
	if (info_start > area_end) {
   16d18:	429c      	cmp	r4, r3
   16d1a:	d805      	bhi.n	16d28 <get_page_cb+0x28>
	if (info->size > ctx->max_size) {
   16d1c:	684b      	ldr	r3, [r1, #4]
   16d1e:	429a      	cmp	r2, r3
   16d20:	d900      	bls.n	16d24 <get_page_cb+0x24>
		ctx->max_size = info->size;
   16d22:	604a      	str	r2, [r1, #4]
		return true;
   16d24:	2001      	movs	r0, #1
   16d26:	e000      	b.n	16d2a <get_page_cb+0x2a>
		return false;
   16d28:	2000      	movs	r0, #0
}
   16d2a:	bd30      	pop	{r4, r5, pc}

00016d2c <k_mutex_unlock>:
	return z_impl_k_mutex_unlock(mutex);
   16d2c:	f7fc bf42 	b.w	13bb4 <z_impl_k_mutex_unlock>

00016d30 <fs_lock>:
	return z_impl_k_mutex_lock(mutex, timeout);
   16d30:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16d34:	30ec      	adds	r0, #236	; 0xec
   16d36:	f7fc becb 	b.w	13ad0 <z_impl_k_mutex_lock>

00016d3a <littlefs_statvfs>:
{
   16d3a:	4603      	mov	r3, r0
   16d3c:	b570      	push	{r4, r5, r6, lr}
	struct fs_littlefs *fs = mountp->fs_data;
   16d3e:	691e      	ldr	r6, [r3, #16]
{
   16d40:	4614      	mov	r4, r2
	stat->f_bsize = lfs->cfg->prog_size;
   16d42:	f8d6 20d8 	ldr.w	r2, [r6, #216]	; 0xd8
{
   16d46:	4608      	mov	r0, r1
	stat->f_bsize = lfs->cfg->prog_size;
   16d48:	6991      	ldr	r1, [r2, #24]
   16d4a:	6021      	str	r1, [r4, #0]
	stat->f_frsize = lfs->cfg->block_size;
   16d4c:	69d1      	ldr	r1, [r2, #28]
	stat->f_blocks = lfs->cfg->block_count;
   16d4e:	6a12      	ldr	r2, [r2, #32]
   16d50:	60a2      	str	r2, [r4, #8]
	stat->f_frsize = lfs->cfg->block_size;
   16d52:	6061      	str	r1, [r4, #4]
	path = fs_impl_strip_prefix(path, mountp);
   16d54:	4619      	mov	r1, r3
   16d56:	f7f6 facd 	bl	d2f4 <fs_impl_strip_prefix>
	fs_lock(fs);
   16d5a:	4630      	mov	r0, r6
   16d5c:	f7ff ffe8 	bl	16d30 <fs_lock>
	ssize_t ret = lfs_fs_size(lfs);
   16d60:	f106 0070 	add.w	r0, r6, #112	; 0x70
   16d64:	f7fb fbf6 	bl	12554 <lfs_fs_size>
   16d68:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
   16d6a:	f106 00ec 	add.w	r0, r6, #236	; 0xec
   16d6e:	f7ff ffdd 	bl	16d2c <k_mutex_unlock>
	if (ret >= 0) {
   16d72:	2d00      	cmp	r5, #0
		stat->f_bfree = stat->f_blocks - ret;
   16d74:	bfa1      	itttt	ge
   16d76:	68a0      	ldrge	r0, [r4, #8]
   16d78:	1b40      	subge	r0, r0, r5
		ret = 0;
   16d7a:	2500      	movge	r5, #0
		stat->f_bfree = stat->f_blocks - ret;
   16d7c:	60e0      	strge	r0, [r4, #12]
	return lfs_to_errno(ret);
   16d7e:	4628      	mov	r0, r5
}
   16d80:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
   16d84:	f7f6 bada 	b.w	d33c <lfs_to_errno>

00016d88 <littlefs_mkdir>:
{
   16d88:	b538      	push	{r3, r4, r5, lr}
   16d8a:	4603      	mov	r3, r0
   16d8c:	4608      	mov	r0, r1
	path = fs_impl_strip_prefix(path, mountp);
   16d8e:	4619      	mov	r1, r3
	struct fs_littlefs *fs = mountp->fs_data;
   16d90:	691d      	ldr	r5, [r3, #16]
	path = fs_impl_strip_prefix(path, mountp);
   16d92:	f7f6 faaf 	bl	d2f4 <fs_impl_strip_prefix>
   16d96:	4604      	mov	r4, r0
	fs_lock(fs);
   16d98:	4628      	mov	r0, r5
   16d9a:	f7ff ffc9 	bl	16d30 <fs_lock>
	int ret = lfs_mkdir(&fs->lfs, path);
   16d9e:	4621      	mov	r1, r4
   16da0:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16da4:	f7fc f874 	bl	12e90 <lfs_mkdir>
   16da8:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16daa:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16dae:	f7ff ffbd 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16db2:	4620      	mov	r0, r4
}
   16db4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return lfs_to_errno(ret);
   16db8:	f7f6 bac0 	b.w	d33c <lfs_to_errno>

00016dbc <littlefs_rename>:
{
   16dbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16dbe:	4604      	mov	r4, r0
   16dc0:	4608      	mov	r0, r1
	from = fs_impl_strip_prefix(from, mountp);
   16dc2:	4621      	mov	r1, r4
	struct fs_littlefs *fs = mountp->fs_data;
   16dc4:	6925      	ldr	r5, [r4, #16]
{
   16dc6:	4617      	mov	r7, r2
	from = fs_impl_strip_prefix(from, mountp);
   16dc8:	f7f6 fa94 	bl	d2f4 <fs_impl_strip_prefix>
	to = fs_impl_strip_prefix(to, mountp);
   16dcc:	4621      	mov	r1, r4
	from = fs_impl_strip_prefix(from, mountp);
   16dce:	4606      	mov	r6, r0
	to = fs_impl_strip_prefix(to, mountp);
   16dd0:	4638      	mov	r0, r7
   16dd2:	f7f6 fa8f 	bl	d2f4 <fs_impl_strip_prefix>
   16dd6:	4604      	mov	r4, r0
	fs_lock(fs);
   16dd8:	4628      	mov	r0, r5
   16dda:	f7ff ffa9 	bl	16d30 <fs_lock>
	int ret = lfs_rename(&fs->lfs, from, to);
   16dde:	4622      	mov	r2, r4
   16de0:	4631      	mov	r1, r6
   16de2:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16de6:	f7fc fa89 	bl	132fc <lfs_rename>
   16dea:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16dec:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16df0:	f7ff ff9c 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16df4:	4620      	mov	r0, r4
}
   16df6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return lfs_to_errno(ret);
   16dfa:	f7f6 ba9f 	b.w	d33c <lfs_to_errno>

00016dfe <littlefs_unlink>:
{
   16dfe:	b538      	push	{r3, r4, r5, lr}
   16e00:	4603      	mov	r3, r0
   16e02:	4608      	mov	r0, r1
	path = fs_impl_strip_prefix(path, mountp);
   16e04:	4619      	mov	r1, r3
	struct fs_littlefs *fs = mountp->fs_data;
   16e06:	691d      	ldr	r5, [r3, #16]
	path = fs_impl_strip_prefix(path, mountp);
   16e08:	f7f6 fa74 	bl	d2f4 <fs_impl_strip_prefix>
   16e0c:	4604      	mov	r4, r0
	fs_lock(fs);
   16e0e:	4628      	mov	r0, r5
   16e10:	f7ff ff8e 	bl	16d30 <fs_lock>
	int ret = lfs_remove(&fs->lfs, path);
   16e14:	4621      	mov	r1, r4
   16e16:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16e1a:	f7fc fa01 	bl	13220 <lfs_remove>
   16e1e:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16e20:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16e24:	f7ff ff82 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16e28:	4620      	mov	r0, r4
}
   16e2a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return lfs_to_errno(ret);
   16e2e:	f7f6 ba85 	b.w	d33c <lfs_to_errno>

00016e32 <littlefs_readdir>:
{
   16e32:	b570      	push	{r4, r5, r6, lr}
	struct fs_littlefs *fs = dp->mp->fs_data;
   16e34:	6843      	ldr	r3, [r0, #4]
   16e36:	691e      	ldr	r6, [r3, #16]
{
   16e38:	4604      	mov	r4, r0
   16e3a:	b0c2      	sub	sp, #264	; 0x108
	fs_lock(fs);
   16e3c:	4630      	mov	r0, r6
{
   16e3e:	460d      	mov	r5, r1
	fs_lock(fs);
   16e40:	f7ff ff76 	bl	16d30 <fs_lock>
	int ret = lfs_dir_read(&fs->lfs, dp->dirp, &info);
   16e44:	6821      	ldr	r1, [r4, #0]
   16e46:	466a      	mov	r2, sp
   16e48:	f106 0070 	add.w	r0, r6, #112	; 0x70
   16e4c:	f7fa ff90 	bl	11d70 <lfs_dir_read>
   16e50:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16e52:	f106 00ec 	add.w	r0, r6, #236	; 0xec
   16e56:	f7ff ff69 	bl	16d2c <k_mutex_unlock>
	if (ret > 0) {
   16e5a:	2c00      	cmp	r4, #0
   16e5c:	dd17      	ble.n	16e8e <littlefs_readdir+0x5c>
		       FS_DIR_ENTRY_DIR : FS_DIR_ENTRY_FILE);
   16e5e:	f89d 3000 	ldrb.w	r3, [sp]
   16e62:	1e9a      	subs	r2, r3, #2
   16e64:	4253      	negs	r3, r2
   16e66:	4153      	adcs	r3, r2
   16e68:	702b      	strb	r3, [r5, #0]
	entry->size = info->size;
   16e6a:	9b01      	ldr	r3, [sp, #4]
   16e6c:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
	strncpy(entry->name, info->name, sizeof(entry->name));
   16e70:	f240 1201 	movw	r2, #257	; 0x101
   16e74:	a902      	add	r1, sp, #8
   16e76:	1c68      	adds	r0, r5, #1
	entry->name[sizeof(entry->name) - 1] = '\0';
   16e78:	2400      	movs	r4, #0
	strncpy(entry->name, info->name, sizeof(entry->name));
   16e7a:	f7ff f88b 	bl	15f94 <strncpy>
	entry->name[sizeof(entry->name) - 1] = '\0';
   16e7e:	f885 4101 	strb.w	r4, [r5, #257]	; 0x101
	return lfs_to_errno(ret);
   16e82:	4620      	mov	r0, r4
}
   16e84:	b042      	add	sp, #264	; 0x108
   16e86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
   16e8a:	f7f6 ba57 	b.w	d33c <lfs_to_errno>
		entry->name[0] = 0;
   16e8e:	bf08      	it	eq
   16e90:	706c      	strbeq	r4, [r5, #1]
   16e92:	e7f6      	b.n	16e82 <littlefs_readdir+0x50>

00016e94 <littlefs_close>:
	struct fs_littlefs *fs = fp->mp->fs_data;
   16e94:	6843      	ldr	r3, [r0, #4]
{
   16e96:	b570      	push	{r4, r5, r6, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16e98:	691e      	ldr	r6, [r3, #16]
{
   16e9a:	4604      	mov	r4, r0
	fs_lock(fs);
   16e9c:	4630      	mov	r0, r6
   16e9e:	f7ff ff47 	bl	16d30 <fs_lock>
	int ret = lfs_file_close(&fs->lfs, LFS_FILEP(fp));
   16ea2:	6821      	ldr	r1, [r4, #0]
   16ea4:	f106 0070 	add.w	r0, r6, #112	; 0x70
   16ea8:	f001 fce8 	bl	1887c <lfs_file_close>
   16eac:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
   16eae:	f106 00ec 	add.w	r0, r6, #236	; 0xec
   16eb2:	f7ff ff3b 	bl	16d2c <k_mutex_unlock>
	release_file_data(fp);
   16eb6:	4620      	mov	r0, r4
   16eb8:	f7f6 fa2e 	bl	d318 <release_file_data>
	return lfs_to_errno(ret);
   16ebc:	4628      	mov	r0, r5
}
   16ebe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
   16ec2:	f7f6 ba3b 	b.w	d33c <lfs_to_errno>

00016ec6 <littlefs_sync>:
{
   16ec6:	b538      	push	{r3, r4, r5, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16ec8:	6843      	ldr	r3, [r0, #4]
   16eca:	691d      	ldr	r5, [r3, #16]
{
   16ecc:	4604      	mov	r4, r0
	fs_lock(fs);
   16ece:	4628      	mov	r0, r5
   16ed0:	f7ff ff2e 	bl	16d30 <fs_lock>
	int ret = lfs_file_sync(&fs->lfs, LFS_FILEP(fp));
   16ed4:	6821      	ldr	r1, [r4, #0]
   16ed6:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16eda:	f001 fc86 	bl	187ea <lfs_file_sync>
   16ede:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16ee0:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16ee4:	f7ff ff22 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16ee8:	4620      	mov	r0, r4
}
   16eea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return lfs_to_errno(ret);
   16eee:	f7f6 ba25 	b.w	d33c <lfs_to_errno>

00016ef2 <littlefs_truncate>:
	struct fs_littlefs *fs = fp->mp->fs_data;
   16ef2:	6843      	ldr	r3, [r0, #4]
{
   16ef4:	b570      	push	{r4, r5, r6, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16ef6:	691d      	ldr	r5, [r3, #16]
{
   16ef8:	4604      	mov	r4, r0
   16efa:	460e      	mov	r6, r1
	fs_lock(fs);
   16efc:	4628      	mov	r0, r5
   16efe:	f7ff ff17 	bl	16d30 <fs_lock>
	int ret = lfs_file_truncate(&fs->lfs, LFS_FILEP(fp), length);
   16f02:	6821      	ldr	r1, [r4, #0]
   16f04:	4632      	mov	r2, r6
   16f06:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16f0a:	f001 fc1d 	bl	18748 <lfs_file_truncate>
   16f0e:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16f10:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16f14:	f7ff ff0a 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16f18:	4620      	mov	r0, r4
}
   16f1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
   16f1e:	f7f6 ba0d 	b.w	d33c <lfs_to_errno>

00016f22 <littlefs_tell>:
{
   16f22:	b538      	push	{r3, r4, r5, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16f24:	6843      	ldr	r3, [r0, #4]
   16f26:	691d      	ldr	r5, [r3, #16]
{
   16f28:	4604      	mov	r4, r0
	fs_lock(fs);
   16f2a:	4628      	mov	r0, r5
   16f2c:	f7ff ff00 	bl	16d30 <fs_lock>
	off_t ret = lfs_file_tell(&fs->lfs, LFS_FILEP(fp));
   16f30:	6821      	ldr	r1, [r4, #0]
   16f32:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16f36:	f001 fa21 	bl	1837c <lfs_file_tell>
   16f3a:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16f3c:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16f40:	f7ff fef4 	bl	16d2c <k_mutex_unlock>
}
   16f44:	4620      	mov	r0, r4
   16f46:	bd38      	pop	{r3, r4, r5, pc}

00016f48 <littlefs_seek>:
{
   16f48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16f4a:	6843      	ldr	r3, [r0, #4]
   16f4c:	691d      	ldr	r5, [r3, #16]
{
   16f4e:	4604      	mov	r4, r0
   16f50:	460e      	mov	r6, r1
   16f52:	4617      	mov	r7, r2
	fs_lock(fs);
   16f54:	4628      	mov	r0, r5
   16f56:	f7ff feeb 	bl	16d30 <fs_lock>
	off_t ret = lfs_file_seek(&fs->lfs, LFS_FILEP(fp), off, whence);
   16f5a:	6821      	ldr	r1, [r4, #0]
   16f5c:	463b      	mov	r3, r7
   16f5e:	4632      	mov	r2, r6
   16f60:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16f64:	f001 fbd6 	bl	18714 <lfs_file_seek>
   16f68:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16f6a:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16f6e:	f7ff fedd 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16f72:	ea04 70e4 	and.w	r0, r4, r4, asr #31
}
   16f76:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return lfs_to_errno(ret);
   16f7a:	f7f6 b9df 	b.w	d33c <lfs_to_errno>

00016f7e <littlefs_write>:
{
   16f7e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16f80:	6843      	ldr	r3, [r0, #4]
   16f82:	691d      	ldr	r5, [r3, #16]
{
   16f84:	4604      	mov	r4, r0
   16f86:	460e      	mov	r6, r1
   16f88:	4617      	mov	r7, r2
	fs_lock(fs);
   16f8a:	4628      	mov	r0, r5
   16f8c:	f7ff fed0 	bl	16d30 <fs_lock>
	ssize_t ret = lfs_file_write(&fs->lfs, LFS_FILEP(fp), ptr, len);
   16f90:	6821      	ldr	r1, [r4, #0]
   16f92:	463b      	mov	r3, r7
   16f94:	4632      	mov	r2, r6
   16f96:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16f9a:	f001 fa45 	bl	18428 <lfs_file_write>
   16f9e:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16fa0:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16fa4:	f7ff fec2 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16fa8:	4620      	mov	r0, r4
}
   16faa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return lfs_to_errno(ret);
   16fae:	f7f6 b9c5 	b.w	d33c <lfs_to_errno>

00016fb2 <littlefs_read>:
{
   16fb2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct fs_littlefs *fs = fp->mp->fs_data;
   16fb4:	6843      	ldr	r3, [r0, #4]
   16fb6:	691d      	ldr	r5, [r3, #16]
{
   16fb8:	4604      	mov	r4, r0
   16fba:	460e      	mov	r6, r1
   16fbc:	4617      	mov	r7, r2
	fs_lock(fs);
   16fbe:	4628      	mov	r0, r5
   16fc0:	f7ff feb6 	bl	16d30 <fs_lock>
	ssize_t ret = lfs_file_read(&fs->lfs, LFS_FILEP(fp), ptr, len);
   16fc4:	6821      	ldr	r1, [r4, #0]
   16fc6:	463b      	mov	r3, r7
   16fc8:	4632      	mov	r2, r6
   16fca:	f105 0070 	add.w	r0, r5, #112	; 0x70
   16fce:	f7fb fa41 	bl	12454 <lfs_file_read>
   16fd2:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   16fd4:	f105 00ec 	add.w	r0, r5, #236	; 0xec
   16fd8:	f7ff fea8 	bl	16d2c <k_mutex_unlock>
	return lfs_to_errno(ret);
   16fdc:	4620      	mov	r0, r4
}
   16fde:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return lfs_to_errno(ret);
   16fe2:	f7f6 b9ab 	b.w	d33c <lfs_to_errno>

00016fe6 <littlefs_stat>:
{
   16fe6:	b570      	push	{r4, r5, r6, lr}
   16fe8:	4603      	mov	r3, r0
   16fea:	b0c2      	sub	sp, #264	; 0x108
   16fec:	4608      	mov	r0, r1
	path = fs_impl_strip_prefix(path, mountp);
   16fee:	4619      	mov	r1, r3
	struct fs_littlefs *fs = mountp->fs_data;
   16ff0:	691e      	ldr	r6, [r3, #16]
{
   16ff2:	4615      	mov	r5, r2
	path = fs_impl_strip_prefix(path, mountp);
   16ff4:	f7f6 f97e 	bl	d2f4 <fs_impl_strip_prefix>
   16ff8:	4604      	mov	r4, r0
	fs_lock(fs);
   16ffa:	4630      	mov	r0, r6
   16ffc:	f7ff fe98 	bl	16d30 <fs_lock>
	int ret = lfs_stat(&fs->lfs, path, &info);
   17000:	4621      	mov	r1, r4
   17002:	466a      	mov	r2, sp
   17004:	f106 0070 	add.w	r0, r6, #112	; 0x70
   17008:	f001 f9c3 	bl	18392 <lfs_stat>
   1700c:	4604      	mov	r4, r0
	k_mutex_unlock(&fs->mutex);
   1700e:	f106 00ec 	add.w	r0, r6, #236	; 0xec
   17012:	f7ff fe8b 	bl	16d2c <k_mutex_unlock>
	if (ret >= 0) {
   17016:	2c00      	cmp	r4, #0
   17018:	db11      	blt.n	1703e <littlefs_stat+0x58>
		       FS_DIR_ENTRY_DIR : FS_DIR_ENTRY_FILE);
   1701a:	f89d 3000 	ldrb.w	r3, [sp]
   1701e:	1e9a      	subs	r2, r3, #2
   17020:	4253      	negs	r3, r2
   17022:	4153      	adcs	r3, r2
   17024:	702b      	strb	r3, [r5, #0]
	entry->size = info->size;
   17026:	9b01      	ldr	r3, [sp, #4]
   17028:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
	strncpy(entry->name, info->name, sizeof(entry->name));
   1702c:	f240 1201 	movw	r2, #257	; 0x101
   17030:	a902      	add	r1, sp, #8
   17032:	1c68      	adds	r0, r5, #1
	entry->name[sizeof(entry->name) - 1] = '\0';
   17034:	2400      	movs	r4, #0
	strncpy(entry->name, info->name, sizeof(entry->name));
   17036:	f7fe ffad 	bl	15f94 <strncpy>
	entry->name[sizeof(entry->name) - 1] = '\0';
   1703a:	f885 4101 	strb.w	r4, [r5, #257]	; 0x101
	return lfs_to_errno(ret);
   1703e:	4620      	mov	r0, r4
}
   17040:	b042      	add	sp, #264	; 0x108
   17042:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return lfs_to_errno(ret);
   17046:	f7f6 b979 	b.w	d33c <lfs_to_errno>

0001704a <fixed_data_unref>:
}
   1704a:	4770      	bx	lr

0001704c <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1704c:	6983      	ldr	r3, [r0, #24]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   1704e:	685b      	ldr	r3, [r3, #4]
{
   17050:	460a      	mov	r2, r1
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   17052:	6819      	ldr	r1, [r3, #0]
   17054:	f7f6 bbd8 	b.w	d808 <net_buf_alloc_len>

00017058 <net_buf_get>:
{
   17058:	b570      	push	{r4, r5, r6, lr}
   1705a:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   1705c:	f001 fdd2 	bl	18c04 <z_impl_k_queue_get>
	if (!buf) {
   17060:	4605      	mov	r5, r0
   17062:	b128      	cbz	r0, 17070 <net_buf_get+0x18>
   17064:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   17066:	7963      	ldrb	r3, [r4, #5]
   17068:	f013 0301 	ands.w	r3, r3, #1
   1706c:	d102      	bne.n	17074 <net_buf_get+0x1c>
	frag->frags = NULL;
   1706e:	6023      	str	r3, [r4, #0]
}
   17070:	4628      	mov	r0, r5
   17072:	bd70      	pop	{r4, r5, r6, pc}
   17074:	2100      	movs	r1, #0
   17076:	4630      	mov	r0, r6
   17078:	f001 fdc4 	bl	18c04 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   1707c:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   1707e:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   17080:	f023 0301 	bic.w	r3, r3, #1
   17084:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   17086:	4604      	mov	r4, r0
   17088:	e7ed      	b.n	17066 <net_buf_get+0xe>

0001708a <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   1708a:	6883      	ldr	r3, [r0, #8]
   1708c:	440b      	add	r3, r1
   1708e:	6003      	str	r3, [r0, #0]
}
   17090:	4770      	bx	lr

00017092 <net_buf_put>:
{
   17092:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   17094:	460a      	mov	r2, r1
   17096:	6814      	ldr	r4, [r2, #0]
   17098:	b914      	cbnz	r4, 170a0 <net_buf_put+0xe>
}
   1709a:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   1709c:	f001 bd8d 	b.w	18bba <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   170a0:	7953      	ldrb	r3, [r2, #5]
   170a2:	f043 0301 	orr.w	r3, r3, #1
   170a6:	7153      	strb	r3, [r2, #5]
   170a8:	4622      	mov	r2, r4
   170aa:	e7f4      	b.n	17096 <net_buf_put+0x4>

000170ac <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   170ac:	7902      	ldrb	r2, [r0, #4]
   170ae:	3201      	adds	r2, #1
   170b0:	7102      	strb	r2, [r0, #4]
	return buf;
}
   170b2:	4770      	bx	lr

000170b4 <net_buf_simple_add>:
	return buf->data + buf->len;
   170b4:	8883      	ldrh	r3, [r0, #4]
   170b6:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   170b8:	4419      	add	r1, r3
   170ba:	8081      	strh	r1, [r0, #4]
	return tail;
}
   170bc:	18d0      	adds	r0, r2, r3
   170be:	4770      	bx	lr

000170c0 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   170c0:	b430      	push	{r4, r5}
   170c2:	8884      	ldrh	r4, [r0, #4]
   170c4:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
   170c6:	18a3      	adds	r3, r4, r2
   170c8:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   170ca:	1928      	adds	r0, r5, r4
}
   170cc:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   170ce:	f7fe bfb4 	b.w	1603a <memcpy>

000170d2 <net_buf_simple_add_u8>:
   170d2:	8883      	ldrh	r3, [r0, #4]
   170d4:	6802      	ldr	r2, [r0, #0]

u8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, u8_t val)
{
   170d6:	b510      	push	{r4, lr}
	buf->len += len;
   170d8:	1c5c      	adds	r4, r3, #1
   170da:	8084      	strh	r4, [r0, #4]
	u8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   170dc:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   170de:	18d0      	adds	r0, r2, r3
   170e0:	bd10      	pop	{r4, pc}

000170e2 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   170e2:	8882      	ldrh	r2, [r0, #4]
   170e4:	1a52      	subs	r2, r2, r1
{
   170e6:	4603      	mov	r3, r0
	buf->len -= len;
   170e8:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
   170ea:	6800      	ldr	r0, [r0, #0]
   170ec:	4408      	add	r0, r1
   170ee:	6018      	str	r0, [r3, #0]
}
   170f0:	4770      	bx	lr

000170f2 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   170f2:	4603      	mov	r3, r0
	void *data = buf->data;
   170f4:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   170f6:	889a      	ldrh	r2, [r3, #4]
   170f8:	1a52      	subs	r2, r2, r1
	buf->data += len;
   170fa:	4401      	add	r1, r0
	buf->len -= len;
   170fc:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   170fe:	6019      	str	r1, [r3, #0]

	return data;
}
   17100:	4770      	bx	lr

00017102 <net_buf_simple_pull_u8>:

u8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)
{
   17102:	b510      	push	{r4, lr}
	u8_t val;

	val = buf->data[0];
   17104:	6803      	ldr	r3, [r0, #0]
   17106:	781c      	ldrb	r4, [r3, #0]
	net_buf_simple_pull(buf, 1);
   17108:	2101      	movs	r1, #1
   1710a:	f7ff ffea 	bl	170e2 <net_buf_simple_pull>

	return val;
}
   1710e:	4620      	mov	r0, r4
   17110:	bd10      	pop	{r4, pc}

00017112 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   17112:	6802      	ldr	r2, [r0, #0]
   17114:	6880      	ldr	r0, [r0, #8]
}
   17116:	1a10      	subs	r0, r2, r0
   17118:	4770      	bx	lr

0001711a <sys_csrand_get>:
#endif /* CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR */

#if defined(CONFIG_HARDWARE_DEVICE_CS_GENERATOR)

int sys_csrand_get(void *dst, size_t outlen)
{
   1711a:	b508      	push	{r3, lr}
	if (rand_get(dst, outlen, true) != 0) {
   1711c:	2201      	movs	r2, #1
   1711e:	f7f6 fc25 	bl	d96c <rand_get>
   17122:	2800      	cmp	r0, #0
		 */
		return -EIO;
	}

	return 0;
}
   17124:	bf18      	it	ne
   17126:	f06f 0004 	mvnne.w	r0, #4
   1712a:	bd08      	pop	{r3, pc}

0001712c <gpio_nrfx_port_get_raw>:
	return port->config->config_info;
   1712c:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1712e:	689b      	ldr	r3, [r3, #8]
   17130:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   17132:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
   17136:	600b      	str	r3, [r1, #0]
}
   17138:	2000      	movs	r0, #0
   1713a:	4770      	bx	lr

0001713c <gpio_nrfx_port_set_masked_raw>:
	return port->config->config_info;
   1713c:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1713e:	689b      	ldr	r3, [r3, #8]
   17140:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   17142:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   17146:	4042      	eors	r2, r0
   17148:	400a      	ands	r2, r1
   1714a:	4042      	eors	r2, r0
    p_reg->OUT = value;
   1714c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   17150:	2000      	movs	r0, #0
   17152:	4770      	bx	lr

00017154 <gpio_nrfx_port_set_bits_raw>:
	return port->config->config_info;
   17154:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   17156:	689b      	ldr	r3, [r3, #8]
   17158:	685b      	ldr	r3, [r3, #4]
}
   1715a:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
   1715c:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
   17160:	4770      	bx	lr

00017162 <gpio_nrfx_port_clear_bits_raw>:
	return port->config->config_info;
   17162:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   17164:	689b      	ldr	r3, [r3, #8]
   17166:	685b      	ldr	r3, [r3, #4]
}
   17168:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   1716a:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
   1716e:	4770      	bx	lr

00017170 <gpio_nrfx_port_toggle_bits>:
	return port->config->config_info;
   17170:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   17172:	689b      	ldr	r3, [r3, #8]
   17174:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   17176:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
   1717a:	404b      	eors	r3, r1
    p_reg->OUT = value;
   1717c:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
   17180:	2000      	movs	r0, #0
   17182:	4770      	bx	lr

00017184 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   17184:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
   17186:	6858      	ldr	r0, [r3, #4]
{
   17188:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
   1718a:	b158      	cbz	r0, 171a4 <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1718c:	2400      	movs	r4, #0
   1718e:	4281      	cmp	r1, r0
   17190:	d113      	bne.n	171ba <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   17192:	6808      	ldr	r0, [r1, #0]
   17194:	b95c      	cbnz	r4, 171ae <gpio_nrfx_manage_callback+0x2a>
   17196:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   17198:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   1719a:	42a1      	cmp	r1, r4
   1719c:	d100      	bne.n	171a0 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   1719e:	6098      	str	r0, [r3, #8]
	parent->next = child;
   171a0:	2000      	movs	r0, #0
   171a2:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   171a4:	b972      	cbnz	r2, 171c4 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   171a6:	2000      	movs	r0, #0
}
   171a8:	bd30      	pop	{r4, r5, pc}
   171aa:	4628      	mov	r0, r5
   171ac:	e7ef      	b.n	1718e <gpio_nrfx_manage_callback+0xa>
   171ae:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   171b0:	6898      	ldr	r0, [r3, #8]
   171b2:	4281      	cmp	r1, r0
	list->tail = node;
   171b4:	bf08      	it	eq
   171b6:	609c      	streq	r4, [r3, #8]
}
   171b8:	e7f2      	b.n	171a0 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   171ba:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   171bc:	4604      	mov	r4, r0
   171be:	2d00      	cmp	r5, #0
   171c0:	d1f3      	bne.n	171aa <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   171c2:	b13a      	cbz	r2, 171d4 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   171c4:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   171c6:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   171c8:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   171ca:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   171cc:	2800      	cmp	r0, #0
   171ce:	d1ea      	bne.n	171a6 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   171d0:	6099      	str	r1, [r3, #8]
}
   171d2:	e7e9      	b.n	171a8 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   171d4:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   171d8:	e7e6      	b.n	171a8 <gpio_nrfx_manage_callback+0x24>

000171da <fire_callbacks>:
{
   171da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct gpio_nrfx_data *data = get_port_data(port);
   171dc:	6887      	ldr	r7, [r0, #8]
{
   171de:	460e      	mov	r6, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   171e0:	6879      	ldr	r1, [r7, #4]
{
   171e2:	4605      	mov	r5, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   171e4:	b1a1      	cbz	r1, 17210 <fire_callbacks+0x36>
	return node->next;
   171e6:	680c      	ldr	r4, [r1, #0]
   171e8:	2c00      	cmp	r4, #0
   171ea:	bf38      	it	cc
   171ec:	2400      	movcc	r4, #0
		if ((cb->pin_mask & pins) & data->int_en) {
   171ee:	693b      	ldr	r3, [r7, #16]
   171f0:	688a      	ldr	r2, [r1, #8]
   171f2:	4033      	ands	r3, r6
   171f4:	4213      	tst	r3, r2
   171f6:	d003      	beq.n	17200 <fire_callbacks+0x26>
			cb->handler(port, cb, pins);
   171f8:	684b      	ldr	r3, [r1, #4]
   171fa:	4632      	mov	r2, r6
   171fc:	4628      	mov	r0, r5
   171fe:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   17200:	b134      	cbz	r4, 17210 <fire_callbacks+0x36>
   17202:	6823      	ldr	r3, [r4, #0]
   17204:	2b00      	cmp	r3, #0
   17206:	bf38      	it	cc
   17208:	2300      	movcc	r3, #0
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1720a:	4621      	mov	r1, r4
   1720c:	461c      	mov	r4, r3
   1720e:	e7ee      	b.n	171ee <fire_callbacks+0x14>
}
   17210:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00017212 <check_level_trigger_pins>:
{
   17212:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return port->config->config_info;
   17214:	6802      	ldr	r2, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
   17216:	6883      	ldr	r3, [r0, #8]
	return port->config->config_info;
   17218:	6897      	ldr	r7, [r2, #8]
	u32_t out = data->int_en & data->pin_int_en;
   1721a:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
   1721e:	400a      	ands	r2, r1
	out &= ~data->trig_edge & ~data->double_edge;
   17220:	e9d3 1006 	ldrd	r1, r0, [r3, #24]
   17224:	4301      	orrs	r1, r0
   17226:	ea22 0201 	bic.w	r2, r2, r1
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   1722a:	6879      	ldr	r1, [r7, #4]
	u32_t pin_states = ~(port_in ^ data->int_active_level);
   1722c:	695b      	ldr	r3, [r3, #20]
    return p_reg->IN;
   1722e:	f8d1 4510 	ldr.w	r4, [r1, #1296]	; 0x510
   17232:	405c      	eors	r4, r3
	u32_t out = pin_states & level_pins;
   17234:	ea22 0404 	bic.w	r4, r2, r4
	u32_t bit = 1U << pin;
   17238:	2501      	movs	r5, #1
	u32_t pin = 0U;
   1723a:	2600      	movs	r6, #0
	while (level_pins) {
   1723c:	b90a      	cbnz	r2, 17242 <check_level_trigger_pins+0x30>
}
   1723e:	4620      	mov	r0, r4
   17240:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (level_pins & bit) {
   17242:	422a      	tst	r2, r5
   17244:	d009      	beq.n	1725a <check_level_trigger_pins+0x48>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   17246:	7a3b      	ldrb	r3, [r7, #8]
   17248:	f006 001f 	and.w	r0, r6, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1724c:	2100      	movs	r1, #0
   1724e:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   17252:	f7f6 fc37 	bl	dac4 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   17256:	ea22 0205 	bic.w	r2, r2, r5
		++pin;
   1725a:	3601      	adds	r6, #1
		bit <<= 1;
   1725c:	006d      	lsls	r5, r5, #1
   1725e:	e7ed      	b.n	1723c <check_level_trigger_pins+0x2a>

00017260 <gpio_nrfx_pin_disable_callback>:
{
   17260:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   17262:	6884      	ldr	r4, [r0, #8]
	WRITE_BIT(data->int_en, pin, enable);
   17264:	2301      	movs	r3, #1
   17266:	fa03 f201 	lsl.w	r2, r3, r1
   1726a:	6923      	ldr	r3, [r4, #16]
   1726c:	ea23 0302 	bic.w	r3, r3, r2
   17270:	6123      	str	r3, [r4, #16]
}
   17272:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
   17274:	f7f6 bc3a 	b.w	daec <gpiote_pin_int_cfg>

00017278 <cfg_level_pins>:
{
   17278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct gpio_nrfx_data *data = get_port_data(port);
   1727a:	6884      	ldr	r4, [r0, #8]
	return port->config->config_info;
   1727c:	6803      	ldr	r3, [r0, #0]
   1727e:	689f      	ldr	r7, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   17280:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   17284:	401a      	ands	r2, r3
	out &= ~data->trig_edge & ~data->double_edge;
   17286:	e9d4 3106 	ldrd	r3, r1, [r4, #24]
   1728a:	430b      	orrs	r3, r1
   1728c:	ea22 0203 	bic.w	r2, r2, r3
	u32_t bit = 1U << pin;
   17290:	2601      	movs	r6, #1
	u32_t pin = 0U;
   17292:	2500      	movs	r5, #0
	while (level_pins) {
   17294:	b902      	cbnz	r2, 17298 <cfg_level_pins+0x20>
}
   17296:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (level_pins & bit) {
   17298:	4216      	tst	r6, r2
   1729a:	d00f      	beq.n	172bc <cfg_level_pins+0x44>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   1729c:	6961      	ldr	r1, [r4, #20]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1729e:	7a3b      	ldrb	r3, [r7, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
   172a0:	40e9      	lsrs	r1, r5
   172a2:	f001 0101 	and.w	r1, r1, #1
   172a6:	f1c1 0103 	rsb	r1, r1, #3
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   172aa:	f005 001f 	and.w	r0, r5, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   172ae:	b2c9      	uxtb	r1, r1
   172b0:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   172b4:	f7f6 fc06 	bl	dac4 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   172b8:	ea22 0206 	bic.w	r2, r2, r6
		++pin;
   172bc:	3501      	adds	r5, #1
		bit <<= 1;
   172be:	0076      	lsls	r6, r6, #1
   172c0:	e7e8      	b.n	17294 <cfg_level_pins+0x1c>

000172c2 <gpio_nrfx_pin_enable_callback>:
{
   172c2:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   172c4:	6884      	ldr	r4, [r0, #8]
	WRITE_BIT(data->int_en, pin, enable);
   172c6:	2301      	movs	r3, #1
   172c8:	fa03 f201 	lsl.w	r2, r3, r1
   172cc:	6923      	ldr	r3, [r4, #16]
   172ce:	4313      	orrs	r3, r2
   172d0:	6123      	str	r3, [r4, #16]
}
   172d2:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
   172d4:	f7f6 bc0a 	b.w	daec <gpiote_pin_int_cfg>

000172d8 <gpio_pin_set>:

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   172d8:	2301      	movs	r3, #1
   172da:	fa03 f101 	lsl.w	r1, r3, r1
   172de:	6883      	ldr	r3, [r0, #8]
   172e0:	681b      	ldr	r3, [r3, #0]
   172e2:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   172e4:	bf18      	it	ne
   172e6:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   172ea:	b112      	cbz	r2, 172f2 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   172ec:	6843      	ldr	r3, [r0, #4]
   172ee:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   172f0:	4718      	bx	r3
   172f2:	6843      	ldr	r3, [r0, #4]
   172f4:	691b      	ldr	r3, [r3, #16]
   172f6:	e7fb      	b.n	172f0 <gpio_pin_set+0x18>

000172f8 <_spi_context_cs_control.isra.0>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   172f8:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   172fa:	6805      	ldr	r5, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   172fc:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   172fe:	b325      	cbz	r5, 1734a <_spi_context_cs_control.isra.0+0x52>
   17300:	68ab      	ldr	r3, [r5, #8]
   17302:	b313      	cbz	r3, 1734a <_spi_context_cs_control.isra.0+0x52>
   17304:	6818      	ldr	r0, [r3, #0]
   17306:	b300      	cbz	r0, 1734a <_spi_context_cs_control.isra.0+0x52>
		if (on) {
   17308:	b161      	cbz	r1, 17324 <_spi_context_cs_control.isra.0+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   1730a:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   1730e:	7919      	ldrb	r1, [r3, #4]
   17310:	0fd2      	lsrs	r2, r2, #31
   17312:	f7ff ffe1 	bl	172d8 <gpio_pin_set>
			k_busy_wait(ctx->config->cs->delay);
   17316:	6823      	ldr	r3, [r4, #0]
   17318:	689b      	ldr	r3, [r3, #8]
   1731a:	6898      	ldr	r0, [r3, #8]
}
   1731c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   17320:	f001 be09 	b.w	18f36 <z_impl_k_busy_wait>
			if (!force_off &&
   17324:	b912      	cbnz	r2, 1732c <_spi_context_cs_control.isra.0+0x34>
   17326:	88aa      	ldrh	r2, [r5, #4]
   17328:	0492      	lsls	r2, r2, #18
   1732a:	d40e      	bmi.n	1734a <_spi_context_cs_control.isra.0+0x52>
			k_busy_wait(ctx->config->cs->delay);
   1732c:	6898      	ldr	r0, [r3, #8]
   1732e:	f001 fe02 	bl	18f36 <z_impl_k_busy_wait>
			gpio_pin_set(ctx->config->cs->gpio_dev,
   17332:	6822      	ldr	r2, [r4, #0]
   17334:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   17336:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   1733a:	7919      	ldrb	r1, [r3, #4]
   1733c:	6818      	ldr	r0, [r3, #0]
   1733e:	43d2      	mvns	r2, r2
}
   17340:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set(ctx->config->cs->gpio_dev,
   17344:	0fd2      	lsrs	r2, r2, #31
   17346:	f7ff bfc7 	b.w	172d8 <gpio_pin_set>
}
   1734a:	bd38      	pop	{r3, r4, r5, pc}

0001734c <spi_context_unlock_unconditionally>:
{
   1734c:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   1734e:	2201      	movs	r2, #1
   17350:	2100      	movs	r1, #0
{
   17352:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   17354:	f7ff ffd0 	bl	172f8 <_spi_context_cs_control.isra.0>
	if (!k_sem_count_get(&ctx->lock)) {
   17358:	68e3      	ldr	r3, [r4, #12]
   1735a:	b923      	cbnz	r3, 17366 <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   1735c:	1d20      	adds	r0, r4, #4
}
   1735e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   17362:	f7fc bfc3 	b.w	142ec <z_impl_k_sem_give>
   17366:	bd10      	pop	{r4, pc}

00017368 <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   17368:	6880      	ldr	r0, [r0, #8]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   1736a:	6803      	ldr	r3, [r0, #0]
   1736c:	428b      	cmp	r3, r1
{
   1736e:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   17370:	d106      	bne.n	17380 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   17372:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   17376:	b934      	cbnz	r4, 17386 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   17378:	f7ff ffe8 	bl	1734c <spi_context_unlock_unconditionally>
	return 0;
   1737c:	4620      	mov	r0, r4
}
   1737e:	bd10      	pop	{r4, pc}
		return -EINVAL;
   17380:	f06f 0015 	mvn.w	r0, #21
   17384:	e7fb      	b.n	1737e <spi_nrfx_release+0x16>
		return -EBUSY;
   17386:	f06f 000f 	mvn.w	r0, #15
   1738a:	e7f8      	b.n	1737e <spi_nrfx_release+0x16>

0001738c <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1738c:	2301      	movs	r3, #1
   1738e:	fa03 f101 	lsl.w	r1, r3, r1
   17392:	6883      	ldr	r3, [r0, #8]
   17394:	681b      	ldr	r3, [r3, #0]
   17396:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   17398:	bf18      	it	ne
   1739a:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   1739e:	b112      	cbz	r2, 173a6 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   173a0:	6843      	ldr	r3, [r0, #4]
   173a2:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   173a4:	4718      	bx	r3
   173a6:	6843      	ldr	r3, [r0, #4]
   173a8:	691b      	ldr	r3, [r3, #16]
   173aa:	e7fb      	b.n	173a4 <gpio_pin_set+0x18>

000173ac <_spi_context_cs_control.isra.0>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   173ac:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   173ae:	6805      	ldr	r5, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   173b0:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   173b2:	b325      	cbz	r5, 173fe <_spi_context_cs_control.isra.0+0x52>
   173b4:	68ab      	ldr	r3, [r5, #8]
   173b6:	b313      	cbz	r3, 173fe <_spi_context_cs_control.isra.0+0x52>
   173b8:	6818      	ldr	r0, [r3, #0]
   173ba:	b300      	cbz	r0, 173fe <_spi_context_cs_control.isra.0+0x52>
		if (on) {
   173bc:	b161      	cbz	r1, 173d8 <_spi_context_cs_control.isra.0+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   173be:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   173c2:	7919      	ldrb	r1, [r3, #4]
   173c4:	0fd2      	lsrs	r2, r2, #31
   173c6:	f7ff ffe1 	bl	1738c <gpio_pin_set>
			k_busy_wait(ctx->config->cs->delay);
   173ca:	6823      	ldr	r3, [r4, #0]
   173cc:	689b      	ldr	r3, [r3, #8]
   173ce:	6898      	ldr	r0, [r3, #8]
}
   173d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   173d4:	f001 bdaf 	b.w	18f36 <z_impl_k_busy_wait>
			if (!force_off &&
   173d8:	b912      	cbnz	r2, 173e0 <_spi_context_cs_control.isra.0+0x34>
   173da:	88aa      	ldrh	r2, [r5, #4]
   173dc:	0492      	lsls	r2, r2, #18
   173de:	d40e      	bmi.n	173fe <_spi_context_cs_control.isra.0+0x52>
			k_busy_wait(ctx->config->cs->delay);
   173e0:	6898      	ldr	r0, [r3, #8]
   173e2:	f001 fda8 	bl	18f36 <z_impl_k_busy_wait>
			gpio_pin_set(ctx->config->cs->gpio_dev,
   173e6:	6822      	ldr	r2, [r4, #0]
   173e8:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   173ea:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   173ee:	7919      	ldrb	r1, [r3, #4]
   173f0:	6818      	ldr	r0, [r3, #0]
   173f2:	43d2      	mvns	r2, r2
}
   173f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set(ctx->config->cs->gpio_dev,
   173f8:	0fd2      	lsrs	r2, r2, #31
   173fa:	f7ff bfc7 	b.w	1738c <gpio_pin_set>
}
   173fe:	bd38      	pop	{r3, r4, r5, pc}

00017400 <spi_context_unlock_unconditionally>:
{
   17400:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   17402:	2201      	movs	r2, #1
   17404:	2100      	movs	r1, #0
{
   17406:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   17408:	f7ff ffd0 	bl	173ac <_spi_context_cs_control.isra.0>
	if (!k_sem_count_get(&ctx->lock)) {
   1740c:	68e3      	ldr	r3, [r4, #12]
   1740e:	b923      	cbnz	r3, 1741a <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   17410:	1d20      	adds	r0, r4, #4
}
   17412:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   17416:	f7fc bf69 	b.w	142ec <z_impl_k_sem_give>
   1741a:	bd10      	pop	{r4, pc}

0001741c <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1741c:	6880      	ldr	r0, [r0, #8]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   1741e:	6803      	ldr	r3, [r0, #0]
   17420:	428b      	cmp	r3, r1
{
   17422:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   17424:	d106      	bne.n	17434 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   17426:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   1742a:	b934      	cbnz	r4, 1743a <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   1742c:	f7ff ffe8 	bl	17400 <spi_context_unlock_unconditionally>
	return 0;
   17430:	4620      	mov	r0, r4
}
   17432:	bd10      	pop	{r4, pc}
		return -EINVAL;
   17434:	f06f 0015 	mvn.w	r0, #21
   17438:	e7fb      	b.n	17432 <spi_nrfx_release+0x16>
		return -EBUSY;
   1743a:	f06f 000f 	mvn.w	r0, #15
   1743e:	e7f8      	b.n	17432 <spi_nrfx_release+0x16>

00017440 <qspi_lock>:
	k_sem_take(&dev_data->sem, K_FOREVER);
   17440:	6880      	ldr	r0, [r0, #8]
	return z_impl_k_sem_take(sem, timeout);
   17442:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   17446:	f7fc bf77 	b.w	14338 <z_impl_k_sem_take>

0001744a <qspi_handler>:
{
   1744a:	b510      	push	{r4, lr}
   1744c:	460c      	mov	r4, r1
	if (event == NRFX_QSPI_EVENT_DONE) {
   1744e:	b940      	cbnz	r0, 17462 <qspi_handler+0x18>
	k_sem_give(&dev_data->sync);
   17450:	6888      	ldr	r0, [r1, #8]
   17452:	3018      	adds	r0, #24
	z_impl_k_sem_give(sem);
   17454:	f7fc ff4a 	bl	142ec <z_impl_k_sem_give>
	k_sem_give(&dev_data->sem);
   17458:	68a0      	ldr	r0, [r4, #8]
}
   1745a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1745e:	f7fc bf45 	b.w	142ec <z_impl_k_sem_give>
   17462:	bd10      	pop	{r4, pc}

00017464 <qspi_nor_write_protection_set>:
{
   17464:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct qspi_nor_data *const driver_data = dev->driver_data;
   17466:	6882      	ldr	r2, [r0, #8]
	struct qspi_cmd cmd = {
   17468:	2300      	movs	r3, #0
   1746a:	2900      	cmp	r1, #0
   1746c:	e9cd 3301 	strd	r3, r3, [sp, #4]
   17470:	9303      	str	r3, [sp, #12]
	driver_data->write_protection = write_protect;
   17472:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
	struct qspi_cmd cmd = {
   17476:	bf14      	ite	ne
   17478:	2304      	movne	r3, #4
   1747a:	2306      	moveq	r3, #6
	if (qspi_send_cmd(dev, &cmd) != 0) {
   1747c:	a901      	add	r1, sp, #4
	struct qspi_cmd cmd = {
   1747e:	f88d 3004 	strb.w	r3, [sp, #4]
	if (qspi_send_cmd(dev, &cmd) != 0) {
   17482:	f7f7 f9c3 	bl	e80c <qspi_send_cmd>
   17486:	2800      	cmp	r0, #0
}
   17488:	bf18      	it	ne
   1748a:	f06f 0004 	mvnne.w	r0, #4
   1748e:	b005      	add	sp, #20
   17490:	f85d fb04 	ldr.w	pc, [sp], #4

00017494 <flash_nrf_write_protection>:
}
   17494:	2000      	movs	r0, #0
   17496:	4770      	bx	lr

00017498 <is_regular_addr_valid>:
{
   17498:	b538      	push	{r3, r4, r5, lr}
   1749a:	4604      	mov	r4, r0
   1749c:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   1749e:	f000 f995 	bl	177cc <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   174a2:	4284      	cmp	r4, r0
   174a4:	d209      	bcs.n	174ba <is_regular_addr_valid+0x22>
   174a6:	2c00      	cmp	r4, #0
   174a8:	db07      	blt.n	174ba <is_regular_addr_valid+0x22>
	    addr < 0 ||
   174aa:	42a8      	cmp	r0, r5
   174ac:	d305      	bcc.n	174ba <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   174ae:	442c      	add	r4, r5
	    len > flash_size ||
   174b0:	4284      	cmp	r4, r0
   174b2:	bf8c      	ite	hi
   174b4:	2000      	movhi	r0, #0
   174b6:	2001      	movls	r0, #1
}
   174b8:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   174ba:	2000      	movs	r0, #0
   174bc:	e7fc      	b.n	174b8 <is_regular_addr_valid+0x20>

000174be <flash_nrf_read>:
{
   174be:	b570      	push	{r4, r5, r6, lr}
   174c0:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   174c2:	4628      	mov	r0, r5
   174c4:	4619      	mov	r1, r3
{
   174c6:	4616      	mov	r6, r2
   174c8:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   174ca:	f7ff ffe5 	bl	17498 <is_regular_addr_valid>
   174ce:	b138      	cbz	r0, 174e0 <flash_nrf_read+0x22>
	if (!len) {
   174d0:	b14c      	cbz	r4, 174e6 <flash_nrf_read+0x28>
	memcpy(data, (void *)addr, len);
   174d2:	4622      	mov	r2, r4
   174d4:	4629      	mov	r1, r5
   174d6:	4630      	mov	r0, r6
   174d8:	f7fe fdaf 	bl	1603a <memcpy>
	return 0;
   174dc:	2000      	movs	r0, #0
}
   174de:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   174e0:	f06f 0015 	mvn.w	r0, #21
   174e4:	e7fb      	b.n	174de <flash_nrf_read+0x20>
		return 0;
   174e6:	4620      	mov	r0, r4
   174e8:	e7f9      	b.n	174de <flash_nrf_read+0x20>

000174ea <flash_page_foreach>:

	return count;
}

void flash_page_foreach(struct device *dev, flash_page_cb cb, void *data)
{
   174ea:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
   174ee:	6843      	ldr	r3, [r0, #4]
{
   174f0:	b086      	sub	sp, #24
	api->page_layout(dev, &layout, &num_blocks);
   174f2:	691b      	ldr	r3, [r3, #16]
{
   174f4:	4688      	mov	r8, r1
   174f6:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
   174f8:	a901      	add	r1, sp, #4
   174fa:	aa02      	add	r2, sp, #8
   174fc:	4798      	blx	r3
	off_t off = 0;
   174fe:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
   17500:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
   17502:	4625      	mov	r5, r4
   17504:	9b02      	ldr	r3, [sp, #8]
   17506:	42ab      	cmp	r3, r5
   17508:	d802      	bhi.n	17510 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
   1750a:	b006      	add	sp, #24
   1750c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
   17510:	9f01      	ldr	r7, [sp, #4]
   17512:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
   17516:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
   17518:	687b      	ldr	r3, [r7, #4]
   1751a:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   1751c:	683a      	ldr	r2, [r7, #0]
   1751e:	42b2      	cmp	r2, r6
   17520:	eb0a 0306 	add.w	r3, sl, r6
   17524:	d802      	bhi.n	1752c <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
   17526:	3501      	adds	r5, #1
   17528:	469a      	mov	sl, r3
   1752a:	e7eb      	b.n	17504 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
   1752c:	4649      	mov	r1, r9
   1752e:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
   17530:	9403      	str	r4, [sp, #12]
			page_info.index = page;
   17532:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
   17534:	47c0      	blx	r8
   17536:	2800      	cmp	r0, #0
   17538:	d0e7      	beq.n	1750a <flash_page_foreach+0x20>
			off += page_info.size;
   1753a:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   1753c:	3601      	adds	r6, #1
			off += page_info.size;
   1753e:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
   17540:	e7ec      	b.n	1751c <flash_page_foreach+0x32>

00017542 <uart_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
   17542:	6882      	ldr	r2, [r0, #8]
{
   17544:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   17546:	e892 0003 	ldmia.w	r2, {r0, r1}
   1754a:	e883 0003 	stmia.w	r3, {r0, r1}
}
   1754e:	2000      	movs	r0, #0
   17550:	4770      	bx	lr

00017552 <uart_nrfx_irq_tx_ready_complete>:
{
   17552:	b508      	push	{r3, lr}
	return event_txdrdy_check();
   17554:	f7f7 fb56 	bl	ec04 <event_txdrdy_check>
}
   17558:	bd08      	pop	{r3, pc}

0001755a <uart_nrfx_irq_update>:
}
   1755a:	2001      	movs	r0, #1
   1755c:	4770      	bx	lr

0001755e <nrf_uarte_event_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1755e:	2300      	movs	r3, #0
   17560:	5043      	str	r3, [r0, r1]
{
   17562:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   17564:	5843      	ldr	r3, [r0, r1]
   17566:	9301      	str	r3, [sp, #4]
    (void)dummy;
   17568:	9b01      	ldr	r3, [sp, #4]
}
   1756a:	b002      	add	sp, #8
   1756c:	4770      	bx	lr

0001756e <uarte_nrfx_isr_int>:
	return dev->config->config_info;
   1756e:	6803      	ldr	r3, [r0, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   17570:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   17572:	689b      	ldr	r3, [r3, #8]
   17574:	6818      	ldr	r0, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
   17576:	6893      	ldr	r3, [r2, #8]
   17578:	7b99      	ldrb	r1, [r3, #14]
{
   1757a:	b510      	push	{r4, lr}
	if (data->int_driven->disable_tx_irq &&
   1757c:	b159      	cbz	r1, 17596 <uarte_nrfx_isr_int+0x28>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1757e:	f8d0 1120 	ldr.w	r1, [r0, #288]	; 0x120
   17582:	b141      	cbz	r1, 17596 <uarte_nrfx_isr_int+0x28>
    p_reg->INTENCLR = mask;
   17584:	f44f 7280 	mov.w	r2, #256	; 0x100
   17588:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1758c:	2201      	movs	r2, #1
   1758e:	60c2      	str	r2, [r0, #12]
		data->int_driven->disable_tx_irq = false;
   17590:	2200      	movs	r2, #0
   17592:	739a      	strb	r2, [r3, #14]
}
   17594:	bd10      	pop	{r4, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   17596:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   1759a:	b11b      	cbz	r3, 175a4 <uarte_nrfx_isr_int+0x36>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ERROR);
   1759c:	f44f 7192 	mov.w	r1, #292	; 0x124
   175a0:	f7ff ffdd 	bl	1755e <nrf_uarte_event_clear>
	if (data->int_driven->cb) {
   175a4:	6892      	ldr	r2, [r2, #8]
   175a6:	6813      	ldr	r3, [r2, #0]
   175a8:	2b00      	cmp	r3, #0
   175aa:	d0f3      	beq.n	17594 <uarte_nrfx_isr_int+0x26>
}
   175ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		data->int_driven->cb(data->int_driven->cb_data);
   175b0:	6850      	ldr	r0, [r2, #4]
   175b2:	4718      	bx	r3

000175b4 <uarte_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
   175b4:	6882      	ldr	r2, [r0, #8]
{
   175b6:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   175b8:	e892 0003 	ldmia.w	r2, {r0, r1}
   175bc:	e883 0003 	stmia.w	r3, {r0, r1}
}
   175c0:	2000      	movs	r0, #0
   175c2:	4770      	bx	lr

000175c4 <uarte_nrfx_err_check>:
	return dev->config->config_info;
   175c4:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   175c6:	689b      	ldr	r3, [r3, #8]
   175c8:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   175ca:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   175ce:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   175d2:	4770      	bx	lr

000175d4 <uarte_nrfx_poll_in>:
	return dev->config->config_info;
   175d4:	6802      	ldr	r2, [r0, #0]
	return config->uarte_regs;
   175d6:	6892      	ldr	r2, [r2, #8]
{
   175d8:	b508      	push	{r3, lr}
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   175da:	6883      	ldr	r3, [r0, #8]
	return config->uarte_regs;
   175dc:	6810      	ldr	r0, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   175de:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   175e2:	b14a      	cbz	r2, 175f8 <uarte_nrfx_poll_in+0x24>
	*c = data->rx_data;
   175e4:	7c1b      	ldrb	r3, [r3, #16]
   175e6:	700b      	strb	r3, [r1, #0]
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   175e8:	f44f 7188 	mov.w	r1, #272	; 0x110
   175ec:	f7ff ffb7 	bl	1755e <nrf_uarte_event_clear>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   175f0:	2301      	movs	r3, #1
   175f2:	6003      	str	r3, [r0, #0]
	return 0;
   175f4:	2000      	movs	r0, #0
}
   175f6:	bd08      	pop	{r3, pc}
		return -1;
   175f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   175fc:	e7fb      	b.n	175f6 <uarte_nrfx_poll_in+0x22>

000175fe <uarte_nrfx_fifo_fill>:
{
   175fe:	b570      	push	{r4, r5, r6, lr}
   17600:	460c      	mov	r4, r1
   17602:	4611      	mov	r1, r2
	return dev->config->config_info;
   17604:	6802      	ldr	r2, [r0, #0]
	return config->uarte_regs;
   17606:	6892      	ldr	r2, [r2, #8]
{
   17608:	4603      	mov	r3, r0
	return config->uarte_regs;
   1760a:	6810      	ldr	r0, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1760c:	f8d0 2120 	ldr.w	r2, [r0, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   17610:	b1a2      	cbz	r2, 1763c <uarte_nrfx_fifo_fill+0x3e>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   17612:	689d      	ldr	r5, [r3, #8]
	if (len > data->int_driven->tx_buff_size) {
   17614:	68ab      	ldr	r3, [r5, #8]
   17616:	899a      	ldrh	r2, [r3, #12]
   17618:	428a      	cmp	r2, r1
   1761a:	bfa8      	it	ge
   1761c:	460a      	movge	r2, r1
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDTX);
   1761e:	f44f 7190 	mov.w	r1, #288	; 0x120
   17622:	f7ff ff9c 	bl	1755e <nrf_uarte_event_clear>
	for (int i = 0; i < len; i++) {
   17626:	2300      	movs	r3, #0
   17628:	68a9      	ldr	r1, [r5, #8]
   1762a:	4293      	cmp	r3, r2
   1762c:	6889      	ldr	r1, [r1, #8]
   1762e:	db07      	blt.n	17640 <uarte_nrfx_fifo_fill+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   17630:	2301      	movs	r3, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   17632:	f8c0 1544 	str.w	r1, [r0, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   17636:	f8c0 2548 	str.w	r2, [r0, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1763a:	6083      	str	r3, [r0, #8]
}
   1763c:	4610      	mov	r0, r2
   1763e:	bd70      	pop	{r4, r5, r6, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
   17640:	5ce6      	ldrb	r6, [r4, r3]
   17642:	54ce      	strb	r6, [r1, r3]
	for (int i = 0; i < len; i++) {
   17644:	3301      	adds	r3, #1
   17646:	e7ef      	b.n	17628 <uarte_nrfx_fifo_fill+0x2a>

00017648 <uarte_nrfx_fifo_read>:
	return dev->config->config_info;
   17648:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   1764a:	689b      	ldr	r3, [r3, #8]
{
   1764c:	4602      	mov	r2, r0
	return config->uarte_regs;
   1764e:	6818      	ldr	r0, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   17650:	f8d0 3110 	ldr.w	r3, [r0, #272]	; 0x110
{
   17654:	b510      	push	{r4, lr}
   17656:	460c      	mov	r4, r1
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   17658:	b143      	cbz	r3, 1766c <uarte_nrfx_fifo_read+0x24>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   1765a:	f44f 7188 	mov.w	r1, #272	; 0x110
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   1765e:	6892      	ldr	r2, [r2, #8]
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   17660:	f7ff ff7d 	bl	1755e <nrf_uarte_event_clear>
		rx_data[num_rx++] = (u8_t)data->rx_data;
   17664:	7c13      	ldrb	r3, [r2, #16]
   17666:	7023      	strb	r3, [r4, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   17668:	2301      	movs	r3, #1
   1766a:	6003      	str	r3, [r0, #0]
	int num_rx = 0;
   1766c:	4618      	mov	r0, r3
}
   1766e:	bd10      	pop	{r4, pc}

00017670 <uarte_nrfx_irq_tx_enable>:
	return dev->config->config_info;
   17670:	6803      	ldr	r3, [r0, #0]
	data->int_driven->disable_tx_irq = false;
   17672:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   17674:	689b      	ldr	r3, [r3, #8]
	data->int_driven->disable_tx_irq = false;
   17676:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   17678:	681b      	ldr	r3, [r3, #0]
	data->int_driven->disable_tx_irq = false;
   1767a:	2100      	movs	r1, #0
   1767c:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
   1767e:	f44f 7280 	mov.w	r2, #256	; 0x100
   17682:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   17686:	4770      	bx	lr

00017688 <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
   17688:	6883      	ldr	r3, [r0, #8]
   1768a:	689b      	ldr	r3, [r3, #8]
   1768c:	2201      	movs	r2, #1
   1768e:	739a      	strb	r2, [r3, #14]
}
   17690:	4770      	bx	lr

00017692 <uarte_nrfx_irq_tx_ready_complete>:
	return dev->config->config_info;
   17692:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   17694:	689b      	ldr	r3, [r3, #8]
   17696:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   17698:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   1769c:	b118      	cbz	r0, 176a6 <uarte_nrfx_irq_tx_ready_complete+0x14>
    return p_reg->INTENSET & mask;
   1769e:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   176a2:	f3c0 2000 	ubfx	r0, r0, #8, #1
}
   176a6:	4770      	bx	lr

000176a8 <uarte_nrfx_irq_rx_ready>:
	return dev->config->config_info;
   176a8:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   176aa:	689b      	ldr	r3, [r3, #8]
   176ac:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   176ae:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   176b2:	3800      	subs	r0, #0
   176b4:	bf18      	it	ne
   176b6:	2001      	movne	r0, #1
   176b8:	4770      	bx	lr

000176ba <uarte_nrfx_irq_rx_enable>:
	return dev->config->config_info;
   176ba:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   176bc:	689b      	ldr	r3, [r3, #8]
   176be:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   176c0:	2210      	movs	r2, #16
   176c2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   176c6:	4770      	bx	lr

000176c8 <uarte_nrfx_irq_rx_disable>:
	return dev->config->config_info;
   176c8:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   176ca:	689b      	ldr	r3, [r3, #8]
   176cc:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   176ce:	2210      	movs	r2, #16
   176d0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   176d4:	4770      	bx	lr

000176d6 <uarte_nrfx_irq_err_enable>:
	return dev->config->config_info;
   176d6:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   176d8:	689b      	ldr	r3, [r3, #8]
   176da:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   176dc:	f44f 7200 	mov.w	r2, #512	; 0x200
   176e0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   176e4:	4770      	bx	lr

000176e6 <uarte_nrfx_irq_err_disable>:
	return dev->config->config_info;
   176e6:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   176e8:	689b      	ldr	r3, [r3, #8]
   176ea:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   176ec:	f44f 7200 	mov.w	r2, #512	; 0x200
   176f0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   176f4:	4770      	bx	lr

000176f6 <uarte_nrfx_irq_update>:
}
   176f6:	2001      	movs	r0, #1
   176f8:	4770      	bx	lr

000176fa <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
   176fa:	6883      	ldr	r3, [r0, #8]
   176fc:	689b      	ldr	r3, [r3, #8]
	data->int_driven->cb_data = cb_data;
   176fe:	e9c3 1200 	strd	r1, r2, [r3]
}
   17702:	4770      	bx	lr

00017704 <uarte_nrfx_irq_is_pending>:
{
   17704:	b508      	push	{r3, lr}
	return dev->config->config_info;
   17706:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   17708:	689b      	ldr	r3, [r3, #8]
   1770a:	6819      	ldr	r1, [r3, #0]
    return p_reg->INTENSET & mask;
   1770c:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
		||
   17710:	05db      	lsls	r3, r3, #23
{
   17712:	4602      	mov	r2, r0
		||
   17714:	d405      	bmi.n	17722 <uarte_nrfx_irq_is_pending+0x1e>
   17716:	f8d1 0304 	ldr.w	r0, [r1, #772]	; 0x304
   1771a:	f010 0010 	ands.w	r0, r0, #16
   1771e:	d106      	bne.n	1772e <uarte_nrfx_irq_is_pending+0x2a>
}
   17720:	bd08      	pop	{r3, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
   17722:	f7ff ffb6 	bl	17692 <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
   17726:	2800      	cmp	r0, #0
   17728:	d0f5      	beq.n	17716 <uarte_nrfx_irq_is_pending+0x12>
		||
   1772a:	2001      	movs	r0, #1
   1772c:	e7f8      	b.n	17720 <uarte_nrfx_irq_is_pending+0x1c>
		 uarte_nrfx_irq_rx_ready(dev)));
   1772e:	4610      	mov	r0, r2
   17730:	f7ff ffba 	bl	176a8 <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
   17734:	3800      	subs	r0, #0
   17736:	bf18      	it	ne
   17738:	2001      	movne	r0, #1
   1773a:	e7f1      	b.n	17720 <uarte_nrfx_irq_is_pending+0x1c>

0001773c <uarte_nrfx_poll_out>:
{
   1773c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return dev->config->config_info;
   17740:	6803      	ldr	r3, [r0, #0]
{
   17742:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
   17746:	689b      	ldr	r3, [r3, #8]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   17748:	6886      	ldr	r6, [r0, #8]
	return config->uarte_regs;
   1774a:	681c      	ldr	r4, [r3, #0]
	if (!k_is_in_isr()) {
   1774c:	f001 fbed 	bl	18f2a <k_is_in_isr>
   17750:	b9d8      	cbnz	r0, 1778a <uarte_nrfx_poll_out+0x4e>
		lock = &data->poll_out_lock;
   17752:	f106 070c 	add.w	r7, r6, #12
   17756:	2564      	movs	r5, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   17758:	f04f 0801 	mov.w	r8, #1
   1775c:	f3bf 8f5b 	dmb	ish
   17760:	e857 3f00 	ldrex	r3, [r7]
   17764:	2b00      	cmp	r3, #0
   17766:	d103      	bne.n	17770 <uarte_nrfx_poll_out+0x34>
   17768:	e847 8200 	strex	r2, r8, [r7]
   1776c:	2a00      	cmp	r2, #0
   1776e:	d1f7      	bne.n	17760 <uarte_nrfx_poll_out+0x24>
   17770:	f3bf 8f5b 	dmb	ish
		while (atomic_cas((atomic_t *) lock,
   17774:	d00b      	beq.n	1778e <uarte_nrfx_poll_out+0x52>
	return z_impl_k_sleep(timeout);
   17776:	2001      	movs	r0, #1
   17778:	3d01      	subs	r5, #1
   1777a:	f7fc fd89 	bl	14290 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
   1777e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   17782:	d1eb      	bne.n	1775c <uarte_nrfx_poll_out+0x20>
}
   17784:	b002      	add	sp, #8
   17786:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*lock = 1;
   1778a:	2301      	movs	r3, #1
   1778c:	60f3      	str	r3, [r6, #12]
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDTX);
   1778e:	f44f 7190 	mov.w	r1, #288	; 0x120
   17792:	4620      	mov	r0, r4
   17794:	f7ff fee3 	bl	1755e <nrf_uarte_event_clear>
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   17798:	f10d 0307 	add.w	r3, sp, #7
   1779c:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   177a0:	2301      	movs	r3, #1
   177a2:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   177a6:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   177aa:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   177ac:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX),
   177b0:	b923      	cbnz	r3, 177bc <uarte_nrfx_poll_out+0x80>
   177b2:	2001      	movs	r0, #1
   177b4:	f000 f808 	bl	177c8 <nrfx_busy_wait>
   177b8:	3d01      	subs	r5, #1
   177ba:	d1f7      	bne.n	177ac <uarte_nrfx_poll_out+0x70>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   177bc:	2301      	movs	r3, #1
   177be:	60e3      	str	r3, [r4, #12]
	*lock = 0;
   177c0:	2300      	movs	r3, #0
   177c2:	60f3      	str	r3, [r6, #12]
   177c4:	e7de      	b.n	17784 <uarte_nrfx_poll_out+0x48>

000177c6 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   177c6:	4700      	bx	r0

000177c8 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   177c8:	f001 bbb5 	b.w	18f36 <z_impl_k_busy_wait>

000177cc <nrfx_nvmc_flash_size_get>:
    return p_reg->CODEPAGESIZE;
   177cc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   177d0:	691a      	ldr	r2, [r3, #16]
    return p_reg->CODESIZE;
   177d2:	6958      	ldr	r0, [r3, #20]
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   177d4:	4350      	muls	r0, r2
   177d6:	4770      	bx	lr

000177d8 <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   177d8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   177dc:	6918      	ldr	r0, [r3, #16]

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   177de:	4770      	bx	lr

000177e0 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   177e0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   177e4:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   177e6:	4770      	bx	lr

000177e8 <transfer_byte>:
{
   177e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    return p_reg->RXD;
   177ea:	f8d0 3518 	ldr.w	r3, [r0, #1304]	; 0x518
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
   177ee:	698a      	ldr	r2, [r1, #24]
   177f0:	b2db      	uxtb	r3, r3
    volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
   177f2:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
   177f6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   177f8:	4293      	cmp	r3, r2
        p_cb->evt.xfer_desc.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
   177fa:	bf3e      	ittt	cc
   177fc:	694a      	ldrcc	r2, [r1, #20]
   177fe:	f89d 4007 	ldrbcc.w	r4, [sp, #7]
   17802:	54d4      	strbcc	r4, [r2, r3]
    ++p_cb->bytes_transferred;
   17804:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    if (p_cb->abort)
   17806:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    ++p_cb->bytes_transferred;
   1780a:	1c53      	adds	r3, r2, #1
   1780c:	624b      	str	r3, [r1, #36]	; 0x24
    size_t bytes_used = p_cb->bytes_transferred + 1;
   1780e:	3202      	adds	r2, #2
    if (p_cb->abort)
   17810:	b13c      	cbz	r4, 17822 <transfer_byte+0x3a>
        if (bytes_used < p_cb->evt.xfer_desc.tx_length)
   17812:	690c      	ldr	r4, [r1, #16]
   17814:	42a2      	cmp	r2, r4
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   17816:	698c      	ldr	r4, [r1, #24]
            p_cb->evt.xfer_desc.tx_length = bytes_used;
   17818:	bf38      	it	cc
   1781a:	610a      	strcc	r2, [r1, #16]
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   1781c:	4294      	cmp	r4, r2
            p_cb->evt.xfer_desc.rx_length = bytes_used;
   1781e:	bf88      	it	hi
   17820:	618a      	strhi	r2, [r1, #24]
    if (bytes_used < p_cb->evt.xfer_desc.tx_length)
   17822:	690d      	ldr	r5, [r1, #16]
   17824:	4295      	cmp	r5, r2
   17826:	d905      	bls.n	17834 <transfer_byte+0x4c>
        nrf_spi_txd_set(p_spi, p_cb->evt.xfer_desc.p_tx_buffer[bytes_used]);
   17828:	68cb      	ldr	r3, [r1, #12]
    p_reg->TXD = data;
   1782a:	5c9b      	ldrb	r3, [r3, r2]
   1782c:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
   17830:	2001      	movs	r0, #1
   17832:	e00b      	b.n	1784c <transfer_byte+0x64>
    else if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   17834:	698c      	ldr	r4, [r1, #24]
   17836:	4294      	cmp	r4, r2
   17838:	d902      	bls.n	17840 <transfer_byte+0x58>
   1783a:	f891 3020 	ldrb.w	r3, [r1, #32]
   1783e:	e7f5      	b.n	1782c <transfer_byte+0x44>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
   17840:	42ab      	cmp	r3, r5
   17842:	d3f5      	bcc.n	17830 <transfer_byte+0x48>
   17844:	42a3      	cmp	r3, r4
   17846:	bf2c      	ite	cs
   17848:	2000      	movcs	r0, #0
   1784a:	2001      	movcc	r0, #1
}
   1784c:	b003      	add	sp, #12
   1784e:	bd30      	pop	{r4, r5, pc}

00017850 <nrfx_usbd_consumer>:
{
   17850:	b530      	push	{r4, r5, lr}
    size_t size = p_transfer->size;
   17852:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
   17854:	680d      	ldr	r5, [r1, #0]
   17856:	429c      	cmp	r4, r3
        p_next->p_data = p_transfer->p_data;
   17858:	bf29      	itett	cs
   1785a:	e9c0 5300 	strdcs	r5, r3, [r0]
        p_next->size = 0;
   1785e:	2100      	movcc	r1, #0
        size -= data_size;
   17860:	1ae4      	subcs	r4, r4, r3
        p_transfer->p_data.addr += data_size;
   17862:	18ed      	addcs	r5, r5, r3
        p_next->p_data = p_transfer->p_data;
   17864:	bf32      	itee	cc
   17866:	e9c0 5100 	strdcc	r5, r1, [r0]
        p_transfer->size = size;
   1786a:	604c      	strcs	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
   1786c:	600d      	strcs	r5, [r1, #0]
    return (ep_size == data_size) && (size != 0);
   1786e:	4293      	cmp	r3, r2
   17870:	d103      	bne.n	1787a <nrfx_usbd_consumer+0x2a>
   17872:	1e20      	subs	r0, r4, #0
   17874:	bf18      	it	ne
   17876:	2001      	movne	r0, #1
}
   17878:	bd30      	pop	{r4, r5, pc}
    return (ep_size == data_size) && (size != 0);
   1787a:	2000      	movs	r0, #0
   1787c:	e7fc      	b.n	17878 <nrfx_usbd_consumer+0x28>

0001787e <nrfx_usbd_feeder_ram>:
    size_t tx_size = p_transfer->size;
   1787e:	684b      	ldr	r3, [r1, #4]
{
   17880:	b510      	push	{r4, lr}
   17882:	429a      	cmp	r2, r3
    p_next->p_data = p_transfer->p_data;
   17884:	680c      	ldr	r4, [r1, #0]
   17886:	bf28      	it	cs
   17888:	461a      	movcs	r2, r3
    p_next->size = tx_size;
   1788a:	e9c0 4200 	strd	r4, r2, [r0]
    p_transfer->size -= tx_size;
   1788e:	1a98      	subs	r0, r3, r2
    p_transfer->p_data.addr += tx_size;
   17890:	680b      	ldr	r3, [r1, #0]
    p_transfer->size -= tx_size;
   17892:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   17894:	441a      	add	r2, r3
}
   17896:	3800      	subs	r0, #0
    p_transfer->p_data.addr += tx_size;
   17898:	600a      	str	r2, [r1, #0]
}
   1789a:	bf18      	it	ne
   1789c:	2001      	movne	r0, #1
   1789e:	bd10      	pop	{r4, pc}

000178a0 <nrfx_usbd_feeder_ram_zlp>:
{
   178a0:	b530      	push	{r4, r5, lr}
    size_t tx_size = p_transfer->size;
   178a2:	684c      	ldr	r4, [r1, #4]
    if (tx_size > ep_size)
   178a4:	680b      	ldr	r3, [r1, #0]
   178a6:	42a2      	cmp	r2, r4
   178a8:	bf28      	it	cs
   178aa:	4622      	movcs	r2, r4
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   178ac:	2a00      	cmp	r2, #0
   178ae:	bf14      	ite	ne
   178b0:	461d      	movne	r5, r3
   178b2:	2500      	moveq	r5, #0
    p_next->size = tx_size;
   178b4:	e9c0 5200 	strd	r5, r2, [r0]
    p_transfer->size -= tx_size;
   178b8:	eba4 0402 	sub.w	r4, r4, r2
    p_transfer->p_data.addr += tx_size;
   178bc:	441a      	add	r2, r3
    p_transfer->size -= tx_size;
   178be:	604c      	str	r4, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   178c0:	600a      	str	r2, [r1, #0]
}
   178c2:	bf14      	ite	ne
   178c4:	2001      	movne	r0, #1
   178c6:	2000      	moveq	r0, #0
   178c8:	bd30      	pop	{r4, r5, pc}

000178ca <ep2bit>:
    return NRFX_USBD_EP_BITPOS(ep);
   178ca:	b243      	sxtb	r3, r0
   178cc:	2b00      	cmp	r3, #0
   178ce:	bfb4      	ite	lt
   178d0:	2000      	movlt	r0, #0
   178d2:	2010      	movge	r0, #16
   178d4:	f003 030f 	and.w	r3, r3, #15
}
   178d8:	4418      	add	r0, r3
   178da:	4770      	bx	lr

000178dc <ev_started_handler>:
}
   178dc:	4770      	bx	lr

000178de <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
   178de:	f7f8 bd6f 	b.w	103c0 <nrf_usbd_ep0in_dma_handler>

000178e2 <nrf_usbd_epin_dma_handler>:
{
   178e2:	b508      	push	{r3, lr}
   178e4:	4601      	mov	r1, r0
    usbd_dma_pending_clear();
   178e6:	f7f8 fc89 	bl	101fc <usbd_dma_pending_clear>
    usbd_ep_state_t * p_state = ep_state_access(ep);
   178ea:	4608      	mov	r0, r1
   178ec:	f7f8 fc78 	bl	101e0 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   178f0:	7b83      	ldrb	r3, [r0, #14]
   178f2:	2b03      	cmp	r3, #3
   178f4:	d10a      	bne.n	1790c <nrf_usbd_epin_dma_handler+0x2a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   178f6:	4608      	mov	r0, r1
   178f8:	f7ff ffe7 	bl	178ca <ep2bit>
   178fc:	2301      	movs	r3, #1
   178fe:	fa03 f000 	lsl.w	r0, r3, r0
   17902:	43c0      	mvns	r0, r0
}
   17904:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   17908:	f7f8 bd48 	b.w	1039c <atomic_and.constprop.0>
    else if (p_state->handler.feeder == NULL)
   1790c:	6803      	ldr	r3, [r0, #0]
   1790e:	2b00      	cmp	r3, #0
   17910:	d0f1      	beq.n	178f6 <nrf_usbd_epin_dma_handler+0x14>
}
   17912:	bd08      	pop	{r3, pc}

00017914 <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
   17914:	2087      	movs	r0, #135	; 0x87
   17916:	f7ff bfe4 	b.w	178e2 <nrf_usbd_epin_dma_handler>

0001791a <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
   1791a:	2086      	movs	r0, #134	; 0x86
   1791c:	f7ff bfe1 	b.w	178e2 <nrf_usbd_epin_dma_handler>

00017920 <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
   17920:	2085      	movs	r0, #133	; 0x85
   17922:	f7ff bfde 	b.w	178e2 <nrf_usbd_epin_dma_handler>

00017926 <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
   17926:	2084      	movs	r0, #132	; 0x84
   17928:	f7ff bfdb 	b.w	178e2 <nrf_usbd_epin_dma_handler>

0001792c <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
   1792c:	2083      	movs	r0, #131	; 0x83
   1792e:	f7ff bfd8 	b.w	178e2 <nrf_usbd_epin_dma_handler>

00017932 <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
   17932:	2082      	movs	r0, #130	; 0x82
   17934:	f7ff bfd5 	b.w	178e2 <nrf_usbd_epin_dma_handler>

00017938 <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
   17938:	2081      	movs	r0, #129	; 0x81
   1793a:	f7ff bfd2 	b.w	178e2 <nrf_usbd_epin_dma_handler>

0001793e <nrfx_usbd_ep_max_packet_size_set>:
{
   1793e:	b508      	push	{r3, lr}
    usbd_ep_state_t * p_state = ep_state_access(ep);
   17940:	f7f8 fc4e 	bl	101e0 <ep_state_access>
    p_state->max_packet_size = size;
   17944:	8181      	strh	r1, [r0, #12]
}
   17946:	bd08      	pop	{r3, pc}

00017948 <nrfx_usbd_ep_status_get>:
{
   17948:	b508      	push	{r3, lr}
    usbd_ep_state_t const * p_state = ep_state_access(ep);
   1794a:	f7f8 fc49 	bl	101e0 <ep_state_access>
	__asm__ volatile(
   1794e:	f04f 0220 	mov.w	r2, #32
   17952:	f3ef 8311 	mrs	r3, BASEPRI
   17956:	f382 8811 	msr	BASEPRI, r2
   1795a:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
   1795e:	6882      	ldr	r2, [r0, #8]
   17960:	600a      	str	r2, [r1, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   17962:	6802      	ldr	r2, [r0, #0]
   17964:	b92a      	cbnz	r2, 17972 <nrfx_usbd_ep_status_get+0x2a>
   17966:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
   17968:	f383 8811 	msr	BASEPRI, r3
   1796c:	f3bf 8f6f 	isb	sy
}
   17970:	bd08      	pop	{r3, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   17972:	2004      	movs	r0, #4
   17974:	e7f8      	b.n	17968 <nrfx_usbd_ep_status_get+0x20>

00017976 <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
   17976:	2007      	movs	r0, #7
   17978:	f7f9 b8e8 	b.w	10b4c <nrf_usbd_epout_dma_handler>

0001797c <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
   1797c:	2006      	movs	r0, #6
   1797e:	f7f9 b8e5 	b.w	10b4c <nrf_usbd_epout_dma_handler>

00017982 <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
   17982:	2005      	movs	r0, #5
   17984:	f7f9 b8e2 	b.w	10b4c <nrf_usbd_epout_dma_handler>

00017988 <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
   17988:	2004      	movs	r0, #4
   1798a:	f7f9 b8df 	b.w	10b4c <nrf_usbd_epout_dma_handler>

0001798e <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
   1798e:	2003      	movs	r0, #3
   17990:	f7f9 b8dc 	b.w	10b4c <nrf_usbd_epout_dma_handler>

00017994 <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
   17994:	2002      	movs	r0, #2
   17996:	f7f9 b8d9 	b.w	10b4c <nrf_usbd_epout_dma_handler>

0001799a <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
   1799a:	2001      	movs	r0, #1
   1799c:	f7f9 b8d6 	b.w	10b4c <nrf_usbd_epout_dma_handler>

000179a0 <lfs_pair_isnull>:
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
   179a0:	6803      	ldr	r3, [r0, #0]
   179a2:	3301      	adds	r3, #1
   179a4:	d004      	beq.n	179b0 <lfs_pair_isnull+0x10>
   179a6:	6840      	ldr	r0, [r0, #4]
   179a8:	1c43      	adds	r3, r0, #1
   179aa:	4258      	negs	r0, r3
   179ac:	4158      	adcs	r0, r3
   179ae:	4770      	bx	lr
   179b0:	2001      	movs	r0, #1
}
   179b2:	4770      	bx	lr

000179b4 <lfs_pair_cmp>:
        const lfs_block_t pairb[2]) {
   179b4:	b510      	push	{r4, lr}
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
   179b6:	680b      	ldr	r3, [r1, #0]
   179b8:	6804      	ldr	r4, [r0, #0]
   179ba:	429c      	cmp	r4, r3
   179bc:	d009      	beq.n	179d2 <lfs_pair_cmp+0x1e>
   179be:	6840      	ldr	r0, [r0, #4]
   179c0:	684a      	ldr	r2, [r1, #4]
   179c2:	4290      	cmp	r0, r2
   179c4:	d005      	beq.n	179d2 <lfs_pair_cmp+0x1e>
   179c6:	4294      	cmp	r4, r2
   179c8:	d003      	beq.n	179d2 <lfs_pair_cmp+0x1e>
   179ca:	1a18      	subs	r0, r3, r0
   179cc:	bf18      	it	ne
   179ce:	2001      	movne	r0, #1
}
   179d0:	bd10      	pop	{r4, pc}
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
   179d2:	2000      	movs	r0, #0
   179d4:	e7fc      	b.n	179d0 <lfs_pair_cmp+0x1c>

000179d6 <lfs_tag_dsize>:
    return ((int32_t)(tag << 22) >> 22) == -1;
   179d6:	f340 0309 	sbfx	r3, r0, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
   179da:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   179de:	bf08      	it	eq
   179e0:	3001      	addeq	r0, #1
    return tag & 0x000003ff;
   179e2:	f3c0 0009 	ubfx	r0, r0, #0, #10
}
   179e6:	3004      	adds	r0, #4
   179e8:	4770      	bx	lr

000179ea <lfs_gstate_xor>:
static inline void lfs_gstate_xor(lfs_gstate_t *a, const lfs_gstate_t *b) {
   179ea:	b510      	push	{r4, lr}
   179ec:	1f03      	subs	r3, r0, #4
   179ee:	3904      	subs	r1, #4
   179f0:	3008      	adds	r0, #8
        ((uint32_t*)a)[i] ^= ((const uint32_t*)b)[i];
   179f2:	f853 2f04 	ldr.w	r2, [r3, #4]!
   179f6:	f851 4f04 	ldr.w	r4, [r1, #4]!
    for (int i = 0; i < 3; i++) {
   179fa:	4283      	cmp	r3, r0
        ((uint32_t*)a)[i] ^= ((const uint32_t*)b)[i];
   179fc:	ea82 0204 	eor.w	r2, r2, r4
   17a00:	601a      	str	r2, [r3, #0]
    for (int i = 0; i < 3; i++) {
   17a02:	d1f6      	bne.n	179f2 <lfs_gstate_xor+0x8>
}
   17a04:	bd10      	pop	{r4, pc}

00017a06 <lfs_gstate_hasmovehere>:
        const lfs_block_t *pair) {
   17a06:	b508      	push	{r3, lr}
    return (tag & 0x70000000) >> 20;
   17a08:	6803      	ldr	r3, [r0, #0]
   17a0a:	0d1b      	lsrs	r3, r3, #20
        const lfs_block_t *pair) {
   17a0c:	4602      	mov	r2, r0
    return lfs_tag_type1(a->tag) && lfs_pair_cmp(a->pair, pair) == 0;
   17a0e:	f413 60e0 	ands.w	r0, r3, #1792	; 0x700
   17a12:	d005      	beq.n	17a20 <lfs_gstate_hasmovehere+0x1a>
   17a14:	1d10      	adds	r0, r2, #4
   17a16:	f7ff ffcd 	bl	179b4 <lfs_pair_cmp>
   17a1a:	fab0 f080 	clz	r0, r0
   17a1e:	0940      	lsrs	r0, r0, #5
}
   17a20:	bd08      	pop	{r3, pc}

00017a22 <lfs_alloc_lookahead>:
            + lfs->cfg->block_count) % lfs->cfg->block_count;
   17a22:	6e83      	ldr	r3, [r0, #104]	; 0x68
   17a24:	6a1a      	ldr	r2, [r3, #32]
   17a26:	6d43      	ldr	r3, [r0, #84]	; 0x54
   17a28:	1ad3      	subs	r3, r2, r3
   17a2a:	440b      	add	r3, r1
    lfs_block_t off = ((block - lfs->free.off)
   17a2c:	fbb3 f1f2 	udiv	r1, r3, r2
   17a30:	fb02 3111 	mls	r1, r2, r1, r3
    if (off < lfs->free.size) {
   17a34:	6d83      	ldr	r3, [r0, #88]	; 0x58
   17a36:	428b      	cmp	r3, r1
static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
   17a38:	b510      	push	{r4, lr}
    if (off < lfs->free.size) {
   17a3a:	d90b      	bls.n	17a54 <lfs_alloc_lookahead+0x32>
        lfs->free.buffer[off / 32] |= 1U << (off % 32);
   17a3c:	094c      	lsrs	r4, r1, #5
   17a3e:	6e42      	ldr	r2, [r0, #100]	; 0x64
   17a40:	2301      	movs	r3, #1
   17a42:	f001 011f 	and.w	r1, r1, #31
   17a46:	fa03 f101 	lsl.w	r1, r3, r1
   17a4a:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   17a4e:	430b      	orrs	r3, r1
   17a50:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
}
   17a54:	2000      	movs	r0, #0
   17a56:	bd10      	pop	{r4, pc}

00017a58 <lfs_dir_commit_size>:
static int lfs_dir_commit_size(void *p, lfs_tag_t tag, const void *buffer) {
   17a58:	4602      	mov	r2, r0
   17a5a:	b508      	push	{r3, lr}
    *size += lfs_tag_dsize(tag);
   17a5c:	4608      	mov	r0, r1
   17a5e:	f7ff ffba 	bl	179d6 <lfs_tag_dsize>
   17a62:	6813      	ldr	r3, [r2, #0]
   17a64:	4403      	add	r3, r0
   17a66:	6013      	str	r3, [r2, #0]
}
   17a68:	2000      	movs	r0, #0
   17a6a:	bd08      	pop	{r3, pc}

00017a6c <lfs_fs_size_count>:
    *size += 1;
   17a6c:	6803      	ldr	r3, [r0, #0]
   17a6e:	3301      	adds	r3, #1
   17a70:	6003      	str	r3, [r0, #0]
}
   17a72:	2000      	movs	r0, #0
   17a74:	4770      	bx	lr

00017a76 <lfs_deinit>:
    if (!lfs->cfg->read_buffer) {
   17a76:	6e83      	ldr	r3, [r0, #104]	; 0x68
   17a78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
static int lfs_deinit(lfs_t *lfs) {
   17a7a:	b510      	push	{r4, lr}
   17a7c:	4604      	mov	r4, r0
    if (!lfs->cfg->read_buffer) {
   17a7e:	b913      	cbnz	r3, 17a86 <lfs_deinit+0x10>
}

// Deallocate memory, only used if buffers are not provided to littlefs
static inline void lfs_free(void *p) {
#ifndef LFS_NO_MALLOC
    free(p);
   17a80:	68c0      	ldr	r0, [r0, #12]
   17a82:	f7fe fa7b 	bl	15f7c <free>
    if (!lfs->cfg->prog_buffer) {
   17a86:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   17a88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   17a8a:	b913      	cbnz	r3, 17a92 <lfs_deinit+0x1c>
   17a8c:	69e0      	ldr	r0, [r4, #28]
   17a8e:	f7fe fa75 	bl	15f7c <free>
    if (!lfs->cfg->lookahead_buffer) {
   17a92:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   17a94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   17a96:	b913      	cbnz	r3, 17a9e <lfs_deinit+0x28>
   17a98:	6e60      	ldr	r0, [r4, #100]	; 0x64
   17a9a:	f7fe fa6f 	bl	15f7c <free>
}
   17a9e:	2000      	movs	r0, #0
   17aa0:	bd10      	pop	{r4, pc}

00017aa2 <lfs_fs_preporphans.isra.0>:
    lfs->gstate.tag += orphans;
   17aa2:	6803      	ldr	r3, [r0, #0]
   17aa4:	4419      	add	r1, r3
    return tag & 0x000003ff;
   17aa6:	f3c1 0309 	ubfx	r3, r1, #0, #10
    return lfs_tag_size(a->tag);
   17aaa:	3b00      	subs	r3, #0
   17aac:	bf18      	it	ne
   17aae:	2301      	movne	r3, #1
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x800, 0, 0)) |
   17ab0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   17ab4:	ea41 71c3 	orr.w	r1, r1, r3, lsl #31
   17ab8:	6001      	str	r1, [r0, #0]
}
   17aba:	4770      	bx	lr

00017abc <lfs_bd_read.isra.0>:
static int lfs_bd_read(lfs_t *lfs,
   17abc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17ac0:	b087      	sub	sp, #28
   17ac2:	e9dd a410 	ldrd	sl, r4, [sp, #64]	; 0x40
   17ac6:	9202      	str	r2, [sp, #8]
    if (block >= lfs->cfg->block_count ||
   17ac8:	6802      	ldr	r2, [r0, #0]
static int lfs_bd_read(lfs_t *lfs,
   17aca:	9305      	str	r3, [sp, #20]
    if (block >= lfs->cfg->block_count ||
   17acc:	6a13      	ldr	r3, [r2, #32]
static int lfs_bd_read(lfs_t *lfs,
   17ace:	9004      	str	r0, [sp, #16]
    if (block >= lfs->cfg->block_count ||
   17ad0:	4553      	cmp	r3, sl
static int lfs_bd_read(lfs_t *lfs,
   17ad2:	e9dd 8612 	ldrd	r8, r6, [sp, #72]	; 0x48
   17ad6:	4689      	mov	r9, r1
    if (block >= lfs->cfg->block_count ||
   17ad8:	d903      	bls.n	17ae2 <lfs_bd_read.isra.0+0x26>
   17ada:	69d2      	ldr	r2, [r2, #28]
            off+size > lfs->cfg->block_size) {
   17adc:	19a3      	adds	r3, r4, r6
    if (block >= lfs->cfg->block_count ||
   17ade:	4293      	cmp	r3, r2
   17ae0:	d922      	bls.n	17b28 <lfs_bd_read.isra.0+0x6c>
        return LFS_ERR_CORRUPT;
   17ae2:	f06f 0053 	mvn.w	r0, #83	; 0x53
   17ae6:	e08f      	b.n	17c08 <lfs_bd_read.isra.0+0x14c>
        if (pcache && block == pcache->block &&
   17ae8:	f1b9 0f00 	cmp.w	r9, #0
   17aec:	d03f      	beq.n	17b6e <lfs_bd_read.isra.0+0xb2>
   17aee:	f8d9 3000 	ldr.w	r3, [r9]
   17af2:	459a      	cmp	sl, r3
   17af4:	d13b      	bne.n	17b6e <lfs_bd_read.isra.0+0xb2>
                off < pcache->off + pcache->size) {
   17af6:	e9d9 5201 	ldrd	r5, r2, [r9, #4]
   17afa:	eb05 0b02 	add.w	fp, r5, r2
        if (pcache && block == pcache->block &&
   17afe:	45a3      	cmp	fp, r4
   17b00:	d935      	bls.n	17b6e <lfs_bd_read.isra.0+0xb2>
            if (off >= pcache->off) {
   17b02:	42a5      	cmp	r5, r4
   17b04:	d814      	bhi.n	17b30 <lfs_bd_read.isra.0+0x74>
                diff = lfs_min(diff, pcache->size - (off-pcache->off));
   17b06:	ebab 0b04 	sub.w	fp, fp, r4
    return (a < b) ? a : b;
   17b0a:	45b3      	cmp	fp, r6
                memcpy(data, &pcache->buffer[off-pcache->off], diff);
   17b0c:	f8d9 100c 	ldr.w	r1, [r9, #12]
   17b10:	bf28      	it	cs
   17b12:	46b3      	movcs	fp, r6
   17b14:	1b65      	subs	r5, r4, r5
   17b16:	4640      	mov	r0, r8
   17b18:	465a      	mov	r2, fp
   17b1a:	4429      	add	r1, r5
   17b1c:	f7fe fa8d 	bl	1603a <memcpy>
                data += diff;
   17b20:	44d8      	add	r8, fp
                off += diff;
   17b22:	445c      	add	r4, fp
                size -= diff;
   17b24:	eba6 060b 	sub.w	r6, r6, fp
    while (size > 0) {
   17b28:	2e00      	cmp	r6, #0
   17b2a:	d1dd      	bne.n	17ae8 <lfs_bd_read.isra.0+0x2c>
    return 0;
   17b2c:	4630      	mov	r0, r6
   17b2e:	e06b      	b.n	17c08 <lfs_bd_read.isra.0+0x14c>
            diff = lfs_min(diff, pcache->off-off);
   17b30:	1b2d      	subs	r5, r5, r4
   17b32:	42b5      	cmp	r5, r6
   17b34:	bf28      	it	cs
   17b36:	4635      	movcs	r5, r6
        if (block == rcache->block &&
   17b38:	9b02      	ldr	r3, [sp, #8]
   17b3a:	681b      	ldr	r3, [r3, #0]
   17b3c:	459a      	cmp	sl, r3
   17b3e:	d11c      	bne.n	17b7a <lfs_bd_read.isra.0+0xbe>
                off < rcache->off + rcache->size) {
   17b40:	9b02      	ldr	r3, [sp, #8]
   17b42:	e9d3 1201 	ldrd	r1, r2, [r3, #4]
   17b46:	440a      	add	r2, r1
        if (block == rcache->block &&
   17b48:	4294      	cmp	r4, r2
   17b4a:	d216      	bcs.n	17b7a <lfs_bd_read.isra.0+0xbe>
            if (off >= rcache->off) {
   17b4c:	428c      	cmp	r4, r1
   17b4e:	d310      	bcc.n	17b72 <lfs_bd_read.isra.0+0xb6>
                diff = lfs_min(diff, rcache->size - (off-rcache->off));
   17b50:	1b12      	subs	r2, r2, r4
   17b52:	4295      	cmp	r5, r2
                memcpy(data, &rcache->buffer[off-rcache->off], diff);
   17b54:	68db      	ldr	r3, [r3, #12]
   17b56:	bf28      	it	cs
   17b58:	4615      	movcs	r5, r2
   17b5a:	1a61      	subs	r1, r4, r1
   17b5c:	4640      	mov	r0, r8
   17b5e:	462a      	mov	r2, r5
   17b60:	4419      	add	r1, r3
   17b62:	f7fe fa6a 	bl	1603a <memcpy>
                data += diff;
   17b66:	44a8      	add	r8, r5
                off += diff;
   17b68:	442c      	add	r4, r5
                size -= diff;
   17b6a:	1b76      	subs	r6, r6, r5
                continue;
   17b6c:	e7dc      	b.n	17b28 <lfs_bd_read.isra.0+0x6c>
   17b6e:	4635      	mov	r5, r6
   17b70:	e7e2      	b.n	17b38 <lfs_bd_read.isra.0+0x7c>
            diff = lfs_min(diff, rcache->off-off);
   17b72:	1b09      	subs	r1, r1, r4
   17b74:	428d      	cmp	r5, r1
   17b76:	bf28      	it	cs
   17b78:	460d      	movcs	r5, r1
        if (size >= hint && off % lfs->cfg->read_size == 0 &&
   17b7a:	9b04      	ldr	r3, [sp, #16]
   17b7c:	6818      	ldr	r0, [r3, #0]
   17b7e:	6842      	ldr	r2, [r0, #4]
   17b80:	f8d0 c014 	ldr.w	ip, [r0, #20]
   17b84:	fbb4 f3fc 	udiv	r3, r4, ip
   17b88:	4617      	mov	r7, r2
   17b8a:	9a05      	ldr	r2, [sp, #20]
   17b8c:	42b2      	cmp	r2, r6
   17b8e:	fb0c 4313 	mls	r3, ip, r3, r4
   17b92:	d816      	bhi.n	17bc2 <lfs_bd_read.isra.0+0x106>
   17b94:	b9ab      	cbnz	r3, 17bc2 <lfs_bd_read.isra.0+0x106>
   17b96:	4566      	cmp	r6, ip
   17b98:	d313      	bcc.n	17bc2 <lfs_bd_read.isra.0+0x106>
    return a - (a % alignment);
   17b9a:	fbb5 f2fc 	udiv	r2, r5, ip
   17b9e:	fb0c 5312 	mls	r3, ip, r2, r5
   17ba2:	eba5 0b03 	sub.w	fp, r5, r3
   17ba6:	9303      	str	r3, [sp, #12]
            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);
   17ba8:	f8cd b000 	str.w	fp, [sp]
   17bac:	4643      	mov	r3, r8
   17bae:	4622      	mov	r2, r4
   17bb0:	4651      	mov	r1, sl
   17bb2:	47b8      	blx	r7
            if (err) {
   17bb4:	bb40      	cbnz	r0, 17c08 <lfs_bd_read.isra.0+0x14c>
            size -= diff;
   17bb6:	9b03      	ldr	r3, [sp, #12]
   17bb8:	1b5d      	subs	r5, r3, r5
            data += diff;
   17bba:	44d8      	add	r8, fp
            off += diff;
   17bbc:	445c      	add	r4, fp
            size -= diff;
   17bbe:	442e      	add	r6, r5
            continue;
   17bc0:	e7b2      	b.n	17b28 <lfs_bd_read.isra.0+0x6c>
        rcache->block = block;
   17bc2:	9a02      	ldr	r2, [sp, #8]
        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
   17bc4:	9902      	ldr	r1, [sp, #8]
        rcache->block = block;
   17bc6:	f8c2 a000 	str.w	sl, [r2]
    return lfs_aligndown(a + alignment-1, alignment);
   17bca:	9d05      	ldr	r5, [sp, #20]
    return a - (a % alignment);
   17bcc:	1ae2      	subs	r2, r4, r3
        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
   17bce:	604a      	str	r2, [r1, #4]
    return lfs_aligndown(a + alignment-1, alignment);
   17bd0:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
   17bd4:	4429      	add	r1, r5
   17bd6:	4421      	add	r1, r4
    return a - (a % alignment);
   17bd8:	fbb1 f5fc 	udiv	r5, r1, ip
   17bdc:	fb0c 1c15 	mls	ip, ip, r5, r1
   17be0:	eba1 0c0c 	sub.w	ip, r1, ip
    return (a < b) ? a : b;
   17be4:	69c1      	ldr	r1, [r0, #28]
        rcache->size = lfs_min(
   17be6:	1b1b      	subs	r3, r3, r4
   17be8:	458c      	cmp	ip, r1
   17bea:	bf94      	ite	ls
   17bec:	4463      	addls	r3, ip
   17bee:	185b      	addhi	r3, r3, r1
   17bf0:	6a81      	ldr	r1, [r0, #40]	; 0x28
   17bf2:	428b      	cmp	r3, r1
   17bf4:	bf28      	it	cs
   17bf6:	460b      	movcs	r3, r1
   17bf8:	9902      	ldr	r1, [sp, #8]
   17bfa:	608b      	str	r3, [r1, #8]
        int err = lfs->cfg->read(lfs->cfg, rcache->block,
   17bfc:	9300      	str	r3, [sp, #0]
   17bfe:	68cb      	ldr	r3, [r1, #12]
   17c00:	4651      	mov	r1, sl
   17c02:	47b8      	blx	r7
        if (err) {
   17c04:	2800      	cmp	r0, #0
   17c06:	d08f      	beq.n	17b28 <lfs_bd_read.isra.0+0x6c>
}
   17c08:	b007      	add	sp, #28
   17c0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00017c0e <lfs_fs_parent_match>:
        lfs_tag_t tag, const void *buffer) {
   17c0e:	b530      	push	{r4, r5, lr}
   17c10:	4613      	mov	r3, r2
   17c12:	b087      	sub	sp, #28
    lfs_t *lfs = find->lfs;
   17c14:	6802      	ldr	r2, [r0, #0]
        lfs_tag_t tag, const void *buffer) {
   17c16:	4604      	mov	r4, r0
    int err = lfs_bd_read(lfs,
   17c18:	ad04      	add	r5, sp, #16
   17c1a:	2008      	movs	r0, #8
   17c1c:	6e91      	ldr	r1, [r2, #104]	; 0x68
   17c1e:	9003      	str	r0, [sp, #12]
   17c20:	9502      	str	r5, [sp, #8]
   17c22:	6858      	ldr	r0, [r3, #4]
   17c24:	9001      	str	r0, [sp, #4]
   17c26:	681b      	ldr	r3, [r3, #0]
   17c28:	9300      	str	r3, [sp, #0]
   17c2a:	69cb      	ldr	r3, [r1, #28]
   17c2c:	f102 0068 	add.w	r0, r2, #104	; 0x68
   17c30:	f102 0110 	add.w	r1, r2, #16
   17c34:	f7ff ff42 	bl	17abc <lfs_bd_read.isra.0>
    if (err) {
   17c38:	b930      	cbnz	r0, 17c48 <lfs_fs_parent_match+0x3a>
    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;
   17c3a:	1d21      	adds	r1, r4, #4
   17c3c:	4628      	mov	r0, r5
   17c3e:	f7ff feb9 	bl	179b4 <lfs_pair_cmp>
   17c42:	3800      	subs	r0, #0
   17c44:	bf18      	it	ne
   17c46:	2001      	movne	r0, #1
}
   17c48:	b007      	add	sp, #28
   17c4a:	bd30      	pop	{r4, r5, pc}

00017c4c <lfs_dir_fetch>:
        lfs_mdir_t *dir, const lfs_block_t pair[2]) {
   17c4c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return (int)lfs_dir_fetchmatch(lfs, dir, pair,
   17c4e:	2300      	movs	r3, #0
   17c50:	e9cd 3302 	strd	r3, r3, [sp, #8]
   17c54:	9301      	str	r3, [sp, #4]
   17c56:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17c5a:	9300      	str	r3, [sp, #0]
   17c5c:	f7f9 fb4a 	bl	112f4 <lfs_dir_fetchmatch>
}
   17c60:	b005      	add	sp, #20
   17c62:	f85d fb04 	ldr.w	pc, [sp], #4

00017c66 <lfs_fs_pred>:
        const lfs_block_t pair[2], lfs_mdir_t *pdir) {
   17c66:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    pdir->tail[1] = 1;
   17c6a:	2301      	movs	r3, #1
   17c6c:	2400      	movs	r4, #0
   17c6e:	e9c2 4306 	strd	r4, r3, [r2, #24]
        const lfs_block_t pair[2], lfs_mdir_t *pdir) {
   17c72:	4606      	mov	r6, r0
   17c74:	4688      	mov	r8, r1
   17c76:	4615      	mov	r5, r2
    while (!lfs_pair_isnull(pdir->tail)) {
   17c78:	f102 0718 	add.w	r7, r2, #24
   17c7c:	4638      	mov	r0, r7
   17c7e:	f7ff fe8f 	bl	179a0 <lfs_pair_isnull>
   17c82:	b110      	cbz	r0, 17c8a <lfs_fs_pred+0x24>
    return LFS_ERR_NOENT;
   17c84:	f06f 0001 	mvn.w	r0, #1
   17c88:	e011      	b.n	17cae <lfs_fs_pred+0x48>
        if (cycle >= lfs->cfg->block_count/2) {
   17c8a:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   17c8c:	6a1b      	ldr	r3, [r3, #32]
   17c8e:	ebb4 0f53 	cmp.w	r4, r3, lsr #1
   17c92:	d20e      	bcs.n	17cb2 <lfs_fs_pred+0x4c>
        if (lfs_pair_cmp(pdir->tail, pair) == 0) {
   17c94:	4641      	mov	r1, r8
   17c96:	4638      	mov	r0, r7
        cycle += 1;
   17c98:	3401      	adds	r4, #1
        if (lfs_pair_cmp(pdir->tail, pair) == 0) {
   17c9a:	f7ff fe8b 	bl	179b4 <lfs_pair_cmp>
   17c9e:	b130      	cbz	r0, 17cae <lfs_fs_pred+0x48>
        int err = lfs_dir_fetch(lfs, pdir, pdir->tail);
   17ca0:	463a      	mov	r2, r7
   17ca2:	4629      	mov	r1, r5
   17ca4:	4630      	mov	r0, r6
   17ca6:	f7ff ffd1 	bl	17c4c <lfs_dir_fetch>
        if (err) {
   17caa:	2800      	cmp	r0, #0
   17cac:	d0e6      	beq.n	17c7c <lfs_fs_pred+0x16>
}
   17cae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return LFS_ERR_CORRUPT;
   17cb2:	f06f 0053 	mvn.w	r0, #83	; 0x53
   17cb6:	e7fa      	b.n	17cae <lfs_fs_pred+0x48>

00017cb8 <lfs_dir_get>:
        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {
   17cb8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return tag & 0x000003ff;
   17cba:	f3c3 0409 	ubfx	r4, r3, #0, #10
    return lfs_dir_getslice(lfs, dir,
   17cbe:	9402      	str	r4, [sp, #8]
   17cc0:	9c06      	ldr	r4, [sp, #24]
   17cc2:	9401      	str	r4, [sp, #4]
   17cc4:	2400      	movs	r4, #0
   17cc6:	9400      	str	r4, [sp, #0]
   17cc8:	f7f9 fe1e 	bl	11908 <lfs_dir_getslice>
}
   17ccc:	b004      	add	sp, #16
   17cce:	bd10      	pop	{r4, pc}

00017cd0 <lfs_cache_zero.isra.0>:
static inline void lfs_cache_zero(lfs_t *lfs, lfs_cache_t *pcache) {
   17cd0:	b510      	push	{r4, lr}
   17cd2:	460c      	mov	r4, r1
    memset(pcache->buffer, 0xff, lfs->cfg->cache_size);
   17cd4:	6a82      	ldr	r2, [r0, #40]	; 0x28
   17cd6:	68e0      	ldr	r0, [r4, #12]
   17cd8:	21ff      	movs	r1, #255	; 0xff
   17cda:	f7fe f9d9 	bl	16090 <memset>
    pcache->block = LFS_BLOCK_NULL;
   17cde:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17ce2:	6023      	str	r3, [r4, #0]
}
   17ce4:	bd10      	pop	{r4, pc}

00017ce6 <lfs_init>:
    if (lfs->cfg->read_buffer) {
   17ce6:	6b0b      	ldr	r3, [r1, #48]	; 0x30
static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
   17ce8:	b510      	push	{r4, lr}
   17cea:	4604      	mov	r4, r0
    lfs->cfg = cfg;
   17cec:	6681      	str	r1, [r0, #104]	; 0x68
    if (lfs->cfg->read_buffer) {
   17cee:	2b00      	cmp	r3, #0
   17cf0:	d031      	beq.n	17d56 <lfs_init+0x70>
        lfs->rcache.buffer = lfs->cfg->read_buffer;
   17cf2:	60c3      	str	r3, [r0, #12]
    if (lfs->cfg->prog_buffer) {
   17cf4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   17cf6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   17cf8:	2a00      	cmp	r2, #0
   17cfa:	d038      	beq.n	17d6e <lfs_init+0x88>
        lfs->pcache.buffer = lfs->cfg->prog_buffer;
   17cfc:	61e2      	str	r2, [r4, #28]
    lfs_cache_zero(lfs, &lfs->rcache);
   17cfe:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   17d00:	4621      	mov	r1, r4
   17d02:	f7ff ffe5 	bl	17cd0 <lfs_cache_zero.isra.0>
    lfs_cache_zero(lfs, &lfs->pcache);
   17d06:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   17d08:	f104 0110 	add.w	r1, r4, #16
   17d0c:	f7ff ffe0 	bl	17cd0 <lfs_cache_zero.isra.0>
    if (lfs->cfg->lookahead_buffer) {
   17d10:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   17d12:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   17d14:	2a00      	cmp	r2, #0
   17d16:	d031      	beq.n	17d7c <lfs_init+0x96>
        lfs->free.buffer = lfs->cfg->lookahead_buffer;
   17d18:	6662      	str	r2, [r4, #100]	; 0x64
    lfs->name_max = lfs->cfg->name_max;
   17d1a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   17d1c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    if (!lfs->name_max) {
   17d1e:	2a00      	cmp	r2, #0
   17d20:	d033      	beq.n	17d8a <lfs_init+0xa4>
        lfs->name_max = LFS_NAME_MAX;
   17d22:	66e2      	str	r2, [r4, #108]	; 0x6c
    lfs->file_max = lfs->cfg->file_max;
   17d24:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if (!lfs->file_max) {
   17d26:	2a00      	cmp	r2, #0
   17d28:	d031      	beq.n	17d8e <lfs_init+0xa8>
    lfs->attr_max = lfs->cfg->attr_max;
   17d2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        lfs->file_max = LFS_FILE_MAX;
   17d2c:	6722      	str	r2, [r4, #112]	; 0x70
    if (!lfs->attr_max) {
   17d2e:	2b00      	cmp	r3, #0
   17d30:	d030      	beq.n	17d94 <lfs_init+0xae>
    lfs->mlist = NULL;
   17d32:	2000      	movs	r0, #0
        lfs->attr_max = LFS_ATTR_MAX;
   17d34:	6763      	str	r3, [r4, #116]	; 0x74
    lfs->root[0] = LFS_BLOCK_NULL;
   17d36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    lfs->root[1] = LFS_BLOCK_NULL;
   17d3a:	e9c4 3308 	strd	r3, r3, [r4, #32]
    lfs->seed = 0;
   17d3e:	e9c4 000a 	strd	r0, r0, [r4, #40]	; 0x28
    lfs->gdisk = (lfs_gstate_t){0};
   17d42:	e9c4 000f 	strd	r0, r0, [r4, #60]	; 0x3c
    lfs->gstate = (lfs_gstate_t){0};
   17d46:	e9c4 000c 	strd	r0, r0, [r4, #48]	; 0x30
    lfs->gdelta = (lfs_gstate_t){0};
   17d4a:	e9c4 0012 	strd	r0, r0, [r4, #72]	; 0x48
    lfs->gdisk = (lfs_gstate_t){0};
   17d4e:	6460      	str	r0, [r4, #68]	; 0x44
    lfs->gstate = (lfs_gstate_t){0};
   17d50:	63a0      	str	r0, [r4, #56]	; 0x38
    lfs->gdelta = (lfs_gstate_t){0};
   17d52:	6520      	str	r0, [r4, #80]	; 0x50
}
   17d54:	bd10      	pop	{r4, pc}
    return malloc(size);
   17d56:	6a88      	ldr	r0, [r1, #40]	; 0x28
   17d58:	f7fe f909 	bl	15f6e <malloc>
        lfs->rcache.buffer = lfs_malloc(lfs->cfg->cache_size);
   17d5c:	60e0      	str	r0, [r4, #12]
        if (!lfs->rcache.buffer) {
   17d5e:	2800      	cmp	r0, #0
   17d60:	d1c8      	bne.n	17cf4 <lfs_init+0xe>
    lfs_deinit(lfs);
   17d62:	4620      	mov	r0, r4
   17d64:	f7ff fe87 	bl	17a76 <lfs_deinit>
    return err;
   17d68:	f06f 000b 	mvn.w	r0, #11
   17d6c:	e7f2      	b.n	17d54 <lfs_init+0x6e>
   17d6e:	6a98      	ldr	r0, [r3, #40]	; 0x28
   17d70:	f7fe f8fd 	bl	15f6e <malloc>
        lfs->pcache.buffer = lfs_malloc(lfs->cfg->cache_size);
   17d74:	61e0      	str	r0, [r4, #28]
        if (!lfs->pcache.buffer) {
   17d76:	2800      	cmp	r0, #0
   17d78:	d1c1      	bne.n	17cfe <lfs_init+0x18>
   17d7a:	e7f2      	b.n	17d62 <lfs_init+0x7c>
   17d7c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   17d7e:	f7fe f8f6 	bl	15f6e <malloc>
        lfs->free.buffer = lfs_malloc(lfs->cfg->lookahead_size);
   17d82:	6660      	str	r0, [r4, #100]	; 0x64
        if (!lfs->free.buffer) {
   17d84:	2800      	cmp	r0, #0
   17d86:	d1c8      	bne.n	17d1a <lfs_init+0x34>
   17d88:	e7eb      	b.n	17d62 <lfs_init+0x7c>
        lfs->name_max = LFS_NAME_MAX;
   17d8a:	22ff      	movs	r2, #255	; 0xff
   17d8c:	e7c9      	b.n	17d22 <lfs_init+0x3c>
        lfs->file_max = LFS_FILE_MAX;
   17d8e:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   17d92:	e7ca      	b.n	17d2a <lfs_init+0x44>
        lfs->attr_max = LFS_ATTR_MAX;
   17d94:	f240 33fe 	movw	r3, #1022	; 0x3fe
   17d98:	e7cb      	b.n	17d32 <lfs_init+0x4c>

00017d9a <lfs_ctz_index.isra.0>:
static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
   17d9a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lfs_off_t b = lfs->cfg->block_size - 2*4;
   17d9c:	69c5      	ldr	r5, [r0, #28]
    lfs_off_t size = *off;
   17d9e:	680e      	ldr	r6, [r1, #0]
    lfs_off_t b = lfs->cfg->block_size - 2*4;
   17da0:	3d08      	subs	r5, #8
    if (i == 0) {
   17da2:	42ae      	cmp	r6, r5
static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
   17da4:	460f      	mov	r7, r1
    if (i == 0) {
   17da6:	d313      	bcc.n	17dd0 <lfs_ctz_index.isra.0+0x36>
    lfs_off_t i = size / b;
   17da8:	fbb6 f0f5 	udiv	r0, r6, r5
    return __builtin_popcount(a);
   17dac:	3801      	subs	r0, #1
   17dae:	f7e8 fdc1 	bl	934 <__popcountsi2>
    i = (size - 4*(lfs_popc(i-1)+2)) / b;
   17db2:	1c84      	adds	r4, r0, #2
   17db4:	eba6 0484 	sub.w	r4, r6, r4, lsl #2
   17db8:	fbb4 f4f5 	udiv	r4, r4, r5
   17dbc:	4620      	mov	r0, r4
   17dbe:	f7e8 fdb9 	bl	934 <__popcountsi2>
    *off = size - b*i - 4*lfs_popc(i);
   17dc2:	eba6 0680 	sub.w	r6, r6, r0, lsl #2
   17dc6:	fb04 6515 	mls	r5, r4, r5, r6
   17dca:	603d      	str	r5, [r7, #0]
    return i;
   17dcc:	4620      	mov	r0, r4
}
   17dce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
   17dd0:	2000      	movs	r0, #0
   17dd2:	e7fc      	b.n	17dce <lfs_ctz_index.isra.0+0x34>

00017dd4 <lfs_ctz_traverse.part.0>:
static int lfs_ctz_traverse(lfs_t *lfs,
   17dd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17dd8:	b089      	sub	sp, #36	; 0x24
   17dda:	469a      	mov	sl, r3
    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
   17ddc:	4606      	mov	r6, r0
   17dde:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17de0:	f856 0f68 	ldr.w	r0, [r6, #104]!
static int lfs_ctz_traverse(lfs_t *lfs,
   17de4:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
   17de8:	3b01      	subs	r3, #1
static int lfs_ctz_traverse(lfs_t *lfs,
   17dea:	4688      	mov	r8, r1
    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
   17dec:	a905      	add	r1, sp, #20
static int lfs_ctz_traverse(lfs_t *lfs,
   17dee:	4691      	mov	r9, r2
    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
   17df0:	9305      	str	r3, [sp, #20]
   17df2:	f7ff ffd2 	bl	17d9a <lfs_ctz_index.isra.0>
   17df6:	4605      	mov	r5, r0
        int err = cb(data, head);
   17df8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17dfa:	4651      	mov	r1, sl
   17dfc:	4658      	mov	r0, fp
   17dfe:	4798      	blx	r3
        if (err) {
   17e00:	bb28      	cbnz	r0, 17e4e <lfs_ctz_traverse.part.0+0x7a>
        if (index == 0) {
   17e02:	b325      	cbz	r5, 17e4e <lfs_ctz_traverse.part.0+0x7a>
        int count = 2 - (index & 1);
   17e04:	f005 0701 	and.w	r7, r5, #1
   17e08:	f1c7 0402 	rsb	r4, r7, #2
        err = lfs_bd_read(lfs,
   17e0c:	a906      	add	r1, sp, #24
   17e0e:	00a3      	lsls	r3, r4, #2
   17e10:	e9cd 0101 	strd	r0, r1, [sp, #4]
   17e14:	9303      	str	r3, [sp, #12]
   17e16:	f8cd a000 	str.w	sl, [sp]
   17e1a:	464a      	mov	r2, r9
   17e1c:	4641      	mov	r1, r8
   17e1e:	4630      	mov	r0, r6
   17e20:	f7ff fe4c 	bl	17abc <lfs_bd_read.isra.0>
        if (err) {
   17e24:	b998      	cbnz	r0, 17e4e <lfs_ctz_traverse.part.0+0x7a>
        for (int i = 0; i < count-1; i++) {
   17e26:	3c01      	subs	r4, #1
   17e28:	4284      	cmp	r4, r0
   17e2a:	dc07      	bgt.n	17e3c <lfs_ctz_traverse.part.0+0x68>
        head = heads[count-1];
   17e2c:	ab08      	add	r3, sp, #32
   17e2e:	eb03 0484 	add.w	r4, r3, r4, lsl #2
        index -= count;
   17e32:	3f02      	subs	r7, #2
        head = heads[count-1];
   17e34:	f854 ac08 	ldr.w	sl, [r4, #-8]
        index -= count;
   17e38:	443d      	add	r5, r7
    while (true) {
   17e3a:	e7dd      	b.n	17df8 <lfs_ctz_traverse.part.0+0x24>
            err = cb(data, heads[i]);
   17e3c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17e3e:	9906      	ldr	r1, [sp, #24]
   17e40:	4658      	mov	r0, fp
   17e42:	4798      	blx	r3
   17e44:	4603      	mov	r3, r0
        for (int i = 0; i < count-1; i++) {
   17e46:	2001      	movs	r0, #1
            if (err) {
   17e48:	2b00      	cmp	r3, #0
   17e4a:	d0ed      	beq.n	17e28 <lfs_ctz_traverse.part.0+0x54>
            err = cb(data, heads[i]);
   17e4c:	4618      	mov	r0, r3
}
   17e4e:	b009      	add	sp, #36	; 0x24
   17e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00017e54 <lfs_ctz_find.constprop.0>:
static int lfs_ctz_find(lfs_t *lfs,
   17e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17e58:	b089      	sub	sp, #36	; 0x24
   17e5a:	4604      	mov	r4, r0
   17e5c:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
   17e60:	9205      	str	r2, [sp, #20]
   17e62:	4688      	mov	r8, r1
    if (size == 0) {
   17e64:	4618      	mov	r0, r3
   17e66:	b943      	cbnz	r3, 17e7a <lfs_ctz_find.constprop.0+0x26>
        *block = LFS_BLOCK_NULL;
   17e68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17e6c:	f8c9 3000 	str.w	r3, [r9]
        *off = 0;
   17e70:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17e72:	6018      	str	r0, [r3, #0]
}
   17e74:	b009      	add	sp, #36	; 0x24
   17e76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
   17e7a:	1e58      	subs	r0, r3, #1
   17e7c:	9007      	str	r0, [sp, #28]
   17e7e:	a907      	add	r1, sp, #28
   17e80:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   17e82:	f7ff ff8a 	bl	17d9a <lfs_ctz_index.isra.0>
    lfs_off_t target = lfs_ctz_index(lfs, &pos);
   17e86:	a912      	add	r1, sp, #72	; 0x48
    lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
   17e88:	4606      	mov	r6, r0
    lfs_off_t target = lfs_ctz_index(lfs, &pos);
   17e8a:	f854 0f68 	ldr.w	r0, [r4, #104]!
   17e8e:	f7ff ff84 	bl	17d9a <lfs_ctz_index.isra.0>
        int err = lfs_bd_read(lfs,
   17e92:	f04f 0a04 	mov.w	sl, #4
    lfs_off_t target = lfs_ctz_index(lfs, &pos);
   17e96:	4607      	mov	r7, r0
        int err = lfs_bd_read(lfs,
   17e98:	f10d 0b14 	add.w	fp, sp, #20
    while (current > target) {
   17e9c:	42b7      	cmp	r7, r6
   17e9e:	9a05      	ldr	r2, [sp, #20]
   17ea0:	d306      	bcc.n	17eb0 <lfs_ctz_find.constprop.0+0x5c>
    *block = head;
   17ea2:	f8c9 2000 	str.w	r2, [r9]
    *off = pos;
   17ea6:	9a14      	ldr	r2, [sp, #80]	; 0x50
   17ea8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17eaa:	6013      	str	r3, [r2, #0]
    return 0;
   17eac:	2000      	movs	r0, #0
   17eae:	e7e1      	b.n	17e74 <lfs_ctz_find.constprop.0+0x20>
                lfs_npw2(current-target+1) - 1,
   17eb0:	1bf5      	subs	r5, r6, r7
    return 32 - __builtin_clz(a-1);
   17eb2:	fab5 f585 	clz	r5, r5
    return __builtin_ctz(a);
   17eb6:	fa96 f3a6 	rbit	r3, r6
   17eba:	fab3 f383 	clz	r3, r3
        lfs_size_t skip = lfs_min(
   17ebe:	f1c5 051f 	rsb	r5, r5, #31
    return (a < b) ? a : b;
   17ec2:	429d      	cmp	r5, r3
   17ec4:	bf28      	it	cs
   17ec6:	461d      	movcs	r5, r3
        int err = lfs_bd_read(lfs,
   17ec8:	00ab      	lsls	r3, r5, #2
   17eca:	e9cd 2300 	strd	r2, r3, [sp]
   17ece:	e9cd ba02 	strd	fp, sl, [sp, #8]
   17ed2:	2304      	movs	r3, #4
   17ed4:	4642      	mov	r2, r8
   17ed6:	2100      	movs	r1, #0
   17ed8:	4620      	mov	r0, r4
   17eda:	f7ff fdef 	bl	17abc <lfs_bd_read.isra.0>
        if (err) {
   17ede:	2800      	cmp	r0, #0
   17ee0:	d1c8      	bne.n	17e74 <lfs_ctz_find.constprop.0+0x20>
        current -= 1 << skip;
   17ee2:	2301      	movs	r3, #1
   17ee4:	fa03 f505 	lsl.w	r5, r3, r5
   17ee8:	1b76      	subs	r6, r6, r5
   17eea:	e7d7      	b.n	17e9c <lfs_ctz_find.constprop.0+0x48>

00017eec <lfs_bd_cmp.constprop.0>:
static int lfs_bd_cmp(lfs_t *lfs,
   17eec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17ef0:	b087      	sub	sp, #28
   17ef2:	4698      	mov	r8, r3
   17ef4:	e9dd 5311 	ldrd	r5, r3, [sp, #68]	; 0x44
   17ef8:	460e      	mov	r6, r1
   17efa:	18ef      	adds	r7, r5, r3
            return (dat < data[i]) ? LFS_CMP_LT : LFS_CMP_GT;
   17efc:	462c      	mov	r4, r5
        int err = lfs_bd_read(lfs,
   17efe:	eb05 0902 	add.w	r9, r5, r2
   17f02:	f100 0a68 	add.w	sl, r0, #104	; 0x68
   17f06:	f04f 0b01 	mov.w	fp, #1
    for (lfs_off_t i = 0; i < size; i++) {
   17f0a:	42bc      	cmp	r4, r7
   17f0c:	d101      	bne.n	17f12 <lfs_bd_cmp.constprop.0+0x26>
    return LFS_CMP_EQ;
   17f0e:	2000      	movs	r0, #0
   17f10:	e01a      	b.n	17f48 <lfs_bd_cmp.constprop.0+0x5c>
        int err = lfs_bd_read(lfs,
   17f12:	f10d 0317 	add.w	r3, sp, #23
   17f16:	9302      	str	r3, [sp, #8]
   17f18:	9b10      	ldr	r3, [sp, #64]	; 0x40
   17f1a:	f8cd b00c 	str.w	fp, [sp, #12]
   17f1e:	1b5b      	subs	r3, r3, r5
   17f20:	4423      	add	r3, r4
   17f22:	e9cd 8300 	strd	r8, r3, [sp]
   17f26:	4632      	mov	r2, r6
   17f28:	eba9 0304 	sub.w	r3, r9, r4
   17f2c:	2100      	movs	r1, #0
   17f2e:	4650      	mov	r0, sl
   17f30:	f7ff fdc4 	bl	17abc <lfs_bd_read.isra.0>
        if (err) {
   17f34:	b940      	cbnz	r0, 17f48 <lfs_bd_cmp.constprop.0+0x5c>
        if (dat != data[i]) {
   17f36:	f814 2b01 	ldrb.w	r2, [r4], #1
   17f3a:	f89d 3017 	ldrb.w	r3, [sp, #23]
   17f3e:	429a      	cmp	r2, r3
   17f40:	d0e3      	beq.n	17f0a <lfs_bd_cmp.constprop.0+0x1e>
            return (dat < data[i]) ? LFS_CMP_LT : LFS_CMP_GT;
   17f42:	bf94      	ite	ls
   17f44:	2002      	movls	r0, #2
   17f46:	2001      	movhi	r0, #1
}
   17f48:	b007      	add	sp, #28
   17f4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00017f4e <lfs_bd_flush>:
        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
   17f4e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   17f52:	460e      	mov	r6, r1
    if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {
   17f54:	6809      	ldr	r1, [r1, #0]
        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
   17f56:	4699      	mov	r9, r3
    if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {
   17f58:	1ccb      	adds	r3, r1, #3
        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
   17f5a:	b085      	sub	sp, #20
   17f5c:	4607      	mov	r7, r0
   17f5e:	4690      	mov	r8, r2
    if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {
   17f60:	d830      	bhi.n	17fc4 <lfs_bd_flush+0x76>
        lfs_size_t diff = lfs_alignup(pcache->size, lfs->cfg->prog_size);
   17f62:	6e80      	ldr	r0, [r0, #104]	; 0x68
    return lfs_aligndown(a + alignment-1, alignment);
   17f64:	68b4      	ldr	r4, [r6, #8]
   17f66:	6982      	ldr	r2, [r0, #24]
   17f68:	4414      	add	r4, r2
   17f6a:	3c01      	subs	r4, #1
    return a - (a % alignment);
   17f6c:	fbb4 f3f2 	udiv	r3, r4, r2
   17f70:	fb02 4313 	mls	r3, r2, r3, r4
   17f74:	1ae4      	subs	r4, r4, r3
        int err = lfs->cfg->prog(lfs->cfg, pcache->block,
   17f76:	9400      	str	r4, [sp, #0]
   17f78:	6885      	ldr	r5, [r0, #8]
   17f7a:	68f3      	ldr	r3, [r6, #12]
   17f7c:	6872      	ldr	r2, [r6, #4]
   17f7e:	47a8      	blx	r5
        if (err) {
   17f80:	4605      	mov	r5, r0
   17f82:	b930      	cbnz	r0, 17f92 <lfs_bd_flush+0x44>
        if (validate) {
   17f84:	f1b9 0f00 	cmp.w	r9, #0
   17f88:	d107      	bne.n	17f9a <lfs_bd_flush+0x4c>
        lfs_cache_zero(lfs, pcache);
   17f8a:	6eb8      	ldr	r0, [r7, #104]	; 0x68
   17f8c:	4631      	mov	r1, r6
   17f8e:	f7ff fe9f 	bl	17cd0 <lfs_cache_zero.isra.0>
}
   17f92:	4628      	mov	r0, r5
   17f94:	b005      	add	sp, #20
   17f96:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    rcache->block = LFS_BLOCK_NULL;
   17f9a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17f9e:	f8c8 3000 	str.w	r3, [r8]
            int res = lfs_bd_cmp(lfs,
   17fa2:	68f3      	ldr	r3, [r6, #12]
   17fa4:	9301      	str	r3, [sp, #4]
   17fa6:	6873      	ldr	r3, [r6, #4]
   17fa8:	9300      	str	r3, [sp, #0]
   17faa:	9402      	str	r4, [sp, #8]
   17fac:	6833      	ldr	r3, [r6, #0]
   17fae:	4622      	mov	r2, r4
   17fb0:	4641      	mov	r1, r8
   17fb2:	4638      	mov	r0, r7
   17fb4:	f7ff ff9a 	bl	17eec <lfs_bd_cmp.constprop.0>
            if (res < 0) {
   17fb8:	2800      	cmp	r0, #0
   17fba:	db05      	blt.n	17fc8 <lfs_bd_flush+0x7a>
            if (res != LFS_CMP_EQ) {
   17fbc:	d0e5      	beq.n	17f8a <lfs_bd_flush+0x3c>
                return LFS_ERR_CORRUPT;
   17fbe:	f06f 0553 	mvn.w	r5, #83	; 0x53
   17fc2:	e7e6      	b.n	17f92 <lfs_bd_flush+0x44>
    return 0;
   17fc4:	2500      	movs	r5, #0
   17fc6:	e7e4      	b.n	17f92 <lfs_bd_flush+0x44>
   17fc8:	4605      	mov	r5, r0
   17fca:	e7e2      	b.n	17f92 <lfs_bd_flush+0x44>

00017fcc <lfs_bd_prog>:
        const void *buffer, lfs_size_t size) {
   17fcc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17fd0:	e9dd 5a0d 	ldrd	r5, sl, [sp, #52]	; 0x34
   17fd4:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   17fd6:	4607      	mov	r7, r0
   17fd8:	460c      	mov	r4, r1
   17fda:	4690      	mov	r8, r2
   17fdc:	4699      	mov	r9, r3
        pcache->size = 0;
   17fde:	f04f 0b00 	mov.w	fp, #0
    while (size > 0) {
   17fe2:	b90e      	cbnz	r6, 17fe8 <lfs_bd_prog+0x1c>
    return 0;
   17fe4:	4630      	mov	r0, r6
   17fe6:	e02e      	b.n	18046 <lfs_bd_prog+0x7a>
        if (block == pcache->block &&
   17fe8:	6822      	ldr	r2, [r4, #0]
   17fea:	990c      	ldr	r1, [sp, #48]	; 0x30
   17fec:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   17fee:	428a      	cmp	r2, r1
   17ff0:	d12c      	bne.n	1804c <lfs_bd_prog+0x80>
                off >= pcache->off &&
   17ff2:	6860      	ldr	r0, [r4, #4]
        if (block == pcache->block &&
   17ff4:	42a8      	cmp	r0, r5
   17ff6:	d829      	bhi.n	1804c <lfs_bd_prog+0x80>
                off < pcache->off + lfs->cfg->cache_size) {
   17ff8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   17ffa:	4402      	add	r2, r0
                off >= pcache->off &&
   17ffc:	42aa      	cmp	r2, r5
   17ffe:	d925      	bls.n	1804c <lfs_bd_prog+0x80>
            lfs_size_t diff = lfs_min(size,
   18000:	1b52      	subs	r2, r2, r5
            memcpy(&pcache->buffer[off-pcache->off], data, diff);
   18002:	68e3      	ldr	r3, [r4, #12]
    return (a < b) ? a : b;
   18004:	42b2      	cmp	r2, r6
   18006:	eba5 0000 	sub.w	r0, r5, r0
   1800a:	bf28      	it	cs
   1800c:	4632      	movcs	r2, r6
   1800e:	4651      	mov	r1, sl
   18010:	4418      	add	r0, r3
   18012:	9201      	str	r2, [sp, #4]
   18014:	f7fe f811 	bl	1603a <memcpy>
            data += diff;
   18018:	9a01      	ldr	r2, [sp, #4]
            pcache->size = lfs_max(pcache->size, off - pcache->off);
   1801a:	6863      	ldr	r3, [r4, #4]
            off += diff;
   1801c:	4415      	add	r5, r2
            data += diff;
   1801e:	4492      	add	sl, r2
            size -= diff;
   18020:	1ab6      	subs	r6, r6, r2
    return (a > b) ? a : b;
   18022:	68a2      	ldr	r2, [r4, #8]
            pcache->size = lfs_max(pcache->size, off - pcache->off);
   18024:	1aeb      	subs	r3, r5, r3
   18026:	4293      	cmp	r3, r2
   18028:	bf38      	it	cc
   1802a:	4613      	movcc	r3, r2
            if (pcache->size == lfs->cfg->cache_size) {
   1802c:	6eba      	ldr	r2, [r7, #104]	; 0x68
            pcache->size = lfs_max(pcache->size, off - pcache->off);
   1802e:	60a3      	str	r3, [r4, #8]
            if (pcache->size == lfs->cfg->cache_size) {
   18030:	6a92      	ldr	r2, [r2, #40]	; 0x28
   18032:	429a      	cmp	r2, r3
   18034:	d1d5      	bne.n	17fe2 <lfs_bd_prog+0x16>
                int err = lfs_bd_flush(lfs, pcache, rcache, validate);
   18036:	464b      	mov	r3, r9
   18038:	4642      	mov	r2, r8
   1803a:	4621      	mov	r1, r4
   1803c:	4638      	mov	r0, r7
   1803e:	f7ff ff86 	bl	17f4e <lfs_bd_flush>
                if (err) {
   18042:	2800      	cmp	r0, #0
   18044:	d0cd      	beq.n	17fe2 <lfs_bd_prog+0x16>
}
   18046:	b003      	add	sp, #12
   18048:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pcache->block = block;
   1804c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1804e:	6022      	str	r2, [r4, #0]
    return a - (a % alignment);
   18050:	699a      	ldr	r2, [r3, #24]
   18052:	fbb5 f3f2 	udiv	r3, r5, r2
   18056:	fb02 5313 	mls	r3, r2, r3, r5
   1805a:	1aeb      	subs	r3, r5, r3
        pcache->size = 0;
   1805c:	e9c4 3b01 	strd	r3, fp, [r4, #4]
   18060:	e7bf      	b.n	17fe2 <lfs_bd_prog+0x16>

00018062 <lfs_dir_commitprog>:
        const void *buffer, lfs_size_t size) {
   18062:	b5f0      	push	{r4, r5, r6, r7, lr}
   18064:	b085      	sub	sp, #20
    int err = lfs_bd_prog(lfs,
   18066:	e9cd 2302 	strd	r2, r3, [sp, #8]
        const void *buffer, lfs_size_t size) {
   1806a:	461d      	mov	r5, r3
    int err = lfs_bd_prog(lfs,
   1806c:	684b      	ldr	r3, [r1, #4]
   1806e:	9301      	str	r3, [sp, #4]
   18070:	680b      	ldr	r3, [r1, #0]
   18072:	9300      	str	r3, [sp, #0]
        const void *buffer, lfs_size_t size) {
   18074:	460c      	mov	r4, r1
   18076:	4617      	mov	r7, r2
    int err = lfs_bd_prog(lfs,
   18078:	2300      	movs	r3, #0
   1807a:	4602      	mov	r2, r0
   1807c:	f100 0110 	add.w	r1, r0, #16
   18080:	f7ff ffa4 	bl	17fcc <lfs_bd_prog>
    if (err) {
   18084:	4606      	mov	r6, r0
   18086:	b940      	cbnz	r0, 1809a <lfs_dir_commitprog+0x38>
    commit->crc = lfs_crc(commit->crc, buffer, size);
   18088:	68e0      	ldr	r0, [r4, #12]
   1808a:	462a      	mov	r2, r5
   1808c:	4639      	mov	r1, r7
   1808e:	f7fb fabb 	bl	13608 <lfs_crc>
    commit->off += size;
   18092:	6863      	ldr	r3, [r4, #4]
    commit->crc = lfs_crc(commit->crc, buffer, size);
   18094:	60e0      	str	r0, [r4, #12]
    commit->off += size;
   18096:	442b      	add	r3, r5
   18098:	6063      	str	r3, [r4, #4]
}
   1809a:	4630      	mov	r0, r6
   1809c:	b005      	add	sp, #20
   1809e:	bdf0      	pop	{r4, r5, r6, r7, pc}

000180a0 <lfs_dir_commitattr>:
        lfs_tag_t tag, const void *buffer) {
   180a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   180a4:	4606      	mov	r6, r0
   180a6:	b089      	sub	sp, #36	; 0x24
    lfs_size_t dsize = lfs_tag_dsize(tag);
   180a8:	4610      	mov	r0, r2
        lfs_tag_t tag, const void *buffer) {
   180aa:	4690      	mov	r8, r2
   180ac:	4699      	mov	r9, r3
   180ae:	460c      	mov	r4, r1
    lfs_size_t dsize = lfs_tag_dsize(tag);
   180b0:	f7ff fc91 	bl	179d6 <lfs_tag_dsize>
    if (commit->off + dsize > commit->end) {
   180b4:	684b      	ldr	r3, [r1, #4]
   180b6:	694a      	ldr	r2, [r1, #20]
   180b8:	4403      	add	r3, r0
   180ba:	4293      	cmp	r3, r2
    lfs_size_t dsize = lfs_tag_dsize(tag);
   180bc:	4607      	mov	r7, r0
    if (commit->off + dsize > commit->end) {
   180be:	d847      	bhi.n	18150 <lfs_dir_commitattr+0xb0>
    lfs_tag_t ntag = lfs_tobe32((tag & 0x7fffffff) ^ commit->ptag);
   180c0:	688b      	ldr	r3, [r1, #8]
   180c2:	f028 4a00 	bic.w	sl, r8, #2147483648	; 0x80000000
   180c6:	ea8a 0303 	eor.w	r3, sl, r3
    return __builtin_bswap32(a);
   180ca:	ba1b      	rev	r3, r3
   180cc:	9307      	str	r3, [sp, #28]
    int err = lfs_dir_commitprog(lfs, commit, &ntag, sizeof(ntag));
   180ce:	aa07      	add	r2, sp, #28
   180d0:	2304      	movs	r3, #4
   180d2:	4630      	mov	r0, r6
   180d4:	f7ff ffc5 	bl	18062 <lfs_dir_commitprog>
    if (err) {
   180d8:	4605      	mov	r5, r0
   180da:	b960      	cbnz	r0, 180f6 <lfs_dir_commitattr+0x56>
    if (!(tag & 0x80000000)) {
   180dc:	f1b8 0f00 	cmp.w	r8, #0
   180e0:	f1a7 0304 	sub.w	r3, r7, #4
   180e4:	db0b      	blt.n	180fe <lfs_dir_commitattr+0x5e>
        err = lfs_dir_commitprog(lfs, commit, buffer, dsize-sizeof(tag));
   180e6:	464a      	mov	r2, r9
   180e8:	4621      	mov	r1, r4
   180ea:	4630      	mov	r0, r6
   180ec:	f7ff ffb9 	bl	18062 <lfs_dir_commitprog>
        if (err) {
   180f0:	bb60      	cbnz	r0, 1814c <lfs_dir_commitattr+0xac>
    commit->ptag = tag & 0x7fffffff;
   180f2:	f8c4 a008 	str.w	sl, [r4, #8]
}
   180f6:	4628      	mov	r0, r5
   180f8:	b009      	add	sp, #36	; 0x24
   180fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            err = lfs_bd_read(lfs,
   180fe:	f106 0368 	add.w	r3, r6, #104	; 0x68
   18102:	46b8      	mov	r8, r7
   18104:	9305      	str	r3, [sp, #20]
   18106:	f10d 0b1b 	add.w	fp, sp, #27
        for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {
   1810a:	f1b8 0f04 	cmp.w	r8, #4
   1810e:	eba7 0308 	sub.w	r3, r7, r8
   18112:	d0ee      	beq.n	180f2 <lfs_dir_commitattr+0x52>
            err = lfs_bd_read(lfs,
   18114:	2201      	movs	r2, #1
   18116:	e9cd b202 	strd	fp, r2, [sp, #8]
   1811a:	f8d9 2004 	ldr.w	r2, [r9, #4]
   1811e:	9805      	ldr	r0, [sp, #20]
   18120:	4413      	add	r3, r2
   18122:	9301      	str	r3, [sp, #4]
   18124:	f8d9 3000 	ldr.w	r3, [r9]
   18128:	9300      	str	r3, [sp, #0]
   1812a:	4632      	mov	r2, r6
   1812c:	f1a8 0304 	sub.w	r3, r8, #4
   18130:	2100      	movs	r1, #0
   18132:	f7ff fcc3 	bl	17abc <lfs_bd_read.isra.0>
            if (err) {
   18136:	b948      	cbnz	r0, 1814c <lfs_dir_commitattr+0xac>
            err = lfs_dir_commitprog(lfs, commit, &dat, 1);
   18138:	2301      	movs	r3, #1
   1813a:	465a      	mov	r2, fp
   1813c:	4621      	mov	r1, r4
   1813e:	4630      	mov	r0, r6
   18140:	f7ff ff8f 	bl	18062 <lfs_dir_commitprog>
            if (err) {
   18144:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   18148:	2800      	cmp	r0, #0
   1814a:	d0de      	beq.n	1810a <lfs_dir_commitattr+0x6a>
   1814c:	4605      	mov	r5, r0
   1814e:	e7d2      	b.n	180f6 <lfs_dir_commitattr+0x56>
        return LFS_ERR_NOSPC;
   18150:	f06f 051b 	mvn.w	r5, #27
   18154:	e7cf      	b.n	180f6 <lfs_dir_commitattr+0x56>

00018156 <lfs_dir_commit_commit>:
static int lfs_dir_commit_commit(void *p, lfs_tag_t tag, const void *buffer) {
   18156:	4613      	mov	r3, r2
    return lfs_dir_commitattr(commit->lfs, commit->commit, tag, buffer);
   18158:	460a      	mov	r2, r1
   1815a:	e9d0 0100 	ldrd	r0, r1, [r0]
   1815e:	f7ff bf9f 	b.w	180a0 <lfs_dir_commitattr>

00018162 <lfs_dir_commitcrc>:
static int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {
   18162:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18166:	b08d      	sub	sp, #52	; 0x34
    const lfs_off_t off1 = commit->off;
   18168:	684b      	ldr	r3, [r1, #4]
   1816a:	9304      	str	r3, [sp, #16]
    const uint32_t crc1 = commit->crc;
   1816c:	68cb      	ldr	r3, [r1, #12]
   1816e:	9306      	str	r3, [sp, #24]
    const lfs_off_t end = lfs_alignup(off1 + 2*sizeof(uint32_t),
   18170:	6e83      	ldr	r3, [r0, #104]	; 0x68
   18172:	699a      	ldr	r2, [r3, #24]
    return lfs_aligndown(a + alignment-1, alignment);
   18174:	9b04      	ldr	r3, [sp, #16]
   18176:	18d7      	adds	r7, r2, r3
   18178:	3707      	adds	r7, #7
    return a - (a % alignment);
   1817a:	fbb7 f3f2 	udiv	r3, r7, r2
   1817e:	fb02 7313 	mls	r3, r2, r3, r7
   18182:	1aff      	subs	r7, r7, r3
            noff = lfs_min(noff, end - 2*sizeof(uint32_t));
   18184:	f1a7 0308 	sub.w	r3, r7, #8
static int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {
   18188:	4680      	mov	r8, r0
   1818a:	460e      	mov	r6, r1
    return (a < b) ? a : b;
   1818c:	f240 3bfe 	movw	fp, #1022	; 0x3fe
            noff = lfs_min(noff, end - 2*sizeof(uint32_t));
   18190:	9305      	str	r3, [sp, #20]
    while (commit->off < end) {
   18192:	6875      	ldr	r5, [r6, #4]
   18194:	42bd      	cmp	r5, r7
   18196:	d325      	bcc.n	181e4 <lfs_dir_commitcrc+0x82>
    rcache->block = LFS_BLOCK_NULL;
   18198:	4641      	mov	r1, r8
   1819a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1819e:	f841 3b10 	str.w	r3, [r1], #16
    int err = lfs_bd_flush(lfs, pcache, rcache, validate);
   181a2:	4642      	mov	r2, r8
   181a4:	2300      	movs	r3, #0
   181a6:	4640      	mov	r0, r8
   181a8:	f7ff fed1 	bl	17f4e <lfs_bd_flush>
    if (err) {
   181ac:	4604      	mov	r4, r0
   181ae:	2800      	cmp	r0, #0
   181b0:	f040 80b3 	bne.w	1831a <lfs_dir_commitcrc+0x1b8>
    err = lfs->cfg->sync(lfs->cfg);
   181b4:	f8d8 0068 	ldr.w	r0, [r8, #104]	; 0x68
   181b8:	6903      	ldr	r3, [r0, #16]
   181ba:	4798      	blx	r3
    if (err) {
   181bc:	4604      	mov	r4, r0
   181be:	2800      	cmp	r0, #0
   181c0:	f040 80ab 	bne.w	1831a <lfs_dir_commitcrc+0x1b8>
    lfs_off_t noff = off1 + sizeof(uint32_t);
   181c4:	9b04      	ldr	r3, [sp, #16]
    lfs_off_t off = commit->begin;
   181c6:	6935      	ldr	r5, [r6, #16]
    lfs_off_t noff = off1 + sizeof(uint32_t);
   181c8:	f103 0a04 	add.w	sl, r3, #4
            err = lfs_bd_read(lfs,
   181cc:	f108 0368 	add.w	r3, r8, #104	; 0x68
   181d0:	9307      	str	r3, [sp, #28]
    while (off < end) {
   181d2:	42bd      	cmp	r5, r7
   181d4:	f080 80a1 	bcs.w	1831a <lfs_dir_commitcrc+0x1b8>
        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
   181d8:	f10a 0304 	add.w	r3, sl, #4
        uint32_t crc = 0xffffffff;
   181dc:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
   181e0:	9305      	str	r3, [sp, #20]
   181e2:	e07e      	b.n	182e2 <lfs_dir_commitcrc+0x180>
        lfs_off_t off = commit->off + sizeof(lfs_tag_t);
   181e4:	f105 0a04 	add.w	sl, r5, #4
        lfs_off_t noff = lfs_min(end - off, 0x3fe) + off;
   181e8:	eba7 050a 	sub.w	r5, r7, sl
   181ec:	455d      	cmp	r5, fp
   181ee:	bf94      	ite	ls
   181f0:	4455      	addls	r5, sl
   181f2:	eb0a 050b 	addhi.w	r5, sl, fp
        if (noff < end) {
   181f6:	42bd      	cmp	r5, r7
   181f8:	d203      	bcs.n	18202 <lfs_dir_commitcrc+0xa0>
   181fa:	9b05      	ldr	r3, [sp, #20]
   181fc:	429d      	cmp	r5, r3
   181fe:	bf28      	it	cs
   18200:	461d      	movcs	r5, r3
        lfs_tag_t tag = 0xffffffff;
   18202:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
        int err = lfs_bd_read(lfs,
   18206:	aa09      	add	r2, sp, #36	; 0x24
   18208:	e9cd 5201 	strd	r5, r2, [sp, #4]
        lfs_tag_t tag = 0xffffffff;
   1820c:	9309      	str	r3, [sp, #36]	; 0x24
        int err = lfs_bd_read(lfs,
   1820e:	6832      	ldr	r2, [r6, #0]
   18210:	9200      	str	r2, [sp, #0]
   18212:	2304      	movs	r3, #4
   18214:	9303      	str	r3, [sp, #12]
   18216:	4642      	mov	r2, r8
   18218:	2100      	movs	r1, #0
   1821a:	f108 0068 	add.w	r0, r8, #104	; 0x68
   1821e:	f7ff fc4d 	bl	17abc <lfs_bd_read.isra.0>
        if (err && err != LFS_ERR_CORRUPT) {
   18222:	4604      	mov	r4, r0
   18224:	b110      	cbz	r0, 1822c <lfs_dir_commitcrc+0xca>
   18226:	f110 0f54 	cmn.w	r0, #84	; 0x54
   1822a:	d176      	bne.n	1831a <lfs_dir_commitcrc+0x1b8>
    return __builtin_bswap32(a);
   1822c:	9b09      	ldr	r3, [sp, #36]	; 0x24
        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
   1822e:	68f0      	ldr	r0, [r6, #12]
   18230:	ba1b      	rev	r3, r3
        bool reset = ~lfs_frombe32(tag) >> 31;
   18232:	ea6f 0903 	mvn.w	r9, r3
   18236:	ea4f 73d9 	mov.w	r3, r9, lsr #31
        tag = LFS_MKTAG(LFS_TYPE_CRC + reset, 0x3ff, noff - off);
   1823a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
   1823e:	eba5 050a 	sub.w	r5, r5, sl
   18242:	ea45 5503 	orr.w	r5, r5, r3, lsl #20
   18246:	f445 257f 	orr.w	r5, r5, #1044480	; 0xff000
        footer[0] = lfs_tobe32(tag ^ commit->ptag);
   1824a:	68b3      	ldr	r3, [r6, #8]
        tag = LFS_MKTAG(LFS_TYPE_CRC + reset, 0x3ff, noff - off);
   1824c:	f445 6540 	orr.w	r5, r5, #3072	; 0xc00
        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
   18250:	ac0a      	add	r4, sp, #40	; 0x28
        tag = LFS_MKTAG(LFS_TYPE_CRC + reset, 0x3ff, noff - off);
   18252:	9509      	str	r5, [sp, #36]	; 0x24
        footer[0] = lfs_tobe32(tag ^ commit->ptag);
   18254:	405d      	eors	r5, r3
        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
   18256:	4621      	mov	r1, r4
   18258:	2204      	movs	r2, #4
   1825a:	ba2d      	rev	r5, r5
        footer[0] = lfs_tobe32(tag ^ commit->ptag);
   1825c:	950a      	str	r5, [sp, #40]	; 0x28
        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
   1825e:	f7fb f9d3 	bl	13608 <lfs_crc>
        err = lfs_bd_prog(lfs,
   18262:	2308      	movs	r3, #8
   18264:	e9cd 4302 	strd	r4, r3, [sp, #8]
   18268:	6873      	ldr	r3, [r6, #4]
   1826a:	9301      	str	r3, [sp, #4]
   1826c:	6833      	ldr	r3, [r6, #0]
        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
   1826e:	60f0      	str	r0, [r6, #12]
        footer[1] = lfs_tole32(commit->crc);
   18270:	900b      	str	r0, [sp, #44]	; 0x2c
        err = lfs_bd_prog(lfs,
   18272:	9300      	str	r3, [sp, #0]
   18274:	4642      	mov	r2, r8
   18276:	2300      	movs	r3, #0
   18278:	f108 0110 	add.w	r1, r8, #16
   1827c:	4640      	mov	r0, r8
   1827e:	f7ff fea5 	bl	17fcc <lfs_bd_prog>
        if (err) {
   18282:	4604      	mov	r4, r0
   18284:	2800      	cmp	r0, #0
   18286:	d148      	bne.n	1831a <lfs_dir_commitcrc+0x1b8>
        commit->off += sizeof(tag)+lfs_tag_size(tag);
   18288:	9b09      	ldr	r3, [sp, #36]	; 0x24
    return tag & 0x000003ff;
   1828a:	f3c3 0209 	ubfx	r2, r3, #0, #10
        commit->off += sizeof(tag)+lfs_tag_size(tag);
   1828e:	1d11      	adds	r1, r2, #4
        commit->ptag = tag ^ ((lfs_tag_t)reset << 31);
   18290:	f009 4900 	and.w	r9, r9, #2147483648	; 0x80000000
        commit->off += sizeof(tag)+lfs_tag_size(tag);
   18294:	6872      	ldr	r2, [r6, #4]
        commit->ptag = tag ^ ((lfs_tag_t)reset << 31);
   18296:	ea89 0303 	eor.w	r3, r9, r3
        commit->off += sizeof(tag)+lfs_tag_size(tag);
   1829a:	440a      	add	r2, r1
        commit->ptag = tag ^ ((lfs_tag_t)reset << 31);
   1829c:	60b3      	str	r3, [r6, #8]
        commit->crc = 0xffffffff; // reset crc for next "commit"
   1829e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
        commit->off += sizeof(tag)+lfs_tag_size(tag);
   182a2:	6072      	str	r2, [r6, #4]
        commit->crc = 0xffffffff; // reset crc for next "commit"
   182a4:	60f3      	str	r3, [r6, #12]
   182a6:	e774      	b.n	18192 <lfs_dir_commitcrc+0x30>
            if (i == off1 && crc != crc1) {
   182a8:	9b04      	ldr	r3, [sp, #16]
   182aa:	429d      	cmp	r5, r3
   182ac:	d102      	bne.n	182b4 <lfs_dir_commitcrc+0x152>
   182ae:	9b06      	ldr	r3, [sp, #24]
   182b0:	4599      	cmp	r9, r3
   182b2:	d12f      	bne.n	18314 <lfs_dir_commitcrc+0x1b2>
            err = lfs_bd_read(lfs,
   182b4:	2301      	movs	r3, #1
   182b6:	9303      	str	r3, [sp, #12]
   182b8:	6833      	ldr	r3, [r6, #0]
   182ba:	9300      	str	r3, [sp, #0]
   182bc:	9b05      	ldr	r3, [sp, #20]
   182be:	9807      	ldr	r0, [sp, #28]
   182c0:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
   182c4:	e9cd 5b01 	strd	r5, fp, [sp, #4]
   182c8:	1b5b      	subs	r3, r3, r5
   182ca:	4642      	mov	r2, r8
   182cc:	2100      	movs	r1, #0
   182ce:	f7ff fbf5 	bl	17abc <lfs_bd_read.isra.0>
            if (err) {
   182d2:	bb08      	cbnz	r0, 18318 <lfs_dir_commitcrc+0x1b6>
            crc = lfs_crc(crc, &dat, 1);
   182d4:	4648      	mov	r0, r9
   182d6:	2201      	movs	r2, #1
   182d8:	4659      	mov	r1, fp
   182da:	f7fb f995 	bl	13608 <lfs_crc>
        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
   182de:	3501      	adds	r5, #1
            crc = lfs_crc(crc, &dat, 1);
   182e0:	4681      	mov	r9, r0
        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
   182e2:	9b05      	ldr	r3, [sp, #20]
   182e4:	42ab      	cmp	r3, r5
   182e6:	d8df      	bhi.n	182a8 <lfs_dir_commitcrc+0x146>
        if (crc != 0) {
   182e8:	f1b9 0f00 	cmp.w	r9, #0
   182ec:	d119      	bne.n	18322 <lfs_dir_commitcrc+0x1c0>
        off = lfs_min(end - noff, 0x3fe) + noff;
   182ee:	eba7 050a 	sub.w	r5, r7, sl
   182f2:	f240 33fe 	movw	r3, #1022	; 0x3fe
   182f6:	429d      	cmp	r5, r3
   182f8:	bf94      	ite	ls
   182fa:	4455      	addls	r5, sl
   182fc:	eb0a 0503 	addhi.w	r5, sl, r3
        if (off < end) {
   18300:	42bd      	cmp	r5, r7
   18302:	d204      	bcs.n	1830e <lfs_dir_commitcrc+0x1ac>
            off = lfs_min(off, end - 2*sizeof(uint32_t));
   18304:	f1a7 0308 	sub.w	r3, r7, #8
    return (a < b) ? a : b;
   18308:	429d      	cmp	r5, r3
   1830a:	bf28      	it	cs
   1830c:	461d      	movcs	r5, r3
        noff = off + sizeof(uint32_t);
   1830e:	f105 0a04 	add.w	sl, r5, #4
   18312:	e75e      	b.n	181d2 <lfs_dir_commitcrc+0x70>
                return LFS_ERR_CORRUPT;
   18314:	f06f 0053 	mvn.w	r0, #83	; 0x53
   18318:	4604      	mov	r4, r0
}
   1831a:	4620      	mov	r0, r4
   1831c:	b00d      	add	sp, #52	; 0x34
   1831e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return LFS_ERR_CORRUPT;
   18322:	f06f 0453 	mvn.w	r4, #83	; 0x53
   18326:	e7f8      	b.n	1831a <lfs_dir_commitcrc+0x1b8>

00018328 <lfs_dir_find_match>:
        lfs_tag_t tag, const void *buffer) {
   18328:	b530      	push	{r4, r5, lr}
   1832a:	4613      	mov	r3, r2
   1832c:	6882      	ldr	r2, [r0, #8]
    return tag & 0x000003ff;
   1832e:	f3c1 0509 	ubfx	r5, r1, #0, #10
        lfs_tag_t tag, const void *buffer) {
   18332:	b085      	sub	sp, #20
   18334:	42aa      	cmp	r2, r5
   18336:	bf28      	it	cs
   18338:	462a      	movcs	r2, r5
    int res = lfs_bd_cmp(lfs,
   1833a:	9202      	str	r2, [sp, #8]
   1833c:	6841      	ldr	r1, [r0, #4]
   1833e:	9101      	str	r1, [sp, #4]
   18340:	6859      	ldr	r1, [r3, #4]
   18342:	9100      	str	r1, [sp, #0]
   18344:	6801      	ldr	r1, [r0, #0]
   18346:	681b      	ldr	r3, [r3, #0]
        lfs_tag_t tag, const void *buffer) {
   18348:	4604      	mov	r4, r0
    int res = lfs_bd_cmp(lfs,
   1834a:	4608      	mov	r0, r1
   1834c:	f7ff fdce 	bl	17eec <lfs_bd_cmp.constprop.0>
    if (res != LFS_CMP_EQ) {
   18350:	b928      	cbnz	r0, 1835e <lfs_dir_find_match+0x36>
    if (name->size != lfs_tag_size(tag)) {
   18352:	68a3      	ldr	r3, [r4, #8]
   18354:	42ab      	cmp	r3, r5
   18356:	d002      	beq.n	1835e <lfs_dir_find_match+0x36>
        return (name->size < lfs_tag_size(tag)) ? LFS_CMP_LT : LFS_CMP_GT;
   18358:	bf2c      	ite	cs
   1835a:	2002      	movcs	r0, #2
   1835c:	2001      	movcc	r0, #1
}
   1835e:	b005      	add	sp, #20
   18360:	bd30      	pop	{r4, r5, pc}

00018362 <lfs_dir_close>:
    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
   18362:	6a83      	ldr	r3, [r0, #40]	; 0x28
   18364:	f100 0228 	add.w	r2, r0, #40	; 0x28
   18368:	b11b      	cbz	r3, 18372 <lfs_dir_close+0x10>
        if (*p == (struct lfs_mlist*)dir) {
   1836a:	428b      	cmp	r3, r1
   1836c:	6818      	ldr	r0, [r3, #0]
   1836e:	d102      	bne.n	18376 <lfs_dir_close+0x14>
            *p = (*p)->next;
   18370:	6010      	str	r0, [r2, #0]
}
   18372:	2000      	movs	r0, #0
   18374:	4770      	bx	lr
    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
   18376:	461a      	mov	r2, r3
   18378:	4603      	mov	r3, r0
   1837a:	e7f5      	b.n	18368 <lfs_dir_close+0x6>

0001837c <lfs_file_tell>:
}
   1837c:	6b48      	ldr	r0, [r1, #52]	; 0x34
   1837e:	4770      	bx	lr

00018380 <lfs_file_size>:
    if (file->flags & LFS_F_WRITING) {
   18380:	e9d1 030b 	ldrd	r0, r3, [r1, #44]	; 0x2c
   18384:	039b      	lsls	r3, r3, #14
   18386:	d503      	bpl.n	18390 <lfs_file_size+0x10>
    return (a > b) ? a : b;
   18388:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   1838a:	4298      	cmp	r0, r3
   1838c:	bf38      	it	cc
   1838e:	4618      	movcc	r0, r3
}
   18390:	4770      	bx	lr

00018392 <lfs_stat>:
int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
   18392:	b530      	push	{r4, r5, lr}
   18394:	b08b      	sub	sp, #44	; 0x2c
   18396:	4615      	mov	r5, r2
   18398:	9101      	str	r1, [sp, #4]
    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
   1839a:	2300      	movs	r3, #0
   1839c:	aa01      	add	r2, sp, #4
   1839e:	a902      	add	r1, sp, #8
int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
   183a0:	4604      	mov	r4, r0
    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
   183a2:	f7f9 fb5f 	bl	11a64 <lfs_dir_find>
    if (tag < 0) {
   183a6:	2800      	cmp	r0, #0
   183a8:	db06      	blt.n	183b8 <lfs_stat+0x26>
    int err = lfs_dir_getinfo(lfs, &cwd, lfs_tag_id(tag), info);
   183aa:	f3c0 2289 	ubfx	r2, r0, #10, #10
   183ae:	462b      	mov	r3, r5
   183b0:	a902      	add	r1, sp, #8
   183b2:	4620      	mov	r0, r4
   183b4:	f7f9 fbfc 	bl	11bb0 <lfs_dir_getinfo>
}
   183b8:	b00b      	add	sp, #44	; 0x2c
   183ba:	bd30      	pop	{r4, r5, pc}

000183bc <lfs_unmount>:
    int err = lfs_deinit(lfs);
   183bc:	f7ff bb5b 	b.w	17a76 <lfs_deinit>

000183c0 <lfs_dir_alloc>:
static int lfs_dir_alloc(lfs_t *lfs, lfs_mdir_t *dir) {
   183c0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   183c2:	460c      	mov	r4, r1
        int err = lfs_alloc(lfs, &dir->pair[(i+1)%2]);
   183c4:	3104      	adds	r1, #4
static int lfs_dir_alloc(lfs_t *lfs, lfs_mdir_t *dir) {
   183c6:	4606      	mov	r6, r0
        int err = lfs_alloc(lfs, &dir->pair[(i+1)%2]);
   183c8:	f7f9 fec6 	bl	12158 <lfs_alloc>
        if (err) {
   183cc:	4605      	mov	r5, r0
   183ce:	bb30      	cbnz	r0, 1841e <lfs_dir_alloc+0x5e>
        int err = lfs_alloc(lfs, &dir->pair[(i+1)%2]);
   183d0:	4621      	mov	r1, r4
   183d2:	4630      	mov	r0, r6
   183d4:	f7f9 fec0 	bl	12158 <lfs_alloc>
        if (err) {
   183d8:	4605      	mov	r5, r0
   183da:	bb00      	cbnz	r0, 1841e <lfs_dir_alloc+0x5e>
    dir->rev = 0;
   183dc:	4622      	mov	r2, r4
    int err = lfs_bd_read(lfs,
   183de:	2304      	movs	r3, #4
    dir->rev = 0;
   183e0:	f842 0f08 	str.w	r0, [r2, #8]!
    int err = lfs_bd_read(lfs,
   183e4:	e9cd 2302 	strd	r2, r3, [sp, #8]
   183e8:	6822      	ldr	r2, [r4, #0]
   183ea:	9001      	str	r0, [sp, #4]
   183ec:	9200      	str	r2, [sp, #0]
   183ee:	4601      	mov	r1, r0
   183f0:	4632      	mov	r2, r6
   183f2:	f106 0068 	add.w	r0, r6, #104	; 0x68
   183f6:	f7ff fb61 	bl	17abc <lfs_bd_read.isra.0>
    if (err && err != LFS_ERR_CORRUPT) {
   183fa:	b110      	cbz	r0, 18402 <lfs_dir_alloc+0x42>
   183fc:	f110 0f54 	cmn.w	r0, #84	; 0x54
   18400:	d110      	bne.n	18424 <lfs_dir_alloc+0x64>
    dir->rev += dir->rev & 1;
   18402:	68a3      	ldr	r3, [r4, #8]
   18404:	3301      	adds	r3, #1
   18406:	f023 0301 	bic.w	r3, r3, #1
    dir->etag = 0xffffffff;
   1840a:	2204      	movs	r2, #4
    dir->rev += dir->rev & 1;
   1840c:	60a3      	str	r3, [r4, #8]
    dir->etag = 0xffffffff;
   1840e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   18412:	e9c4 2303 	strd	r2, r3, [r4, #12]
    dir->count = 0;
   18416:	2200      	movs	r2, #0
    dir->tail[0] = LFS_BLOCK_NULL;
   18418:	e9c4 2305 	strd	r2, r3, [r4, #20]
    dir->tail[1] = LFS_BLOCK_NULL;
   1841c:	61e3      	str	r3, [r4, #28]
}
   1841e:	4628      	mov	r0, r5
   18420:	b004      	add	sp, #16
   18422:	bd70      	pop	{r4, r5, r6, pc}
   18424:	4605      	mov	r5, r0
   18426:	e7fa      	b.n	1841e <lfs_dir_alloc+0x5e>

00018428 <lfs_file_write>:
        const void *buffer, lfs_size_t size) {
   18428:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1842c:	b091      	sub	sp, #68	; 0x44
   1842e:	4606      	mov	r6, r0
   18430:	9306      	str	r3, [sp, #24]
    if (file->flags & LFS_F_READING) {
   18432:	6b0b      	ldr	r3, [r1, #48]	; 0x30
        const void *buffer, lfs_size_t size) {
   18434:	9208      	str	r2, [sp, #32]
    if (file->flags & LFS_F_READING) {
   18436:	035d      	lsls	r5, r3, #13
        const void *buffer, lfs_size_t size) {
   18438:	460c      	mov	r4, r1
    if (file->flags & LFS_F_READING) {
   1843a:	d41c      	bmi.n	18476 <lfs_file_write+0x4e>
    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
   1843c:	6b27      	ldr	r7, [r4, #48]	; 0x30
   1843e:	0539      	lsls	r1, r7, #20
   18440:	d422      	bmi.n	18488 <lfs_file_write+0x60>
    if (file->pos + size > lfs->file_max) {
   18442:	f8d4 8034 	ldr.w	r8, [r4, #52]	; 0x34
   18446:	9b06      	ldr	r3, [sp, #24]
   18448:	6f32      	ldr	r2, [r6, #112]	; 0x70
   1844a:	eb08 0103 	add.w	r1, r8, r3
   1844e:	4291      	cmp	r1, r2
   18450:	f200 815d 	bhi.w	1870e <lfs_file_write+0x2e6>
    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
   18454:	f417 3700 	ands.w	r7, r7, #131072	; 0x20000
   18458:	d01c      	beq.n	18494 <lfs_file_write+0x6c>
    if ((file->flags & LFS_F_INLINE) &&
   1845a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1845c:	02da      	lsls	r2, r3, #11
   1845e:	d42b      	bmi.n	184b8 <lfs_file_write+0x90>
            for (lfs_off_t i = 0; i < skips; i++) {
   18460:	9b06      	ldr	r3, [sp, #24]
   18462:	9305      	str	r3, [sp, #20]
    while (nsize > 0) {
   18464:	9a05      	ldr	r2, [sp, #20]
   18466:	6b23      	ldr	r3, [r4, #48]	; 0x30
   18468:	2a00      	cmp	r2, #0
   1846a:	d149      	bne.n	18500 <lfs_file_write+0xd8>
    file->flags &= ~LFS_F_ERRED;
   1846c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
    return size;
   18470:	9d06      	ldr	r5, [sp, #24]
    file->flags &= ~LFS_F_ERRED;
   18472:	6323      	str	r3, [r4, #48]	; 0x30
    return size;
   18474:	e004      	b.n	18480 <lfs_file_write+0x58>
        int err = lfs_file_flush(lfs, file);
   18476:	f7f9 ff7f 	bl	12378 <lfs_file_flush>
        if (err) {
   1847a:	4605      	mov	r5, r0
   1847c:	2800      	cmp	r0, #0
   1847e:	d0dd      	beq.n	1843c <lfs_file_write+0x14>
}
   18480:	4628      	mov	r0, r5
   18482:	b011      	add	sp, #68	; 0x44
   18484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
   18488:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1848a:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1848c:	428a      	cmp	r2, r1
        file->pos = file->ctz.size;
   1848e:	bf88      	it	hi
   18490:	6362      	strhi	r2, [r4, #52]	; 0x34
   18492:	e7d6      	b.n	18442 <lfs_file_write+0x1a>
    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
   18494:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   18496:	4598      	cmp	r8, r3
   18498:	d9df      	bls.n	1845a <lfs_file_write+0x32>
        file->pos = file->ctz.size;
   1849a:	6363      	str	r3, [r4, #52]	; 0x34
            lfs_ssize_t res = lfs_file_write(lfs, file, &(uint8_t){0}, 1);
   1849c:	2301      	movs	r3, #1
   1849e:	aa0f      	add	r2, sp, #60	; 0x3c
   184a0:	4621      	mov	r1, r4
   184a2:	4630      	mov	r0, r6
   184a4:	f88d 703c 	strb.w	r7, [sp, #60]	; 0x3c
   184a8:	f7ff ffbe 	bl	18428 <lfs_file_write>
            if (res < 0) {
   184ac:	1e05      	subs	r5, r0, #0
   184ae:	dbe7      	blt.n	18480 <lfs_file_write+0x58>
        while (file->pos < pos) {
   184b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   184b2:	4598      	cmp	r8, r3
   184b4:	d8f2      	bhi.n	1849c <lfs_file_write+0x74>
   184b6:	e7d0      	b.n	1845a <lfs_file_write+0x32>
            lfs_max(file->pos+nsize, file->ctz.size) >
   184b8:	9b06      	ldr	r3, [sp, #24]
   184ba:	6b65      	ldr	r5, [r4, #52]	; 0x34
                lfs->cfg->cache_size, lfs->cfg->block_size/8))) {
   184bc:	6eb2      	ldr	r2, [r6, #104]	; 0x68
            lfs_max(file->pos+nsize, file->ctz.size) >
   184be:	18e9      	adds	r1, r5, r3
   184c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    return (a < b) ? a : b;
   184c2:	6a90      	ldr	r0, [r2, #40]	; 0x28
    return (a > b) ? a : b;
   184c4:	4299      	cmp	r1, r3
   184c6:	bf38      	it	cc
   184c8:	4619      	movcc	r1, r3
    return (a < b) ? a : b;
   184ca:	f240 37fe 	movw	r7, #1022	; 0x3fe
            lfs_min(0x3fe, lfs_min(
   184ce:	69d3      	ldr	r3, [r2, #28]
   184d0:	42b8      	cmp	r0, r7
   184d2:	ea4f 03d3 	mov.w	r3, r3, lsr #3
   184d6:	bf28      	it	cs
   184d8:	4638      	movcs	r0, r7
   184da:	4283      	cmp	r3, r0
   184dc:	bf28      	it	cs
   184de:	4603      	movcs	r3, r0
    if ((file->flags & LFS_F_INLINE) &&
   184e0:	4299      	cmp	r1, r3
   184e2:	d9bd      	bls.n	18460 <lfs_file_write+0x38>
    lfs->free.ack = lfs->cfg->block_count;
   184e4:	6a13      	ldr	r3, [r2, #32]
    file->off = file->pos;
   184e6:	63e5      	str	r5, [r4, #60]	; 0x3c
    int err = lfs_file_relocate(lfs, file);
   184e8:	4621      	mov	r1, r4
    lfs->free.ack = lfs->cfg->block_count;
   184ea:	6633      	str	r3, [r6, #96]	; 0x60
    int err = lfs_file_relocate(lfs, file);
   184ec:	4630      	mov	r0, r6
   184ee:	f7f9 febd 	bl	1226c <lfs_file_relocate>
    if (err) {
   184f2:	6b23      	ldr	r3, [r4, #48]	; 0x30
   184f4:	4605      	mov	r5, r0
   184f6:	bb20      	cbnz	r0, 18542 <lfs_file_write+0x11a>
    file->flags &= ~LFS_F_INLINE;
   184f8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   184fc:	6323      	str	r3, [r4, #48]	; 0x30
        if (err) {
   184fe:	e7af      	b.n	18460 <lfs_file_write+0x38>
        if (!(file->flags & LFS_F_WRITING) ||
   18500:	f413 3100 	ands.w	r1, r3, #131072	; 0x20000
   18504:	d004      	beq.n	18510 <lfs_file_write+0xe8>
                file->off == lfs->cfg->block_size) {
   18506:	6eb2      	ldr	r2, [r6, #104]	; 0x68
        if (!(file->flags & LFS_F_WRITING) ||
   18508:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1850a:	69d2      	ldr	r2, [r2, #28]
   1850c:	4290      	cmp	r0, r2
   1850e:	d149      	bne.n	185a4 <lfs_file_write+0x17c>
            if (!(file->flags & LFS_F_INLINE)) {
   18510:	02db      	lsls	r3, r3, #11
   18512:	6b62      	ldr	r2, [r4, #52]	; 0x34
   18514:	f100 80e6 	bmi.w	186e4 <lfs_file_write+0x2bc>
   18518:	f104 0940 	add.w	r9, r4, #64	; 0x40
                if (!(file->flags & LFS_F_WRITING) && file->pos > 0) {
   1851c:	b9c9      	cbnz	r1, 18552 <lfs_file_write+0x12a>
   1851e:	b1c2      	cbz	r2, 18552 <lfs_file_write+0x12a>
                    int err = lfs_ctz_find(lfs, NULL, &file->cache,
   18520:	f104 033c 	add.w	r3, r4, #60	; 0x3c
   18524:	9302      	str	r3, [sp, #8]
   18526:	3a01      	subs	r2, #1
   18528:	f104 0338 	add.w	r3, r4, #56	; 0x38
   1852c:	9301      	str	r3, [sp, #4]
   1852e:	9200      	str	r2, [sp, #0]
   18530:	4649      	mov	r1, r9
   18532:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
   18536:	4630      	mov	r0, r6
   18538:	f7ff fc8c 	bl	17e54 <lfs_ctz_find.constprop.0>
                    if (err) {
   1853c:	4605      	mov	r5, r0
   1853e:	b120      	cbz	r0, 1854a <lfs_file_write+0x122>
                file->flags |= LFS_F_ERRED;
   18540:	6b23      	ldr	r3, [r4, #48]	; 0x30
   18542:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   18546:	6323      	str	r3, [r4, #48]	; 0x30
                return err;
   18548:	e79a      	b.n	18480 <lfs_file_write+0x58>
                    lfs_cache_zero(lfs, &file->cache);
   1854a:	6eb0      	ldr	r0, [r6, #104]	; 0x68
   1854c:	4649      	mov	r1, r9
   1854e:	f7ff fbbf 	bl	17cd0 <lfs_cache_zero.isra.0>
    lfs->free.ack = lfs->cfg->block_count;
   18552:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   18554:	6a1b      	ldr	r3, [r3, #32]
   18556:	6633      	str	r3, [r6, #96]	; 0x60
                int err = lfs_ctz_extend(lfs, &file->cache, &lfs->rcache,
   18558:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1855a:	9309      	str	r3, [sp, #36]	; 0x24
   1855c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1855e:	9307      	str	r3, [sp, #28]
            lfs_size_t noff = size - 1;
   18560:	3b01      	subs	r3, #1
   18562:	930b      	str	r3, [sp, #44]	; 0x2c
        int err = lfs_alloc(lfs, &nblock);
   18564:	a90d      	add	r1, sp, #52	; 0x34
   18566:	4630      	mov	r0, r6
   18568:	f7f9 fdf6 	bl	12158 <lfs_alloc>
        if (err) {
   1856c:	4605      	mov	r5, r0
   1856e:	2800      	cmp	r0, #0
   18570:	d1e6      	bne.n	18540 <lfs_file_write+0x118>
            err = lfs_bd_erase(lfs, nblock);
   18572:	6eb0      	ldr	r0, [r6, #104]	; 0x68
    int err = lfs->cfg->erase(lfs->cfg, block);
   18574:	990d      	ldr	r1, [sp, #52]	; 0x34
   18576:	68c3      	ldr	r3, [r0, #12]
   18578:	4798      	blx	r3
            if (err) {
   1857a:	4605      	mov	r5, r0
   1857c:	b130      	cbz	r0, 1858c <lfs_file_write+0x164>
                    if (err == LFS_ERR_CORRUPT) {
   1857e:	f115 0f54 	cmn.w	r5, #84	; 0x54
   18582:	d1dd      	bne.n	18540 <lfs_file_write+0x118>
    rcache->block = LFS_BLOCK_NULL;
   18584:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   18588:	6423      	str	r3, [r4, #64]	; 0x40
   1858a:	e7eb      	b.n	18564 <lfs_file_write+0x13c>
            if (size == 0) {
   1858c:	9b07      	ldr	r3, [sp, #28]
   1858e:	6eb0      	ldr	r0, [r6, #104]	; 0x68
   18590:	2b00      	cmp	r3, #0
   18592:	d12d      	bne.n	185f0 <lfs_file_write+0x1c8>
                *block = nblock;
   18594:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18596:	63a3      	str	r3, [r4, #56]	; 0x38
                *off = 0;
   18598:	9b07      	ldr	r3, [sp, #28]
                *off = noff;
   1859a:	63e3      	str	r3, [r4, #60]	; 0x3c
            file->flags |= LFS_F_WRITING;
   1859c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1859e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   185a2:	6323      	str	r3, [r4, #48]	; 0x30
        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
   185a4:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   185a6:	69df      	ldr	r7, [r3, #28]
   185a8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   185aa:	1aff      	subs	r7, r7, r3
   185ac:	9b05      	ldr	r3, [sp, #20]
   185ae:	429f      	cmp	r7, r3
   185b0:	bf28      	it	cs
   185b2:	461f      	movcs	r7, r3
            int err = lfs_bd_prog(lfs, &file->cache, &lfs->rcache, true,
   185b4:	f104 0840 	add.w	r8, r4, #64	; 0x40
   185b8:	9b08      	ldr	r3, [sp, #32]
   185ba:	9302      	str	r3, [sp, #8]
   185bc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   185be:	9301      	str	r3, [sp, #4]
   185c0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   185c2:	9300      	str	r3, [sp, #0]
   185c4:	9703      	str	r7, [sp, #12]
   185c6:	2301      	movs	r3, #1
   185c8:	4632      	mov	r2, r6
   185ca:	4641      	mov	r1, r8
   185cc:	4630      	mov	r0, r6
   185ce:	f7ff fcfd 	bl	17fcc <lfs_bd_prog>
            if (err) {
   185d2:	4605      	mov	r5, r0
   185d4:	2800      	cmp	r0, #0
   185d6:	f000 808a 	beq.w	186ee <lfs_file_write+0x2c6>
                if (err == LFS_ERR_CORRUPT) {
   185da:	f110 0f54 	cmn.w	r0, #84	; 0x54
   185de:	d1af      	bne.n	18540 <lfs_file_write+0x118>
            err = lfs_file_relocate(lfs, file);
   185e0:	4621      	mov	r1, r4
   185e2:	4630      	mov	r0, r6
   185e4:	f7f9 fe42 	bl	1226c <lfs_file_relocate>
            if (err) {
   185e8:	4605      	mov	r5, r0
   185ea:	2800      	cmp	r0, #0
   185ec:	d0e4      	beq.n	185b8 <lfs_file_write+0x190>
   185ee:	e7a7      	b.n	18540 <lfs_file_write+0x118>
            lfs_size_t noff = size - 1;
   185f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   185f2:	930e      	str	r3, [sp, #56]	; 0x38
            lfs_off_t index = lfs_ctz_index(lfs, &noff);
   185f4:	a90e      	add	r1, sp, #56	; 0x38
   185f6:	f7ff fbd0 	bl	17d9a <lfs_ctz_index.isra.0>
            if (noff != lfs->cfg->block_size) {
   185fa:	6eb2      	ldr	r2, [r6, #104]	; 0x68
            noff = noff + 1;
   185fc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
            if (noff != lfs->cfg->block_size) {
   185fe:	69d2      	ldr	r2, [r2, #28]
            noff = noff + 1;
   18600:	3301      	adds	r3, #1
            if (noff != lfs->cfg->block_size) {
   18602:	4293      	cmp	r3, r2
            noff = noff + 1;
   18604:	930e      	str	r3, [sp, #56]	; 0x38
            if (noff != lfs->cfg->block_size) {
   18606:	d153      	bne.n	186b0 <lfs_file_write+0x288>
            index += 1;
   18608:	1c47      	adds	r7, r0, #1
    return __builtin_ctz(a);
   1860a:	fa97 f7a7 	rbit	r7, r7
            lfs_block_t nhead = head;
   1860e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18610:	930f      	str	r3, [sp, #60]	; 0x3c
   18612:	fab7 f787 	clz	r7, r7
            lfs_size_t skips = lfs_ctz(index) + 1;
   18616:	f107 0a01 	add.w	sl, r7, #1
            for (lfs_off_t i = 0; i < skips; i++) {
   1861a:	46a8      	mov	r8, r5
                err = lfs_bd_prog(lfs, pcache, rcache, true,
   1861c:	f04f 0b04 	mov.w	fp, #4
   18620:	ea4f 0388 	mov.w	r3, r8, lsl #2
   18624:	930a      	str	r3, [sp, #40]	; 0x28
   18626:	ab0f      	add	r3, sp, #60	; 0x3c
   18628:	9302      	str	r3, [sp, #8]
   1862a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1862c:	9301      	str	r3, [sp, #4]
   1862e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18630:	9300      	str	r3, [sp, #0]
   18632:	f8cd b00c 	str.w	fp, [sp, #12]
   18636:	2301      	movs	r3, #1
   18638:	4632      	mov	r2, r6
   1863a:	4649      	mov	r1, r9
   1863c:	4630      	mov	r0, r6
   1863e:	f7ff fcc5 	bl	17fcc <lfs_bd_prog>
                if (err) {
   18642:	4605      	mov	r5, r0
   18644:	2800      	cmp	r0, #0
   18646:	d19a      	bne.n	1857e <lfs_file_write+0x156>
                if (i != skips-1) {
   18648:	4547      	cmp	r7, r8
   1864a:	d138      	bne.n	186be <lfs_file_write+0x296>
            for (lfs_off_t i = 0; i < skips; i++) {
   1864c:	f108 0801 	add.w	r8, r8, #1
   18650:	45c2      	cmp	sl, r8
   18652:	d8e5      	bhi.n	18620 <lfs_file_write+0x1f8>
            *block = nblock;
   18654:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18656:	63a3      	str	r3, [r4, #56]	; 0x38
            *off = 4*skips;
   18658:	ea4f 038a 	mov.w	r3, sl, lsl #2
   1865c:	e79d      	b.n	1859a <lfs_file_write+0x172>
                    err = lfs_bd_read(lfs,
   1865e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18660:	9200      	str	r2, [sp, #0]
   18662:	e9cd 7a02 	strd	r7, sl, [sp, #8]
   18666:	f8cd 8004 	str.w	r8, [sp, #4]
   1866a:	eba3 0308 	sub.w	r3, r3, r8
   1866e:	4632      	mov	r2, r6
   18670:	2100      	movs	r1, #0
   18672:	4658      	mov	r0, fp
   18674:	f7ff fa22 	bl	17abc <lfs_bd_read.isra.0>
                    if (err) {
   18678:	4605      	mov	r5, r0
   1867a:	2800      	cmp	r0, #0
   1867c:	f47f af60 	bne.w	18540 <lfs_file_write+0x118>
                    err = lfs_bd_prog(lfs,
   18680:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18682:	9300      	str	r3, [sp, #0]
   18684:	e9cd 7a02 	strd	r7, sl, [sp, #8]
   18688:	f8cd 8004 	str.w	r8, [sp, #4]
   1868c:	2301      	movs	r3, #1
   1868e:	4632      	mov	r2, r6
   18690:	4649      	mov	r1, r9
   18692:	4630      	mov	r0, r6
   18694:	f7ff fc9a 	bl	17fcc <lfs_bd_prog>
                    if (err) {
   18698:	4605      	mov	r5, r0
   1869a:	2800      	cmp	r0, #0
   1869c:	f47f af6f 	bne.w	1857e <lfs_file_write+0x156>
                for (lfs_off_t i = 0; i < noff; i++) {
   186a0:	f108 0801 	add.w	r8, r8, #1
   186a4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   186a6:	4543      	cmp	r3, r8
   186a8:	d8d9      	bhi.n	1865e <lfs_file_write+0x236>
                *block = nblock;
   186aa:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   186ac:	63a2      	str	r2, [r4, #56]	; 0x38
   186ae:	e774      	b.n	1859a <lfs_file_write+0x172>
                for (lfs_off_t i = 0; i < noff; i++) {
   186b0:	46a8      	mov	r8, r5
                    err = lfs_bd_read(lfs,
   186b2:	f106 0b68 	add.w	fp, r6, #104	; 0x68
   186b6:	f04f 0a01 	mov.w	sl, #1
   186ba:	af0f      	add	r7, sp, #60	; 0x3c
   186bc:	e7f2      	b.n	186a4 <lfs_file_write+0x27c>
                    err = lfs_bd_read(lfs,
   186be:	ab0f      	add	r3, sp, #60	; 0x3c
   186c0:	9302      	str	r3, [sp, #8]
   186c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   186c4:	9301      	str	r3, [sp, #4]
   186c6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   186c8:	9300      	str	r3, [sp, #0]
   186ca:	4601      	mov	r1, r0
   186cc:	f8cd b00c 	str.w	fp, [sp, #12]
   186d0:	2304      	movs	r3, #4
   186d2:	4632      	mov	r2, r6
   186d4:	f106 0068 	add.w	r0, r6, #104	; 0x68
   186d8:	f7ff f9f0 	bl	17abc <lfs_bd_read.isra.0>
                    if (err) {
   186dc:	4605      	mov	r5, r0
   186de:	2800      	cmp	r0, #0
   186e0:	d0b4      	beq.n	1864c <lfs_file_write+0x224>
   186e2:	e72d      	b.n	18540 <lfs_file_write+0x118>
                file->block = LFS_BLOCK_INLINE;
   186e4:	f06f 0301 	mvn.w	r3, #1
                file->off = file->pos;
   186e8:	e9c4 320e 	strd	r3, r2, [r4, #56]	; 0x38
   186ec:	e756      	b.n	1859c <lfs_file_write+0x174>
        file->pos += diff;
   186ee:	6b63      	ldr	r3, [r4, #52]	; 0x34
   186f0:	443b      	add	r3, r7
   186f2:	6363      	str	r3, [r4, #52]	; 0x34
        file->off += diff;
   186f4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   186f6:	443b      	add	r3, r7
   186f8:	63e3      	str	r3, [r4, #60]	; 0x3c
        data += diff;
   186fa:	9b08      	ldr	r3, [sp, #32]
   186fc:	443b      	add	r3, r7
   186fe:	9308      	str	r3, [sp, #32]
        nsize -= diff;
   18700:	9b05      	ldr	r3, [sp, #20]
   18702:	1bdb      	subs	r3, r3, r7
   18704:	9305      	str	r3, [sp, #20]
    lfs->free.ack = lfs->cfg->block_count;
   18706:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   18708:	6a1b      	ldr	r3, [r3, #32]
   1870a:	6633      	str	r3, [r6, #96]	; 0x60
}
   1870c:	e6aa      	b.n	18464 <lfs_file_write+0x3c>
        return LFS_ERR_FBIG;
   1870e:	f06f 051a 	mvn.w	r5, #26
   18712:	e6b5      	b.n	18480 <lfs_file_write+0x58>

00018714 <lfs_file_seek>:
        lfs_soff_t off, int whence) {
   18714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18716:	4606      	mov	r6, r0
   18718:	460c      	mov	r4, r1
   1871a:	4615      	mov	r5, r2
   1871c:	461f      	mov	r7, r3
    int err = lfs_file_flush(lfs, file);
   1871e:	f7f9 fe2b 	bl	12378 <lfs_file_flush>
    if (err) {
   18722:	b938      	cbnz	r0, 18734 <lfs_file_seek+0x20>
    if (whence == LFS_SEEK_SET) {
   18724:	b93f      	cbnz	r7, 18736 <lfs_file_seek+0x22>
        npos = off;
   18726:	4628      	mov	r0, r5
    if (npos > lfs->file_max) {
   18728:	6f33      	ldr	r3, [r6, #112]	; 0x70
   1872a:	4283      	cmp	r3, r0
    file->pos = npos;
   1872c:	bf2c      	ite	cs
   1872e:	6360      	strcs	r0, [r4, #52]	; 0x34
        return LFS_ERR_INVAL;
   18730:	f06f 0015 	mvncc.w	r0, #21
}
   18734:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if (whence == LFS_SEEK_CUR) {
   18736:	2f01      	cmp	r7, #1
    lfs_off_t npos = file->pos;
   18738:	6b60      	ldr	r0, [r4, #52]	; 0x34
    } else if (whence == LFS_SEEK_CUR) {
   1873a:	d101      	bne.n	18740 <lfs_file_seek+0x2c>
        npos = file->ctz.size + off;
   1873c:	4428      	add	r0, r5
   1873e:	e7f3      	b.n	18728 <lfs_file_seek+0x14>
    } else if (whence == LFS_SEEK_END) {
   18740:	2f02      	cmp	r7, #2
   18742:	d1f1      	bne.n	18728 <lfs_file_seek+0x14>
        npos = file->ctz.size + off;
   18744:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   18746:	e7f9      	b.n	1873c <lfs_file_seek+0x28>

00018748 <lfs_file_truncate>:
int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
   18748:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (size > LFS_FILE_MAX) {
   1874c:	1e16      	subs	r6, r2, #0
int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
   1874e:	b086      	sub	sp, #24
   18750:	4605      	mov	r5, r0
   18752:	460c      	mov	r4, r1
    if (size > LFS_FILE_MAX) {
   18754:	db46      	blt.n	187e4 <lfs_file_truncate+0x9c>
    lfs_off_t pos = file->pos;
   18756:	6b4f      	ldr	r7, [r1, #52]	; 0x34
    lfs_off_t oldsize = lfs_file_size(lfs, file);
   18758:	f7ff fe12 	bl	18380 <lfs_file_size>
    if (size < oldsize) {
   1875c:	4286      	cmp	r6, r0
   1875e:	d223      	bcs.n	187a8 <lfs_file_truncate+0x60>
        int err = lfs_file_flush(lfs, file);
   18760:	4628      	mov	r0, r5
   18762:	f7f9 fe09 	bl	12378 <lfs_file_flush>
        if (err) {
   18766:	2800      	cmp	r0, #0
   18768:	d139      	bne.n	187de <lfs_file_truncate+0x96>
        err = lfs_ctz_find(lfs, NULL, &file->cache,
   1876a:	f104 033c 	add.w	r3, r4, #60	; 0x3c
   1876e:	9302      	str	r3, [sp, #8]
   18770:	f104 0338 	add.w	r3, r4, #56	; 0x38
   18774:	e9cd 6300 	strd	r6, r3, [sp]
   18778:	f104 0140 	add.w	r1, r4, #64	; 0x40
   1877c:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
   18780:	4628      	mov	r0, r5
   18782:	f7ff fb67 	bl	17e54 <lfs_ctz_find.constprop.0>
        if (err) {
   18786:	bb50      	cbnz	r0, 187de <lfs_file_truncate+0x96>
        file->ctz.head = file->block;
   18788:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        file->ctz.size = size;
   1878a:	e9c4 360a 	strd	r3, r6, [r4, #40]	; 0x28
        file->flags |= LFS_F_DIRTY | LFS_F_READING;
   1878e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   18790:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
   18794:	6323      	str	r3, [r4, #48]	; 0x30
    lfs_soff_t res = lfs_file_seek(lfs, file, pos, LFS_SEEK_SET);
   18796:	2300      	movs	r3, #0
   18798:	463a      	mov	r2, r7
   1879a:	4621      	mov	r1, r4
   1879c:	4628      	mov	r0, r5
   1879e:	f7ff ffb9 	bl	18714 <lfs_file_seek>
    if (res < 0) {
   187a2:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   187a6:	e01a      	b.n	187de <lfs_file_truncate+0x96>
    } else if (size > oldsize) {
   187a8:	d9f5      	bls.n	18796 <lfs_file_truncate+0x4e>
        if (file->pos != oldsize) {
   187aa:	4287      	cmp	r7, r0
   187ac:	d110      	bne.n	187d0 <lfs_file_truncate+0x88>
            lfs_ssize_t res = lfs_file_write(lfs, file, &(uint8_t){0}, 1);
   187ae:	f04f 0800 	mov.w	r8, #0
        while (file->pos < size) {
   187b2:	6b63      	ldr	r3, [r4, #52]	; 0x34
   187b4:	42b3      	cmp	r3, r6
   187b6:	d2ee      	bcs.n	18796 <lfs_file_truncate+0x4e>
            lfs_ssize_t res = lfs_file_write(lfs, file, &(uint8_t){0}, 1);
   187b8:	2301      	movs	r3, #1
   187ba:	f10d 0217 	add.w	r2, sp, #23
   187be:	4621      	mov	r1, r4
   187c0:	4628      	mov	r0, r5
   187c2:	f88d 8017 	strb.w	r8, [sp, #23]
   187c6:	f7ff fe2f 	bl	18428 <lfs_file_write>
            if (res < 0) {
   187ca:	2800      	cmp	r0, #0
   187cc:	daf1      	bge.n	187b2 <lfs_file_truncate+0x6a>
   187ce:	e006      	b.n	187de <lfs_file_truncate+0x96>
            lfs_soff_t res = lfs_file_seek(lfs, file, 0, LFS_SEEK_END);
   187d0:	2302      	movs	r3, #2
   187d2:	2200      	movs	r2, #0
   187d4:	4628      	mov	r0, r5
   187d6:	f7ff ff9d 	bl	18714 <lfs_file_seek>
            if (res < 0) {
   187da:	2800      	cmp	r0, #0
   187dc:	dae7      	bge.n	187ae <lfs_file_truncate+0x66>
}
   187de:	b006      	add	sp, #24
   187e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LFS_ERR_INVAL;
   187e4:	f06f 0015 	mvn.w	r0, #21
   187e8:	e7f9      	b.n	187de <lfs_file_truncate+0x96>

000187ea <lfs_file_sync>:
int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
   187ea:	b570      	push	{r4, r5, r6, lr}
    if (file->flags & LFS_F_ERRED) {
   187ec:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   187ee:	031e      	lsls	r6, r3, #12
int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
   187f0:	b086      	sub	sp, #24
   187f2:	4605      	mov	r5, r0
   187f4:	460c      	mov	r4, r1
    if (file->flags & LFS_F_ERRED) {
   187f6:	d502      	bpl.n	187fe <lfs_file_sync+0x14>
        return 0;
   187f8:	2000      	movs	r0, #0
}
   187fa:	b006      	add	sp, #24
   187fc:	bd70      	pop	{r4, r5, r6, pc}
    int err = lfs_file_flush(lfs, file);
   187fe:	f7f9 fdbb 	bl	12378 <lfs_file_flush>
    if (err) {
   18802:	6b22      	ldr	r2, [r4, #48]	; 0x30
   18804:	b118      	cbz	r0, 1880e <lfs_file_sync+0x24>
        file->flags |= LFS_F_ERRED;
   18806:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   1880a:	6322      	str	r2, [r4, #48]	; 0x30
        return err;
   1880c:	e7f5      	b.n	187fa <lfs_file_sync+0x10>
    if ((file->flags & LFS_F_DIRTY) &&
   1880e:	03d1      	lsls	r1, r2, #15
   18810:	d5f2      	bpl.n	187f8 <lfs_file_sync+0xe>
            !lfs_pair_isnull(file->m.pair)) {
   18812:	f104 0608 	add.w	r6, r4, #8
   18816:	4630      	mov	r0, r6
   18818:	f7ff f8c2 	bl	179a0 <lfs_pair_isnull>
    if ((file->flags & LFS_F_DIRTY) &&
   1881c:	2800      	cmp	r0, #0
   1881e:	d1eb      	bne.n	187f8 <lfs_file_sync+0xe>
        if (file->flags & LFS_F_INLINE) {
   18820:	02d3      	lsls	r3, r2, #11
            ctz = file->ctz;
   18822:	bf5d      	ittte	pl
   18824:	e9d4 010a 	ldrdpl	r0, r1, [r4, #40]	; 0x28
   18828:	466b      	movpl	r3, sp
   1882a:	e9c3 0100 	strdpl	r0, r1, [r3]
            size = file->ctz.size;
   1882e:	6ae2      	ldrmi	r2, [r4, #44]	; 0x2c
        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
   18830:	88a1      	ldrh	r1, [r4, #4]
            buffer = file->cache.buffer;
   18832:	bf4b      	itete	mi
   18834:	6ce3      	ldrmi	r3, [r4, #76]	; 0x4c
            size = sizeof(ctz);
   18836:	2208      	movpl	r2, #8
            type = LFS_TYPE_INLINESTRUCT;
   18838:	f240 2001 	movwmi	r0, #513	; 0x201
            type = LFS_TYPE_CTZSTRUCT;
   1883c:	f240 2002 	movwpl	r0, #514	; 0x202
        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
   18840:	ea42 2281 	orr.w	r2, r2, r1, lsl #10
   18844:	ea42 5200 	orr.w	r2, r2, r0, lsl #20
   18848:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1884c:	6d22      	ldr	r2, [r4, #80]	; 0x50
   1884e:	6893      	ldr	r3, [r2, #8]
   18850:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
   18854:	f043 5381 	orr.w	r3, r3, #270532608	; 0x10200000
   18858:	9304      	str	r3, [sp, #16]
   1885a:	6853      	ldr	r3, [r2, #4]
   1885c:	9305      	str	r3, [sp, #20]
   1885e:	aa02      	add	r2, sp, #8
   18860:	2302      	movs	r3, #2
   18862:	4631      	mov	r1, r6
   18864:	4628      	mov	r0, r5
   18866:	f7fa f8d3 	bl	12a10 <lfs_dir_commit>
        if (err) {
   1886a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1886c:	b118      	cbz	r0, 18876 <lfs_file_sync+0x8c>
            file->flags |= LFS_F_ERRED;
   1886e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
        file->flags &= ~LFS_F_DIRTY;
   18872:	6323      	str	r3, [r4, #48]	; 0x30
   18874:	e7c1      	b.n	187fa <lfs_file_sync+0x10>
   18876:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   1887a:	e7fa      	b.n	18872 <lfs_file_sync+0x88>

0001887c <lfs_file_close>:
int lfs_file_close(lfs_t *lfs, lfs_file_t *file) {
   1887c:	b570      	push	{r4, r5, r6, lr}
   1887e:	4605      	mov	r5, r0
   18880:	460c      	mov	r4, r1
    int err = lfs_file_sync(lfs, file);
   18882:	f7ff ffb2 	bl	187ea <lfs_file_sync>
    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
   18886:	6aab      	ldr	r3, [r5, #40]	; 0x28
    int err = lfs_file_sync(lfs, file);
   18888:	4606      	mov	r6, r0
    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
   1888a:	f105 0228 	add.w	r2, r5, #40	; 0x28
   1888e:	b11b      	cbz	r3, 18898 <lfs_file_close+0x1c>
        if (*p == (struct lfs_mlist*)file) {
   18890:	42a3      	cmp	r3, r4
   18892:	6819      	ldr	r1, [r3, #0]
   18894:	d10c      	bne.n	188b0 <lfs_file_close+0x34>
            *p = (*p)->next;
   18896:	6011      	str	r1, [r2, #0]
    if (!file->cfg->buffer) {
   18898:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1889a:	681b      	ldr	r3, [r3, #0]
   1889c:	b913      	cbnz	r3, 188a4 <lfs_file_close+0x28>
    free(p);
   1889e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
   188a0:	f7fd fb6c 	bl	15f7c <free>
    file->flags &= ~LFS_F_OPENED;
   188a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   188a6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   188aa:	6323      	str	r3, [r4, #48]	; 0x30
}
   188ac:	4630      	mov	r0, r6
   188ae:	bd70      	pop	{r4, r5, r6, pc}
    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
   188b0:	461a      	mov	r2, r3
   188b2:	460b      	mov	r3, r1
   188b4:	e7eb      	b.n	1888e <lfs_file_close+0x12>

000188b6 <lfs_dir_split>:
        lfs_mdir_t *source, uint16_t split, uint16_t end) {
   188b6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   188ba:	4698      	mov	r8, r3
    lfs->free.ack = lfs->cfg->block_count;
   188bc:	6e83      	ldr	r3, [r0, #104]	; 0x68
        lfs_mdir_t *source, uint16_t split, uint16_t end) {
   188be:	b08d      	sub	sp, #52	; 0x34
    lfs->free.ack = lfs->cfg->block_count;
   188c0:	6a1b      	ldr	r3, [r3, #32]
   188c2:	6603      	str	r3, [r0, #96]	; 0x60
        lfs_mdir_t *source, uint16_t split, uint16_t end) {
   188c4:	460c      	mov	r4, r1
    int err = lfs_dir_alloc(lfs, &tail);
   188c6:	a904      	add	r1, sp, #16
        lfs_mdir_t *source, uint16_t split, uint16_t end) {
   188c8:	f8bd 9054 	ldrh.w	r9, [sp, #84]	; 0x54
   188cc:	4606      	mov	r6, r0
   188ce:	4617      	mov	r7, r2
    int err = lfs_dir_alloc(lfs, &tail);
   188d0:	f7ff fd76 	bl	183c0 <lfs_dir_alloc>
    if (err) {
   188d4:	4605      	mov	r5, r0
   188d6:	bb38      	cbnz	r0, 18928 <lfs_dir_split+0x72>
    tail.split = dir->split;
   188d8:	7de3      	ldrb	r3, [r4, #23]
   188da:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    tail.tail[0] = dir->tail[0];
   188de:	69a3      	ldr	r3, [r4, #24]
   188e0:	930a      	str	r3, [sp, #40]	; 0x28
    tail.tail[1] = dir->tail[1];
   188e2:	69e3      	ldr	r3, [r4, #28]
   188e4:	930b      	str	r3, [sp, #44]	; 0x2c
    err = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);
   188e6:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   188ea:	e9cd 9301 	strd	r9, r3, [sp, #4]
   188ee:	9b14      	ldr	r3, [sp, #80]	; 0x50
   188f0:	9300      	str	r3, [sp, #0]
   188f2:	463a      	mov	r2, r7
   188f4:	4643      	mov	r3, r8
   188f6:	a904      	add	r1, sp, #16
   188f8:	4630      	mov	r0, r6
   188fa:	f7f9 fe39 	bl	12570 <lfs_dir_compact>
    if (err) {
   188fe:	4605      	mov	r5, r0
   18900:	b990      	cbnz	r0, 18928 <lfs_dir_split+0x72>
    dir->tail[0] = tail.pair[0];
   18902:	f8dd 8010 	ldr.w	r8, [sp, #16]
    dir->tail[1] = tail.pair[1];
   18906:	9f05      	ldr	r7, [sp, #20]
    dir->tail[0] = tail.pair[0];
   18908:	f8c4 8018 	str.w	r8, [r4, #24]
    dir->split = true;
   1890c:	2301      	movs	r3, #1
    dir->tail[1] = tail.pair[1];
   1890e:	61e7      	str	r7, [r4, #28]
    dir->split = true;
   18910:	75e3      	strb	r3, [r4, #23]
    if (lfs_pair_cmp(dir->pair, lfs->root) == 0 && split == 0) {
   18912:	f106 0120 	add.w	r1, r6, #32
   18916:	4620      	mov	r0, r4
   18918:	f7ff f84c 	bl	179b4 <lfs_pair_cmp>
   1891c:	b920      	cbnz	r0, 18928 <lfs_dir_split+0x72>
   1891e:	f1b9 0f00 	cmp.w	r9, #0
   18922:	d101      	bne.n	18928 <lfs_dir_split+0x72>
        lfs->root[1] = tail.pair[1];
   18924:	e9c6 8708 	strd	r8, r7, [r6, #32]
}
   18928:	4628      	mov	r0, r5
   1892a:	b00d      	add	sp, #52	; 0x34
   1892c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00018930 <device_busy_set>:
	atomic_set_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
   18930:	4770      	bx	lr

00018932 <device_busy_clear>:
   18932:	4770      	bx	lr

00018934 <arch_system_halt>:
	__asm__ volatile(
   18934:	f04f 0220 	mov.w	r2, #32
   18938:	f3ef 8311 	mrs	r3, BASEPRI
   1893c:	f382 8811 	msr	BASEPRI, r2
   18940:	f3bf 8f6f 	isb	sy
	for (;;) {
   18944:	e7fe      	b.n	18944 <arch_system_halt+0x10>

00018946 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   18946:	f7fd baa8 	b.w	15e9a <z_clock_idle_exit>

0001894a <k_heap_init>:
{
   1894a:	b410      	push	{r4}
   1894c:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   18950:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   18954:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   18956:	f7fc bb3e 	b.w	14fd6 <sys_heap_init>

0001895a <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   1895a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1895e:	4605      	mov	r5, r0
   18960:	b085      	sub	sp, #20
	s64_t now, end = z_timeout_end_calc(timeout);
   18962:	4610      	mov	r0, r2
{
   18964:	460f      	mov	r7, r1
	s64_t now, end = z_timeout_end_calc(timeout);
   18966:	f000 fb33 	bl	18fd0 <z_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   1896a:	f105 0a14 	add.w	sl, r5, #20
	s64_t now, end = z_timeout_end_calc(timeout);
   1896e:	4606      	mov	r6, r0
   18970:	4680      	mov	r8, r0
   18972:	4689      	mov	r9, r1
   18974:	f04f 0320 	mov.w	r3, #32
   18978:	f3ef 8411 	mrs	r4, BASEPRI
   1897c:	f383 8811 	msr	BASEPRI, r3
   18980:	f3bf 8f6f 	isb	sy
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   18984:	f105 0b0c 	add.w	fp, r5, #12
		ret = sys_heap_alloc(&h->heap, bytes);
   18988:	4639      	mov	r1, r7
   1898a:	4628      	mov	r0, r5
   1898c:	f7fc facb 	bl	14f26 <sys_heap_alloc>
   18990:	9003      	str	r0, [sp, #12]
		now = z_tick_get();
   18992:	f7fb feb1 	bl	146f8 <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
   18996:	9b03      	ldr	r3, [sp, #12]
   18998:	b13b      	cbz	r3, 189aa <k_heap_alloc+0x50>
	__asm__ volatile(
   1899a:	f384 8811 	msr	BASEPRI, r4
   1899e:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
   189a2:	4618      	mov	r0, r3
   189a4:	b005      	add	sp, #20
   189a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((ret != NULL) || ((end - now) <= 0)) {
   189aa:	ebb8 0200 	subs.w	r2, r8, r0
   189ae:	9200      	str	r2, [sp, #0]
   189b0:	eb69 0201 	sbc.w	r2, r9, r1
   189b4:	9201      	str	r2, [sp, #4]
   189b6:	e9dd 1200 	ldrd	r1, r2, [sp]
   189ba:	2901      	cmp	r1, #1
   189bc:	f172 0200 	sbcs.w	r2, r2, #0
   189c0:	dbeb      	blt.n	1899a <k_heap_alloc+0x40>
				   K_TICKS(end - now));
   189c2:	1a30      	subs	r0, r6, r0
   189c4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   189c8:	f647 72ff 	movw	r2, #32767	; 0x7fff
   189cc:	2300      	movs	r3, #0
   189ce:	fbe1 2300 	umlal	r2, r3, r1, r0
   189d2:	0bd2      	lsrs	r2, r2, #15
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   189d4:	ea42 4343 	orr.w	r3, r2, r3, lsl #17
   189d8:	4621      	mov	r1, r4
   189da:	465a      	mov	r2, fp
   189dc:	4650      	mov	r0, sl
   189de:	f7fb fba5 	bl	1412c <z_pend_curr>
	__asm__ volatile(
   189e2:	f04f 0320 	mov.w	r3, #32
   189e6:	f3ef 8411 	mrs	r4, BASEPRI
   189ea:	f383 8811 	msr	BASEPRI, r3
   189ee:	f3bf 8f6f 	isb	sy
   189f2:	e7c9      	b.n	18988 <k_heap_alloc+0x2e>

000189f4 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   189f4:	b538      	push	{r3, r4, r5, lr}
   189f6:	4604      	mov	r4, r0
   189f8:	f04f 0320 	mov.w	r3, #32
   189fc:	f3ef 8511 	mrs	r5, BASEPRI
   18a00:	f383 8811 	msr	BASEPRI, r3
   18a04:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   18a08:	f7fc f9da 	bl	14dc0 <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
   18a0c:	f104 000c 	add.w	r0, r4, #12
   18a10:	f000 fa6b 	bl	18eea <z_unpend_all>
   18a14:	b130      	cbz	r0, 18a24 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   18a16:	4629      	mov	r1, r5
   18a18:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   18a1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   18a20:	f000 b978 	b.w	18d14 <z_reschedule>
	__asm__ volatile(
   18a24:	f385 8811 	msr	BASEPRI, r5
   18a28:	f3bf 8f6f 	isb	sy
}
   18a2c:	bd38      	pop	{r3, r4, r5, pc}

00018a2e <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
   18a2e:	b570      	push	{r4, r5, r6, lr}
	block->id.heap = p->heap;
   18a30:	6800      	ldr	r0, [r0, #0]
   18a32:	6048      	str	r0, [r1, #4]
{
   18a34:	4614      	mov	r4, r2
   18a36:	460e      	mov	r6, r1
	block->data = k_heap_alloc(p->heap, size, timeout);
   18a38:	461a      	mov	r2, r3
   18a3a:	4621      	mov	r1, r4
{
   18a3c:	461d      	mov	r5, r3
	block->data = k_heap_alloc(p->heap, size, timeout);
   18a3e:	f7ff ff8c 	bl	1895a <k_heap_alloc>
   18a42:	6030      	str	r0, [r6, #0]

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
   18a44:	b13c      	cbz	r4, 18a56 <k_mem_pool_alloc+0x28>
   18a46:	b930      	cbnz	r0, 18a56 <k_mem_pool_alloc+0x28>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
   18a48:	2d00      	cmp	r5, #0
   18a4a:	bf0c      	ite	eq
   18a4c:	f06f 000b 	mvneq.w	r0, #11
   18a50:	f06f 000a 	mvnne.w	r0, #10
	} else {
		return 0;
	}
}
   18a54:	bd70      	pop	{r4, r5, r6, pc}
		return 0;
   18a56:	2000      	movs	r0, #0
   18a58:	e7fc      	b.n	18a54 <k_mem_pool_alloc+0x26>

00018a5a <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
	k_heap_free(id->heap, id->data);
   18a5a:	e9d0 1000 	ldrd	r1, r0, [r0]
   18a5e:	f7ff bfc9 	b.w	189f4 <k_heap_free>

00018a62 <k_mem_slab_init>:
{
   18a62:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   18a64:	2400      	movs	r4, #0
   18a66:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   18a68:	ea41 0402 	orr.w	r4, r1, r2
   18a6c:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   18a70:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   18a74:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   18a76:	d10c      	bne.n	18a92 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   18a78:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   18a7a:	42a3      	cmp	r3, r4
   18a7c:	d103      	bne.n	18a86 <k_mem_slab_init+0x24>
   18a7e:	e9c0 0000 	strd	r0, r0, [r0]
}
   18a82:	2000      	movs	r0, #0
}
   18a84:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   18a86:	6945      	ldr	r5, [r0, #20]
   18a88:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   18a8a:	3401      	adds	r4, #1
		slab->free_list = p;
   18a8c:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   18a8e:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   18a90:	e7f3      	b.n	18a7a <k_mem_slab_init+0x18>
		return -EINVAL;
   18a92:	f06f 0015 	mvn.w	r0, #21
	return rc;
   18a96:	e7f5      	b.n	18a84 <k_mem_slab_init+0x22>

00018a98 <k_mem_pool_free>:
	k_mem_pool_free_id(&block->id);
   18a98:	f7ff bfdf 	b.w	18a5a <k_mem_pool_free_id>

00018a9c <k_mem_pool_malloc>:
{
   18a9c:	b513      	push	{r0, r1, r4, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   18a9e:	2408      	movs	r4, #8
   18aa0:	190a      	adds	r2, r1, r4
   18aa2:	d204      	bcs.n	18aae <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   18aa4:	2300      	movs	r3, #0
   18aa6:	4669      	mov	r1, sp
   18aa8:	f7ff ffc1 	bl	18a2e <k_mem_pool_alloc>
   18aac:	b110      	cbz	r0, 18ab4 <k_mem_pool_malloc+0x18>
		return NULL;
   18aae:	2000      	movs	r0, #0
}
   18ab0:	b002      	add	sp, #8
   18ab2:	bd10      	pop	{r4, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   18ab4:	9800      	ldr	r0, [sp, #0]
   18ab6:	4622      	mov	r2, r4
   18ab8:	4669      	mov	r1, sp
   18aba:	f7fd fabe 	bl	1603a <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   18abe:	9800      	ldr	r0, [sp, #0]
   18ac0:	3008      	adds	r0, #8
   18ac2:	e7f5      	b.n	18ab0 <k_mem_pool_malloc+0x14>

00018ac4 <k_free>:
	if (ptr != NULL) {
   18ac4:	b110      	cbz	r0, 18acc <k_free+0x8>
		k_mem_pool_free_id(ptr);
   18ac6:	3808      	subs	r0, #8
   18ac8:	f7ff bfc7 	b.w	18a5a <k_mem_pool_free_id>
}
   18acc:	4770      	bx	lr

00018ace <z_impl_k_mutex_init>:
{
   18ace:	4603      	mov	r3, r0
	mutex->owner = NULL;
   18ad0:	2000      	movs	r0, #0
	mutex->lock_count = 0U;
   18ad2:	e9c3 0002 	strd	r0, r0, [r3, #8]
   18ad6:	e9c3 3300 	strd	r3, r3, [r3]
}
   18ada:	4770      	bx	lr

00018adc <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   18adc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18ae0:	4604      	mov	r4, r0
   18ae2:	460d      	mov	r5, r1
   18ae4:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   18ae6:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
   18aea:	f04f 0220 	mov.w	r2, #32
   18aee:	f3ef 8611 	mrs	r6, BASEPRI
   18af2:	f382 8811 	msr	BASEPRI, r2
   18af6:	f3bf 8f6f 	isb	sy
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   18afa:	b1db      	cbz	r3, 18b34 <queue_insert+0x58>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   18afc:	2008      	movs	r0, #8
   18afe:	f7fa ffd1 	bl	13aa4 <z_thread_malloc>
		if (anode == NULL) {
   18b02:	b938      	cbnz	r0, 18b14 <queue_insert+0x38>
	__asm__ volatile(
   18b04:	f386 8811 	msr	BASEPRI, r6
   18b08:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   18b0c:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   18b10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node->next_and_flags = flags;
   18b14:	2301      	movs	r3, #1
		anode->data = data;
   18b16:	f8c0 8004 	str.w	r8, [r0, #4]
   18b1a:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   18b1c:	6803      	ldr	r3, [r0, #0]
   18b1e:	f003 0203 	and.w	r2, r3, #3
   18b22:	b95d      	cbnz	r5, 18b3c <queue_insert+0x60>
	parent->next_and_flags = cur_flags | (unative_t)child;
   18b24:	6823      	ldr	r3, [r4, #0]
   18b26:	4313      	orrs	r3, r2
   18b28:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   18b2a:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   18b2c:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   18b2e:	b973      	cbnz	r3, 18b4e <queue_insert+0x72>
	list->tail = node;
   18b30:	6060      	str	r0, [r4, #4]
}
   18b32:	e00c      	b.n	18b4e <queue_insert+0x72>
	node->next_and_flags = flags;
   18b34:	f8c8 3000 	str.w	r3, [r8]
}
   18b38:	4640      	mov	r0, r8
   18b3a:	e7ef      	b.n	18b1c <queue_insert+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   18b3c:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   18b3e:	f033 0303 	bics.w	r3, r3, #3
   18b42:	d114      	bne.n	18b6e <queue_insert+0x92>
	parent->next_and_flags = cur_flags | (unative_t)child;
   18b44:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   18b46:	6862      	ldr	r2, [r4, #4]
   18b48:	b95a      	cbnz	r2, 18b62 <queue_insert+0x86>
	list->head = node;
   18b4a:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   18b4e:	2104      	movs	r1, #4
   18b50:	4638      	mov	r0, r7
   18b52:	f000 fba1 	bl	19298 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   18b56:	4638      	mov	r0, r7
   18b58:	4631      	mov	r1, r6
   18b5a:	f000 f8db 	bl	18d14 <z_reschedule>
	return 0;
   18b5e:	2000      	movs	r0, #0
   18b60:	e7d6      	b.n	18b10 <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   18b62:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   18b64:	f003 0303 	and.w	r3, r3, #3
   18b68:	4303      	orrs	r3, r0
   18b6a:	6013      	str	r3, [r2, #0]
   18b6c:	e7e0      	b.n	18b30 <queue_insert+0x54>
   18b6e:	4313      	orrs	r3, r2
   18b70:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   18b72:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   18b74:	f003 0303 	and.w	r3, r3, #3
   18b78:	4318      	orrs	r0, r3
   18b7a:	6028      	str	r0, [r5, #0]
}
   18b7c:	e7e7      	b.n	18b4e <queue_insert+0x72>

00018b7e <z_queue_node_peek>:
{
   18b7e:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   18b80:	4604      	mov	r4, r0
   18b82:	b130      	cbz	r0, 18b92 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   18b84:	6802      	ldr	r2, [r0, #0]
   18b86:	0793      	lsls	r3, r2, #30
   18b88:	d003      	beq.n	18b92 <z_queue_node_peek+0x14>
		ret = anode->data;
   18b8a:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   18b8c:	b109      	cbz	r1, 18b92 <z_queue_node_peek+0x14>
			k_free(anode);
   18b8e:	f7ff ff99 	bl	18ac4 <k_free>
}
   18b92:	4620      	mov	r0, r4
   18b94:	bd10      	pop	{r4, pc}

00018b96 <z_impl_k_queue_init>:
	list->head = NULL;
   18b96:	2300      	movs	r3, #0
	list->tail = NULL;
   18b98:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&queue->poll_events);
   18b9c:	f100 0308 	add.w	r3, r0, #8
   18ba0:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
   18ba4:	4770      	bx	lr

00018ba6 <k_queue_append>:
{
	(void)queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
   18ba6:	460a      	mov	r2, r1
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   18ba8:	2300      	movs	r3, #0
   18baa:	6841      	ldr	r1, [r0, #4]
   18bac:	f7ff bf96 	b.w	18adc <queue_insert>

00018bb0 <k_queue_prepend>:
			   data, false);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, NULL, data, false);
   18bb0:	2300      	movs	r3, #0
{
   18bb2:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false);
   18bb4:	4619      	mov	r1, r3
   18bb6:	f7ff bf91 	b.w	18adc <queue_insert>

00018bba <k_queue_append_list>:
}
#include <syscalls/k_queue_alloc_prepend_mrsh.c>
#endif

int k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
   18bba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18bbc:	4603      	mov	r3, r0
	/* invalid head or tail of list */
	CHECKIF(head == NULL || tail == NULL) {
   18bbe:	b1f1      	cbz	r1, 18bfe <k_queue_append_list+0x44>
   18bc0:	b1ea      	cbz	r2, 18bfe <k_queue_append_list+0x44>
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   18bc2:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   18bc6:	f04f 0020 	mov.w	r0, #32
   18bca:	f3ef 8711 	mrs	r7, BASEPRI
   18bce:	f380 8811 	msr	BASEPRI, r0
   18bd2:	f3bf 8f6f 	isb	sy
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   18bd6:	685c      	ldr	r4, [r3, #4]
   18bd8:	b95c      	cbnz	r4, 18bf2 <k_queue_append_list+0x38>
	list->head = node;
   18bda:	6019      	str	r1, [r3, #0]
	list->tail = node;
   18bdc:	605a      	str	r2, [r3, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   18bde:	2104      	movs	r1, #4
   18be0:	4630      	mov	r0, r6
   18be2:	f000 fb59 	bl	19298 <z_handle_obj_poll_events>
#else
	sys_sflist_append_list(&queue->data_q, head, tail);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* !CONFIG_POLL */

	z_reschedule(&queue->lock, key);
   18be6:	4630      	mov	r0, r6
   18be8:	4639      	mov	r1, r7
   18bea:	f000 f893 	bl	18d14 <z_reschedule>

	return 0;
   18bee:	2000      	movs	r0, #0
}
   18bf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   18bf2:	6825      	ldr	r5, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   18bf4:	f005 0503 	and.w	r5, r5, #3
   18bf8:	4329      	orrs	r1, r5
   18bfa:	6021      	str	r1, [r4, #0]
}
   18bfc:	e7ee      	b.n	18bdc <k_queue_append_list+0x22>
		return -EINVAL;
   18bfe:	f06f 0015 	mvn.w	r0, #21
   18c02:	e7f5      	b.n	18bf0 <k_queue_append_list+0x36>

00018c04 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   18c04:	b5f0      	push	{r4, r5, r6, r7, lr}
   18c06:	4605      	mov	r5, r0
   18c08:	b087      	sub	sp, #28
   18c0a:	460e      	mov	r6, r1
   18c0c:	f04f 0320 	mov.w	r3, #32
   18c10:	f3ef 8711 	mrs	r7, BASEPRI
   18c14:	f383 8811 	msr	BASEPRI, r3
   18c18:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   18c1c:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   18c1e:	b19c      	cbz	r4, 18c48 <z_impl_k_queue_get+0x44>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   18c20:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   18c22:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   18c24:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   18c28:	4294      	cmp	r4, r2
	list->head = node;
   18c2a:	6003      	str	r3, [r0, #0]
	list->tail = node;
   18c2c:	bf08      	it	eq
   18c2e:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   18c30:	2101      	movs	r1, #1
   18c32:	4620      	mov	r0, r4
   18c34:	f7ff ffa3 	bl	18b7e <z_queue_node_peek>
   18c38:	4604      	mov	r4, r0
	__asm__ volatile(
   18c3a:	f387 8811 	msr	BASEPRI, r7
   18c3e:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   18c42:	4620      	mov	r0, r4
   18c44:	b007      	add	sp, #28
   18c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   18c48:	2900      	cmp	r1, #0
   18c4a:	d0f6      	beq.n	18c3a <z_impl_k_queue_get+0x36>
   18c4c:	f387 8811 	msr	BASEPRI, r7
   18c50:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   18c54:	2104      	movs	r1, #4
   18c56:	4603      	mov	r3, r0
   18c58:	4622      	mov	r2, r4
   18c5a:	eb0d 0001 	add.w	r0, sp, r1
   18c5e:	f000 fb0c 	bl	1927a <k_poll_event_init>
	event.state = K_POLL_STATE_NOT_READY;
   18c62:	9b04      	ldr	r3, [sp, #16]
   18c64:	f364 3310 	bfi	r3, r4, #12, #5
   18c68:	9304      	str	r3, [sp, #16]
	return z_impl_k_poll(events, num_events, timeout);
   18c6a:	2101      	movs	r1, #1
   18c6c:	4632      	mov	r2, r6
   18c6e:	a801      	add	r0, sp, #4
   18c70:	f7fb fdac 	bl	147cc <z_impl_k_poll>
	if (err && err != -EAGAIN) {
   18c74:	b108      	cbz	r0, 18c7a <z_impl_k_queue_get+0x76>
   18c76:	300b      	adds	r0, #11
   18c78:	d1e3      	bne.n	18c42 <z_impl_k_queue_get+0x3e>
	__asm__ volatile(
   18c7a:	f04f 0320 	mov.w	r3, #32
   18c7e:	f3ef 8611 	mrs	r6, BASEPRI
   18c82:	f383 8811 	msr	BASEPRI, r3
   18c86:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   18c8a:	6828      	ldr	r0, [r5, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   18c8c:	b138      	cbz	r0, 18c9e <z_impl_k_queue_get+0x9a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   18c8e:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   18c90:	686a      	ldr	r2, [r5, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   18c92:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   18c96:	4290      	cmp	r0, r2
	list->head = node;
   18c98:	602b      	str	r3, [r5, #0]
	list->tail = node;
   18c9a:	bf08      	it	eq
   18c9c:	606b      	streq	r3, [r5, #4]
	val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   18c9e:	2101      	movs	r1, #1
   18ca0:	f7ff ff6d 	bl	18b7e <z_queue_node_peek>
   18ca4:	4604      	mov	r4, r0
	__asm__ volatile(
   18ca6:	f386 8811 	msr	BASEPRI, r6
   18caa:	f3bf 8f6f 	isb	sy
	return k_queue_poll(queue, timeout);
   18cae:	e7c8      	b.n	18c42 <z_impl_k_queue_get+0x3e>

00018cb0 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   18cb0:	f990 000e 	ldrsb.w	r0, [r0, #14]
   18cb4:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   18cb8:	4298      	cmp	r0, r3
   18cba:	bfac      	ite	ge
   18cbc:	2000      	movge	r0, #0
   18cbe:	2001      	movlt	r0, #1
   18cc0:	4770      	bx	lr

00018cc2 <z_find_first_thread_to_unpend>:
{
   18cc2:	b510      	push	{r4, lr}
	__asm__ volatile(
   18cc4:	f04f 0320 	mov.w	r3, #32
   18cc8:	f3ef 8411 	mrs	r4, BASEPRI
   18ccc:	f383 8811 	msr	BASEPRI, r3
   18cd0:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   18cd4:	f000 f85c 	bl	18d90 <z_priq_dumb_best>
	__asm__ volatile(
   18cd8:	f384 8811 	msr	BASEPRI, r4
   18cdc:	f3bf 8f6f 	isb	sy
}
   18ce0:	bd10      	pop	{r4, pc}

00018ce2 <z_unpend_thread_no_timeout>:
{
   18ce2:	b538      	push	{r3, r4, r5, lr}
   18ce4:	4604      	mov	r4, r0
	__asm__ volatile(
   18ce6:	f04f 0320 	mov.w	r3, #32
   18cea:	f3ef 8511 	mrs	r5, BASEPRI
   18cee:	f383 8811 	msr	BASEPRI, r3
   18cf2:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   18cf6:	4601      	mov	r1, r0
   18cf8:	6880      	ldr	r0, [r0, #8]
   18cfa:	f7fa fff7 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   18cfe:	7b63      	ldrb	r3, [r4, #13]
   18d00:	f023 0302 	bic.w	r3, r3, #2
   18d04:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   18d06:	2300      	movs	r3, #0
   18d08:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   18d0a:	f385 8811 	msr	BASEPRI, r5
   18d0e:	f3bf 8f6f 	isb	sy
}
   18d12:	bd38      	pop	{r3, r4, r5, pc}

00018d14 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   18d14:	b921      	cbnz	r1, 18d20 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   18d16:	f3ef 8005 	mrs	r0, IPSR
   18d1a:	b908      	cbnz	r0, 18d20 <z_reschedule+0xc>
   18d1c:	f7ec be8e 	b.w	5a3c <arch_swap>
   18d20:	f381 8811 	msr	BASEPRI, r1
   18d24:	f3bf 8f6f 	isb	sy
}
   18d28:	4770      	bx	lr

00018d2a <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   18d2a:	4603      	mov	r3, r0
   18d2c:	b920      	cbnz	r0, 18d38 <z_reschedule_irqlock+0xe>
   18d2e:	f3ef 8205 	mrs	r2, IPSR
   18d32:	b90a      	cbnz	r2, 18d38 <z_reschedule_irqlock+0xe>
   18d34:	f7ec be82 	b.w	5a3c <arch_swap>
   18d38:	f383 8811 	msr	BASEPRI, r3
   18d3c:	f3bf 8f6f 	isb	sy
}
   18d40:	4770      	bx	lr

00018d42 <z_reschedule_unlocked>:
	__asm__ volatile(
   18d42:	f04f 0320 	mov.w	r3, #32
   18d46:	f3ef 8011 	mrs	r0, BASEPRI
   18d4a:	f383 8811 	msr	BASEPRI, r3
   18d4e:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   18d52:	f7ff bfea 	b.w	18d2a <z_reschedule_irqlock>

00018d56 <z_unpend_thread>:
{
   18d56:	b510      	push	{r4, lr}
   18d58:	4601      	mov	r1, r0
   18d5a:	f04f 0320 	mov.w	r3, #32
   18d5e:	f3ef 8411 	mrs	r4, BASEPRI
   18d62:	f383 8811 	msr	BASEPRI, r3
   18d66:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   18d6a:	6880      	ldr	r0, [r0, #8]
   18d6c:	f7fa ffbe 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   18d70:	7b4b      	ldrb	r3, [r1, #13]
   18d72:	f023 0302 	bic.w	r3, r3, #2
   18d76:	734b      	strb	r3, [r1, #13]
		thread->base.pended_on = NULL;
   18d78:	2300      	movs	r3, #0
   18d7a:	608b      	str	r3, [r1, #8]
	__asm__ volatile(
   18d7c:	f384 8811 	msr	BASEPRI, r4
   18d80:	f3bf 8f6f 	isb	sy
}
   18d84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return z_abort_timeout(&thread->base.timeout);
   18d88:	f101 0018 	add.w	r0, r1, #24
   18d8c:	f000 b8da 	b.w	18f44 <z_abort_timeout>

00018d90 <z_priq_dumb_best>:
{
   18d90:	4603      	mov	r3, r0
	return list->head == list;
   18d92:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18d94:	4283      	cmp	r3, r0
   18d96:	d003      	beq.n	18da0 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   18d98:	2800      	cmp	r0, #0
   18d9a:	bf38      	it	cc
   18d9c:	2000      	movcc	r0, #0
   18d9e:	4770      	bx	lr
	struct k_thread *thread = NULL;
   18da0:	2000      	movs	r0, #0
}
   18da2:	4770      	bx	lr

00018da4 <z_ready_thread>:
{
   18da4:	b510      	push	{r4, lr}
	__asm__ volatile(
   18da6:	f04f 0320 	mov.w	r3, #32
   18daa:	f3ef 8411 	mrs	r4, BASEPRI
   18dae:	f383 8811 	msr	BASEPRI, r3
   18db2:	f3bf 8f6f 	isb	sy
		ready_thread(thread);
   18db6:	f7fa ffef 	bl	13d98 <ready_thread>
	__asm__ volatile(
   18dba:	f384 8811 	msr	BASEPRI, r4
   18dbe:	f3bf 8f6f 	isb	sy
}
   18dc2:	bd10      	pop	{r4, pc}

00018dc4 <z_thread_timeout>:
{
   18dc4:	b538      	push	{r3, r4, r5, lr}
	if (thread->base.pended_on != NULL) {
   18dc6:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   18dca:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   18dcc:	f1a0 0118 	sub.w	r1, r0, #24
	if (thread->base.pended_on != NULL) {
   18dd0:	b1c3      	cbz	r3, 18e04 <z_thread_timeout+0x40>
	__asm__ volatile(
   18dd2:	f04f 0320 	mov.w	r3, #32
   18dd6:	f3ef 8511 	mrs	r5, BASEPRI
   18dda:	f383 8811 	msr	BASEPRI, r3
   18dde:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   18de2:	f850 0c10 	ldr.w	r0, [r0, #-16]
   18de6:	f7fa ff81 	bl	13cec <z_priq_dumb_remove>
   18dea:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   18dee:	f023 0302 	bic.w	r3, r3, #2
   18df2:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
   18df6:	2300      	movs	r3, #0
   18df8:	f844 3c10 	str.w	r3, [r4, #-16]
	__asm__ volatile(
   18dfc:	f385 8811 	msr	BASEPRI, r5
   18e00:	f3bf 8f6f 	isb	sy
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   18e04:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   18e08:	f023 0314 	bic.w	r3, r3, #20
   18e0c:	f804 3c0b 	strb.w	r3, [r4, #-11]
	z_ready_thread(thread);
   18e10:	4608      	mov	r0, r1
}
   18e12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_ready_thread(thread);
   18e16:	f7ff bfc5 	b.w	18da4 <z_ready_thread>

00018e1a <z_remove_thread_from_ready_q>:
{
   18e1a:	b510      	push	{r4, lr}
	__asm__ volatile(
   18e1c:	f04f 0320 	mov.w	r3, #32
   18e20:	f3ef 8411 	mrs	r4, BASEPRI
   18e24:	f383 8811 	msr	BASEPRI, r3
   18e28:	f3bf 8f6f 	isb	sy
		unready_thread(thread);
   18e2c:	f7fb f90c 	bl	14048 <unready_thread>
	__asm__ volatile(
   18e30:	f384 8811 	msr	BASEPRI, r4
   18e34:	f3bf 8f6f 	isb	sy
}
   18e38:	bd10      	pop	{r4, pc}

00018e3a <add_to_waitq_locked>:
{
   18e3a:	b538      	push	{r3, r4, r5, lr}
   18e3c:	4604      	mov	r4, r0
   18e3e:	460d      	mov	r5, r1
	unready_thread(thread);
   18e40:	f7fb f902 	bl	14048 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   18e44:	7b63      	ldrb	r3, [r4, #13]
   18e46:	f043 0302 	orr.w	r3, r3, #2
   18e4a:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   18e4c:	b1c5      	cbz	r5, 18e80 <add_to_waitq_locked+0x46>
	return list->head == list;
   18e4e:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   18e50:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18e52:	429d      	cmp	r5, r3
   18e54:	bf08      	it	eq
   18e56:	2300      	moveq	r3, #0
   18e58:	2b00      	cmp	r3, #0
   18e5a:	bf38      	it	cc
   18e5c:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   18e5e:	b183      	cbz	r3, 18e82 <add_to_waitq_locked+0x48>
	if (thread_1->base.prio < thread_2->base.prio) {
   18e60:	f994 100e 	ldrsb.w	r1, [r4, #14]
   18e64:	f993 200e 	ldrsb.w	r2, [r3, #14]
   18e68:	4291      	cmp	r1, r2
   18e6a:	db04      	blt.n	18e76 <add_to_waitq_locked+0x3c>
	return (node == list->tail) ? NULL : node->next;
   18e6c:	686a      	ldr	r2, [r5, #4]
   18e6e:	429a      	cmp	r2, r3
   18e70:	d007      	beq.n	18e82 <add_to_waitq_locked+0x48>
   18e72:	681b      	ldr	r3, [r3, #0]
   18e74:	e7f3      	b.n	18e5e <add_to_waitq_locked+0x24>
	node->prev = successor->prev;
   18e76:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   18e78:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   18e7c:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   18e7e:	605c      	str	r4, [r3, #4]
}
   18e80:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = list->tail;
   18e82:	686b      	ldr	r3, [r5, #4]
   18e84:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   18e86:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   18e88:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
   18e8a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   18e8c:	606c      	str	r4, [r5, #4]
   18e8e:	e7f7      	b.n	18e80 <add_to_waitq_locked+0x46>

00018e90 <z_unpend_first_thread>:
{
   18e90:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   18e92:	f04f 0320 	mov.w	r3, #32
   18e96:	f3ef 8211 	mrs	r2, BASEPRI
   18e9a:	f383 8811 	msr	BASEPRI, r3
   18e9e:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   18ea2:	f7ff ff75 	bl	18d90 <z_priq_dumb_best>
   18ea6:	4604      	mov	r4, r0
	__asm__ volatile(
   18ea8:	f382 8811 	msr	BASEPRI, r2
   18eac:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   18eb0:	b1c8      	cbz	r0, 18ee6 <z_unpend_first_thread+0x56>
	__asm__ volatile(
   18eb2:	f04f 0320 	mov.w	r3, #32
   18eb6:	f3ef 8511 	mrs	r5, BASEPRI
   18eba:	f383 8811 	msr	BASEPRI, r3
   18ebe:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   18ec2:	4601      	mov	r1, r0
   18ec4:	6880      	ldr	r0, [r0, #8]
   18ec6:	f7fa ff11 	bl	13cec <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   18eca:	7b63      	ldrb	r3, [r4, #13]
   18ecc:	f023 0302 	bic.w	r3, r3, #2
   18ed0:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   18ed2:	2300      	movs	r3, #0
   18ed4:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   18ed6:	f385 8811 	msr	BASEPRI, r5
   18eda:	f3bf 8f6f 	isb	sy
   18ede:	f104 0018 	add.w	r0, r4, #24
   18ee2:	f000 f82f 	bl	18f44 <z_abort_timeout>
}
   18ee6:	4620      	mov	r0, r4
   18ee8:	bd38      	pop	{r3, r4, r5, pc}

00018eea <z_unpend_all>:
{
   18eea:	b538      	push	{r3, r4, r5, lr}
   18eec:	4605      	mov	r5, r0
	int need_sched = 0;
   18eee:	2000      	movs	r0, #0
	return list->head == list;
   18ef0:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18ef2:	42a5      	cmp	r5, r4
   18ef4:	d000      	beq.n	18ef8 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   18ef6:	b904      	cbnz	r4, 18efa <z_unpend_all+0x10>
}
   18ef8:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   18efa:	4620      	mov	r0, r4
   18efc:	f7ff ff2b 	bl	18d56 <z_unpend_thread>
		z_ready_thread(thread);
   18f00:	4620      	mov	r0, r4
   18f02:	f7ff ff4f 	bl	18da4 <z_ready_thread>
		need_sched = 1;
   18f06:	2001      	movs	r0, #1
   18f08:	e7f2      	b.n	18ef0 <z_unpend_all+0x6>

00018f0a <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   18f0a:	b15a      	cbz	r2, 18f24 <z_impl_k_sem_init+0x1a>
   18f0c:	428a      	cmp	r2, r1
   18f0e:	d309      	bcc.n	18f24 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   18f10:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   18f14:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   18f18:	e9c0 0000 	strd	r0, r0, [r0]
   18f1c:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   18f20:	2000      	movs	r0, #0
   18f22:	4770      	bx	lr
		return -EINVAL;
   18f24:	f06f 0015 	mvn.w	r0, #21
}
   18f28:	4770      	bx	lr

00018f2a <k_is_in_isr>:
   18f2a:	f3ef 8005 	mrs	r0, IPSR
}
   18f2e:	3800      	subs	r0, #0
   18f30:	bf18      	it	ne
   18f32:	2001      	movne	r0, #1
   18f34:	4770      	bx	lr

00018f36 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   18f36:	f7ee b859 	b.w	6fec <arch_busy_wait>

00018f3a <z_impl_k_thread_name_set>:
}
   18f3a:	f06f 0046 	mvn.w	r0, #70	; 0x46
   18f3e:	4770      	bx	lr

00018f40 <k_thread_name_get>:
}
   18f40:	2000      	movs	r0, #0
   18f42:	4770      	bx	lr

00018f44 <z_abort_timeout>:
{
   18f44:	b510      	push	{r4, lr}
	__asm__ volatile(
   18f46:	f04f 0220 	mov.w	r2, #32
   18f4a:	f3ef 8411 	mrs	r4, BASEPRI
   18f4e:	f382 8811 	msr	BASEPRI, r2
   18f52:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   18f56:	6803      	ldr	r3, [r0, #0]
   18f58:	b13b      	cbz	r3, 18f6a <z_abort_timeout+0x26>
			remove_timeout(to);
   18f5a:	f7fb fb05 	bl	14568 <remove_timeout>
			ret = 0;
   18f5e:	2000      	movs	r0, #0
	__asm__ volatile(
   18f60:	f384 8811 	msr	BASEPRI, r4
   18f64:	f3bf 8f6f 	isb	sy
}
   18f68:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   18f6a:	f06f 0015 	mvn.w	r0, #21
   18f6e:	e7f7      	b.n	18f60 <z_abort_timeout+0x1c>

00018f70 <z_get_next_timeout_expiry>:
{
   18f70:	b510      	push	{r4, lr}
	__asm__ volatile(
   18f72:	f04f 0320 	mov.w	r3, #32
   18f76:	f3ef 8411 	mrs	r4, BASEPRI
   18f7a:	f383 8811 	msr	BASEPRI, r3
   18f7e:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   18f82:	f7fb fb05 	bl	14590 <next_timeout>
	__asm__ volatile(
   18f86:	f384 8811 	msr	BASEPRI, r4
   18f8a:	f3bf 8f6f 	isb	sy
}
   18f8e:	bd10      	pop	{r4, pc}

00018f90 <z_set_timeout_expiry>:
{
   18f90:	b570      	push	{r4, r5, r6, lr}
   18f92:	4604      	mov	r4, r0
   18f94:	460d      	mov	r5, r1
	__asm__ volatile(
   18f96:	f04f 0320 	mov.w	r3, #32
   18f9a:	f3ef 8611 	mrs	r6, BASEPRI
   18f9e:	f383 8811 	msr	BASEPRI, r3
   18fa2:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   18fa6:	f7fb faf3 	bl	14590 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   18faa:	2801      	cmp	r0, #1
   18fac:	dd05      	ble.n	18fba <z_set_timeout_expiry+0x2a>
   18fae:	42a0      	cmp	r0, r4
   18fb0:	dd03      	ble.n	18fba <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   18fb2:	4629      	mov	r1, r5
   18fb4:	4620      	mov	r0, r4
   18fb6:	f7ec fbfb 	bl	57b0 <z_clock_set_timeout>
	__asm__ volatile(
   18fba:	f386 8811 	msr	BASEPRI, r6
   18fbe:	f3bf 8f6f 	isb	sy
}
   18fc2:	bd70      	pop	{r4, r5, r6, pc}

00018fc4 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   18fc4:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   18fc6:	f7fb fb97 	bl	146f8 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   18fca:	bd08      	pop	{r3, pc}

00018fcc <z_impl_k_uptime_ticks>:

s64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
   18fcc:	f7fb bb94 	b.w	146f8 <z_tick_get>

00018fd0 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
   18fd0:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   18fd2:	1c43      	adds	r3, r0, #1
{
   18fd4:	4601      	mov	r1, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   18fd6:	d01e      	beq.n	19016 <z_timeout_end_calc+0x46>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   18fd8:	b918      	cbnz	r0, 18fe2 <z_timeout_end_calc+0x12>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
   18fda:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
   18fde:	f7fb bb8b 	b.w	146f8 <z_tick_get>
   18fe2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   18fe6:	f240 34e7 	movw	r4, #999	; 0x3e7
   18fea:	2500      	movs	r5, #0
   18fec:	fbe0 4501 	umlal	r4, r5, r0, r1
   18ff0:	4620      	mov	r0, r4
   18ff2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   18ff6:	2300      	movs	r3, #0
   18ff8:	4629      	mov	r1, r5
   18ffa:	f7e7 fc83 	bl	904 <__aeabi_uldivmod>
   18ffe:	4604      	mov	r4, r0
	return z_tick_get() + MAX(1, dt);
   19000:	f7fb fb7a 	bl	146f8 <z_tick_get>
   19004:	b12c      	cbz	r4, 19012 <z_timeout_end_calc+0x42>
   19006:	4623      	mov	r3, r4
   19008:	2200      	movs	r2, #0
   1900a:	18c0      	adds	r0, r0, r3
   1900c:	eb42 0101 	adc.w	r1, r2, r1
}
   19010:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
   19012:	2301      	movs	r3, #1
   19014:	e7f8      	b.n	19008 <z_timeout_end_calc+0x38>
		return UINT64_MAX;
   19016:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1901a:	4601      	mov	r1, r0
   1901c:	e7f8      	b.n	19010 <z_timeout_end_calc+0x40>

0001901e <k_timer_init>:
	timer->status = 0U;
   1901e:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   19020:	e9c0 1206 	strd	r1, r2, [r0, #24]
	sys_dlist_init(&w->waitq);
   19024:	f100 0210 	add.w	r2, r0, #16
   19028:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   1902c:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   19030:	6243      	str	r3, [r0, #36]	; 0x24
	timer->user_data = NULL;
   19032:	6283      	str	r3, [r0, #40]	; 0x28
}
   19034:	4770      	bx	lr

00019036 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   19036:	b510      	push	{r4, lr}
   19038:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   1903a:	f7ff ff83 	bl	18f44 <z_abort_timeout>

	if (inactive) {
   1903e:	b9d8      	cbnz	r0, 19078 <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
   19040:	69e3      	ldr	r3, [r4, #28]
   19042:	b10b      	cbz	r3, 19048 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   19044:	4620      	mov	r0, r4
   19046:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   19048:	f104 0010 	add.w	r0, r4, #16
   1904c:	2100      	movs	r1, #0
   1904e:	f7ff fe38 	bl	18cc2 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   19052:	4604      	mov	r4, r0
   19054:	b180      	cbz	r0, 19078 <z_impl_k_timer_stop+0x42>
		z_unpend_thread_no_timeout(thread);
   19056:	f7ff fe44 	bl	18ce2 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
   1905a:	4620      	mov	r0, r4
   1905c:	f7ff fea2 	bl	18da4 <z_ready_thread>
	__asm__ volatile(
   19060:	f04f 0320 	mov.w	r3, #32
   19064:	f3ef 8011 	mrs	r0, BASEPRI
   19068:	f383 8811 	msr	BASEPRI, r3
   1906c:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
   19070:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   19074:	f7ff be59 	b.w	18d2a <z_reschedule_irqlock>
   19078:	bd10      	pop	{r4, pc}

0001907a <clear_event_registrations>:
	while (num_events--) {
   1907a:	2314      	movs	r3, #20
{
   1907c:	b530      	push	{r4, r5, lr}
   1907e:	fb03 0101 	mla	r1, r3, r1, r0
	event->poller = NULL;
   19082:	2400      	movs	r4, #0
	while (num_events--) {
   19084:	4281      	cmp	r1, r0
   19086:	d100      	bne.n	1908a <clear_event_registrations+0x10>
}
   19088:	bd30      	pop	{r4, r5, pc}
	switch (event->type) {
   1908a:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
   1908e:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
   19092:	f003 030f 	and.w	r3, r3, #15
   19096:	2b02      	cmp	r3, #2
   19098:	d80a      	bhi.n	190b0 <clear_event_registrations+0x36>
   1909a:	b15b      	cbz	r3, 190b4 <clear_event_registrations+0x3a>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   1909c:	f851 3c14 	ldr.w	r3, [r1, #-20]
   190a0:	b143      	cbz	r3, 190b4 <clear_event_registrations+0x3a>
	node->prev->next = node->next;
   190a2:	f851 5c10 	ldr.w	r5, [r1, #-16]
   190a6:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   190a8:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   190aa:	e941 4405 	strd	r4, r4, [r1, #-20]
}
   190ae:	e001      	b.n	190b4 <clear_event_registrations+0x3a>
	switch (event->type) {
   190b0:	2b04      	cmp	r3, #4
   190b2:	d0f3      	beq.n	1909c <clear_event_registrations+0x22>
	__asm__ volatile(
   190b4:	f382 8811 	msr	BASEPRI, r2
   190b8:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   190bc:	f04f 0320 	mov.w	r3, #32
   190c0:	f3ef 8211 	mrs	r2, BASEPRI
   190c4:	f383 8811 	msr	BASEPRI, r3
   190c8:	f3bf 8f6f 	isb	sy
   190cc:	3914      	subs	r1, #20
   190ce:	e7d9      	b.n	19084 <clear_event_registrations+0xa>

000190d0 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   190d0:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   190d2:	6884      	ldr	r4, [r0, #8]
{
   190d4:	4605      	mov	r5, r0
   190d6:	460e      	mov	r6, r1
	int retcode = 0;

	if (poller) {
   190d8:	b19c      	cbz	r4, 19102 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   190da:	68a3      	ldr	r3, [r4, #8]
   190dc:	b95b      	cbnz	r3, 190f6 <signal_poll_event+0x26>
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
   190de:	7023      	strb	r3, [r4, #0]
	int retcode = 0;
   190e0:	4618      	mov	r0, r3
	event->poller = NULL;
   190e2:	2300      	movs	r3, #0
   190e4:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   190e6:	68eb      	ldr	r3, [r5, #12]
   190e8:	f3c3 3104 	ubfx	r1, r3, #12, #5
   190ec:	430e      	orrs	r6, r1
   190ee:	f366 3310 	bfi	r3, r6, #12, #5
   190f2:	60eb      	str	r3, [r5, #12]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
   190f4:	e004      	b.n	19100 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   190f6:	4798      	blx	r3
		poller->is_polling = false;
   190f8:	2300      	movs	r3, #0
		if (retcode < 0) {
   190fa:	2800      	cmp	r0, #0
		poller->is_polling = false;
   190fc:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   190fe:	daf0      	bge.n	190e2 <signal_poll_event+0x12>
}
   19100:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   19102:	4620      	mov	r0, r4
   19104:	e7ed      	b.n	190e2 <signal_poll_event+0x12>

00019106 <k_poll_poller_cb>:
{
   19106:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   19108:	6883      	ldr	r3, [r0, #8]
   1910a:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
   1910c:	7b63      	ldrb	r3, [r4, #13]
   1910e:	079a      	lsls	r2, r3, #30
{
   19110:	460d      	mov	r5, r1
	if (!z_is_thread_pending(thread)) {
   19112:	d50e      	bpl.n	19132 <k_poll_poller_cb+0x2c>
	if (z_is_thread_timeout_expired(thread)) {
   19114:	6a23      	ldr	r3, [r4, #32]
   19116:	3302      	adds	r3, #2
   19118:	d014      	beq.n	19144 <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
   1911a:	4620      	mov	r0, r4
   1911c:	f7ff fe1b 	bl	18d56 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   19120:	2d08      	cmp	r5, #8
   19122:	bf0c      	ite	eq
   19124:	f06f 0303 	mvneq.w	r3, #3
   19128:	2300      	movne	r3, #0
   1912a:	6723      	str	r3, [r4, #112]	; 0x70
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1912c:	7b63      	ldrb	r3, [r4, #13]
   1912e:	06db      	lsls	r3, r3, #27
   19130:	d001      	beq.n	19136 <k_poll_poller_cb+0x30>
		return 0;
   19132:	2000      	movs	r0, #0
}
   19134:	bd38      	pop	{r3, r4, r5, pc}
	if (!z_is_thread_ready(thread)) {
   19136:	69a5      	ldr	r5, [r4, #24]
   19138:	2d00      	cmp	r5, #0
   1913a:	d1fa      	bne.n	19132 <k_poll_poller_cb+0x2c>
	z_ready_thread(thread);
   1913c:	4620      	mov	r0, r4
   1913e:	f7ff fe31 	bl	18da4 <z_ready_thread>
	return 0;
   19142:	e7f6      	b.n	19132 <k_poll_poller_cb+0x2c>
		return -EAGAIN;
   19144:	f06f 000a 	mvn.w	r0, #10
   19148:	e7f4      	b.n	19134 <k_poll_poller_cb+0x2e>

0001914a <add_event>:
{
   1914a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1914c:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   1914e:	e9d0 2300 	ldrd	r2, r3, [r0]
   19152:	4290      	cmp	r0, r2
   19154:	4604      	mov	r4, r0
   19156:	460d      	mov	r5, r1
   19158:	d106      	bne.n	19168 <add_event+0x1e>
	node->prev = list->tail;
   1915a:	6863      	ldr	r3, [r4, #4]
   1915c:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   1915e:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   19160:	602c      	str	r4, [r5, #0]
	list->tail->next = node;
   19162:	601d      	str	r5, [r3, #0]
	list->tail = node;
   19164:	6065      	str	r5, [r4, #4]
}
   19166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   19168:	2b00      	cmp	r3, #0
   1916a:	d0f6      	beq.n	1915a <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   1916c:	689b      	ldr	r3, [r3, #8]
   1916e:	6879      	ldr	r1, [r7, #4]
   19170:	6858      	ldr	r0, [r3, #4]
   19172:	f7ff fd9d 	bl	18cb0 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   19176:	2800      	cmp	r0, #0
   19178:	d1ef      	bne.n	1915a <add_event+0x10>
	return list->head == list;
   1917a:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1917c:	42b4      	cmp	r4, r6
   1917e:	d0ec      	beq.n	1915a <add_event+0x10>
   19180:	2e00      	cmp	r6, #0
   19182:	bf38      	it	cc
   19184:	2600      	movcc	r6, #0
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   19186:	2e00      	cmp	r6, #0
   19188:	d0e7      	beq.n	1915a <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   1918a:	68b3      	ldr	r3, [r6, #8]
   1918c:	6878      	ldr	r0, [r7, #4]
   1918e:	6859      	ldr	r1, [r3, #4]
   19190:	f7ff fd8e 	bl	18cb0 <z_is_t1_higher_prio_than_t2>
   19194:	b128      	cbz	r0, 191a2 <add_event+0x58>
	node->prev = successor->prev;
   19196:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   19198:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   1919c:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   1919e:	6075      	str	r5, [r6, #4]
			return;
   191a0:	e7e1      	b.n	19166 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   191a2:	6863      	ldr	r3, [r4, #4]
   191a4:	42b3      	cmp	r3, r6
   191a6:	d0d8      	beq.n	1915a <add_event+0x10>
   191a8:	6836      	ldr	r6, [r6, #0]
   191aa:	e7ec      	b.n	19186 <add_event+0x3c>

000191ac <register_events>:
{
   191ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   191b0:	f04f 0a00 	mov.w	sl, #0
{
   191b4:	460e      	mov	r6, r1
   191b6:	4614      	mov	r4, r2
   191b8:	461f      	mov	r7, r3
   191ba:	4683      	mov	fp, r0
	int events_registered = 0;
   191bc:	4655      	mov	r5, sl
	event->poller = NULL;
   191be:	46d0      	mov	r8, sl
	for (int ii = 0; ii < num_events; ii++) {
   191c0:	45b2      	cmp	sl, r6
   191c2:	db02      	blt.n	191ca <register_events+0x1e>
}
   191c4:	4628      	mov	r0, r5
   191c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   191ca:	f04f 0320 	mov.w	r3, #32
   191ce:	f3ef 8911 	mrs	r9, BASEPRI
   191d2:	f383 8811 	msr	BASEPRI, r3
   191d6:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   191da:	f89b 200d 	ldrb.w	r2, [fp, #13]
   191de:	f002 020f 	and.w	r2, r2, #15
   191e2:	2a02      	cmp	r2, #2
   191e4:	d006      	beq.n	191f4 <register_events+0x48>
   191e6:	2a04      	cmp	r2, #4
   191e8:	d008      	beq.n	191fc <register_events+0x50>
   191ea:	2a01      	cmp	r2, #1
   191ec:	d120      	bne.n	19230 <register_events+0x84>
		if (event->signal->signaled != 0U) {
   191ee:	f8db 3010 	ldr.w	r3, [fp, #16]
   191f2:	e001      	b.n	191f8 <register_events+0x4c>
		if (k_sem_count_get(event->sem) > 0) {
   191f4:	f8db 3010 	ldr.w	r3, [fp, #16]
		if (event->signal->signaled != 0U) {
   191f8:	689b      	ldr	r3, [r3, #8]
   191fa:	e002      	b.n	19202 <register_events+0x56>
		if (!k_queue_is_empty(event->queue)) {
   191fc:	f8db 3010 	ldr.w	r3, [fp, #16]
   19200:	681b      	ldr	r3, [r3, #0]
		if (event->signal->signaled != 0U) {
   19202:	b1ab      	cbz	r3, 19230 <register_events+0x84>
	event->state |= state;
   19204:	f8db 300c 	ldr.w	r3, [fp, #12]
	event->poller = NULL;
   19208:	f8cb 8008 	str.w	r8, [fp, #8]
	event->state |= state;
   1920c:	f3c3 3104 	ubfx	r1, r3, #12, #5
   19210:	430a      	orrs	r2, r1
   19212:	f362 3310 	bfi	r3, r2, #12, #5
   19216:	f8cb 300c 	str.w	r3, [fp, #12]
			poller->is_polling = false;
   1921a:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
   1921e:	f389 8811 	msr	BASEPRI, r9
   19222:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   19226:	f10a 0a01 	add.w	sl, sl, #1
   1922a:	f10b 0b14 	add.w	fp, fp, #20
   1922e:	e7c7      	b.n	191c0 <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
   19230:	2f00      	cmp	r7, #0
   19232:	d1f4      	bne.n	1921e <register_events+0x72>
   19234:	7823      	ldrb	r3, [r4, #0]
   19236:	2b00      	cmp	r3, #0
   19238:	d0f1      	beq.n	1921e <register_events+0x72>
	switch (event->type) {
   1923a:	f89b 300d 	ldrb.w	r3, [fp, #13]
   1923e:	f003 030f 	and.w	r3, r3, #15
   19242:	2b02      	cmp	r3, #2
   19244:	d008      	beq.n	19258 <register_events+0xac>
   19246:	2b04      	cmp	r3, #4
   19248:	d011      	beq.n	1926e <register_events+0xc2>
   1924a:	2b01      	cmp	r3, #1
   1924c:	d10b      	bne.n	19266 <register_events+0xba>
		add_event(&event->signal->poll_events, event, poller);
   1924e:	f8db 0010 	ldr.w	r0, [fp, #16]
   19252:	4622      	mov	r2, r4
   19254:	4659      	mov	r1, fp
   19256:	e004      	b.n	19262 <register_events+0xb6>
		add_event(&event->sem->poll_events, event, poller);
   19258:	f8db 0010 	ldr.w	r0, [fp, #16]
   1925c:	4622      	mov	r2, r4
   1925e:	4659      	mov	r1, fp
   19260:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
   19262:	f7ff ff72 	bl	1914a <add_event>
	event->poller = poller;
   19266:	f8cb 4008 	str.w	r4, [fp, #8]
				events_registered += 1;
   1926a:	3501      	adds	r5, #1
   1926c:	e7d7      	b.n	1921e <register_events+0x72>
		add_event(&event->queue->poll_events, event, poller);
   1926e:	f8db 0010 	ldr.w	r0, [fp, #16]
   19272:	4622      	mov	r2, r4
   19274:	4659      	mov	r1, fp
   19276:	3008      	adds	r0, #8
   19278:	e7f3      	b.n	19262 <register_events+0xb6>

0001927a <k_poll_event_init>:
{
   1927a:	b510      	push	{r4, lr}
	event->type = type;
   1927c:	0452      	lsls	r2, r2, #17
   1927e:	0209      	lsls	r1, r1, #8
   19280:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
   19284:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
   19288:	430a      	orrs	r2, r1
   1928a:	7b01      	ldrb	r1, [r0, #12]
	event->poller = NULL;
   1928c:	2400      	movs	r4, #0
	event->type = type;
   1928e:	430a      	orrs	r2, r1
	event->obj = obj;
   19290:	e9c0 2303 	strd	r2, r3, [r0, #12]
	event->poller = NULL;
   19294:	6084      	str	r4, [r0, #8]
}
   19296:	bd10      	pop	{r4, pc}

00019298 <z_handle_obj_poll_events>:

void z_handle_obj_poll_events(sys_dlist_t *events, u32_t state)
{
   19298:	4603      	mov	r3, r0
	return list->head == list;
   1929a:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   1929c:	4283      	cmp	r3, r0
   1929e:	d008      	beq.n	192b2 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   192a0:	e9d0 3200 	ldrd	r3, r2, [r0]
   192a4:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   192a6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   192a8:	2300      	movs	r3, #0
	node->prev = NULL;
   192aa:	e9c0 3300 	strd	r3, r3, [r0]
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   192ae:	f7ff bf0f 	b.w	190d0 <signal_poll_event>
	}
}
   192b2:	4770      	bx	lr

000192b4 <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   192b4:	4770      	bx	lr
